SCHEMA ISO13584_25_library_implicit_schema;


CONSTANT

	version_len: INTEGER := 9; 

	sep_cv: STRING := '-';

	revision_len: INTEGER := 3; 

	supplier_code_len: INTEGER := 70;

	class_code_len: INTEGER := 14;

	sep_id: STRING := '.'; 

	value_code_len: INTEGER :=18; 

	property_code_len: INTEGER := 14; 

	DET_classification_len: INTEGER := 3;

	data_type_code_len:INTEGER := 14;

	value_format_len: INTEGER := 80;

	source_doc_len: INTEGER := 80;

	pref_name_len: INTEGER := 70;

	syn_name_len: INTEGER := pref_name_len;

	short_name_len: INTEGER := 30;

	dictionary_code_len: INTEGER := 80;

	element_code_len: INTEGER := 14;

	compiler_version_length: INTEGER := 9;

	external_item_code_length: INTEGER := 128;

	external_file_address_length: INTEGER := 18;

	http_file_name_length: INTEGER := 128;

	http_directory_name_length: INTEGER := 128;

 	dummy_gri : geometric_representation_item := representation_item('')||
                   geometric_representation_item();

END_CONSTANT;

(* ===================================================================================== *)
(* TYPES																				 *)
(* Wed Jul 04 17:17:27 2001                                                              *)
(* ===================================================================================== *)


TYPE integer_type = INTEGER; 
END_TYPE; -- integer_type




TYPE string_value = STRING;
END_TYPE; -- string_value




TYPE boolean_value = BOOLEAN;
END_TYPE; -- boolean_value




TYPE integer_value = INTEGER;
END_TYPE; -- integer_value




TYPE real_value = REAL;
END_TYPE; -- real_value




TYPE defined_entity_instance_value = SELECT(
	placement,
	axis1_placement,
	axis2_placement_2d,
	axis2_placement_3d);
END_TYPE; -- defined_entity_instance_value



TYPE amount_of_substance_measure = REAL;
END_TYPE;



TYPE area_measure = REAL;
END_TYPE;



TYPE context_dependent_measure = REAL;
END_TYPE;



TYPE count_measure = NUMBER;
END_TYPE;



TYPE descriptive_measure = STRING;
END_TYPE;



TYPE electric_current_measure = REAL;
END_TYPE;



TYPE length_measure = REAL;
END_TYPE;



TYPE luminous_intensity_measure = REAL;
END_TYPE;



TYPE mass_measure = REAL;
END_TYPE;



TYPE measure_value = SELECT
  (length_measure,
   mass_measure,
   time_measure,
   electric_current_measure,
   thermodynamic_temperature_measure,
   amount_of_substance_measure,
   luminous_intensity_measure,
   plane_angle_measure,
   solid_angle_measure,
   area_measure,
   volume_measure,
   ratio_measure,
   parameter_value,
   numeric_measure,
   context_dependent_measure,
   descriptive_measure,
   positive_length_measure,
   positive_plane_angle_measure,
   positive_ratio_measure,
   count_measure);
END_TYPE;



TYPE numeric_measure = NUMBER;
END_TYPE;



TYPE parameter_value = REAL;
END_TYPE;



TYPE plane_angle_measure = REAL;
END_TYPE;



TYPE positive_length_measure = length_measure;
WHERE
  WR1: SELF > 0;
END_TYPE;



TYPE positive_plane_angle_measure = plane_angle_measure;
WHERE
  WR1: SELF > 0;
END_TYPE;



TYPE positive_ratio_measure = ratio_measure;
WHERE
  WR1: SELF > 0;
END_TYPE;



TYPE ratio_measure = REAL;
END_TYPE;



TYPE solid_angle_measure = REAL;
END_TYPE;



TYPE thermodynamic_temperature_measure = REAL;
END_TYPE;



TYPE time_measure = REAL;
END_TYPE;



TYPE volume_measure = REAL;
END_TYPE;




TYPE code_type = identifier;
WHERE
	WR1: NOT(SELF LIKE '*.*');
	WR2: NOT(SELF LIKE '*-*');
	WR3: NOT(SELF LIKE '* *');
	WR4: NOT(SELF = '');
END_TYPE; -- code_type



TYPE identifier = STRING; 
END_TYPE; 




TYPE version_type = code_type;
WHERE
	WR1: LENGTH(SELF) <= version_len;
	WR2: EXISTS(VALUE(SELF)) AND ('INTEGER' IN TYPEOF(VALUE(SELF)))
		AND (VALUE(SELF) >= 0);
END_TYPE; -- version_type




TYPE revision_type = code_type; 
WHERE 
	WR1: LENGTH(SELF) <= revision_len; 
END_TYPE; -- revision_type




TYPE supplier_code_type = code_type;
WHERE
	WR1: LENGTH(SELF) <= supplier_code_len; 
END_TYPE; -- supplier_code_type




TYPE class_code_type = code_type; 
WHERE 
	WR1: LENGTH(SELF) <= class_code_len;
END_TYPE; -- class_code_type




TYPE definition_type = translatable_text;
END_TYPE; -- definition_type




TYPE translatable_text = SELECT(text, translated_text);
END_TYPE; -- translatable_text




TYPE note_type = translatable_text;
END_TYPE; -- note_type




TYPE remark_type = translatable_text; 
END_TYPE; -- remark_type




TYPE value_code_type = identifier;
WHERE
	WR1: LENGTH(SELF) <= value_code_len; 
END_TYPE; -- value_code_type




TYPE property_code_type = code_type; 
WHERE 
	WR1: LENGTH(SELF) <= property_code_len;
END_TYPE; -- property_code_type




TYPE DET_classification_type = identifier;
WHERE
	WR1: LENGTH(SELF) = DET_classification_len; 
END_TYPE; -- DET_classification_type




TYPE data_type_code_type = code_type; 
WHERE 
	WR1: LENGTH(SELF) = data_type_code_len;
END_TYPE; -- data_type_code_type




TYPE value_format_type = identifier;
WHERE
	WR1: LENGTH(SELF) <= value_format_len; 
END_TYPE; -- value_format_type




TYPE currency_code = identifier;
WHERE
	WR1: LENGTH(SELF) = 3;
END_TYPE; -- currency_code




TYPE level = ENUMERATION OF(
	min,		
	nom,		
	typ,		
	max);	
END_TYPE; -- level 



TYPE value_type = SELECT(value_code_type, integer_type); 
END_TYPE; -- value_type



TYPE label = STRING; 
END_TYPE;



TYPE unit = SELECT 
  (named_unit, 
   derived_unit);
END_TYPE;




TYPE date_type = STRING(10) FIXED;
END_TYPE; -- date_type




TYPE source_doc_type = identifier; 
WHERE
	WR1: LENGTH(SELF) <= source_doc_len; 
END_TYPE; -- source_doc_type




TYPE pref_name_type = translatable_label;
WHERE
	WR1: check_label_length(SELF, pref_name_len);
END_TYPE; -- pref_name_type




TYPE translatable_label = SELECT(label, translated_label);
END_TYPE; -- translatable_label




TYPE syn_name_type = SELECT(label_with_language, label);
WHERE
	WR1: check_syn_length(SELF, syn_name_len); 
END_TYPE; -- syn_name_type




TYPE short_name_type = translatable_label;
WHERE
	WR1: check_label_length(SELF, short_name_len); 
END_TYPE; -- short_name_type

	
 



TYPE language_code = identifier; 
END_TYPE; -- language_code



TYPE text = STRING; 
END_TYPE;




TYPE dictionary_code_type = code_type;
WHERE
	WR1: LENGTH(SELF) <= dictionary_code_len;
END_TYPE; -- dictionary_code_type




TYPE table_code_type = code_type;
WHERE
	WR1: LENGTH(SELF) <= element_code_len;
END_TYPE; -- table_code_type




TYPE property_or_data_type_BSU = SELECT(
	property_BSU,
	data_type_BSU);
END_TYPE; -- property_or_data_type_BSU



TYPE year_number = INTEGER;  
END_TYPE; 




TYPE program_library_code_type = code_type;
WHERE
	WR1: LENGTH(SELF) <= element_code_len;
END_TYPE; -- program_library_code_type




TYPE document_code_type = code_type;
WHERE
	WR1: LENGTH(SELF) <= element_code_len;
END_TYPE; -- document_code_type




TYPE absolute_URL_type = identifier;
WHERE
	WR1: SELF LIKE '*://*';
END_TYPE; -- absolute_URL_type




TYPE program_status = ENUMERATION OF(source, compiled);
END_TYPE; -- program_status




TYPE compiler_version_type = identifier;
WHERE
	WR1: LENGTH(SELF) <= compiler_version_length;
	WR2: control_compiler_version_format(SELF);
END_TYPE; -- compiler_version_type




TYPE IAB_RFC = INTEGER;
WHERE
	WR1: SELF > 0;
END_TYPE; -- IAB_RFC




TYPE external_item_code_type = identifier;
WHERE
	WR1: LENGTH(SELF) <= external_item_code_length;
	WR2: NOT(SELF LIKE '* *');
END_TYPE; -- external_item_code_type




TYPE program_reference_name_type = identifier;
END_TYPE; -- program_reference_name_type




TYPE illustration_type = ENUMERATION OF(
	schematic_drawing, realistic_picture, not_static_picture);
END_TYPE; -- illustration_type




TYPE character_set_type = identifier;
END_TYPE; -- character_set_type




TYPE external_file_address = identifier;
WHERE
	WR1: LENGTH(SELF) <= external_file_address_length;
	WR2: NOT(SELF LIKE '* *');
END_TYPE; -- external_file_address




TYPE content_encoding_type = identifier;
WHERE
	WR1: (SELF = '7bit' ) OR (SELF = '8bit' ) OR (SELF = 'binary' )
		OR (SELF = 'quoted-printable' ) OR (SELF = 'base64' );
END_TYPE; -- content_encoding_type




TYPE MIME_type = identifier;
WHERE
	WR1: NOT(SELF LIKE '* *');
END_TYPE; -- MIME_type




TYPE MIME_subtype = identifier;
WHERE
	WR1: NOT(SELF LIKE '* *');
END_TYPE; -- MIME_subtype




TYPE http_file_name_type = identifier;
WHERE
	WR1: LENGTH(SELF) <= http_file_name_length;
	WR2: NOT(SELF LIKE '* *');
	WR3: NOT(SELF LIKE '*.*.*');
	WR4: ((NOT(SELF LIKE '*.*'))
		AND (LENGTH(SELF) <= http_file_name_length - 4))
		OR ((SELF LIKE '*.?')
		AND (LENGTH(SELF) <= http_file_name_length - 2))
		OR ((SELF LIKE '*.??')
		AND (LENGTH(SELF) <= http_file_name_length - 1))
		OR (SELF LIKE '*.???');
END_TYPE; -- http_file_name_type




TYPE http_directory_name_type = identifier;
WHERE
	WR1: LENGTH(SELF) <= http_directory_name_length;
	WR2: NOT(SELF LIKE '* *');
END_TYPE; -- http_directory_name_type




TYPE primitive_value = SELECT(
	simple_value,
	complex_value);
END_TYPE; -- primitive_value




TYPE classification_value = INTEGER;
END_TYPE; -- classification_value



TYPE si_prefix = ENUMERATION OF
  (exa, 
   peta, 
   tera, 
   giga, 
   mega, 
   kilo, 
   hecto, 
   deca, 
   deci,
   centi, 
   milli, 
   micro, 
   nano, 
   pico, 
   femto, 
   atto);
END_TYPE;



TYPE si_unit_name = ENUMERATION OF
  (metre, 
   gram, 
   second, 
   ampere, 
   kelvin, 
   mole, 
   candela, 
   radian, 
   steradian,
   hertz, 
   newton, 
   pascal, 
   joule, 
   watt, 
   coulomb, 
   volt, 
   farad, 
   ohm, 
   siemens, 
   weber, 
   tesla, 
   henry, 
   degree_Celsius, 
   lumen,
   lux, 
   becquerel, 
   gray, 
   sievert);
END_TYPE;



TYPE dimension_count = INTEGER;
WHERE
  WR1: SELF > 0;
END_TYPE;



TYPE FOUNDED_ITEM_SELECT = SELECT (
   REPRESENTATION_ITEM);
END_TYPE;




TYPE vector_or_direction = SELECT
   (vector, 
    direction);
 END_TYPE;




TYPE translatable_string_value = SELECT(string_value,
	translated_string_value);
END_TYPE; -- translatable_string_value




TYPE simple_value = SELECT(
	number_value,
	translatable_string_value,
	boolean_value);
END_TYPE; -- simple_value




TYPE null_or_boolean_value = SELECT(
	null_value,
	boolean_value);
END_TYPE; -- null_or_boolean_value




TYPE number_value = SELECT(
	integer_value,
	real_value);
END_TYPE; -- nunmber_value




TYPE null_or_integer_value = SELECT(
	null_value,
	integer_value);
END_TYPE; -- null_or_integer_value




TYPE null_or_real_value = SELECT(
	null_value,
	real_value);
END_TYPE; -- null_or_real_value




TYPE ENTITY_INSTANCE_VALUE = SELECT(
   DEFINED_ENTITY_INSTANCE_VALUE,
   CONTROLLED_ENTITY_INSTANCE_VALUE,
   UNCONTROLLED_ENTITY_INSTANCE_VALUE);
END_TYPE;



TYPE controlled_entity_instance_value = SELECT(
	PLIB_entity_instance_value);
END_TYPE; -- controlled_entity_instance_value



TYPE PLIB_entity_instance_value = SELECT(
	program_reference,
	representation_reference);
END_TYPE; -- PLIB_entity_instance_value



TYPE null_or_primitive_value = SELECT(
	null_value,
	primitive_value);
END_TYPE; -- null_or_primitive_value




TYPE null_or_translatable_string_value = SELECT(
	null_value,
	translatable_string_value);
END_TYPE; -- null_or_translatable_string_value




TYPE null_or_simple_value = SELECT(
	null_value,
	simple_value);
END_TYPE; -- null_or_simple_value




TYPE null_or_number_value = SELECT(
	null_value,
	number_value);
END_TYPE; -- nunmber_value




TYPE complex_value = SELECT(
	entity_instance_value,
	level_spec_value,
	dic_class_instance);
END_TYPE; -- complex_value




TYPE null_or_complex_value = SELECT(
	entity_instance_value,
	level_spec_value,
	dic_class_instance);
END_TYPE; -- null_or_complex_value




TYPE null_or_entity_instance_value = SELECT(
	null_value,
	entity_instance_value);
END_TYPE; -- null_or_entity_instance_value




TYPE null_or_level_spec_value = SELECT(
	null_value,
	level_spec_value);
END_TYPE; -- null_or_level_spec_value




TYPE null_or_int_level_spec_value = SELECT(
	null_value,
	int_level_spec_value);
END_TYPE; -- null_or_int_level_spec_value




TYPE null_or_real_level_spec_value = SELECT(
	null_value,
	real_level_spec_value);
END_TYPE; -- null_or_real_level_spec_value




TYPE null_or_dic_class_instance = SELECT(
	null_value,
	dic_class_instance);
END_TYPE; -- null_or_dic_class_instance



TYPE PERSON_ORGANIZATION_SELECT = SELECT (
   PERSON,
   ORGANIZATION);
END_TYPE;




TYPE axis2_placement = SELECT 
   (axis2_placement_2d, 
    axis2_placement_3d);
 END_TYPE;



TYPE trimming_select = SELECT 
   (cartesian_point, 
    parameter_value);
 END_TYPE;



TYPE GEOMETRIC_SET_SELECT = SELECT (
   POINT);
END_TYPE;


(* ===================================================================================== *)
(* ENTITIES																			  	 *)
(* Wed Jul 04 17:17:27 2001                                                              *)
(* ===================================================================================== *)



ENTITY supplier_BSU
SUBTYPE OF(basic_semantic_unit); 
	SELF\basic_semantic_unit.code: supplier_code_type; 
DERIVE 
	SELF\basic_semantic_unit.version: version_type := '1';
	absolute_id: identifier := SELF\basic_semantic_unit.code; 
UNIQUE 
	UR1: absolute_id; 
END_ENTITY; -- supplier_BSU




ENTITY supplier_element
SUBTYPE OF(dictionary_element);
	SELF\dictionary_element.identified_by: supplier_BSU;
	org: organization;
	addr: address;
INVERSE
	associated_items: SET [0:?] OF supplier_BSU_relationship 
		FOR relating_supplier;
END_ENTITY; -- supplier_element




ENTITY class_BSU
SUBTYPE OF(basic_semantic_unit);
	SELF\basic_semantic_unit.code: class_code_type;
	defined_by: supplier_BSU;
DERIVE
	absolute_id: identifier 
		:= defined_by.absolute_id + sep_id + dic_identifier; 
	known_visible_properties : SET [0:?]OF property_BSU
		:=compute_known_visible_properties(SELF);
	known_visible_data_types: SET [0:?]OF data_type_BSU
		:=compute_known_visible_data_types(SELF);
INVERSE
	subclasses: SET [0:?] OF class FOR its_superclass;
	added_visible_properties:SET [0:?] OF property_BSU 
		FOR name_scope;
	added_visible_data_types:SET [0:?] OF data_type_BSU 
		FOR name_scope;
UNIQUE
	UR1: absolute_id; 
END_ENTITY; -- class_BSU




ENTITY item_class 
SUPERTYPE OF (ONEOF (
              COMPONENT_CLASS,
              MATERIAL_CLASS))

SUBTYPE OF(class);
	simplified_drawing: OPTIONAL graphics;
	sub_class_properties: SET [0:?] OF property_BSU;
	class_constant_values: SET [0:?] 
		OF class_value_assignment;
	coded_name: OPTIONAL value_code_type;
WHERE
	WR1: QUERY(p <* sub_class_properties
		| NOT(p IN SELF.described_by)) = [];
	WR2: NOT all_class_descriptions_reachable(SELF.identified_by) OR
		(QUERY(va <* class_constant_values | SIZEOF(QUERY(c <*
		va.super_class_defined_property.describes_classes |
		is_subclass(SELF, c) 
		AND (va.super_class_defined_property 
		IN c\item_class.sub_class_properties))) <> 1) = []);
END_ENTITY; -- item_class




ENTITY component_class 
SUBTYPE OF(item_class);
END_ENTITY; -- component_class




ENTITY material_class 
SUBTYPE OF(item_class);
END_ENTITY; -- material_class




ENTITY property_BSU
SUBTYPE OF(basic_semantic_unit);
	SELF\basic_semantic_unit.code: property_code_type;
	name_scope: class_BSU;
DERIVE
	absolute_id: identifier :=
		name_scope.defined_by.absolute_id
		+ sep_id + name_scope.dic_identifier
		+ sep_id + dic_identifier;
INVERSE
	describes_classes: SET OF class FOR described_by;
UNIQUE
	UR1: absolute_id;
WHERE
	WR1: QUERY(c <* describes_classes |
		NOT(is_subclass(c, name_scope.definition[1])))= [];
END_ENTITY; -- property_BSU




ENTITY property_DET
ABSTRACT SUPERTYPE OF (ONEOF (
                       CONDITION_DET,
                       DEPENDENT_P_DET,
                       NON_DEPENDENT_P_DET))

SUBTYPE OF(class_and_property_elements);
	SELF\dictionary_element.identified_by: property_BSU;
	preferred_symbol: OPTIONAL mathematical_string;
	synonymous_symbols: SET [0:?] OF mathematical_string;
	figure: OPTIONAL graphics;
	det_classification: OPTIONAL DET_classification_type;
	domain: data_type;
	formula: OPTIONAL mathematical_string;
DERIVE
	describes_classes: SET [0:?] OF class
		:= identified_by.describes_classes;
END_ENTITY; -- property_DET




ENTITY condition_DET
SUBTYPE OF(property_DET);
END_ENTITY; -- condition_DET




ENTITY dependent_P_DET
SUBTYPE OF(property_DET);
	depends_on: SET [1:?] OF property_BSU;
WHERE
	WR1: QUERY(p <* depends_on | NOT(definition_available_implies(
		p, ('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.CONDITION_DET'
		IN TYPEOF(p.definition[1]))))) = [];
END_ENTITY; -- dependent_P_DET




ENTITY non_dependent_P_DET
SUBTYPE OF(property_DET);
END_ENTITY; -- non_dependent_P_DET




ENTITY class_value_assignment;
	super_class_defined_property: property_BSU;
	assigned_value: value_code_type;
WHERE
	WR1: definition_available_implies(super_class_defined_property, 
		('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA'
		+'.NON_QUANTITATIVE_CODE_TYPE' IN TYPEOF(
		super_class_defined_property.
		definition[1]\property_DET.domain)));
	WR2: definition_available_implies(super_class_defined_property, 
		(SIZEOF(QUERY(v <* 
		super_class_defined_property.
		definition[1]\property_DET.domain
		\non_quantitative_code_type.domain.its_values |
		assigned_value = v.value_code)) = 1));
END_ENTITY; -- class_value_assignment




ENTITY data_type_BSU
SUBTYPE OF(basic_semantic_unit);
	SELF\basic_semantic_unit.code: data_type_code_type;
	name_scope: class_BSU;
DERIVE
	absolute_id: identifier := 
		name_scope.defined_by.absolute_id 	
		+ sep_id + name_scope.dic_identifier 	
		+ sep_id + dic_identifier; 			
INVERSE
	defining_class: SET OF class FOR defined_types;
UNIQUE
	absolute_id;
WHERE
	WR1: is_subclass(defining_class[1], name_scope.definition[1]); 
END_ENTITY; -- data_type_BSU




ENTITY data_type_element
SUBTYPE OF(dictionary_element);
	SELF\dictionary_element.identified_by: data_type_BSU;
	names: item_names;
	type_definition: data_type;
END_ENTITY; -- data_type_element




ENTITY number_type
SUPERTYPE OF (ONEOF (
              INT_TYPE,
              REAL_TYPE))

SUBTYPE OF(simple_type); 
END_ENTITY; -- number_type




ENTITY int_type
SUPERTYPE OF (ONEOF (
              INT_MEASURE_TYPE,
              INT_CURRENCY_TYPE,
              NON_QUANTITATIVE_INT_TYPE))

SUBTYPE OF(number_type);
END_ENTITY; -- int_type




ENTITY int_measure_type
SUBTYPE OF(int_type);
	unit: dic_unit;
END_ENTITY; -- int_measure_type




ENTITY int_currency_type
SUBTYPE OF(int_type);
	currency: OPTIONAL currency_code; 
END_ENTITY; -- int_currency_type




ENTITY non_quantitative_int_type
SUBTYPE OF(int_type);
	domain: value_domain;
WHERE
	WR1: QUERY(v <* domain.its_values | 
		'ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.VALUE_CODE_TYPE' IN
		TYPEOF(v.value_code)) = [];
END_ENTITY; -- non_quantitative_int_type




ENTITY real_type
SUPERTYPE OF (ONEOF (
              REAL_MEASURE_TYPE,
              REAL_CURRENCY_TYPE))

SUBTYPE OF(number_type);
END_ENTITY; -- real_type




ENTITY real_measure_type
SUBTYPE OF(real_type);
	unit: dic_unit;
END_ENTITY; -- real_measure_type




ENTITY real_currency_type
SUBTYPE OF(real_type);
	currency: OPTIONAL currency_code; 
END_ENTITY; -- real_currency_type




ENTITY boolean_type
SUBTYPE OF(simple_type);
END_ENTITY; -- boolean_type




ENTITY string_type
SUBTYPE OF(simple_type);
END_ENTITY; -- string_type




ENTITY non_quantitative_code_type
SUBTYPE OF(string_type);
	domain: value_domain;
WHERE
	WR1: QUERY(v <* domain.its_values | 
		NOT('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.VALUE_CODE_TYPE' IN
		TYPEOF(v.value_code))) = [];
END_ENTITY; -- non_quantitative_code_type




ENTITY complex_type
ABSTRACT SUPERTYPE OF (ONEOF (
                       LEVEL_TYPE,
                       CLASS_INSTANCE_TYPE,
                       ENTITY_INSTANCE_TYPE))

SUBTYPE OF(data_type);
END_ENTITY; -- complex_type




ENTITY level_type
SUBTYPE OF(complex_type);
	levels: LIST [1:4] OF UNIQUE level;
	value_type: simple_type;
WHERE
	WR1: 'ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.NUMBER_TYPE'
		IN TYPEOF(value_type);
END_ENTITY; -- level_type




ENTITY class_instance_type
SUBTYPE OF(complex_type);
	domain: class_BSU;
END_ENTITY; -- class_instance_type




ENTITY entity_instance_type
SUBTYPE OF(complex_type);
	type_name: SET OF STRING;
END_ENTITY; -- entity_instance_type




ENTITY placement_type
SUPERTYPE OF (ONEOF (
              AXIS1_PLACEMENT_TYPE,
              AXIS2_PLACEMENT_2D_TYPE,
              AXIS2_PLACEMENT_3D_TYPE))

SUBTYPE OF(entity_instance_type);
WHERE
	WR1: 'ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.PLACEMENT'
		IN SELF\entity_instance_type.type_name;
END_ENTITY; -- placement_type




ENTITY axis1_placement_type
SUBTYPE OF(placement_type);
WHERE
	WR1: 'ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.AXIS1_PLACEMENT' IN
		SELF\entity_instance_type.type_name;
END_ENTITY; -- axis1_placement_type




ENTITY axis2_placement_2d_type
SUBTYPE OF(placement_type);
WHERE
	WR1: 'ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.AXIS2_PLACEMENT_2D'
		IN SELF\entity_instance_type.type_name;
END_ENTITY; -- axis2_placement_2d_type




ENTITY axis2_placement_3d_type
SUBTYPE OF(placement_type);
WHERE
	WR1: 'ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.AXIS2_PLACEMENT_3D'
		IN SELF\entity_instance_type.type_name;
END_ENTITY; -- axis2_placement_3d_type




ENTITY named_type
SUBTYPE OF(data_type );
	referred_type: data_type_BSU;
END_ENTITY; -- named_type




ENTITY value_domain;
	its_values: LIST [2:?] OF dic_value;
	source_doc_of_value_domain: OPTIONAL document;
	languages: OPTIONAL present_translations;
	terms: LIST [0:?] OF item_names;
WHERE
	WR1: NOT EXISTS(languages) OR (QUERY(v <* its_values |
		languages :<>: v.meaning.languages) = []);
	WR2: codes_are_unique(its_values);
    WR3: EXISTS(languages) OR (QUERY(v <* its_values |
		EXISTS(v.meaning.languages)) = []);
END_ENTITY; -- value_domain




ENTITY dic_value;
	value_code: value_type;
	meaning: item_names;
	source_doc_of_value: OPTIONAL document;
END_ENTITY; -- dic_value




ENTITY non_si_unit
SUBTYPE OF(named_unit);
	name: label;
END_ENTITY; -- non_si_unit




ENTITY dic_unit;
	structured_representation: unit; 
	string_representation: OPTIONAL mathematical_string;
END_ENTITY; -- dic_unit




ENTITY dates;
	date_of_original_definition: date_type;
	date_of_current_version: date_type;
	date_of_current_revision: OPTIONAL date_type;
END_ENTITY; -- dates




ENTITY identified_document
SUBTYPE OF(document);
	document_identifier: source_doc_type;
END_ENTITY; -- identified_document




ENTITY item_names;
	preferred_name: pref_name_type;
	synonymous_names: SET OF syn_name_type;
	short_name: OPTIONAL short_name_type;
	languages: OPTIONAL present_translations;
	icon : OPTIONAL graphics;
WHERE
	WR1: NOT(EXISTS(languages )) OR (
		('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA'
		+ '.TRANSLATED_LABEL' IN TYPEOF(preferred_name))
		AND (languages :=: preferred_name\translated_label.languages)
		AND (NOT(EXISTS(short_name)) OR ('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA'
		+ '.TRANSLATED_LABEL' IN TYPEOF(short_name)))
		AND (languages :=: short_name\translated_label.languages)
		AND (QUERY(s <* synonymous_names |
		NOT('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA' +
		'.LABEL_WITH_LANGUAGE' IN TYPEOF(s))) = []));
	WR2: NOT EXISTS(languages) OR (QUERY(s <* synonymous_names |
		EXISTS(s.language) AND NOT(s.language IN
		QUERY(l <* languages.language_codes | TRUE
		))) = []);
	WR3: EXISTS(languages) OR
		(('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.LABEL' IN
		TYPEOF(preferred_name))
		AND (NOT(EXISTS(short_name)) OR
		('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.LABEL' IN
		TYPEOF(short_name)))
		AND (QUERY(s <* synonymous_names |
		'ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.LABEL_WITH_LANGUAGE' IN
		TYPEOF(s)) = []));
END_ENTITY; -- item_names




ENTITY label_with_language;
	l: label;
	language: language_code;
END_ENTITY; -- label_with_language




ENTITY mathematical_string;
	text_representation: text;
	SGML_representation: OPTIONAL text;
END_ENTITY; -- mathematical_string




ENTITY global_language_assignment;
	language: language_code;
END_ENTITY; -- global_language_assignment




ENTITY present_translations; 
	language_codes: LIST [1:?] OF UNIQUE language_code;
UNIQUE
	UR1: language_codes;
END_ENTITY; -- present_translations




ENTITY translated_label; 
	labels: LIST [1:?] OF label;
	languages: present_translations; 
WHERE
	WR1: SIZEOF(labels) = SIZEOF(languages.language_codes);
END_ENTITY; -- translated_label




ENTITY translated_text; 
	texts: LIST [1:?] OF text;
	languages: present_translations; 
WHERE
	WR1: SIZEOF(texts) = SIZEOF(languages.language_codes);
END_ENTITY; -- translated_text



ENTITY entity_instance_type_for_aggregate
SUBTYPE OF (entity_instance_type) ;
	type_structure: aggregate_type;
WHERE
	WR1: SELF\entity_instance_type.type_name =
		['ISO13584_25_LIBRARY_IMPLICIT_SCHEMA' +
			'.AGGREGATE_TYPE'] ;
END_ENTITY;



ENTITY list_type
SUBTYPE OF (aggregate_type);
	uniqueness: BOOLEAN;
WHERE
	WR1: EXISTS(bound_1) OR NOT(EXISTS(bound_2));
    WR2: NOT(EXISTS(bound_1)) OR (bound_1 >= 0);
END_ENTITY;



ENTITY set_type
SUBTYPE OF (aggregate_type);
WHERE
	WR1: EXISTS(bound_1) OR NOT(EXISTS(bound_2));
    WR2: NOT(EXISTS(bound_1)) OR (bound_1 >= 0);
END_ENTITY;



ENTITY bag_type
SUBTYPE OF (aggregate_type);
WHERE
	WR1: EXISTS(bound_1) OR NOT(EXISTS(bound_2));
    WR2: NOT(EXISTS(bound_1)) OR (bound_1 >= 0);
END_ENTITY;



ENTITY array_type
SUBTYPE OF (aggregate_type);
    SELF\aggregate_type.bound_1: INTEGER;
    SELF\aggregate_type.bound_2: INTEGER;
	uniqueness: BOOLEAN;
    are_optional: BOOLEAN;
END_ENTITY;



ENTITY dictionary
SUPERTYPE OF (
              DICTIONARY_IN_STANDARD_FORMAT);
	identified_by: OPTIONAL dictionary_identification;
	is_complete: OPTIONAL BOOLEAN;
	updates: OPTIONAL dictionary_identification;
	update_agreement: OPTIONAL identifier;
	referenced_dictionaries: SET [0:?] OF dictionary_identification;
	responsible_supplier: supplier_BSU;
	library_structure: library_iim_identification;
	base_protocols: SET [0:?] OF external_file_protocol;
	supported_vep: SET [0:?] OF
		view_exchange_protocol_identification;
	referred_suppliers: SET [1:?] OF supplier_BSU;
	contained_classes: LIST [0:?] OF UNIQUE class_BSU;
	a_posteriori_semantic_relationships: SET [0:?] OF
		a_posteriori_semantic_relationship;
	names: item_names;
	note: OPTIONAL note_type;
	remark: OPTIONAL remark_type;
WHERE
	WR1: prefix_ordered_class_list(SELF.contained_classes);
	WR2: (EXISTS(identified_by) AND EXISTS(is_complete))
		OR (NOT(EXISTS(identified_by)) AND NOT(EXISTS(is_complete)));
	WR3: NOT(EXISTS(identified_by)) OR
		(SELF.identified_by.defined_by = SELF.responsible_supplier);
	WR4: NOT(EXISTS(updates)) OR
		(EXISTS(identified_by) AND (is_complete = FALSE));
	WR5: NOT(EXISTS(update_agreement)) OR EXISTS(updates);
	WR6: NOT(EXISTS(updates)) OR
		((updates.code = identified_by.code)
		AND (updates.defined_by = identified_by.defined_by)
		AND (updates.version <= identified_by.version)
		AND (NOT(updates.version = identified_by.version) OR
		(updates.revision < identified_by.revision)));
END_ENTITY; -- dictionary




ENTITY dictionary_in_standard_format
SUBTYPE OF(dictionary);
WHERE
	WR1: QUERY(int <* SELF\dictionary.base_protocols
		| ((SIZEOF(QUERY(vep <* SELF\dictionary.supported_vep
		| int IN vep\data_exchange_specification_identification
		.external_file_protocols )) = 0) AND NOT(int IN
		SELF\dictionary.library_structure
		.external_file_protocols))) = [];
END_ENTITY; -- dictionary_in_standard_format




ENTITY library_iim_identification
SUBTYPE OF(data_exchange_specification_identification);
END_ENTITY; -- library_iim_identification




ENTITY view_exchange_protocol_identification
SUBTYPE OF(data_exchange_specification_identification);
	referenced_ISO10303_AP: OPTIONAL application_protocol_definition;
END_ENTITY; -- view_exchange_protocol_identification




ENTITY representation_type
	SUBTYPE OF(entity_instance_type);
WHERE
	WR1:'ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.REPRESENTATION'
		IN SELF\entity_instance_type.type_name;
END_ENTITY; -- representation_type




ENTITY geometric_representation_context_type
	SUBTYPE OF(entity_instance_type);
WHERE
	WR1:'ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.GEOMETRIC_REPRESENTATION_CONTEXT'
		IN SELF\entity_instance_type.type_name;
END_ENTITY; -- geometric_representation_context_type




ENTITY representation_reference_type
	SUBTYPE OF(entity_instance_type);
WHERE
	WR1:'ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.REPRESENTATION_REFERENCE'
		IN SELF\entity_instance_type.type_name;
END_ENTITY; -- representation_reference_type




ENTITY program_reference_type
	SUBTYPE OF(entity_instance_type);
WHERE
	WR1: 'ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.PROGRAM_REFERENCE'
		IN SELF\entity_instance_type.type_name;
END_ENTITY; -- program_reference_type




ENTITY program_library_BSU
SUBTYPE OF(supplier_related_BSU);
	defined_by: supplier_BSU;
	SELF\basic_semantic_unit.code: program_library_code_type;
DERIVE
	absolute_id: identifier := defined_by.dic_identifier
		+ sep_id + dic_identifier;
INVERSE
	associated_to_supplier: supplier_BSU_relationship
		FOR related_tokens;
UNIQUE
	UR1: absolute_id;
WHERE
	WR1: defined_by :=: associated_to_supplier.
		relating_supplier\dictionary_element.identified_by;
END_ENTITY; -- program_library_BSU




ENTITY document_BSU
SUBTYPE OF(class_related_BSU);
	name_scope: class_BSU;
	SELF\basic_semantic_unit.code: document_code_type;
DERIVE
	absolute_id: identifier :=
		name_scope.defined_by.dic_identifier + sep_id
		+ name_scope.dic_identifier + sep_id
		+ dic_identifier;
INVERSE
	associate_to_class: class_BSU_relationship FOR related_tokens;
UNIQUE
	UR1: absolute_id;
END_ENTITY; -- document_BSU




ENTITY supplier_program_library_relationship
SUBTYPE OF(supplier_BSU_relationship);
	SELF\supplier_BSU_relationship.related_tokens:
		SET [1:?] OF program_library_BSU;
END_ENTITY; -- supplier_program_library_relationship




ENTITY class_document_relationship
SUBTYPE OF(class_BSU_relationship);
	SELF\class_BSU_relationship.related_tokens:
		SET [1:?] OF document_BSU;
WHERE
	WR1: visible_documents(
		SELF\class_BSU_relationship.relating_class.identified_by,
		SELF.related_tokens);
END_ENTITY; -- class_document_relationship




ENTITY representation_P_DET
SUBTYPE OF(property_DET);
WHERE
	WR1: NOT('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.CONDITION_DET'
		IN TYPEOF(SELF)) AND
		NOT('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.DEPENDENT_P_DET'
		IN TYPEOF(SELF)) AND
		NOT('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA' +
		'.NON_DEPENDENT_P_DET' IN TYPEOF(SELF));
END_ENTITY; -- representation_P_DET




ENTITY program_library_element
SUBTYPE OF(supplier_related_dictionary_element);
	SELF\dictionary_element.identified_by: program_library_BSU;
END_ENTITY; -- program_library_element




ENTITY document_element
SUPERTYPE OF (ONEOF (
              DOCUMENT_ELEMENT_WITH_HTTP_ACCESS,
              DOCUMENT_ELEMENT_WITH_TRANSLATED_HTTP_ACCESS))

SUBTYPE OF(class_related_dictionary_element);
	SELF\dictionary_element.identified_by: document_BSU;
	authors: OPTIONAL LIST [1:?] OF person;
	publishing_organisation: organization;
END_ENTITY; -- document_element




ENTITY document_element_with_http_access
SUBTYPE OF(document_element);
	remote_location: absolute_URL_type;
END_ENTITY; -- document_element_with_http_access




ENTITY document_element_with_translated_http_access
SUBTYPE OF(document_element);
	remote_locations: LIST [1:?] OF absolute_URL_type;
	languages: present_translations;
WHERE
	WR1: SIZEOF(remote_locations) = SIZEOF(languages.language_codes);
END_ENTITY; -- document_element_with_translated_http_access




ENTITY referenced_document
SUBTYPE OF(document);
	document_reference: document_BSU;
WHERE
	WR1: NOT('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA' +
		'.IDENTIFIED_DOCUMENT' IN TYPEOF(SELF));
END_ENTITY; -- referenced_document




ENTITY referenced_graphics
SUBTYPE OF(graphics);
	graphics_reference: document_BSU;
END_ENTITY; -- referenced_graphics




ENTITY feature_class
SUBTYPE OF(item_class);
WHERE
	WR1: NOT(('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.'
		+ 'COMPONENT_CLASS') IN TYPEOF(SELF));
	WR2: NOT(('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.'
		+ 'MATERIAL_CLASS') IN TYPEOF(SELF));
END_ENTITY; -- feature_class




ENTITY functional_model_class
SUBTYPE OF(a_priori_semantic_relationship,
	abstract_functional_model_class);
DERIVE
	SELF\a_priori_semantic_relationship.referenced_classes:
		SET [1:?] OF class_BSU :=
		[SELF\abstract_functional_model_class.created_view]
		+ SELF\abstract_functional_model_class.case_of;
	SELF\a_priori_semantic_relationship.referenced_properties:
		LIST [0:?] OF property_BSU :=
		SELF\abstract_functional_model_class
			.imported_properties_from_view
		+ SELF\abstract_functional_model_class
			.imported_properties_from_models;
	SELF\a_priori_semantic_relationship.referenced_data_types:
		SET [0:?] OF data_type_BSU :=
		SELF\abstract_functional_model_class
			.imported_types_from_view
		+ SELF\abstract_functional_model_class
			.imported_types_from_models;
	SELF\a_priori_semantic_relationship.referenced_tables:
		SET [0:?] OF table_BSU :=
		SELF\abstract_functional_model_class
			.imported_tables_from_view
		+ SELF\abstract_functional_model_class
			.imported_tables_from_models;
	SELF\a_priori_semantic_relationship.referenced_documents:
		SET [0:?] OF document_BSU :=
		SELF\abstract_functional_model_class
			.imported_documents_from_view
		+ SELF\abstract_functional_model_class
			.imported_documents_from_models;
END_ENTITY; -- functional_model_class




ENTITY fm_class_view_of
SUBTYPE OF(a_priori_semantic_relationship,
	abstract_functional_model_class);
	view_of: class_BSU;
	imported_properties_from_item: LIST [0:?] OF property_BSU;
	imported_types_from_item: SET [0:?] OF data_type_BSU;
	imported_tables_from_item: SET [0:?] OF table_BSU;
	imported_documents_from_item: SET [0:?] OF document_BSU;
DERIVE
	SELF\a_priori_semantic_relationship.referenced_classes:
		SET [2:2] OF class_BSU :=
		[SELF\abstract_functional_model_class.created_view,
		SELF.view_of] + SELF\abstract_functional_model_class.case_of;
	SELF\a_priori_semantic_relationship.referenced_properties:
		LIST [0:?] OF property_BSU :=
		SELF\abstract_functional_model_class
		.imported_properties_from_view
		+ SELF\abstract_functional_model_class
		.imported_properties_from_models
		+ SELF.imported_properties_from_item;
	SELF\a_priori_semantic_relationship.referenced_data_types:
		SET [0:?] OF data_type_BSU :=
		SELF\abstract_functional_model_class
		.imported_types_from_view
		+ SELF\abstract_functional_model_class
		.imported_types_from_models
		+ SELF.imported_types_from_item;
	SELF\a_priori_semantic_relationship.referenced_tables:
		SET [0:?] OF table_BSU :=
		SELF\abstract_functional_model_class
		.imported_tables_from_view
		+ SELF\abstract_functional_model_class
		.imported_tables_from_models
		+ SELF.imported_tables_from_item;
	SELF\a_priori_semantic_relationship.referenced_documents:
		SET [0:?] OF document_BSU :=
		SELF\abstract_functional_model_class
		.imported_documents_from_view
		+ SELF\abstract_functional_model_class
		.imported_documents_from_models
		+ SELF.imported_documents_from_item;
WHERE
	WR1: check_view_of_instance_datatype(SELF);
END_ENTITY; -- fm_class_view_of




ENTITY functional_view_class
SUPERTYPE OF (
              NON_INSTANTIABLE_FUNCTIONAL_VIEW_CLASS)

SUBTYPE OF(class);
	representation_type: OPTIONAL STRING;
	view_control_variables: LIST [0:?] OF UNIQUE property_BSU;
	view_properties: LIST [0:?] OF UNIQUE property_BSU;
DERIVE
	SELF\class.described_by: LIST [0:?] OF UNIQUE property_BSU
		:= SELF.view_control_variables + SELF.view_properties;
WHERE
	WR1: QUERY(v_c_v <* SELF.view_control_variables
		| NOT((data_type_typeof(v_c_v) = [])
		OR (('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA'
		+ '.NON_QUANTITATIVE_INT_TYPE' IN data_type_typeof(v_c_v))
		AND ordered_index_value(
		data_type_non_quantitative_int_type(v_c_v)[1].domain))))
		= [];
	WR2: NOT EXISTS(SELF.representation_type)
		OR ('_SCHEMA.' LIKE SELF.representation_type);
	WR3: NOT EXISTS(SELF\class.its_superclass)
		OR (('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.'
		+ 'FUNCTIONAL_VIEW_CLASS')
		IN TYPEOF(SELF\class.its_superclass));
	WR4: QUERY(prop <* SELF\class.described_by
		| definition_available_implies(prop,
		('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA'
		+'.REPRESENTATION_P_DET') IN TYPEOF(prop.definition[1])))
		= SELF\class.described_by;
END_ENTITY; -- functional_view_class




ENTITY non_instantiable_functional_view_class
SUBTYPE OF(functional_view_class);
DERIVE
	SELF\functional_view_class.view_properties
		: LIST [0:?] OF UNIQUE property_BSU := [];
WHERE
	WR1: NOT EXISTS(SELF\functional_view_class.representation_type);
END_ENTITY; -- non_instantiable_functional_view_class




ENTITY view_control_variable_range;
	parameter_type: property_BSU;
	range_lobound: INTEGER;
	range_hibound: INTEGER;
WHERE
	WR1: (data_type_typeof(SELF.parameter_type) = [])
		OR ('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA'
		+ '.NON_QUANTITATIVE_INT_TYPE'
		IN data_type_typeof(SELF.parameter_type));
	WR2: SELF.range_lobound <= SELF.range_hibound;
	WR3: view_control_variables_attributes_belong_to_domain(SELF);
END_ENTITY; -- view_control_variable_range




ENTITY item_class_case_of
SUPERTYPE OF (ONEOF (
              COMPONENT_CLASS_CASE_OF,
              MATERIAL_CLASS_CASE_OF,
              FEATURE_CLASS_CASE_OF))

SUBTYPE OF(item_class, a_priori_semantic_relationship);
	is_case_of: SET [1:?] OF class_BSU;
	imported_properties: LIST [0:?] OF property_BSU;
	imported_types: SET [0:?]OF data_type_BSU;
	imported_tables: SET [0:?] OF table_BSU;
	imported_documents: SET [0:?] OF document_BSU;
DERIVE
	SELF\a_priori_semantic_relationship.referenced_classes:
		SET [1:?] OF class_BSU
		:= SELF.is_case_of;
	SELF\a_priori_semantic_relationship.referenced_properties:
		LIST [0:?] OF property_BSU := SELF.imported_properties;
	SELF\a_priori_semantic_relationship.referenced_data_types:
		SET [0:?] OF data_type_BSU := SELF.imported_types;
	SELF\a_priori_semantic_relationship.referenced_tables:
		SET [0:?] OF table_BSU := SELF.imported_tables;
	SELF\a_priori_semantic_relationship.referenced_documents:
		SET [0:?] OF document_BSU := SELF.imported_documents;
WHERE
	WR1: superclass_of_item_is_item(SELF);
	WR2: check_is_case_of_referenced_classes_definition(SELF);
END_ENTITY; -- item_class_case_of




ENTITY component_class_case_of
SUBTYPE OF(item_class_case_of, component_class);
WHERE
	WR1: check_is_case_of_referenced_classes_definition(SELF);
END_ENTITY; -- component_class_case_of




ENTITY material_class_case_of
SUBTYPE OF(item_class_case_of, material_class);
WHERE
	WR1: check_is_case_of_referenced_classes_definition(SELF);
END_ENTITY; -- material_class_case_of




ENTITY feature_class_case_of
SUBTYPE OF(item_class_case_of, feature_class);
WHERE
	WR1: check_is_case_of_referenced_classes_definition(SELF);
END_ENTITY; -- feature_class_case_of




ENTITY a_posteriori_case_of
SUBTYPE OF(a_posteriori_semantic_relationship );
	source: class_BSU;
	is_case_of: class_BSU;
	corresponding_properties: SET [0:?] OF
		LIST [2:2] OF property_BSU;
WHERE
	WR1: definition_available_implies(SELF.source,
		('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.ITEM_CLASS'
		IN TYPEOF(SELF.source.definition[1]))
		OR (('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA'
		 + '.ABSTRACT_FUNCTIONAL_MODEL_CLASS')
		IN TYPEOF(SELF.source.definition[1])));
	WR2: definition_available_implies(SELF.source,
		(('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.ITEM_CLASS'
		IN TYPEOF(SELF.source.definition[1]))
		AND (definition_available_implies(SELF.is_case_of,
		('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.ITEM_CLASS'
		IN TYPEOF(SELF.source.definition[1])))))
		OR (('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA'
		 + '.ABSTRACT_FUNCTIONAL_MODEL_CLASS'
		IN TYPEOF(SELF.source.definition[1]))
		AND (definition_available_implies(SELF.is_case_of,
		('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA'
		 + '.ABSTRACT_FUNCTIONAL_MODEL_CLASS'
		IN TYPEOF(SELF.source.definition[1]))))));
	WR3: QUERY(couple <* SELF.corresponding_properties
		| NOT compatible_types(couple[1], couple[2])) = [];
	WR4: QUERY(couple <* SELF.corresponding_properties
		| (NOT applicable_properties(SELF.source,[couple[1]])
		OR NOT applicable_properties(SELF.is_case_of,[couple [2]])))
		= [];
END_ENTITY; -- a_posteriori_case_of




ENTITY a_posteriori_view_of
SUBTYPE OF(a_posteriori_semantic_relationship);
	functional_model: class_BSU;
	is_view_of: class_BSU;
	corresponding_properties: SET [0:?] OF
		LIST [2:2] OF property_BSU;
WHERE
	WR1: definition_available_implies(SELF.functional_model,
		('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA'
		+'.FUNCTIONAL_MODEL_CLASS' IN TYPEOF(
		SELF.functional_model.definition[1])));
	WR2: definition_available_implies(SELF.is_view_of,
		('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.ITEM_CLASS'
		IN TYPEOF(SELF.is_view_of.definition[1])));
	WR3: QUERY(couple <* SELF.corresponding_properties
		| NOT compatible_types(couple [1], couple [2])) = [];
	WR4: QUERY(couple <* SELF.corresponding_properties
		| (NOT applicable_properties(
		SELF.functional_model,[couple[1]]) OR NOT
		applicable_properties(SELF.is_view_of,[couple [2]]))) = [];
END_ENTITY; -- a_posteriori_view_of




ENTITY standard_simple_program_protocol
SUBTYPE OF(standard_protocol, simple_program_protocol);
WHERE
	WR1: NOT EXISTS(SELF\external_file_protocol.base_protocol);
END_ENTITY; -- standard_simple_program_protocol




ENTITY non_standard_simple_program_protocol
SUBTYPE OF(non_standard_protocol, simple_program_protocol);
WHERE
	WR1: NOT EXISTS(SELF\external_file_protocol.base_protocol);
END_ENTITY; -- non_standard_simple_program_protocol




ENTITY linked_interface_program_protocol
SUBTYPE OF(program_protocol);
	link_libraries: SET [1:?] OF program_library_BSU;
WHERE
	WR1: QUERY(pl <* SELF.link_libraries
		| (SIZEOF(pl\basic_semantic_unit.referenced_by) > 0)
		AND (pl\basic_semantic_unit.referenced_by[1]
		\external_item.used_protocol <> SELF.base_protocol)) = [];
	WR2: NOT('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.STANDARD_PROTOCOL'
		IN TYPEOF(SELF)) AND
		NOT('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.NON_STANDARD_PROTOCOL'
		IN TYPEOF(SELF));
	WR3: EXISTS(base_protocol)
		AND ('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.PROGRAM_PROTOCOL'
		IN TYPEOF(base_protocol));
END_ENTITY; -- linked_interface_program_protocol




ENTITY standard_data_protocol
SUBTYPE OF(data_protocol, standard_protocol);
WHERE
	WR1: NOT EXISTS(SELF\external_file_protocol.base_protocol);
END_ENTITY; -- standard_data_protocol




ENTITY non_standard_data_protocol
SUBTYPE OF(data_protocol, non_standard_protocol);
WHERE
	WR1: NOT EXISTS(SELF\external_file_protocol.base_protocol);
END_ENTITY; -- non_standard_data_protocol




ENTITY http_protocol
SUBTYPE OF(standard_data_protocol);
	http_RFC: IAB_RFC;
END_ENTITY; -- http_protocol




ENTITY program_library_content
SUBTYPE OF(supplier_BSU_related_content);
	SELF\content_item.dictionary_definition: program_library_BSU;
	SELF\external_item.used_protocol: program_protocol;
END_ENTITY; -- program_library_content




ENTITY document_content
SUBTYPE OF(class_BSU_related_content);
	SELF\content_item.dictionary_definition: document_BSU;
	SELF\external_item.used_protocol: data_protocol;
END_ENTITY; -- document_content




ENTITY representation_reference
SUBTYPE OF(class_extension_external_item);
	SELF\external_item.used_protocol: data_protocol;
	representation_id: OPTIONAL label;
END_ENTITY; -- representation_reference




ENTITY program_reference
SUBTYPE OF(class_extension_external_item);
	SELF\external_item.used_protocol: program_protocol;
	syntactical_name: program_reference_name_type;
	in_parameters: LIST [0:?] OF property_or_data_type_BSU;
	out_parameters: LIST [0:?] OF property_or_data_type_BSU;
	inout_parameters: LIST [0:?] OF property_or_data_type_BSU;
END_ENTITY; -- program_reference




ENTITY message
SUBTYPE OF(dialogue_resource);
END_ENTITY; -- message




ENTITY illustration
SUPERTYPE OF (ONEOF (
              A6_ILLUSTRATION,
              A9_ILLUSTRATION))

SUBTYPE OF(dialogue_resource, graphics);
	kind_of_content: illustration_type;
	width: OPTIONAL length_measure_with_unit;
	height: OPTIONAL length_measure_with_unit;
WHERE
	WR1: (NOT EXISTS(SELF.width) AND NOT EXISTS(SELF.height))
		OR (EXISTS(SELF.width) AND EXISTS(SELF.height));
END_ENTITY; -- illustration




ENTITY A6_illustration
SUBTYPE OF(illustration);
END_ENTITY; -- A6_illustration




ENTITY A9_illustration
SUBTYPE OF(illustration);
END_ENTITY; -- A9_illustration




ENTITY translated_external_content
SUBTYPE OF(external_content);
	languages: present_translations;
WHERE
	WR1: SIZEOF(SELF\external_content.consists_of)
		= SIZEOF(SELF.languages.language_codes);
END_ENTITY; -- translated_external_content




ENTITY not_translated_external_content
SUBTYPE OF(external_content);
WHERE
	WR1: SIZEOF(SELF\external_content.consists_of) = 1;
END_ENTITY; -- not_translated_external_content




ENTITY not_translatable_external_content
SUBTYPE OF(external_content);
WHERE
	WR1: SIZEOF(SELF\external_content.consists_of) = 1;
END_ENTITY; -- not_translatable_external_content




ENTITY language_specific_content;
	content_files: SET [1:?] OF external_file_unit;
	main_file: OPTIONAL external_file_unit;
	character_encoding: OPTIONAL character_set_type;
INVERSE
	content_of: external_content FOR consists_of;
WHERE
	WR1: NOT EXISTS(main_file) OR (main_file IN content_files);
	WR2: EXISTS(main_file) XOR
		('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.PROGRAM_LIBRARY_CONTENT'
		IN TYPEOF(SELF.content_of.content_of));
	WR3: EXISTS(character_encoding) OR NOT
		('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.HTTP_PROTOCOL'
		IN TYPEOF(SELF.content_of.content_of.used_protocol));
END_ENTITY; -- language_specific_content




ENTITY external_file_unit
SUPERTYPE OF (
              HTTP_FILE);
	file: external_file_address;
	content_encoding: OPTIONAL content_encoding_type;
INVERSE
	unit_of: language_specific_content FOR content_files;
WHERE
	WR1: (('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.HTTP_PROTOCOL'
		IN TYPEOF(SELF.unit_of.content_of.content_of.used_protocol))
		AND ('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.HTTP_FILE'
		IN TYPEOF(SELF)))
		XOR NOT
		(('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.HTTP_PROTOCOL'
		IN TYPEOF(SELF.unit_of.content_of.content_of.used_protocol))
		OR ('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.HTTP_FILE'
		IN TYPEOF(SELF)));
END_ENTITY; -- external_file_unit




ENTITY http_file
SUBTYPE OF(external_file_unit);
	mime: MIME_type;
	exchange_format: MIME_subtype;
	format_RFC: OPTIONAL IAB_RFC;
	http_file_name: http_file_name_type;
	http_directory: OPTIONAL http_class_directory;
	remote_access: OPTIONAL absolute_URL_type;
UNIQUE
	UR1: http_file_name, http_directory;
WHERE
	WR1: EXISTS(http_directory) XOR
		('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.SUPPLIER_BSU_RELATED_CONTENT'
		IN TYPEOF(SELF.unit_of.content_of.content_of));
END_ENTITY; -- http_file




ENTITY http_class_directory;
	name: http_directory_name_type;
	class: class_BSU;
UNIQUE
	UR1: class;
END_ENTITY; -- http_class_directory




ENTITY level_spec_value
ABSTRACT SUPERTYPE OF (ONEOF (
                       INT_LEVEL_SPEC_VALUE,
                       REAL_LEVEL_SPEC_VALUE));
	values: ARRAY [1:4] OF OPTIONAL NUMBER;
END_ENTITY; -- level_spec_value




ENTITY int_level_spec_value
SUBTYPE OF(level_spec_value);
	SELF\level_spec_value.values: ARRAY [1:4] OF OPTIONAL INTEGER;
END_ENTITY; -- int_level_spec_value




ENTITY real_level_spec_value
SUBTYPE OF(level_spec_value);
	SELF\level_spec_value.values: ARRAY [1:4] OF OPTIONAL REAL;
END_ENTITY; -- real_level_spec_value




ENTITY dic_component_instance
SUPERTYPE OF (
              LIB_COMPONENT_INSTANCE)

SUBTYPE OF(dic_item_instance);
WHERE
	WR1: check_class_type_for_dic_item_instance(SELF);
END_ENTITY; -- dic_component_instance




ENTITY dic_material_instance
SUPERTYPE OF (
              LIB_MATERIAL_INSTANCE)

SUBTYPE OF(dic_item_instance);
WHERE
	WR1: check_class_type_for_dic_item_instance(SELF);
END_ENTITY; -- dic_material_instance




ENTITY dic_feature_instance
SUPERTYPE OF (
              LIB_FEATURE_INSTANCE)

SUBTYPE OF(dic_item_instance);
WHERE
	WR1: check_class_type_for_dic_item_instance(SELF);
END_ENTITY; -- dic_feature_instance




ENTITY lib_item_instance
SUPERTYPE OF (ONEOF (
                       LIB_COMPONENT_INSTANCE,
                       LIB_MATERIAL_INSTANCE,
                       LIB_FEATURE_INSTANCE))

SUBTYPE OF(dic_item_instance);
	supplier_identification: OPTIONAL STRING;
	supplier_designation: OPTIONAL translatable_label;
	user_identification: OPTIONAL STRING;
	user_designation: OPTIONAL translatable_label;
	is_global_id: BOOLEAN;
	source_class_content: OPTIONAL version_type;
END_ENTITY; -- lib_item_instance




ENTITY lib_component_instance
SUBTYPE OF(dic_component_instance, lib_item_instance);
END_ENTITY; -- lib_component_instance




ENTITY lib_material_instance
SUBTYPE OF(dic_material_instance, lib_item_instance);
END_ENTITY; -- lib_material_instance




ENTITY lib_feature_instance
SUBTYPE OF(dic_feature_instance, lib_item_instance);
END_ENTITY; -- lib_feature_instance




ENTITY dic_f_model_instance
SUPERTYPE OF (
              LIB_F_MODEL_INSTANCE)

SUBTYPE OF(dic_class_instance);
WHERE
	WR1: check_class_type_for_dic_f_model_instance(SELF);
END_ENTITY; -- dic_f_model_instance




ENTITY lib_f_model_instance
SUBTYPE OF(dic_f_model_instance);
END_ENTITY; -- lib_f_model_instance




ENTITY dic_f_view_instance
SUBTYPE OF(dic_class_instance, representation);
	generated_by: OPTIONAL dic_f_model_instance;
	view_of: OPTIONAL dic_item_instance;
DERIVE
	SELF\dic_class_instance.case_of: SET OF class_BSU := [];
WHERE
	WR1: check_class_type_for_dic_f_view_instance(SELF);
	WR2: NOT all_class_descriptions_reachable(
		SELF\dic_class_instance.class_def)
		OR (QUERY(prop <* functional_view_v_c_v(
		SELF\dic_class_instance.class_def)
		| SIZEOF(QUERY(prop2 <* SELF.properties
		| prop2.prop_def = prop))<>1) = []);
	WR3: correct_view_from_model(SELF);
END_ENTITY; -- dic_f_view_instance




ENTITY property_value;
	its_value: OPTIONAL primitive_value;
	prop_def: property_BSU;
WHERE
	WR1: (EXISTS(SELF.its_value) AND (compatible_type_and_value
		(SELF.prop_def, SELF.its_value) ))
		OR NOT EXISTS(SELF.its_value);
END_ENTITY; -- property_value




ENTITY context_dependent_property_value
SUBTYPE OF(property_value);
	the_context: LIST[1:?] OF property_value;
WHERE
	WR1: QUERY(c <* SELF.the_context | NOT(is_condition_det(c)))
		= [];
	WR2: is_dependent_p_det(SELF\property_value.prop_def);
	WR3: all_context_parameters_referenced(SELF);
END_ENTITY; -- context_dependent_property_value




ENTITY translated_string_value;
	string_values: LIST [1:?] OF string_value;
	languages: present_translations;
WHERE
	WR1: SIZEOF(string_values) = SIZEOF(languages.language_codes);
END_ENTITY; -- translated_string_value




ENTITY null_value;
END_ENTITY; -- null_value



ENTITY aggregate_entity_instance_value
SUBTYPE OF (uncontrolled_entity_instance_value);
	the_value: aggregate_value;
END_ENTITY;



ENTITY list_value
SUBTYPE OF (aggregate_value);
	SELF\aggregate_value.values: LIST OF primitive_value;
END_ENTITY;



ENTITY set_value
SUBTYPE OF (aggregate_value);
	SELF\aggregate_value.values: LIST OF primitive_value;
WHERE
    WR1: VALUE_UNIQUE(values);
END_ENTITY;



ENTITY bag_value
SUBTYPE OF (aggregate_value);
	SELF\aggregate_value.values: LIST OF primitive_value;
END_ENTITY;



ENTITY array_value
SUBTYPE OF (aggregate_value) ;
    bound_1: INTEGER;
    bound_2: INTEGER;
WHERE
    WR1: SIZEOF(SELF\aggregate_value.values) = SELF.bound_2 - SELF.bound_1 + 1;
END_ENTITY;



ENTITY library
SUPERTYPE OF (
              LIBRARY_IN_STANDARD_FORMAT)

SUBTYPE OF(dictionary);
	linked_interfaces: SET [0:?] OF external_file_protocol;
WHERE
	WR1: QUERY(class <* SELF\dictionary.contained_classes |
		referenced_veps_exist_in_supported_veps(
		SELF, class)) = [];
	WR2: QUERY(class <* SELF.contained_classes |
		referenced_protocols_exist_in_supported_protocols(
		SELF, class)) = [];
	WR3: QUERY(int <* SELF.linked_interfaces
		| NOT(('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA'+
		'.LINKED_INTERFACE_PROGRAM_PROTOCOL')
		IN TYPEOF(int))) = [];
END_ENTITY; -- library




ENTITY library_in_standard_format
SUBTYPE OF(library, dictionary_in_standard_format);
WHERE
	WR1: QUERY(int <* SELF\library.linked_interfaces
		| SIZEOF(QUERY(vep <* SELF\dictionary.supported_vep
		| int\external_file_protocol.base_protocol IN
		vep\data_exchange_specification_identification
		.external_file_protocols )) = 0) = [];
END_ENTITY; -- library_in_standard_format




ENTITY explicit_item_class_extension
SUBTYPE OF(explicit_model_class_extension);
	access_icon: OPTIONAL A9_illustration;
	content_msg: OPTIONAL message;
	create_icon: LIST [0:?] OF A6_illustration;
	create_msg: OPTIONAL message;
	class_presentation_on_paper: LIST [0:?] OF illustration;
	class_presentation_on_screen: LIST [0:?] OF illustration;
WHERE
	WR1: QUERY(inst <* SELF\explicit_model_class_extension.POPULATION
		| NOT('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA' +
		'.DIC_ITEM_INSTANCE' IN TYPEOF(inst))) = [];
	WR2: definition_available_implies(
		SELF\content_item.dictionary_definition,
		'ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.ITEM_CLASS' IN TYPEOF(
		(SELF\content_item.dictionary_definition.definition[1])));
	WR3: NOT(EXISTS(SELF.access_icon)) OR (SELF.access_icon IN
		SELF\model_class_extension.referenced_external_items);
	WR4: NOT(EXISTS(SELF.content_msg)) OR (SELF.content_msg IN
		SELF\model_class_extension.referenced_external_items);
	WR5: list_to_set(SELF.create_icon)
		<= SELF\model_class_extension.referenced_external_items;
	WR6: NOT(EXISTS(SELF.create_msg)) OR (SELF.create_msg IN
		SELF\model_class_extension.referenced_external_items);
	WR7: list_to_set(SELF.class_presentation_on_paper)
		<= SELF\model_class_extension.referenced_external_items;
	WR8: list_to_set(SELF.class_presentation_on_screen)
		<= SELF\model_class_extension.referenced_external_items;
	WR9: QUERY(icon <* SELF.class_presentation_on_paper |
		(NOT EXISTS(icon.width)) OR (icon.kind_of_content
		= illustration_type.not_static_picture)) = [];
	WR10: QUERY(icon <* SELF.class_presentation_on_screen |
		(NOT EXISTS(icon.width))) = [];
END_ENTITY; -- explicit_item_class_extension




ENTITY explicit_functional_model_class_extension
SUBTYPE OF(explicit_model_class_extension);
	measure_unit: OPTIONAL global_unit_assigned_context;
	required_item_values: SET [0:?] OF property_bsu;
	referenced_representation: OPTIONAL property_bsu;
	available_views_icon: OPTIONAL A6_illustration;
	available_views_msg: OPTIONAL message;
	context_param_icon: LIST [0:?] OF A6_illustration;
	context_param_msg: OPTIONAL message;
WHERE
	WR1:definition_available_implies(
		SELF\content_item.dictionary_definition,
		'ISO13584_25_LIBRARY_IMPLICIT_SCHEMA'+
		'.ABSTRACT_FUNCTIONAL_MODEL_CLASS' IN TYPEOF
		(SELF\content_item.dictionary_definition.definition[1]));
	WR2: required_values_are_non_dependent_p_det(SELF);
	WR3: required_values_are_imported_properties(SELF);
	WR4: SELF.required_item_values <= list_to_set(
		SELF\explicit_model_class_extension.instance_identification);
	WR5: NOT(EXISTS(SELF.available_views_icon))
		OR (SELF.available_views_icon IN
		SELF\model_class_extension.referenced_external_items);
	WR6: NOT(EXISTS(SELF.available_views_msg))
		OR (SELF.available_views_msg IN
		SELF\model_class_extension.referenced_external_items);
	WR7: list_to_set(SELF.context_param_icon) <=
		SELF\model_class_extension.referenced_external_items;
	WR8: NOT(EXISTS(SELF.context_param_msg))
		OR (SELF.context_param_msg IN
		SELF\model_class_extension.referenced_external_items);
	WR9: exists_representation_for_instanciable_view(SELF);
	WR10: all_view_control_variables_belong_to_each_view(SELF);
	WR11: QUERY(a_view <* SELF\explicit_model_class_extension.
		POPULATION | NOT('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA' +
		'.DIC_F_MODEL_INSTANCE' IN TYPEOF(a_view))) = [];
	WR12: all_vcvs_belong_to_instance_identification(SELF);
	WR13: NOT EXISTS (referenced_representation)
		OR (QUERY(inst <* SELF.POPULATION | NOT
		(is_provided_once_property_value(
		inst, referenced_representation))) = []);
	WR14: NOT EXISTS (referenced_representation)
		OR (QUERY(inst <* SELF.POPULATION | NOT
		(number_of_instance_representations(
		inst)= 1)) = []);
	WR15: EXISTS (referenced_representation)
		OR (QUERY(inst <* SELF.POPULATION | NOT
		(number_of_instance_representations(
		inst)= 0)) = []);
	WR16: NOT EXISTS (referenced_representation)
		OR (SIZEOF ( referenced_representation.definition) = 0)
		OR NOT ('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.' +
			'PROGRAM_REFERENCE_TYPE' IN
			data_type_typeof(referenced_representation))
		OR (QUERY(inst <* SELF.POPULATION | NOT
		(correct_parameters_for_explicit_program(
		inst, referenced_representation))) = []);
END_ENTITY; -- explicit_functional_model_class_extension




ENTITY property_classification;
	its_value: classification_value;
	prop_def: property_BSU;
END_ENTITY; -- property_classification




ENTITY property_value_recommended_presentation;
	prop_def: property_BSU;
	recommended_presentation_unit: unit;
	recommended_presentation_format: value_format_type;
WHERE
	WR1: presentation_unit_is_correct(SELF.prop_def,
		SELF.recommended_presentation_unit);
END_ENTITY;



ENTITY amount_of_substance_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.AMOUNT_OF_SUBSTANCE_UNIT' IN
       TYPEOF (SELF\measure_with_unit.unit_component);
END_ENTITY;



ENTITY amount_of_substance_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1: (SELF\named_unit.dimensions.length_exponent                    = 0.0) AND
          (SELF\named_unit.dimensions.mass_exponent                      = 0.0) AND
          (SELF\named_unit.dimensions.time_exponent                      = 0.0) AND
          (SELF\named_unit.dimensions.electric_current_exponent          = 0.0) AND
          (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND
          (SELF\named_unit.dimensions.amount_of_substance_exponent       = 1.0) AND
          (SELF\named_unit.dimensions.luminous_intensity_exponent        = 0.0);
END_ENTITY;



ENTITY area_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.AREA_UNIT' IN TYPEOF (SELF\measure_with_unit.unit_component);
END_ENTITY;



ENTITY area_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1: (SELF\named_unit.dimensions.length_exponent = 2.0)                    AND
       (SELF\named_unit.dimensions.mass_exponent = 0.0)                      AND
       (SELF\named_unit.dimensions.time_exponent = 0.0)                      AND
       (SELF\named_unit.dimensions.electric_current_exponent = 0.0)          AND
       (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND
       (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0)       AND
       (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY;



ENTITY context_dependent_unit
  SUBTYPE OF (named_unit);
  name : label;
END_ENTITY;



ENTITY conversion_based_unit
  SUBTYPE OF (named_unit);
  name              : label;
  conversion_factor : measure_with_unit;
END_ENTITY;



ENTITY derived_unit;
  elements : SET [1:?] OF derived_unit_element;
WHERE
  WR1 : ( SIZEOF ( elements ) > 1 ) OR
          (( SIZEOF ( elements ) = 1 ) AND ( elements[1].exponent <> 1.0 ));
END_ENTITY;



ENTITY derived_unit_element;
  unit     : named_unit;
  exponent : REAL;
END_ENTITY;



ENTITY dimensional_exponents;
  length_exponent                    : REAL; 
  mass_exponent                      : REAL;
  time_exponent                      : REAL;
  electric_current_exponent          : REAL;
  thermodynamic_temperature_exponent : REAL;
  amount_of_substance_exponent       : REAL;
  luminous_intensity_exponent        : REAL;
END_ENTITY;



ENTITY electric_current_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.ELECTRIC_CURRENT_UNIT' IN TYPEOF (SELF\measure_with_unit.unit_component);
END_ENTITY;



ENTITY electric_current_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1: (SELF\named_unit.dimensions.length_exponent                    = 0.0) AND
       (SELF\named_unit.dimensions.mass_exponent                      = 0.0) AND
       (SELF\named_unit.dimensions.time_exponent                      = 0.0) AND
       (SELF\named_unit.dimensions.electric_current_exponent          = 1.0) AND
       (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND
       (SELF\named_unit.dimensions.amount_of_substance_exponent       = 0.0) AND
       (SELF\named_unit.dimensions.luminous_intensity_exponent        = 0.0);
END_ENTITY;



ENTITY global_unit_assigned_context
  SUBTYPE OF (representation_context);
  units : SET [1:?] OF unit;
END_ENTITY; 



ENTITY length_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.LENGTH_UNIT' IN TYPEOF (SELF\measure_with_unit.unit_component);
END_ENTITY;                             



ENTITY length_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1: (SELF\named_unit.dimensions.length_exponent = 1.0)                    AND
       (SELF\named_unit.dimensions.mass_exponent = 0.0)                      AND
       (SELF\named_unit.dimensions.time_exponent = 0.0)                      AND
       (SELF\named_unit.dimensions.electric_current_exponent = 0.0)          AND
       (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND
       (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0)       AND
       (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY;



ENTITY luminous_intensity_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.LUMINOUS_INTENSITY_UNIT' IN
       TYPEOF (SELF\measure_with_unit.unit_component);
END_ENTITY;



ENTITY luminous_intensity_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1: (SELF\named_unit.dimensions.length_exponent                    = 0.0) AND
       (SELF\named_unit.dimensions.mass_exponent                      = 0.0) AND
       (SELF\named_unit.dimensions.time_exponent                      = 0.0) AND
       (SELF\named_unit.dimensions.electric_current_exponent          = 0.0) AND
       (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND
       (SELF\named_unit.dimensions.amount_of_substance_exponent       = 0.0) AND
       (SELF\named_unit.dimensions.luminous_intensity_exponent        = 1.0);
END_ENTITY;



ENTITY mass_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.MASS_UNIT' IN TYPEOF (SELF\measure_with_unit.unit_component);
END_ENTITY;



ENTITY mass_unit 
  SUBTYPE OF (named_unit);
WHERE
  WR1: (SELF\named_unit.dimensions.length_exponent                    = 0.0) AND
       (SELF\named_unit.dimensions.mass_exponent                      = 1.0) AND
       (SELF\named_unit.dimensions.time_exponent                      = 0.0) AND
       (SELF\named_unit.dimensions.electric_current_exponent          = 0.0) AND
       (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND
       (SELF\named_unit.dimensions.amount_of_substance_exponent       = 0.0) AND
       (SELF\named_unit.dimensions.luminous_intensity_exponent        = 0.0);
END_ENTITY ;



ENTITY measure_with_unit
  SUPERTYPE OF (ONEOF (
              LENGTH_MEASURE_WITH_UNIT,
              MASS_MEASURE_WITH_UNIT,
              TIME_MEASURE_WITH_UNIT,
              ELECTRIC_CURRENT_MEASURE_WITH_UNIT,
              THERMODYNAMIC_TEMPERATURE_MEASURE_WITH_UNIT,
              AMOUNT_OF_SUBSTANCE_MEASURE_WITH_UNIT,
              LUMINOUS_INTENSITY_MEASURE_WITH_UNIT,
              PLANE_ANGLE_MEASURE_WITH_UNIT,
              SOLID_ANGLE_MEASURE_WITH_UNIT,
              AREA_MEASURE_WITH_UNIT,
              VOLUME_MEASURE_WITH_UNIT,
              RATIO_MEASURE_WITH_UNIT));
  value_component : measure_value;
  unit_component  : unit;
WHERE
  WR1: valid_units (SELF);
END_ENTITY;



ENTITY named_unit
  SUPERTYPE OF (ONEOF (
              SI_UNIT,
              CONVERSION_BASED_UNIT,
              CONTEXT_DEPENDENT_UNIT)
              ANDOR ONEOF (
              LENGTH_UNIT,
              MASS_UNIT,
              TIME_UNIT,
              ELECTRIC_CURRENT_UNIT,
              THERMODYNAMIC_TEMPERATURE_UNIT,
              AMOUNT_OF_SUBSTANCE_UNIT,
              LUMINOUS_INTENSITY_UNIT,
              PLANE_ANGLE_UNIT,
              SOLID_ANGLE_UNIT,
              AREA_UNIT,
              VOLUME_UNIT,
              RATIO_UNIT));
  dimensions : dimensional_exponents;
END_ENTITY;



ENTITY plane_angle_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.PLANE_ANGLE_UNIT' IN
       TYPEOF (SELF\measure_with_unit.unit_component);
END_ENTITY;



ENTITY plane_angle_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1: (SELF\named_unit.dimensions.length_exponent                    = 0.0) AND
       (SELF\named_unit.dimensions.mass_exponent                      = 0.0) AND
       (SELF\named_unit.dimensions.time_exponent                      = 0.0) AND
       (SELF\named_unit.dimensions.electric_current_exponent          = 0.0) AND
       (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND
       (SELF\named_unit.dimensions.amount_of_substance_exponent       = 0.0) AND
       (SELF\named_unit.dimensions.luminous_intensity_exponent        = 0.0);
END_ENTITY;



ENTITY ratio_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.RATIO_UNIT' IN TYPEOF (SELF\measure_with_unit.unit_component);
END_ENTITY;



ENTITY ratio_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1: (SELF\named_unit.dimensions.length_exponent = 0.0)                    AND
       (SELF\named_unit.dimensions.mass_exponent = 0.0)                      AND
       (SELF\named_unit.dimensions.time_exponent = 0.0)                      AND
       (SELF\named_unit.dimensions.electric_current_exponent = 0.0)          AND
       (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND
       (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0)       AND
       (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY;



ENTITY si_unit
  SUBTYPE OF (named_unit);
  prefix     : OPTIONAL si_prefix;
  name       : si_unit_name;
DERIVE
  SELF\named_unit.dimensions : dimensional_exponents 
                             := dimensions_for_si_unit (SELF.name);
END_ENTITY;



ENTITY solid_angle_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.SOLID_ANGLE_UNIT' IN TYPEOF (SELF\measure_with_unit.unit_component);
END_ENTITY;



ENTITY solid_angle_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1: (SELF\named_unit.dimensions.length_exponent                    = 0.0) AND
       (SELF\named_unit.dimensions.mass_exponent                      = 0.0) AND
       (SELF\named_unit.dimensions.time_exponent                      = 0.0) AND
       (SELF\named_unit.dimensions.electric_current_exponent          = 0.0) AND
       (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND
       (SELF\named_unit.dimensions.amount_of_substance_exponent       = 0.0) AND
       (SELF\named_unit.dimensions.luminous_intensity_exponent        = 0.0);
END_ENTITY;



ENTITY thermodynamic_temperature_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.THERMODYNAMIC_TEMPERATURE_UNIT' IN
       TYPEOF (SELF\measure_with_unit.unit_component);
END_ENTITY;



ENTITY thermodynamic_temperature_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1: (SELF\named_unit.dimensions.length_exponent                    = 0.0) AND
       (SELF\named_unit.dimensions.mass_exponent                      = 0.0) AND
       (SELF\named_unit.dimensions.time_exponent                      = 0.0) AND
       (SELF\named_unit.dimensions.electric_current_exponent          = 0.0) AND
       (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 1.0) AND
       (SELF\named_unit.dimensions.amount_of_substance_exponent       = 0.0) AND
       (SELF\named_unit.dimensions.luminous_intensity_exponent        = 0.0);
END_ENTITY;



ENTITY time_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.TIME_UNIT' IN TYPEOF (SELF\measure_with_unit.unit_component);
END_ENTITY;



ENTITY time_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1: (SELF\named_unit.dimensions.length_exponent                    = 0.0) AND
       (SELF\named_unit.dimensions.mass_exponent                      = 0.0) AND
       (SELF\named_unit.dimensions.time_exponent                      = 1.0) AND
       (SELF\named_unit.dimensions.electric_current_exponent          = 0.0) AND
       (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND
       (SELF\named_unit.dimensions.amount_of_substance_exponent       = 0.0) AND
       (SELF\named_unit.dimensions.luminous_intensity_exponent        = 0.0);
END_ENTITY;



ENTITY volume_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.VOLUME_UNIT' IN TYPEOF (SELF\measure_with_unit.unit_component);
END_ENTITY;



ENTITY volume_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1: (SELF\named_unit.dimensions.length_exponent = 3.0)                    AND
       (SELF\named_unit.dimensions.mass_exponent = 0.0)                      AND
       (SELF\named_unit.dimensions.time_exponent = 0.0)                      AND
       (SELF\named_unit.dimensions.electric_current_exponent = 0.0)          AND
       (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND
       (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0)       AND
       (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY;



ENTITY address; 
  internal_location       : OPTIONAL label;
  street_number           : OPTIONAL label;
  street                  : OPTIONAL label;
  postal_box              : OPTIONAL label;
  town                    : OPTIONAL label;
  region                  : OPTIONAL label;
  postal_code             : OPTIONAL label;
  country                 : OPTIONAL label;
  facsimile_number        : OPTIONAL label;
  telephone_number        : OPTIONAL label;
  electronic_mail_address : OPTIONAL label;
  telex_number            : OPTIONAL label;
WHERE
  WR1: EXISTS(internal_location)       OR
       EXISTS(street_number)           OR
       EXISTS(street)                  OR
       EXISTS(postal_box)              OR
       EXISTS(town)                    OR
       EXISTS(region)                  OR
       EXISTS(postal_code)             OR
       EXISTS(country)                 OR
       EXISTS(facsimile_number)        OR
       EXISTS(telephone_number)        OR
       EXISTS(electronic_mail_address) OR
       EXISTS(telex_number);
END_ENTITY; 



ENTITY organization; 
  id          : OPTIONAL identifier; 
  name        : label; 
  description : text; 
END_ENTITY; 



ENTITY person; 
  id            : identifier;
  last_name     : OPTIONAL label; 
  first_name    : OPTIONAL label; 
  middle_names  : OPTIONAL LIST [1:?] OF label; 
  prefix_titles : OPTIONAL LIST [1:?] OF label;
  suffix_titles : OPTIONAL LIST [1:?] OF label;
UNIQUE 
  UR1: id;
WHERE
  WR1: EXISTS(last_name) OR EXISTS(first_name);
END_ENTITY; 



ENTITY axis1_placement
 SUBTYPE OF (placement);
   axis     : OPTIONAL direction;
 DERIVE
   z : direction := NVL(normalise(axis), dummy_gri ||
                                 direction([0.0,0.0,1.0]));
 WHERE
   WR1: SELF\geometric_representation_item.dim  = 3;
 END_ENTITY;



ENTITY axis2_placement_2d
   SUBTYPE OF (placement);
   ref_direction : OPTIONAL direction;
 DERIVE
   p             : LIST [2:2] OF direction := build_2axes(ref_direction);
 WHERE
   WR1: SELF\geometric_representation_item.dim = 2;
 END_ENTITY;



ENTITY axis2_placement_3d
   SUBTYPE OF (placement);
   axis          : OPTIONAL direction;
   ref_direction : OPTIONAL direction;
 DERIVE
   p             : LIST [3:3] OF direction := build_axes(axis,ref_direction);
 WHERE
   WR1: SELF\placement.location.dim = 3;
   WR2: (NOT (EXISTS (axis))) OR (axis.dim = 3);
   WR3: (NOT (EXISTS (ref_direction))) OR (ref_direction.dim = 3);
   WR4: (NOT (EXISTS (axis))) OR (NOT (EXISTS (ref_direction))) OR
          (cross_product(axis,ref_direction).magnitude > 0.0);
 END_ENTITY;



ENTITY geometric_representation_context
  SUBTYPE OF (representation_context);
  coordinate_space_dimension : dimension_count;
END_ENTITY;



ENTITY placement
   SUPERTYPE OF (ONEOF (
              AXIS1_PLACEMENT,
              AXIS2_PLACEMENT_2D,
              AXIS2_PLACEMENT_3D))
  SUBTYPE OF (geometric_representation_item);
   location : cartesian_point;
 END_ENTITY;



ENTITY representation;
  name             : label;
  items            : SET[1:?] OF representation_item;
  context_of_items : representation_context;
END_ENTITY;



ENTITY representation_context;
  context_identifier : identifier;
  context_type       : text;
INVERSE
  representations_in_context : SET [1:?] OF representation
    FOR context_of_items;
END_ENTITY;



ENTITY representation_item;
  name : label;
WHERE
  WR1: SIZEOF(using_representations(SELF)) > 0;
END_ENTITY;



ENTITY application_context;
  application          : text; 
INVERSE   
  context_elements : SET [1:?] OF  application_context_element 
                                FOR frame_of_reference;
END_ENTITY;



ENTITY application_context_element
  ;
  name                 : label;
  frame_of_reference   : application_context;
END_ENTITY;



ENTITY application_protocol_definition;
  status                                    : label;
  application_interpreted_model_schema_name : label; 
  application_protocol_year                 : year_number; 
  application                               : application_context;
END_ENTITY;




ENTITY basic_semantic_unit
ABSTRACT SUPERTYPE OF (ONEOF (
                       SUPPLIER_BSU,
                       CLASS_BSU,
                       PROPERTY_BSU,
                       DATA_TYPE_BSU,
                       SUPPLIER_RELATED_BSU,
                       CLASS_RELATED_BSU));
	
	code: code_type;
	version: version_type;
DERIVE
	dic_identifier: identifier := code + sep_cv + version;
INVERSE
	definition: SET [0:1] OF dictionary_element FOR 
	identified_by;
	referenced_by: SET [0:1] OF content_item 
		FOR dictionary_definition;
END_ENTITY; -- basic_semantic_unit




ENTITY dictionary_element
ABSTRACT SUPERTYPE OF (ONEOF (
                       SUPPLIER_ELEMENT,
                       CLASS_AND_PROPERTY_ELEMENTS,
                       DATA_TYPE_ELEMENT));

	identified_by: basic_semantic_unit;
	time_stamps: OPTIONAL dates;
	revision: revision_type;
END_ENTITY; -- dictionary_element




ENTITY content_item
ABSTRACT SUPERTYPE;
	dictionary_definition: basic_semantic_unit;
END_ENTITY; -- content_item




ENTITY supplier_BSU_relationship
ABSTRACT SUPERTYPE;
	relating_supplier: supplier_element;
	related_tokens: SET [1:?] OF supplier_related_BSU;
END_ENTITY; -- supplier_BSU_relationship




ENTITY supplier_related_BSU
ABSTRACT SUPERTYPE

SUBTYPE OF(basic_semantic_unit);
END_ENTITY; -- supplier_related_BSU




ENTITY class
ABSTRACT SUPERTYPE OF (
                       ITEM_CLASS)

SUBTYPE OF(class_and_property_elements);
	SELF\dictionary_element.identified_by: class_BSU;
	its_superclass: OPTIONAL class_BSU;
	described_by: LIST [0:?] OF UNIQUE property_BSU;
	defined_types: SET [0:?] OF data_type_BSU;
DERIVE
	subclasses: SET [0:?] OF class := identified_by.subclasses;
	known_applicable_properties: SET [0:?] OF property_BSU
		:= compute_known_applicable_properties(
			SELF\dictionary_element.identified_by);
	known_applicable_data_types: SET [0:?] OF data_type_BSU
		:= compute_known_applicable_data_types(
			SELF\dictionary_element.identified_by);
INVERSE
	associated_items: SET [0:?] OF class_BSU_relationship 
		FOR relating_class;
WHERE
	WR1: acyclic_superclass_relationship(SELF.identified_by, []);
	WR2: NOT all_class_descriptions_reachable(
		SELF\dictionary_element.identified_by)
		OR (list_to_set(SELF.described_by) <= 
		SELF\dictionary_element.identified_by
		\class_BSU.known_visible_properties);
	WR3: NOT all_class_descriptions_reachable(
		SELF\dictionary_element.identified_by)
		OR (SELF.defined_types <= 
		SELF\dictionary_element.identified_by
		\class_BSU.known_visible_data_types); 
	WR4: check_properties_applicability(SELF);
	WR5: check_datatypes_applicability(SELF);
END_ENTITY; -- class




ENTITY class_and_property_elements
ABSTRACT SUPERTYPE OF (ONEOF (
                       PROPERTY_DET,
                       CLASS))

SUBTYPE OF(dictionary_element);
	names: item_names;
	definition: definition_type;
	source_doc_of_definition: OPTIONAL document;
	note: OPTIONAL note_type;
	remark: OPTIONAL remark_type;
END_ENTITY; -- class_and_property_elements




ENTITY document
ABSTRACT SUPERTYPE;
END_ENTITY; -- document




ENTITY class_BSU_relationship
ABSTRACT SUPERTYPE;
	relating_class: class;
	related_tokens: SET [1:?] OF class_related_BSU;
END_ENTITY; -- class_BSU_relationship




ENTITY class_related_BSU
ABSTRACT SUPERTYPE

SUBTYPE OF(basic_semantic_unit);
END_ENTITY; -- class_related_BSU




ENTITY graphics
ABSTRACT SUPERTYPE;
END_ENTITY; -- graphics




ENTITY data_type
ABSTRACT SUPERTYPE OF (ONEOF (
                       SIMPLE_TYPE,
                       COMPLEX_TYPE,
                       NAMED_TYPE));
END_ENTITY; -- data_type




ENTITY simple_type
ABSTRACT SUPERTYPE OF (ONEOF (
                       NUMBER_TYPE,
                       BOOLEAN_TYPE,
                       STRING_TYPE))

SUBTYPE OF(data_type);
	value_format: value_format_type;
END_ENTITY; -- simple_type



ENTITY aggregate_type
ABSTRACT SUPERTYPE OF(ONEOF(
		list_type,
		set_type,
		bag_type,
		array_type));
    bound_1: OPTIONAL INTEGER;
    bound_2: OPTIONAL INTEGER;
	value_type: data_type;
WHERE
    WR1: bound_1 <= bound_2;
END_ENTITY;



ENTITY dictionary_identification;
	code: dictionary_code_type;
	version: version_type;
	revision: revision_type;
	defined_by: supplier_bsu;
DERIVE
	absolute_id: identifier :=
		defined_by.absolute_id + sep_id + code + sep_cv + version;
INVERSE
	definition: SET [0:1] OF dictionary FOR identified_by;
UNIQUE
	UR1: absolute_id;
END_ENTITY;




ENTITY external_file_protocol
ABSTRACT SUPERTYPE OF ((ONEOF (
                       STANDARD_PROTOCOL,
                       NON_STANDARD_PROTOCOL))
                       ANDOR (ONEOF (
                       PROGRAM_PROTOCOL,
                       DATA_PROTOCOL)));
	organisation: organization;
	country: OPTIONAL identifier;
	protocol_name: identifier;
	protocol_version: identifier;
	level: OPTIONAL identifier;
	designation: item_names;
	base_protocol: OPTIONAL program_protocol;
WHERE
	WR1: (NOT(SELF.protocol_name LIKE '* *'))
		AND (NOT(SELF.protocol_name LIKE '*.*'))
		AND (NOT(SELF.protocol_name LIKE '*-*'));
	WR2: NOT(SELF.protocol_version LIKE '* *');
END_ENTITY; -- external_file_protocol




ENTITY program_protocol
ABSTRACT SUPERTYPE OF (ONEOF (
                       LINKED_INTERFACE_PROGRAM_PROTOCOL,
                       SIMPLE_PROGRAM_PROTOCOL))

SUBTYPE OF(external_file_protocol);
END_ENTITY; -- program_protocol




ENTITY a_posteriori_semantic_relationship
ABSTRACT SUPERTYPE OF (ONEOF (
                       A_POSTERIORI_CASE_OF,
                       A_POSTERIORI_VIEW_OF));
END_ENTITY; -- a_posteriori_semantic_relationship




ENTITY a_priori_semantic_relationship
ABSTRACT SUPERTYPE OF (ONEOF (
                       ITEM_CLASS_CASE_OF,
                       FM_CLASS_VIEW_OF,
                       FUNCTIONAL_MODEL_CLASS))

SUBTYPE OF(class);
	referenced_classes: SET [1:?] OF class_BSU;
	referenced_properties: LIST [0:?] OF property_BSU;
	referenced_data_types: SET [0:?] OF data_type_BSU;
	referenced_tables: SET[0:?] OF table_BSU;
	referenced_documents: SET[0:?] OF document_BSU;
END_ENTITY; -- a_priori_semantic_relationship




ENTITY table_BSU
SUBTYPE OF(class_related_BSU, table_identification);
	name_scope: class_BSU;
	SELF\basic_semantic_unit.code: table_code_type;
DERIVE
	absolute_id: identifier:= name_scope.
		defined_by.dic_identifier + sep_id
		+ name_scope.dic_identifier + sep_id
		+ dic_identifier;
UNIQUE
	UR1: absolute_id;
END_ENTITY; -- table_BSU




ENTITY table_identification
ABSTRACT SUPERTYPE;
WHERE
	WR1: SIZEOF(USEDIN(SELF,
		'ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.TABLE_SPECIFICATION'
		+ '.TABLE_IDENTIFIER'))
		<= 1;
	WR2: SIZEOF(USEDIN(SELF,
		'ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.TABLE_EXTENSION'
		+ '.TABLE_IDENTIFIER')) <= 1;
	
END_ENTITY; -- table_identification




ENTITY data_exchange_specification_identification
ABSTRACT SUPERTYPE OF (ONEOF (
                       LIBRARY_IIM_IDENTIFICATION,
                       VIEW_EXCHANGE_PROTOCOL_IDENTIFICATION));
	source_document_identifier: OPTIONAL identifier;
	status: label;
	name: identifier;
	date: year_number;
	application: OPTIONAL identifier;
	level: OPTIONAL identifier;
	external_file_protocols: SET [0:?] OF external_file_protocol;
END_ENTITY; -- data_exchange_specification_identification




ENTITY supplier_related_dictionary_element
ABSTRACT SUPERTYPE OF (
                       PROGRAM_LIBRARY_ELEMENT)

SUBTYPE OF(dictionary_element);
	SELF\dictionary_element.identified_by: supplier_related_BSU;
	names: item_names;
	definition: definition_type;
	note: OPTIONAL note_type;
	remark: OPTIONAL remark_type;
END_ENTITY; -- supplier_related_dictionary_element




ENTITY class_related_dictionary_element
ABSTRACT SUPERTYPE OF (ONEOF (
                       DOCUMENT_ELEMENT))

SUBTYPE OF(dictionary_element);
	SELF\dictionary_element.identified_by: class_related_BSU;
	names: item_names;
	definition: definition_type;
	note: OPTIONAL note_type;
	remark: OPTIONAL remark_type;
END_ENTITY; -- class_related_dictionary_element




ENTITY abstract_functional_model_class
ABSTRACT SUPERTYPE OF (ONEOF (
                       FUNCTIONAL_MODEL_CLASS,
                       FM_CLASS_VIEW_OF))

SUBTYPE OF(class);
	created_view: class_BSU;
	v_c_v_range: SET [0:?] OF view_control_variable_range;
	imported_properties_from_view: LIST [0:?] OF property_BSU;
	imported_types_from_view: SET [0:?] OF data_type_BSU;
	imported_tables_from_view: SET [0:?] OF table_BSU;
	imported_documents_from_view: SET [0:?] OF document_BSU;
	case_of: SET [0:?] OF class_BSU;
	imported_properties_from_models: LIST [0:?] OF property_BSU;
	imported_types_from_models: SET [0:?] OF data_type_BSU;
	imported_tables_from_models: SET [0:?] OF table_BSU;
	imported_documents_from_models: SET [0:?] OF document_BSU;
WHERE
	WR1: created_view_is_functional_view(SELF.created_view);
	WR2: QUERY(v_c_v <* SELF.v_c_v_range
		| NOT applicable_properties(SELF.created_view,
		[v_c_v.parameter_type])) = [];
	WR3: QUERY(v_c_v <* SELF.v_c_v_range
		| NOT(v_c_v.parameter_type
		IN SELF.imported_properties_from_view )) = [];
	WR4: NOT EXISTS(SELF\class.its_superclass)
		OR ('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA'
		+'.ABSTRACT_FUNCTIONAL_MODEL_CLASS'
		IN TYPEOF(SELF\class.its_superclass));
	WR5: QUERY(v_c_v <* SELF.v_c_v_range
		| SIZEOF(QUERY(v_c_v_2 <* SELF.v_c_v_range
		| v_c_v.parameter_type = v_c_v_2.parameter_type)) <> 1) = [];
	WR6: QUERY(prop <* SELF\class.described_by
		| definition_available_implies(prop,
		('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA'
		+'.REPRESENTATION_P_DET') IN TYPEOF(prop.definition[1])))
		= SELF\class.described_by;
	WR7: QUERY(cl <* SELF.case_of
		| definition_available_implies(cl,
		('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA'
		+'.ABSTRACT_FUNCTIONAL_MODEL_CLASS')
		IN TYPEOF(cl.definition[1])))
		= SELF.case_of;
END_ENTITY; -- abstract_functional_model_class




ENTITY standard_protocol
ABSTRACT SUPERTYPE OF (ONEOF (
                       STANDARD_SIMPLE_PROGRAM_PROTOCOL,
                       STANDARD_DATA_PROTOCOL))

SUBTYPE OF(external_file_protocol);
END_ENTITY; -- standard_protocol




ENTITY simple_program_protocol
ABSTRACT SUPERTYPE OF (ONEOF (
                       STANDARD_SIMPLE_PROGRAM_PROTOCOL,
                       NON_STANDARD_SIMPLE_PROGRAM_PROTOCOL))

SUBTYPE OF(program_protocol);
	language: identifier;
	status: program_status;
	compiler_supplier: OPTIONAL organization;
	compiler_name: OPTIONAL identifier;
	compiler_version: OPTIONAL compiler_version_type;
WHERE
	WR1: ((SELF.status = source)
		AND (NOT(EXISTS(SELF.compiler_supplier)))
		AND (NOT(EXISTS(SELF.compiler_name)))
		AND (NOT(EXISTS(SELF.compiler_version))))
		OR ((SELF.status = compiled)
		AND (EXISTS(SELF.compiler_supplier))
		AND (EXISTS(SELF.compiler_name))
		AND (EXISTS(SELF.compiler_version)));
END_ENTITY; -- simple_program_protocol




ENTITY non_standard_protocol
ABSTRACT SUPERTYPE OF (ONEOF (
                       NON_STANDARD_SIMPLE_PROGRAM_PROTOCOL,
                       NON_STANDARD_DATA_PROTOCOL))

SUBTYPE OF(external_file_protocol);
END_ENTITY; -- non_standard_protocol




ENTITY external_item
ABSTRACT SUPERTYPE OF (ONEOF (
                       DICTIONARY_EXTERNAL_ITEM,
                       CLASS_EXTENSION_EXTERNAL_ITEM));
	used_protocol: external_file_protocol;
	content: external_content;
END_ENTITY; -- external_item




ENTITY external_content
ABSTRACT SUPERTYPE OF (ONEOF (
                       TRANSLATED_EXTERNAL_CONTENT,
                       NOT_TRANSLATED_EXTERNAL_CONTENT,
                       NOT_TRANSLATABLE_EXTERNAL_CONTENT));
	consists_of: LIST[1:?] OF language_specific_content;
INVERSE
	content_of: external_item FOR content;
END_ENTITY; -- external_content




ENTITY data_protocol
ABSTRACT SUPERTYPE OF (ONEOF (
                       STANDARD_DATA_PROTOCOL,
                       NON_STANDARD_DATA_PROTOCOL))

SUBTYPE OF(external_file_protocol);
END_ENTITY; -- data_protocol




ENTITY supplier_BSU_related_content
ABSTRACT SUPERTYPE OF (
                       PROGRAM_LIBRARY_CONTENT)

SUBTYPE OF(dictionary_external_item);
	SELF\content_item.dictionary_definition: supplier_related_BSU;
END_ENTITY; -- supplier_BSU_related_content




ENTITY dictionary_external_item
ABSTRACT SUPERTYPE OF (ONEOF (
                       SUPPLIER_BSU_RELATED_CONTENT,
                       CLASS_BSU_RELATED_CONTENT))

SUBTYPE OF(content_item, external_item);
	revision: revision_type;
END_ENTITY; -- dictionary_external_item




ENTITY class_BSU_related_content
ABSTRACT SUPERTYPE OF (
                       DOCUMENT_CONTENT)

SUBTYPE OF(dictionary_external_item);
	SELF\content_item.dictionary_definition: class_related_BSU;
END_ENTITY; -- class_BSU_related_content




ENTITY class_extension_external_item
ABSTRACT SUPERTYPE OF (ONEOF (
                       DIALOGUE_RESOURCE,
                       REPRESENTATION_REFERENCE,
                       PROGRAM_REFERENCE))

SUBTYPE OF(external_item);
	code: external_item_code_type;
INVERSE
	belongs_to: model_class_extension FOR referenced_external_items;
UNIQUE
	UR1: code, belongs_to;
END_ENTITY; -- class_extension_external_item




ENTITY model_class_extension
ABSTRACT SUPERTYPE OF (ONEOF (
                       EXPLICIT_MODEL_CLASS_EXTENSION))

SUBTYPE OF(class_extension);
	referenced_external_items: SET [0:?] OF
		class_extension_external_item;
	used_protocols: SET [0:?] OF external_file_protocol;
	referenced_view_exchange_protocol: LIST [0:?] OF
		view_exchange_protocol_identification;
	content_version: OPTIONAL version_type;
	content_revision: OPTIONAL revision_type;
	recommended_presentation: SET [0:?] OF
		property_value_recommended_presentation;
	classification: SET [0:?] OF property_classification;
WHERE
	WR1: QUERY(item <* SELF.referenced_external_items
		| NOT(item\external_item.used_protocol
		IN SELF.used_protocols)) = [];
	WR2: QUERY (prop <* classification | NOT
		applicable_properties(SELF\content_item.
		dictionary_definition, [prop.prop_def])) = [];
	WR3: (EXISTS (SELF.content_version)
		AND EXISTS (SELF.content_revision))
		OR (NOT EXISTS (SELF.content_version)
		AND NOT EXISTS (SELF.content_revision));
END_ENTITY; -- model_class_extension




ENTITY class_extension
ABSTRACT SUPERTYPE OF (ONEOF (
                       MODEL_CLASS_EXTENSION))

SUBTYPE OF(content_item);
	SELF\content_item.dictionary_definition: class_BSU;
END_ENTITY; -- class_extension




ENTITY dialogue_resource
ABSTRACT SUPERTYPE OF (ONEOF (
                       MESSAGE,
                       ILLUSTRATION))

SUBTYPE OF(class_extension_external_item);
	SELF\external_item.used_protocol: data_protocol;
END_ENTITY; -- dialogue_resource




ENTITY dic_item_instance
SUPERTYPE OF (ONEOF (
              DIC_COMPONENT_INSTANCE,
              DIC_MATERIAL_INSTANCE,
              DIC_FEATURE_INSTANCE)
              ANDOR 
              LIB_ITEM_INSTANCE)

SUBTYPE OF(dic_class_instance);
WHERE
	WR1: check_class_type_for_dic_item_instance(SELF);
	WR2: QUERY(prop <* SELF.properties
		| (SIZEOF(prop.prop_def.definition) = 1)
		AND (('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA' +
		'.DEPENDENT_P_DET')
		IN TYPEOF(prop.prop_def.definition[1]))
		AND (prop.prop_def.definition[1]\dependent_P_DET.depends_on
		>= collects_property_context(prop.prop_def, SELF)))
		= [];
END_ENTITY; -- dic_item_instance




ENTITY dic_class_instance
ABSTRACT SUPERTYPE OF (ONEOF (
                       DIC_ITEM_INSTANCE,
                       DIC_F_MODEL_INSTANCE,
                       DIC_F_VIEW_INSTANCE));
	class_def: class_BSU;
	properties: LIST [0:?] OF property_value;
	case_of: SET [0:?] OF class_BSU;
WHERE
	WR1: (QUERY(prop <* SELF.properties |
		NOT((applicable_properties(
		SELF.class_def, [prop.prop_def])))) = [ ]);
	WR2: QUERY(prop <* SELF.properties
		| (SIZEOF(QUERY (prop1 <* SELF.properties
		| prop1.prop_def = prop.prop_def)) = 1))
		= SELF.properties;
	WR3: check_property_values_translations(QUERY(prop_val <*
		properties | 'ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.' +
		'TRANSLATED_STRING_VALUE' IN TYPEOF(prop_val.its_value)));
	WR4: compatible_instance_caseof_with_class_definition(SELF);
END_ENTITY; -- dic_class_instance




ENTITY uncontrolled_entity_instance_value
ABSTRACT SUPERTYPE;
END_ENTITY; -- uncontrolled_entity_instance_value



ENTITY aggregate_value
ABSTRACT SUPERTYPE OF(ONEOF(
		list_value,
		set_value,
		bag_value,
		array_value));
    values: LIST OF null_or_primitive_value;
END_ENTITY;



ENTITY explicit_model_class_extension
ABSTRACT SUPERTYPE OF (ONEOF (
                       EXPLICIT_ITEM_CLASS_EXTENSION,
                       EXPLICIT_FUNCTIONAL_MODEL_CLASS_EXTENSION))

SUBTYPE OF(model_class_extension);
	instance_identification: LIST[1:?] OF UNIQUE property_BSU;
	POPULATION: LIST[1:?] OF UNIQUE dic_class_instance;
	table_like: BOOLEAN;
WHERE
	WR1: NOT table_like OR (QUERY(inst <* SELF.POPULATION |
		NOT same_order_for_properties(POPULATION[1].properties,
		inst.properties)) = []);
	WR2: applicable_properties(
		SELF\content_item.dictionary_definition,
		list_to_set(SELF.instance_identification));
	WR3: all_properties_are_applicable(SELF);
	WR4: same_string_values_translations_for_class_extension(SELF);
	WR5: QUERY (inst <* SELF.POPULATION |
		inst.class_def :<>: SELF\content_item.dictionary_definition)
		= [];
	WR6: QUERY(inst <* SELF.POPULATION | NOT(
		QUERY(prop <* inst.properties | NOT(EXISTS(prop.its_value))
		AND (prop.prop_def IN SELF.instance_identification)) = []))
		= [];
END_ENTITY; -- explicit_model_class_extension



ENTITY direction
   SUBTYPE OF (geometric_representation_item);
   direction_ratios : LIST [2:3] OF REAL;
 WHERE
   WR1: SIZEOF(QUERY(tmp <* direction_ratios | tmp <> 0.0)) > 0;
 END_ENTITY;



ENTITY geometric_representation_item
  SUPERTYPE OF (ONEOF (
              POINT,
              DIRECTION,
              VECTOR,
              PLACEMENT))
  SUBTYPE OF (representation_item);
DERIVE
  dim : dimension_count := dimension_of(SELF);
WHERE
  WR1: SIZEOF (QUERY (using_rep <* using_representations (SELF) |
       NOT ('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.GEOMETRIC_REPRESENTATION_CONTEXT' IN
       TYPEOF (using_rep.context_of_items)))) = 0;
END_ENTITY;



ENTITY vector
   SUBTYPE OF (geometric_representation_item);
   orientation : direction;
   magnitude   : length_measure;
 WHERE
   WR1 : magnitude >= 0.0;
 END_ENTITY;



ENTITY cartesian_point
   SUBTYPE OF (point);
   coordinates  : LIST [1:3] OF length_measure;
 END_ENTITY;



ENTITY point
   SUPERTYPE OF (ONEOF (
              CARTESIAN_POINT))
  SUBTYPE OF (geometric_representation_item);
 END_ENTITY;


(* ===================================================================================== *)
(* FUNCTIONS																			 *)
(* Wed Jul 04 17:17:27 2001                                                              *)
(* ===================================================================================== *)


FUNCTION compatible_instance_caseof_with_class_definition(
	inst: dic_class_instance): LOGICAL;
LOCAL
	is_a_subclass: LOGICAL := FALSE;
	res: LOGICAL := TRUE;
	dic_case_of: class_BSU;
	inst_case_of: class_BSU;
END_LOCAL;

IF (SIZEOF(inst.case_of) > 0)
THEN
	IF (SIZEOF(inst.class_def.definition) = 1)
	THEN
		IF ('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.' +
			'A_PRIORI_SEMANTIC_RELATIONSHIP' IN
			TYPEOF(inst.class_def.definition))
		THEN
			REPEAT i := 1 TO SIZEOF(inst.case_of);
				inst_case_of := inst.case_of[i];

				REPEAT j := 1 TO SIZEOF(
					inst.class_def.definition[1]\
					a_priori_semantic_relationship.
					referenced_classes);

					dic_case_of := inst.class_def.definition[1]
						\a_priori_semantic_relationship.
						referenced_classes[j];

					IF ((SIZEOF(inst_case_of.definition) = 1) AND
						(SIZEOF(dic_case_of.definition) = 1))
					THEN

						IF (is_subclass(dic_case_of.definition[1],
							inst_case_of.definition[1]))
						THEN
							is_a_subclass := TRUE;
						END_IF;
					ELSE
						is_a_subclass := UNKNOWN;
					END_IF;
				END_REPEAT;

				IF (NOT(is_a_subclass))
				THEN
					RETURN(FALSE);
				END_IF;

				res := res AND is_a_subclass;
				is_a_subclass := FALSE;

			END_REPEAT;

			RETURN(res);
		ELSE
			RETURN(FALSE);
		END_IF;
	ELSE
		RETURN(UNKNOWN);
	END_IF;
ELSE
	RETURN(TRUE);
END_IF;

END_FUNCTION; -- compatible_instance_caseof_with_class_definition


FUNCTION correct_parameters_for_explicit_program(
		a_model: dic_class_instance;
		prop: property_BSU): BOOLEAN;

	IF NOT('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.' +
			'PROGRAM_REFERENCE_TYPE' IN
			data_type_typeof(prop))
	THEN
		RETURN (FALSE); --not a program
	END_IF;

	REPEAT i := 1 TO SIZEOF(a_model.properties);
		IF (prop = a_model.properties[i].prop_def)
		THEN	--characteristics of the program_reference
			IF EXISTS(a_model.properties[i].its_value) AND
				('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.' +
				'PROGRAM_REFERENCE' IN
				TYPEOF(a_model.properties[i].its_value)) AND
				(SIZEOF(a_model.properties[i].its_value.
				out_parameters) = 0)
				AND (SIZEOF(a_model.properties[i].its_value.
				inout_parameters) = 0) AND
				(QUERY (in_p <* a_model.properties[i].its_value.
				in_parameters
 				| NOT('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.' +
				'PROPERTY_BSU' IN TYPEOF (in_p))
				OR NOT is_provided_once_property_value(
				a_model, in_p)) = [])
			THEN
				RETURN(TRUE); --correct program_reference
			ELSE
				RETURN(FALSE); --not correct program_reference
			END_IF;
		END_IF;
	END_REPEAT;

	RETURN(FALSE); -- program_reference was not found
END_FUNCTION; -- correct_parameters_for_explicit_program




FUNCTION exists_representation_for_instanciable_view(
	ext: explicit_functional_model_class_extension): LOGICAL;
LOCAL
	cpt: INTEGER := 0;
	prop_val: property_value;
END_LOCAL;

IF (SIZEOF(ext.dictionary_definition.definition) = 1)
THEN
	IF (SIZEOF(ext.dictionary_definition.definition[1]\
		abstract_functional_model_class.created_view.definition) = 1)
	THEN
		IF (NOT('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.' +
			'NON_INSTANTIABLE_FUNCTIONAL_VIEW_CLASS' IN TYPEOF(
			ext.dictionary_definition.definition[1]\
			abstract_functional_model_class.created_view.
			definition[1])))
		THEN
			RETURN(EXISTS(ext.referenced_representation)
					AND
					(('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.' +
					'PROGRAM_REFERENCE' IN
					data_type_type_name(
					ext.referenced_representation))
					OR ('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.' +
					'REPRESENTATION_REFERENCE' IN
					data_type_type_name(
					ext.referenced_representation))
					OR ('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.' +
					'REPRESENTATION' IN
					data_type_type_name(
					ext.referenced_representation)))) ;
		ELSE
			RETURN(NOT EXISTS(ext.referenced_representation));
		END_IF;
	ELSE
		RETURN(UNKNOWN);
	END_IF;
ELSE
	RETURN(UNKNOWN);
END_IF;

END_FUNCTION; -- exists_representation_for_instanciable_view




FUNCTION is_provided_once_property_value(
	a_model: dic_class_instance;
	prop: property_or_data_type_BSU): BOOLEAN;
LOCAL
	cpt: INTEGER := 0;
END_LOCAL;

	IF NOT (('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.' +
		'PROPERTY_BSU') IN TYPEOF (prop))
	THEN
		RETURN(FALSE);
	END_IF;

	REPEAT i := 1 TO SIZEOF(a_model.properties);
		IF ((prop = a_model.properties[i].prop_def) AND
			EXISTS(a_model.properties[i].its_value))
		THEN
			cpt := cpt + 1;
		END_IF;
	END_REPEAT;
	RETURN (cpt = 1);
END_FUNCTION; -- is_provided_once_property_value



FUNCTION number_of_instance_representations(
		a_model: dic_class_instance): INTEGER;
LOCAL
	cpt: INTEGER := 0;
	prop_val: property_value;
END_LOCAL;

REPEAT i := 1 TO SIZEOF(a_model.properties);
	prop_val := a_model.properties[i];
	IF data_type_typeof(prop_val.prop_def) = []
	THEN
		RETURN(?);
	END_IF;
	IF ('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.' +
		'ENTITY_INSTANCE_TYPE' IN
		data_type_typeof(prop_val.prop_def))
	THEN
		IF (('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.' +
			'PROGRAM_REFERENCE' IN
			data_type_type_name(prop_val.prop_def))
			OR ('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.' +
			'REPRESENTATION_REFERENCE' IN
			data_type_type_name(prop_val.prop_def))
			OR ('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.' +
			'REPRESENTATION' IN
			data_type_type_name(prop_val.prop_def)))
		THEN
			cpt := cpt + 1;
		END_IF;
	END_IF;
END_REPEAT;

RETURN (cpt );

END_FUNCTION; -- number_of_instance_representations



FUNCTION compute_known_visible_properties(cl: class_BSU):
	SET OF property_BSU;
LOCAL
	s: SET OF property_BSU := [];
END_LOCAL;

s := s + USEDIN(cl, 'ISO13584_25_LIBRARY_IMPLICIT_SCHEMA' +
	'.PROPERTY_BSU.NAME_SCOPE');
IF SIZEOF(cl.definition) = 0
THEN
	RETURN(s);
ELSE
	IF EXISTS(cl.definition[1]\class.its_superclass) THEN
		s := s + compute_known_visible_properties(
			cl.definition[1]\class.its_superclass);
	END_IF;
	
	RETURN(s);
END_IF;

END_FUNCTION; -- compute_known_visible_properties




FUNCTION compute_known_applicable_properties(cl: class_BSU): 
	SET OF property_BSU;

LOCAL 
	s: SET OF property_BSU := [];
END_LOCAL;

IF SIZEOF(cl.definition)=0
THEN 
	RETURN(s);
ELSE
	REPEAT i := 1 TO SIZEOF(cl.definition[1]\class.described_by);
		s := s + cl.definition[1]\class.described_by[i];
	END_REPEAT;

	IF EXISTS(cl.definition[1]\class.its_superclass) 
	THEN 
		s := s + compute_known_applicable_properties(
			cl.definition[1]\class.its_superclass);
	END_IF;

	RETURN(s); 
END_IF;
END_FUNCTION; -- compute_known_applicable_properties




FUNCTION compute_known_applicable_data_types(cl: class_BSU):
	SET OF data_type_BSU;
LOCAL
	s: SET OF data_type_BSU := [];
END_LOCAL;

IF SIZEOF(cl.definition) = 0
THEN
	RETURN(s);
ELSE
	REPEAT i := 1 TO SIZEOF(cl.definition[1]\class.defined_types);
		s := s + cl.definition[1]\class.defined_types[i];
	END_REPEAT;
	
	IF EXISTS(cl.definition[1]\class.its_superclass) 
	THEN
		s := s + compute_known_applicable_data_types(
			cl.definition[1]\class.its_superclass);
	END_IF;
	
	RETURN(s);
END_IF;

END_FUNCTION; -- compute_known_applicable_data_types




FUNCTION acyclic_superclass_relationship(
	current: class_BSU; visited: SET OF class): LOGICAL;

IF SIZEOF(current.definition) = 1 THEN 
	IF current.definition[1] IN visited THEN
		RETURN(FALSE);

	ELSE
		IF EXISTS(current.definition[1]\class.its_superclass)
		THEN 
			RETURN(acyclic_superclass_relationship(
				current.definition[1]\class.its_superclass,
				visited + current.definition[1])); 
		ELSE
			RETURN(TRUE);
		END_IF;
	END_IF;
ELSE
	RETURN(UNKNOWN);
END_IF;
END_FUNCTION; -- acyclic_superclass_relationship




FUNCTION all_class_descriptions_reachable(cl: class_BSU): BOOLEAN;

IF NOT EXISTS(cl)
THEN
	RETURN(UNKNOWN);
END_IF;

IF SIZEOF(cl.definition) = 0
THEN
	RETURN(FALSE);
END_IF;

IF NOT(EXISTS(cl.definition[1]\class.its_superclass))
THEN
	RETURN(TRUE);
ELSE
	RETURN(all_class_descriptions_reachable(
		cl.definition[1]\class.its_superclass));
END_IF;

END_FUNCTION; -- all_class_descriptions_reachable




FUNCTION list_to_set(l: LIST [0:?] OF GENERIC:type_elem):
	SET OF GENERIC: type_elem;

LOCAL
	s: SET OF GENERIC: type_elem := [];
END_LOCAL;

REPEAT i := 1 TO SIZEOF(l);
	s := s + l[i];
END_REPEAT;

RETURN(s);
END_FUNCTION; -- list_to_set




FUNCTION check_properties_applicability(cl: class): LOGICAL;
LOCAL
	inter: SET OF property_bsu := [];
END_LOCAL;

IF EXISTS(cl.its_superclass)
THEN
	IF (SIZEOF(cl.its_superclass.definition)=1)
	THEN
		inter := (list_to_set(cl.described_by) * 
			cl.its_superclass.definition[1]\class.
			known_applicable_properties);
		RETURN(inter = []);
	ELSE
		RETURN(UNKNOWN);
	END_IF;
ELSE
	RETURN(TRUE);
END_IF;

END_FUNCTION; -- check_properties_applicability




FUNCTION check_datatypes_applicability(cl: class): LOGICAL;
LOCAL
	inter: SET OF data_type_bsu := [];
END_LOCAL;

IF EXISTS(cl.its_superclass)
THEN
	IF (SIZEOF(cl.its_superclass.definition) = 1)
	THEN
		inter := cl.defined_types * 
			cl.its_superclass.definition[1]\class.
			known_applicable_data_types;
		RETURN(inter = []);
	ELSE
		RETURN(UNKNOWN);
	END_IF;
ELSE
	RETURN(TRUE);
END_IF;

END_FUNCTION; -- check_datatypes_applicability




FUNCTION compute_known_visible_data_types(cl: class_BSU):
	SET OF data_type_BSU;
LOCAL
	s: SET OF data_type_BSU :=[ ];
END_LOCAL;

s := s + USEDIN(cl, 'ISO13584_25_LIBRARY_IMPLICIT_SCHEMA' +
	'.DATA_TYPE_BSU.NAME_SCOPE');

IF SIZEOF(cl.definition) = 0
THEN
	RETURN(s);
ELSE
	IF EXISTS(cl.definition[1]\class.its_superclass) 
	THEN
		s := s + compute_known_visible_data_types(
			cl.definition[1]\class.its_superclass);
	END_IF;

	RETURN(s);
END_IF;

END_FUNCTION; -- compute_known_visible_data_types




FUNCTION is_subclass(sub, ssuper: class): LOGICAL;
	IF (NOT EXISTS(sub)) OR (NOT EXISTS(ssuper)) THEN
		RETURN(UNKNOWN);
	END_IF;
	
	IF sub = ssuper
	THEN
		RETURN(TRUE);
	END_IF;
	
	IF NOT EXISTS(sub.its_superclass) 
	THEN
		
		RETURN(FALSE); 
	END_IF;
	
	IF SIZEOF(sub.its_superclass.definition) = 1 
	THEN


		IF (sub.its_superclass.definition[1] = ssuper) 
		THEN
			RETURN(TRUE);
		ELSE
			RETURN(is_subclass(sub.its_superclass.definition[1],
				ssuper));
		END_IF;
	ELSE
		RETURN(UNKNOWN);
	END_IF;

END_FUNCTION; -- is_subclass




FUNCTION definition_available_implies(
	BSU: basic_semantic_unit;
	expression: LOGICAL): LOGICAL;

RETURN(NOT(SIZEOF(BSU.definition) = 1) OR expression);

END_FUNCTION; -- definition_available_implies




FUNCTION codes_are_unique(values: LIST OF dic_value): BOOLEAN;
LOCAL
	ls: SET OF STRING := [];
	li: SET OF INTEGER := [];
END_LOCAL;

IF('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.VALUE_CODE_TYPE' IN
	TYPEOF(values[1].value_code))
THEN
	REPEAT i := 1 TO SIZEOF(values);
		ls := ls + values[i].value_code;
	END_REPEAT;

	RETURN(SIZEOF(values) = SIZEOF(ls));
ELSE
	IF('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.INTEGER_TYPE' IN
		TYPEOF(values[1].value_code))
	THEN
		REPEAT i := 1 TO SIZEOF(values);
			li := li + values[i].value_code;
		END_REPEAT;

		RETURN(SIZEOF(values) = SIZEOF(li));
	ELSE
		RETURN(UNKNOWN);
	END_IF;
END_IF;

END_FUNCTION; -- codes_are_unique




FUNCTION check_label_length(l: translatable_label;
	l_length: INTEGER): BOOLEAN;

IF 'ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.TRANSLATED_LABEL'
	IN TYPEOF(l) 
THEN 
	REPEAT i :=1 TO SIZEOF(l.labels);
		IF LENGTH(l.labels[i]) > l_length 
		THEN
			RETURN(FALSE);
		END_IF;
	END_REPEAT;

	RETURN(TRUE);

ELSE 
	RETURN(LENGTH(l) <= l_length); 
END_IF;
END_FUNCTION; -- check_label_length 




FUNCTION check_syn_length(s: syn_name_type; s_length: INTEGER):BOOLEAN;

IF 'ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.LABEL_WITH_LANGUAGE'
	IN TYPEOF(s)
THEN
	RETURN(LENGTH(s.l) <= s_length); 
ELSE
	RETURN(LENGTH(s) <= s_length); 
END_IF;
END_FUNCTION; -- check_syn_length 




FUNCTION prefix_ordered_class_list(classes: LIST[2:?] OF class_BSU):
	BOOLEAN;

LOCAL
	related_token: class_related_BSU;	-- items associated with
		-- a class through a class_BSU_relationship
END_LOCAL;

REPEAT i := 1 TO SIZEOF(classes);

	IF SIZEOF(classes[i].definition) = 1
	THEN

		IF (EXISTS(classes[i].definition[1]\class.its_superclass))
			AND (NOT((classes[i].definition[1]\class.its_superclass)
			IN (makes_sub_list(classes, 1, i - 1))))
		THEN
			RETURN(FALSE);
		END_IF;

		IF ('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA'+
			'.A_PRIORI_SEMANTIC_RELATIONSHIP'
			IN TYPEOF(classes[i].definition[1]))
		THEN
			IF (QUERY(x <* classes[i].definition[1]
			\a_priori_semantic_relationship.
			referenced_classes | NOT(x IN makes_sub_list(
			classes, 1, i - 1))) <> [])
			THEN
				RETURN(FALSE);
			END_IF;
		END_IF;

		IF NOT(SIZEOF(classes[i].definition[1]\class.described_by)
			= 0)
		THEN
			IF (makes_reference_outside(classes[i].definition[1]
				\class.described_by, makes_sub_list(
				classes, 1, i)))
			THEN
				RETURN(FALSE);
			END_IF;
		END_IF;

		IF ('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA'+
			'.A_PRIORI_SEMANTIC_RELATIONSHIP'
			IN TYPEOF(classes[i].definition[1]))
		THEN
			IF makes_reference_outside(classes[i].definition[1]\
			a_priori_semantic_relationship.referenced_properties,
			makes_sub_list(classes, 1, i - 1))
			THEN
				RETURN(FALSE);
			END_IF;
		END_IF;

		IF NOT(SIZEOF(classes[i].definition[1]\class.defined_types)
			= 0)
		THEN
			IF makes_reference_outside(classes[i].definition[1]\
				class.defined_types, makes_sub_list
				(classes, 1, i))
			THEN
				RETURN(FALSE);
			END_IF;
		END_IF;

		IF ('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA'+
			'.A_PRIORI_SEMANTIC_RELATIONSHIP'
			IN TYPEOF(classes[i].definition[1]))
		THEN
			IF makes_reference_outside(classes[i].definition[1]\
			a_priori_semantic_relationship.referenced_data_types,
			makes_sub_list(classes, 1, i - 1))
			THEN
				RETURN(FALSE);
			END_IF;
		END_IF;

		IF NOT(SIZEOF(classes[i].definition[1]\
			class.associated_items) = 0)
		THEN
			REPEAT j := 1 TO SIZEOF(classes[i].definition[1]
			\class.associated_items);
				REPEAT k := 1 TO SIZEOF(classes[i].definition[1]
				\class.associated_items[j]
				\class_BSU_relationship.related_tokens);

					related_token := classes[i].definition[1]
						\class.associated_items[j]
						\class_BSU_relationship.related_tokens[k];

					IF (('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA'+
						'.TABLE_BSU') IN (TYPEOF(related_token)))
						AND NOT(related_token\table_BSU.name_scope
						IN makes_sub_list(classes, 1, i))
					THEN
						RETURN(FALSE);
					END_IF;

					IF (('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA'+
						'.DOCUMENT_BSU')
						IN (TYPEOF(related_token)))
						AND NOT(related_token\document_BSU
						.name_scope IN makes_sub_list
						(classes, 1, i))
					THEN
						RETURN(FALSE);
					END_IF;
				END_REPEAT;
			END_REPEAT;
		END_IF;
	END_IF;
END_REPEAT;

RETURN(TRUE);
END_FUNCTION; -- prefix_ordered_class_list




FUNCTION makes_sub_list(cla: LIST [1:?] OF class_BSU;
	i, j: INTEGER): LIST [1:?] OF class_BSU;

LOCAL
	c: LIST [0:?] OF class_BSU := [];
END_LOCAL;

REPEAT k := i TO j;
	c := c + cla[k];
END_REPEAT;

RETURN(c);

END_FUNCTION; -- makes_sub_list




FUNCTION makes_reference_outside (
	p: AGGREGATE OF property_or_data_type_BSU;
	l: LIST[1:?] OF class_BSU): BOOLEAN;

LOCAL
	bool: BOOLEAN := FALSE;
	temp: SET[0:1] OF class_BSU := [];
END_LOCAL;

REPEAT j := 1 TO SIZEOF(p);
	IF ((('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.PROPERTY_BSU'
		IN TYPEOF(p[j]))
		AND (NOT(p[j]\property_bsu.name_scope IN l)))
		OR
		(('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.DATA_TYPE_BSU'
		IN TYPEOF(p[j]))
		AND (NOT(p[j]\data_type_bsu.name_scope IN l))))
	THEN
		bool := TRUE;
		RETURN(bool);
	END_IF;

	IF ((('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.PROPERTY_BSU'
		IN TYPEOF(p[j]))
		AND (NOT(SIZEOF(p[j]\basic_semantic_unit.definition) = 0)))
		OR
		(('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.DATA_TYPE_BSU'
		IN TYPEOF(p[j]))
		AND (NOT(SIZEOF(p[j]\basic_semantic_unit.definition) = 0))))
	THEN
		IF ('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.CLASS_INSTANCE_TYPE'
			IN data_type_typeof(p[j]))
		THEN
			temp := data_type_class_of(p[j]);
			IF NOT(temp[1] IN l)
			THEN
				bool := bool OR TRUE ;
			ELSE
				bool := bool OR FALSE;
			END_IF;
		END_IF;

		IF SIZEOF(data_type_named_type(p[j])) = 1
		THEN
			bool := bool OR makes_reference_outside
				(data_type_named_type(p[j]), l);
		END_IF;
	END_IF;
END_REPEAT;

RETURN(bool);

END_FUNCTION; -- makes_reference_outside




FUNCTION data_type_typeof(type_spec: property_or_data_type_BSU):
	SET OF STRING;

LOCAL
	res: BOOLEAN := FALSE;
	x: data_type;
END_LOCAL;

IF NOT EXISTS(type_spec)
THEN
	RETURN([]); -- type_spec is indeterminate
END_IF;

IF ('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.PROPERTY_BSU' IN
	TYPEOF(type_spec))
THEN
	IF NOT(SIZEOF(type_spec.definition) = 0)
	THEN
		x := type_spec.definition[1]\property_DET.domain;
		res := TRUE;
	END_IF;
ELSE
	IF NOT(SIZEOF(type_spec.definition) = 0)
	THEN
		x := type_spec.definition[1]
			\data_type_element.type_definition;
		res := TRUE;
	END_IF;
END_IF;

IF NOT(res)
THEN
	RETURN([]);
END_IF;

IF ('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.NAMED_TYPE' IN TYPEOF(x))
THEN
	IF NOT(SIZEOF(x\named_type.referred_type.definition) = 0)
	THEN
		RETURN(data_type_typeof(x\named_type.referred_type));
	ELSE
		RETURN([]);
	END_IF;
ELSE
	RETURN(TYPEOF(x));
END_IF;

END_FUNCTION; -- data_type_typeof




FUNCTION data_type_class_of(type_spec: property_or_data_type_BSU):
	SET[0:1] OF class_BSU;

LOCAL
	res: BOOLEAN := FALSE;
	s: SET[0:1] OF class_BSU := [];
	x: data_type;
END_LOCAL;

IF NOT EXISTS(type_spec)
THEN
	RETURN([]); -- type_spec is indeterminate
END_IF;

IF ('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.PROPERTY_BSU' IN
	TYPEOF(type_spec))
THEN
	IF NOT(SIZEOF(type_spec.definition) = 0)
	THEN
		x := type_spec.definition[1]\property_DET.domain;
		res := TRUE;
	END_IF;
ELSE
	IF NOT(SIZEOF(type_spec.definition) = 0)
	THEN
		x := type_spec.definition[1]\data_type_element
			.type_definition;
		res := TRUE;
	END_IF;
END_IF;

IF res
THEN
	IF ('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.CLASS_INSTANCE_TYPE' IN
		TYPEOF(x))
	THEN
		s := s + x\class_instance_type.domain;
		RETURN(s);
	END_IF;

	IF ('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.NAMED_TYPE'
		IN TYPEOF(x))
	THEN
		s := data_type_class_of(x\named_type.referred_type);
		RETURN(s);
	END_IF;
END_IF;

RETURN(s);

END_FUNCTION; -- data_type_class_of




FUNCTION data_type_named_type(type_spec: property_or_data_type_BSU):
	SET[0:1] OF data_type_BSU;

LOCAL
	res: BOOLEAN := FALSE;
	s: SET[0:1] OF data_type_BSU := [];
	x: data_type;
END_LOCAL;

IF NOT EXISTS(type_spec)
THEN
	RETURN([]); -- type_spec is indeterminate
END_IF;

IF ('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.PROPERTY_BSU' IN
	TYPEOF(type_spec))
THEN
	IF NOT(SIZEOF(type_spec.definition) = 0)
	THEN
		x := type_spec.definition[1]\property_DET.domain;
		res := TRUE;
	END_IF;
ELSE
	IF NOT(SIZEOF(type_spec.definition) = 0)
	THEN
		x := type_spec.definition[1]\data_type_element
			.type_definition;
		res := TRUE;
	END_IF;
END_IF;

IF res
THEN
	IF ('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.NAMED_TYPE'
		IN TYPEOF(x))
	THEN
		s := s + x\named_type.referred_type;
	END_IF;
END_IF;

RETURN(s);

END_FUNCTION; -- data_type_named_type




FUNCTION visible_documents(cl: class_BSU;
	doc: AGGREGATE OF document_BSU): LOGICAL;

IF NOT EXISTS(cl)
THEN
	RETURN(UNKNOWN);
END_IF;

REPEAT i := SIZEOF(doc) TO 1 BY -1;
	IF doc[i].name_scope = cl
	THEN
		doc := doc - doc[i];
	END_IF;
END_REPEAT;

IF SIZEOF(doc) = 0
THEN
	RETURN(TRUE);
END_IF;

IF SIZEOF(cl.definition) = 0
THEN
	RETURN(UNKNOWN);
END_IF;

IF EXISTS(cl.definition[1]\class.its_superclass)
THEN
	RETURN(visible_documents(cl.definition[1]
		\class.its_superclass, doc));
ELSE
	RETURN(FALSE);
END_IF;

END_FUNCTION; -- visible_documents




FUNCTION created_view_is_functional_view(cl: class_BSU): LOGICAL;

IF (SIZEOF(cl\basic_semantic_unit.definition) = 1) THEN
	RETURN('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA' +
		'.FUNCTIONAL_VIEW_CLASS'
		IN TYPEOF(cl\basic_semantic_unit.definition[1]));
ELSE
	RETURN(UNKNOWN);
END_IF;

END_FUNCTION; -- created_view_is_functional_view




FUNCTION applicable_properties(cl: class_BSU;
	prop: AGGREGATE OF property_BSU): LOGICAL;

IF SIZEOF(prop) = 0
THEN
	RETURN(TRUE);
END_IF;

IF NOT EXISTS(cl)
THEN
	RETURN(UNKNOWN);
END_IF;

IF SIZEOF(cl.definition) = 0
THEN
	RETURN(UNKNOWN);
END_IF;

prop := prop - list_to_set(cl.definition[1]\class.described_by);

IF 'ISO13584_25_LIBRARY_IMPLICIT_SCHEMA' +
	'.A_PRIORI_SEMANTIC_RELATIONSHIP' IN TYPEOF(cl.definition[1])
THEN
	prop := prop - list_to_set(cl.definition[1]
		\a_priori_semantic_relationship.referenced_properties);
END_IF;

IF SIZEOF(prop) = 0
THEN
	RETURN(TRUE);
ELSE
	IF EXISTS(cl.definition[1]\class.its_superclass)
	THEN
		RETURN(applicable_properties(cl.definition[1]
			\class.its_superclass, prop));
	ELSE
		RETURN(FALSE);
	END_IF;
END_IF;

END_FUNCTION; -- applicable_properties




FUNCTION check_view_of_instance_datatype(
	fmc_view_of: fm_class_view_of): LOGICAL;

IF (SIZEOF(fmc_view_of.view_of.definition) = 1)
THEN
	RETURN('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.ITEM_CLASS'
		IN TYPEOF(fmc_view_of.view_of.definition[1]));
ELSE
	RETURN(UNKNOWN);
END_IF;

END_FUNCTION; -- check_view_of_instance_datatype




FUNCTION ordered_index_value(x: value_domain): BOOLEAN;

REPEAT i := LOBOUND(x.its_values) TO SIZEOF(x.its_values);
	IF x.its_values[i].value_code <> x.its_values[i-1].value_code + 1
	THEN
		RETURN(FALSE);
	END_IF;
END_REPEAT;

RETURN(TRUE);

END_FUNCTION; -- ordered_index_value




FUNCTION data_type_non_quantitative_int_type(
	type_spec: property_or_data_type_BSU):
	SET [0:1] OF non_quantitative_int_type;
LOCAL
	res: BOOLEAN := FALSE;
	s: SET [0:1] OF non_quantitative_int_type := [];
	x: data_type;
END_LOCAL;

IF NOT EXISTS(type_spec)
THEN
	RETURN([]); -- type_spec is indeterminate
END_IF;

IF ('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.PROPERTY_BSU' IN
	TYPEOF(type_spec))
THEN
	IF NOT(SIZEOF(type_spec.definition) = 0)
	THEN
		x := type_spec.definition[1]\property_DET.domain;
		res := TRUE;
	END_IF;
ELSE
	IF NOT(SIZEOF(type_spec.definition) = 0)
	THEN
		x := type_spec.definition[1]\
		data_type_element.type_definition;
		res := TRUE;
	END_IF;
END_IF;

IF res
THEN
	IF ('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA'+
		'.NON_QUANTITATIVE_INT_TYPE') IN TYPEOF(x)
	THEN
		s := s + x;
		RETURN(s);
	END_IF;

	IF ('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.NAMED_TYPE')
		IN TYPEOF(x)
	THEN
		s := data_type_non_quantitative_int_type(
			x\named_type.referred_type);
		RETURN(s);
	END_IF;
END_IF;

RETURN([]);

END_FUNCTION; -- data_type_non_quantitative_int_type




FUNCTION view_control_variables_attributes_belong_to_domain(
	vcv_range: view_control_variable_range): LOGICAL;

IF (data_type_typeof(vcv_range.parameter_type) <> [])
THEN
	RETURN((data_type_non_quantitative_int_type(
		vcv_range.parameter_type)[1].domain
		.its_values[1].value_code <= vcv_range.range_lobound)
		AND (vcv_range.range_hibound <=
		data_type_non_quantitative_int_type(
		vcv_range.parameter_type)[1].domain
		.its_values[HIINDEX(data_type_non_quantitative_int_type(
		vcv_range.parameter_type)[1].domain.its_values)].value_code)
	);
ELSE
	RETURN(UNKNOWN);
END_IF;

END_FUNCTION; -- view_control_variables_attributes_belong_to_domain




FUNCTION superclass_of_item_is_item(cl: item_class): LOGICAL;

IF NOT EXISTS(cl\class.its_superclass)
THEN
	RETURN(TRUE);
END_IF;

IF SIZEOF(cl\class.its_superclass.definition) = 0
THEN
	RETURN(UNKNOWN);
END_IF;

RETURN(('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.ITEM_CLASS')
	IN TYPEOF(cl\class.its_superclass.definition[1]));

END_FUNCTION; -- superclass_of_item_is_item




FUNCTION check_is_case_of_referenced_classes_definition(
	cl: item_class_case_of): BOOLEAN;
LOCAL
	class_def_ok: BOOLEAN := TRUE;
	done: BOOLEAN := FALSE;
END_LOCAL;

REPEAT i := 1 TO SIZEOF(cl.is_case_of);
	IF (SIZEOF(cl.is_case_of[i].definition) = 1)
	THEN
		IF ('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA' +
			'.COMPONENT_CLASS_CASE_OF' IN TYPEOF(cl))
		THEN
			IF (NOT('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA' +
				'.COMPONENT_CLASS'
				IN TYPEOF(cl.is_case_of[i].definition[1])))
			THEN
				class_def_ok := FALSE;
			END_IF;
			done := TRUE;
		END_IF;
		IF ('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA' +
			'.FEATURE_CLASS_CASE_OF' IN TYPEOF(cl))
		THEN
			IF (NOT('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA' +
				'.FEATURE_CLASS'
				IN TYPEOF(cl.is_case_of[i].definition[1])))
			THEN
				class_def_ok := FALSE;
			END_IF;
			done := TRUE;
		END_IF;
		IF ('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA' +
			'.MATERIAL_CLASS_CASE_OF' IN TYPEOF(cl))
		THEN
			IF (NOT('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA' +
				'.MATERIAL_CLASS'
				IN TYPEOF(cl.is_case_of[i].definition[1])))
			THEN
				class_def_ok := FALSE;
			END_IF;
			done := TRUE;
		END_IF;
		IF (('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA' +
			'.ITEM_CLASS_CASE_OF' IN TYPEOF(cl))
			AND (NOT done))
		THEN
			IF (NOT('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA' +
				'.ITEM_CLASS'
				IN TYPEOF(cl.is_case_of[i].definition[1])))
			THEN
				class_def_ok := FALSE;
			END_IF;
		END_IF;

		done := FALSE;
	END_IF;
END_REPEAT;

RETURN(class_def_ok);

END_FUNCTION; -- check_is_case_of_referenced_classes_definition




FUNCTION compatible_types(p1: property_or_data_type_BSU;
	p2: property_or_data_type_BSU): LOGICAL;

LOCAL
	p1_domain, p2_domain: data_type;
END_LOCAL;

IF (NOT EXISTS(p1)) OR (NOT EXISTS(p2))
THEN
	RETURN(UNKNOWN); -- p1 or p2 indeterminate
END_IF;



IF p1 = p2
THEN
	RETURN(TRUE);
END_IF;



IF ((TYPEOF(p1) = TYPEOF(p2))
	AND (p1\basic_semantic_unit.code = p2.code)
	AND (p1.name_scope\basic_semantic_unit.code =
		p2.name_scope\basic_semantic_unit.code)
	AND (p1\basic_semantic_unit.version >=
		p2\basic_semantic_unit.version))
THEN
	RETURN(TRUE);
END_IF;



IF (SIZEOF(p1\basic_semantic_unit.definition) = 0)
	OR (SIZEOF(p2\basic_semantic_unit.definition) = 0)
THEN
	RETURN(UNKNOWN);
ELSE
	IF ('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.PROPERTY_BSU'
		IN TYPEOF(p1))
	THEN
		p1_domain := p1.definition [1]\property_DET.domain;
	ELSE
		p1_domain := p1.definition[1]\data_type_element
			.type_definition;
	END_IF;

	IF ('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.PROPERTY_BSU'
		IN TYPEOF(p2))
	THEN
		p2_domain := p2.definition [1]\property_DET.domain;
	ELSE
		p2_domain := p2.definition[1]\data_type_element
			.type_definition;
	END_IF;
END_IF;



IF p1_domain = p2_domain
THEN
	RETURN(TRUE);
END_IF;



IF (NOT(SIZEOF(data_type_typeof(p1)) = 0))
	AND (data_type_typeof(p1)<= data_type_typeof(p2))
	AND (NOT('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.COMPLEX_TYPE' IN
	data_type_typeof(p2)))
THEN
	RETURN(TRUE);
END_IF;



IF ('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.CLASS_INSTANCE_TYPE' IN
	data_type_typeof(p1))
	AND ('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.CLASS_INSTANCE_TYPE' IN
	data_type_typeof(p2))
THEN
	RETURN(compatible_subclass(data_type_class_of(p1)[1],
		data_type_class_of(p2)[1]));
END_IF;



IF ('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.ENTITY_INSTANCE_TYPE' IN
	data_type_typeof(p1))
	AND ('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.ENTITY_INSTANCE_TYPE'
	IN data_type_typeof(p2))
THEN
	IF ((data_type_type_name(p1) <= data_type_type_name(p2))
		AND (data_type_type_name(p1) <> []))
	THEN
		RETURN(TRUE);
	ELSE
		RETURN(FALSE);
	END_IF;
END_IF;



IF ('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.LEVEL_TYPE' IN
	data_type_typeof(p1))
	AND ('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.LEVEL_TYPE' IN
	data_type_typeof(p2))
THEN
	IF (data_type_level_spec(p1) = data_type_level_spec(p2))
		AND (data_type_level_value_typeof(p1) <> [])
		AND (data_type_level_value_typeof(p1)
		<= data_type_level_value_typeof(p2))
	THEN
		RETURN(TRUE);
	ELSE
		RETURN(FALSE);
	END_IF;
END_IF;



IF ((data_type_typeof(p1) = []) OR (data_type_typeof(p2) = []))
THEN
	RETURN(UNKNOWN);
ELSE
	RETURN(FALSE);
END_IF;

END_FUNCTION; -- compatible_types




FUNCTION compatible_subclass(c1, c2: class_BSU): LOGICAL;

IF (NOT EXISTS(c1)) OR (NOT EXISTS(c2))
THEN
	RETURN(UNKNOWN); -- c1 or c2 indeterminate
END_IF;

IF c1 = c2
THEN
	RETURN(TRUE);
END_IF;

IF ((c1.code = c2.code) AND (c1.version >= c2.version)
	AND (c1.defined_by.code = c2.defined_by.code))
THEN
	RETURN(TRUE);
END_IF;

IF SIZEOF(c2.definition) = 0
THEN
	RETURN(UNKNOWN);
ELSE
	IF EXISTS(c2.definition[1]\class.its_superclass)
	THEN
		RETURN(compatible_subclass(c1, c2.definition[1]
			\class.its_superclass));
	ELSE
		RETURN(FALSE);
	END_IF;
END_IF;

END_FUNCTION; -- compatible_subclass




FUNCTION data_type_type_name(t: property_or_data_type_BSU):
	SET [0:?] OF STRING;

LOCAL
	res: BOOLEAN := FALSE;
	s: SET [0:1] OF STRING := [];
	x: data_type;
END_LOCAL;

IF NOT EXISTS(t)
THEN
	RETURN([]); -- t is indeterminate
END_IF;

IF ('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.PROPERTY_BSU' IN TYPEOF(t))
THEN
	IF NOT(SIZEOF(t.definition) = 0)
	THEN
		x := t.definition[1]\property_DET.domain;
		res := TRUE;
	END_IF;
ELSE
	IF NOT(SIZEOF(t.definition) = 0)
	THEN
		x := t.definition[1]\data_type_element.type_definition;
		res := TRUE;
	END_IF;
END_IF;

IF res
THEN
	IF ('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.ENTITY_INSTANCE_TYPE'
		IN TYPEOF(x))
	THEN
		s := x\entity_instance_type.type_name;
	END_IF;

	IF ('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.NAMED_TYPE'
		IN TYPEOF(x))
	THEN
		s := data_type_type_name(x\named_type.referred_type);
	END_IF;
END_IF;

RETURN(s);

END_FUNCTION; -- data_type_type_name




FUNCTION data_type_level_spec(t: property_or_data_type_BSU):
	LIST[0:4] OF UNIQUE Level;

LOCAL
	res: BOOLEAN := FALSE;
	s: LIST[0:4] OF UNIQUE level := [];
	x: data_type;
END_LOCAL;

IF NOT EXISTS(t)
THEN
	RETURN([]); -- t is indeterminate
END_IF;

IF ('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.PROPERTY_BSU' IN TYPEOF(t))
THEN
	IF NOT(SIZEOF(t.definition) = 0)
	THEN
		x := t.definition[1]\property_DET.domain;
		res := TRUE;
	END_IF;
ELSE
	IF NOT(SIZEOF(t.definition) = 0)
	THEN
		x := t.definition[1]\data_type_element.type_definition;
		res := TRUE;
	END_IF;
END_IF;

IF res
THEN
	IF ('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.LEVEL_TYPE'
		IN TYPEOF(x))
	THEN
		s := x\level_type.levels;
	END_IF;

	IF ('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.NAMED_TYPE'
		IN TYPEOF(x))
	THEN
		s := data_type_level_spec(x\named_type.referred_type);
	END_IF;
END_IF;

RETURN(s);

END_FUNCTION; -- data_type_level_spec




FUNCTION data_type_level_value_typeof(t: property_or_data_type_BSU):
	SET OF STRING;

LOCAL
	res: BOOLEAN := FALSE;
	s: SET OF STRING := [];
	x: data_type;
END_LOCAL;

IF NOT EXISTS(t)
THEN
	RETURN([]); -- t is indeterminate
END_IF;

IF ('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.PROPERTY_BSU' IN TYPEOF(t))
THEN
	IF NOT(SIZEOF(t.definition) = 0)
	THEN
		x := t.definition[1]\property_DET.domain;
		res := TRUE;
	END_IF;
ELSE
	IF NOT(SIZEOF(t.definition) = 0)
	THEN
		x := t.definition[1]\data_type_element.type_definition;
		res := TRUE;
	END_IF;
END_IF;

IF res
THEN
	IF ('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.LEVEL_TYPE'
		IN TYPEOF(x))
	THEN
		s := TYPEOF(x\level_type.value_type);
	END_IF;

	IF ('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.NAMED_TYPE'
		IN TYPEOF(x))
	THEN
		s := data_type_level_value_typeof(
			x\named_type.referred_type);
	END_IF;

END_IF;

RETURN(s);

END_FUNCTION; -- data_type_level_value_typeof




FUNCTION control_compiler_version_format(the_compiler_version: STRING):
	BOOLEAN;
LOCAL
	result: BOOLEAN := TRUE;
END_LOCAL;

REPEAT i := 1 TO LENGTH(the_compiler_version);
	IF (NOT((the_compiler_version[i] LIKE '#')
		OR (the_compiler_version[i] LIKE '.')
		OR (the_compiler_version[i] LIKE '_')))
	THEN
		result := FALSE;
	END_IF;
END_REPEAT;
	RETURN(result);
END_FUNCTION; -- control_compiler_version_format




FUNCTION check_property_values_translations(props:
	LIST OF property_value): LOGICAL;
LOCAL
	translated_string_values: SET OF translated_string_value := [];
END_LOCAL;

	REPEAT i := 1 TO SIZEOF(props);
		translated_string_values :=
			translated_string_values + props[i].its_value;
	END_REPEAT;

	RETURN(same_translations(translated_string_values));
END_FUNCTION; -- check_property_values_translations




FUNCTION same_translations(translated_string_values: SET OF
	translated_string_value): LOGICAL;
LOCAL
	comp: translated_string_value;
END_LOCAL;

	IF (SIZEOF(translated_string_values) <> 0)
	THEN
		comp := translated_string_values[1];
		REPEAT i := 2 TO SIZEOF(translated_string_values);
			IF (translated_string_values[i].languages <>
				comp.languages)
			THEN
				RETURN(FALSE);
			END_IF;
		END_REPEAT;

		RETURN(TRUE);
	ELSE
		RETURN(UNKNOWN);
	END_IF;

END_FUNCTION; -- same_translations




FUNCTION check_class_type_for_dic_item_instance(
	dic_cl: dic_item_instance): LOGICAL;

IF (SIZEOF(dic_cl.class_def.definition) = 1) THEN

	IF ('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.' +
		'DIC_COMPONENT_INSTANCE') IN TYPEOF(dic_cl)
	THEN
		IF (SIZEOF(dic_cl.case_of) = 0)
		THEN
			RETURN(('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA'
				+ '.COMPONENT_CLASS'
				IN TYPEOF(dic_cl.class_def.definition[1])));
		ELSE
			RETURN('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA'
				+ '.COMPONENT_CLASS_CASE_OF'
				IN TYPEOF(dic_cl.class_def.definition[1]));
		END_IF;
	END_IF;
	-- what to return if here???, by AM
	IF ('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.' +
		'DIC_MATERIAL_INSTANCE') IN TYPEOF(dic_cl)
	THEN
		IF (SIZEOF(dic_cl.case_of) = 0)
		THEN
			RETURN(('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA'
				+ '.MATERIAL_CLASS'
				IN TYPEOF(dic_cl.class_def.definition[1])));
		ELSE
			RETURN('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA'
				+ '.MATERIAL_CLASS_CASE_OF'
				IN TYPEOF(dic_cl.class_def.definition[1]));
		END_IF;
	END_IF;

	IF ('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.' +
		'DIC_FEATURE_INSTANCE') IN TYPEOF(dic_cl)
	THEN
		IF (SIZEOF(dic_cl.case_of) = 0)
		THEN
			RETURN('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA'
				+ '.FEATURE_CLASS'
				IN TYPEOF(dic_cl.class_def.definition[1]));
		ELSE
			RETURN('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA'
				+ '.FEATURE_CLASS_CASE_OF'
				IN TYPEOF(dic_cl.class_def.definition[1]));
		END_IF;
	END_IF;

	IF ('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.' +
		'DIC_ITEM_INSTANCE') IN TYPEOF(dic_cl)
	THEN
		IF (SIZEOF(dic_cl.case_of) = 0)
		THEN
			RETURN(('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA'
				+ '.ITEM_CLASS'
				IN TYPEOF(dic_cl.class_def.definition[1])));
		ELSE
			RETURN('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA'
				+ '.ITEM_CLASS_CASE_OF'
				IN TYPEOF(dic_cl.class_def.definition[1]));
		END_IF;
	END_IF;

ELSE
	RETURN(UNKNOWN);
END_IF;

	RETURN(?);
END_FUNCTION; -- check_class_type_for_dic_item_instance


FUNCTION check_class_type_for_dic_f_model_instance(
	dic_cl: dic_f_model_instance): LOGICAL;

IF (SIZEOF(dic_cl.class_def.definition) = 1)
THEN
	IF ('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA'
		+ '.ABSTRACT_FUNCTIONAL_MODEL_CLASS'
		IN TYPEOF(dic_cl.class_def.definition[1]))
	THEN
		RETURN(NOT(SIZEOF(dic_cl.case_of) <> 0) OR
			(SIZEOF(dic_cl.class_def.definition[1]\
			abstract_functional_model_class.case_of) <> 0));
	ELSE
		RETURN(FALSE);
	END_IF;
ELSE
	RETURN(UNKNOWN);
END_IF;
END_FUNCTION; -- check_class_type_for_dic_f_model_instance


FUNCTION check_class_type_for_dic_f_view_instance(
	dic_cl: dic_f_model_instance): LOGICAL;

IF (SIZEOF(dic_cl.class_def.definition) = 1)
THEN
	IF ('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA' +
		'.DIC_F_VIEW_INSTANCE') IN TYPEOF(dic_cl)
	THEN
			RETURN('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA'
			+ '.FUNCTIONAL_VIEW_CLASS'
			IN TYPEOF(dic_cl.class_def.definition[1]));
	END_IF;

ELSE
	RETURN(UNKNOWN);
END_IF;

	RETURN(?);
END_FUNCTION; -- check_class_type_for_dic_f_view_instance


FUNCTION collects_property_context(prop: property_BSU;
	inst: dic_class_instance): SET OF property_BSU;

LOCAL
	assigned_context_parameters: SET OF property_BSU;
		--assigned context parameters of the dic_class_instance
	correct: BOOLEAN; --prop belongs to inst properties
END_LOCAL;

assigned_context_parameters := [];
correct := FALSE;

REPEAT i := 1 TO SIZEOF(inst.properties);

	IF inst.properties[i].prop_def :=: prop
	THEN
		correct := TRUE;
	END_IF;

	IF ((SIZEOF(inst.properties[i].prop_def.definition) = 0)
		OR ((SIZEOF(inst.properties[i].prop_def.definition) = 1)
	AND (('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.CONDITION_DET')
	IN TYPEOF(inst.properties[i].prop_def.definition[1]))))
	THEN
		assigned_context_parameters := assigned_context_parameters
			+ inst.properties[i].prop_def;
	END_IF;

	IF (('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA' +
	'.CONTEXT_DEPENDENT_PROPERTY_VALUE') IN
	TYPEOF(inst.properties[i]))
	THEN
		assigned_context_parameters := assigned_context_parameters
			+ collects_assigned_instance_properties(list_to_set(
			inst.properties[i].the_context));
	END_IF;

END_REPEAT;

IF NOT correct
THEN
	assigned_context_parameters := [];
END_IF;

RETURN(assigned_context_parameters );

END_FUNCTION; -- collects_property_context




FUNCTION collects_assigned_instance_properties(
	props: SET [0:?] OF property_value): SET OF property_BSU;

LOCAL
	assign_prop: SET OF property_BSU;
		-- assigned properties of the dic_class_instance
END_LOCAL;

assign_prop := [];

REPEAT i := 1 TO SIZEOF(props);
	assign_prop := assign_prop + props[i].prop_def;
END_REPEAT;

RETURN(assign_prop);

END_FUNCTION; -- collects_assigned_instance_properties




FUNCTION functional_view_v_c_v(cl: class_BSU): LIST OF property_BSU;

IF NOT EXISTS(cl)
THEN
	RETURN([]); -- cl is indeterminate
END_IF;

IF NOT(all_class_descriptions_reachable(cl))
THEN
	RETURN([]); -- some dictionary_element are not available
END_IF;

IF NOT('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.FUNCTIONAL_VIEW_CLASS' IN
	TYPEOF(cl.definition[1]))
THEN
	RETURN([]);
END_IF;

RETURN(retrieve_functional_view_v_c_v(cl, []));

END_FUNCTION; -- functional_view_v_c_v




FUNCTION retrieve_functional_view_v_c_v(cl: class_BSU;
	pr: LIST OF property_BSU): LIST OF property_BSU;

LOCAL
	prop: LIST OF property_BSU := pr;
END_LOCAL;

IF SIZEOF(cl.definition) = 0 -- abnormal case
	THEN RETURN([]);
END_IF;

IF NOT('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.FUNCTIONAL_VIEW_CLASS' IN
	TYPEOF(cl.definition[1]))
THEN
	RETURN([]);
END_IF;

IF SIZEOF(cl.definition) = 1
THEN
	prop := prop + cl.definition[1]
		\functional_view_class.view_control_variables;
				-- view_control_variables of this class
END_IF;

IF NOT(EXISTS(cl.definition[1]\class.its_superclass))
THEN
	RETURN(prop);
ELSE
	RETURN(retrieve_functional_view_v_c_v(
		cl.definition[1]\class.its_superclass, prop));
END_IF;

	
END_FUNCTION; -- retrieve_functional_view_v_c_v




FUNCTION correct_view_from_model(fv: dic_f_view_instance): LOGICAL;

IF NOT EXISTS(fv.generated_by)
THEN
	RETURN(UNKNOWN);
END_IF;

IF NOT(SIZEOF(fv.generated_by\dic_class_instance.class_def.
	definition) = 1)
THEN
	RETURN(UNKNOWN);
ELSE
	RETURN(fv.generated_by\dic_class_instance.class_def
		.definition[1].created_view =
		fv\dic_class_instance.class_def);
END_IF;

END_FUNCTION; -- correct_view_from_model




FUNCTION compatible_type_and_value(dom: property_or_data_type_BSU;
	val: primitive_value): LOGICAL;

LOCAL
	temp: SET[0:1] OF class_BSU;
	set_string: SET OF STRING := [];
	set_integer: SET OF INTEGER := [];
	code_type: non_quantitative_code_type;
	int_type: non_quantitative_int_type;
END_LOCAL;

IF data_type_typeof(dom) = []
THEN
	RETURN(UNKNOWN);

END_IF;



IF ('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.INTEGER_VALUE' IN TYPEOF(val))
THEN
    IF (('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.NON_QUANTITATIVE_INT_TYPE' IN
		data_type_typeof(dom))
		AND (SIZEOF(data_type_non_quantitative_int_type(dom)) = 1))
    THEN
		set_integer := [];
		code_type := data_type_non_quantitative_int_type(dom)[1];

		REPEAT j := 1 TO SIZEOF(code_type.domain.its_values);
			set_integer := set_integer + code_type.domain.its_values[j].value_code;
		END_REPEAT;
        RETURN(val IN set_integer);
    ELSE
		RETURN(('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.INT_TYPE'
			IN data_type_typeof(dom)) OR
			(('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.NUMBER_TYPE'
			IN data_type_typeof(dom))
			AND NOT('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.REAL_TYPE'
			IN data_type_typeof(dom))));
    END_IF;
END_IF;

IF ('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.REAL_VALUE' IN TYPEOF(val))
THEN
	RETURN(('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.REAL_TYPE'
		IN data_type_typeof(dom)) OR
		(('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.NUMBER_TYPE'
		IN data_type_typeof(dom))
		AND NOT('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.INT_TYPE'
		IN data_type_typeof(dom))));
END_IF;

IF ('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.NUMBER_VALUE' IN TYPEOF(val))
THEN
	RETURN('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.NUMBER_TYPE'
		IN data_type_typeof(dom));
END_IF;

IF ('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.BOOLEAN_VALUE' IN TYPEOF(val))
THEN
	RETURN('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.BOOLEAN_TYPE'
		IN data_type_typeof(dom));
END_IF;

IF ('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.TRANSLATABLE_STRING_VALUE' IN TYPEOF(val))
THEN
	IF (('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA' +
		'.NON_QUANTITATIVE_CODE_TYPE') IN  data_type_typeof(dom))
    THEN
        IF (SIZEOF(data_type_non_quantitative_code_type(dom)) = 1)
		THEN
			set_string := [];
			code_type := data_type_non_quantitative_code_type(dom)[1];

			REPEAT j := 1 TO SIZEOF(code_type.domain.its_values);
				set_string := set_string + code_type.domain.its_values[j].value_code;
			END_REPEAT;

            RETURN(('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.STRING_VALUE' IN TYPEOF(val)) AND (val IN set_string));

        ELSE
            RETURN(UNKNOWN);
        END_IF;
	ELSE
		RETURN('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA' +
			'.STRING_TYPE' IN data_type_typeof(dom));
	END_IF;
END_IF;


IF 'ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.ENTITY_INSTANCE_VALUE'
	IN TYPEOF(val)
THEN
	IF 'ISO13584_25_LIBRARY_IMPLICIT_SCHEMA' +
		'.UNCONTROLLED_ENTITY_INSTANCE_VALUE'
		IN TYPEOF(val)
	THEN
		RETURN(UNKNOWN);
	END_IF;
	IF ('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.ENTITY_INSTANCE_TYPE'
		IN data_type_typeof(dom))
AND (SIZEOF(data_type_type_name(dom)) <> 0)
		AND (data_type_type_name(dom) <= TYPEOF(val))
	THEN
		RETURN(TRUE);
	ELSE
		RETURN(FALSE);
	END_IF;
END_IF;

IF 'ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.DIC_CLASS_INSTANCE'
	IN TYPEOF(val)
THEN
	IF ('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.CLASS_INSTANCE_TYPE'
		IN data_type_typeof(dom))
		AND (SIZEOF(data_type_class_of(dom)) <> 0)
	THEN
		temp := data_type_class_of(dom);
		RETURN(compatible_class_and_class(temp[1],
			val\dic_class_instance.class_def));
	ELSE
		RETURN(FALSE);
	END_IF;
END_IF;

IF 'ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.LEVEL_SPEC_VALUE' IN TYPEOF(val)
THEN
	IF ('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.LEVEL_TYPE'
		IN data_type_typeof(dom))
	THEN
		RETURN(compatible_level_type_and_instance(
			data_type_level_spec(dom),
			data_type_level_value_typeof(dom),
			val));
	ELSE
		RETURN(FALSE);
	END_IF;
END_IF;

RETURN(UNKNOWN);

END_FUNCTION; -- compatible_type_and_value




FUNCTION compatible_class_and_class(cl1:class_BSU; cl2:class_BSU):
	LOGICAL;

IF (cl1.defined_by\basic_semantic_unit.code =
	cl2.defined_by\basic_semantic_unit.code) AND
	(cl1\basic_semantic_unit.code =
	cl2\basic_semantic_unit.code) AND
	(cl1\basic_semantic_unit.version >=
	cl2\basic_semantic_unit.version)
THEN 

	RETURN(TRUE);
END_IF;

IF (SIZEOF(cl2\basic_semantic_unit.definition) = 0)
THEN 
	RETURN(UNKNOWN);
END_IF;

IF (SIZEOF(cl2\basic_semantic_unit.definition) = 1)
	AND (NOT EXISTS(cl2\basic_semantic_unit.
	definition[1]\class.its_superclass))
THEN 
	RETURN(FALSE);
END_IF;

RETURN(compatible_class_and_class(cl1, cl2\basic_semantic_unit.
	definition[1]\class.its_superclass));

END_FUNCTION; -- compatible_class_and_class




FUNCTION compatible_level_type_and_instance(
	levels: LIST [1:4] OF UNIQUE level; value_typeof: SET OF STRING;
	val: level_spec_value): BOOLEAN;

LOCAL
	c_val: BOOLEAN;
END_LOCAL;

c_val := FALSE;

IF ('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.INT_LEVEL_SPEC_VALUE'
	IN TYPEOF(val))
	AND NOT('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.REAL_TYPE' IN
	value_typeof)
THEN
	c_val := TRUE;
END_IF;

IF ('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.REAL_LEVEL_SPEC_VALUE'
	IN TYPEOF(val))
	AND NOT('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.INT_TYPE'
	IN value_typeof)
THEN
	c_val := TRUE;
END_IF;

RETURN(c_val AND (right_values_for_level_spec(levels, val)));

END_FUNCTION; -- compatible_level_type_and_instance




FUNCTION right_values_for_level_spec(
	levels: LIST [1:4] OF UNIQUE level;
	val: level_spec_value): BOOLEAN;

LOCAL
	c_place: BOOLEAN;
	lev: SET [1:4] OF level;
END_LOCAL;

c_place := TRUE;
lev := list_to_set(levels);

IF EXISTS(val.values[1])
THEN
	IF level.min IN lev
	THEN
		lev := lev - [level.min];
	ELSE
		c_place := FALSE;
	END_IF;
END_IF;

IF EXISTS(val.values[2])
THEN
	IF level.nom IN lev
	THEN
		lev := lev - [level.nom];
	ELSE
		c_place := FALSE;
	END_IF;
END_IF;

IF EXISTS(val.values[3])
THEN
	IF level.typ IN lev
	THEN
		lev := lev - [level.typ];
	ELSE
		c_place := FALSE;
	END_IF;
END_IF;

IF EXISTS(val.values[4])
THEN
	IF level.max IN lev
	THEN
		lev := lev - [level.max];
	ELSE
		c_place := FALSE;
	END_IF;
END_IF;

IF (c_place)
THEN
	RETURN(TRUE);
ELSE
	RETURN(FALSE);
END_IF;

END_FUNCTION; -- right_values_for_level_spec




FUNCTION is_condition_det(prop: property_value): LOGICAL;

IF(SIZEOF(prop.prop_def.definition) > 0) THEN
	RETURN('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.CONDITION_DET'
		IN TYPEOF(prop.prop_def.definition[1]));
ELSE
	RETURN(UNKNOWN);
END_IF;

END_FUNCTION; -- is_condition_det




FUNCTION is_dependent_p_det(prop: property_bsu): LOGICAL;

IF(SIZEOF(prop.definition) > 0) THEN
	RETURN('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.DEPENDENT_P_DET'
		IN TYPEOF(prop.definition[1]));
ELSE
	RETURN(UNKNOWN);
END_IF;

END_FUNCTION; -- is_dependent_p_det




FUNCTION all_context_parameters_referenced(
	cdpv: context_dependent_property_value): LOGICAL;

IF(SIZEOF(cdpv\property_value.prop_def.definition) > 0) THEN
	RETURN(cdpv\property_value.prop_def.definition[1]\
		dependent_p_det.depends_on
		>= collects_assigned_instance_properties(
		list_to_set(cdpv.the_context)));
ELSE
	RETURN(UNKNOWN);
END_IF;

END_FUNCTION; -- all_context_parameters_referenced




FUNCTION referenced_veps_exist_in_supported_veps(
	lib: library; cl: class_BSU): LOGICAL;
LOCAL
	class_extension: SET [0:1] OF content_item :=
		cl\basic_semantic_unit.referenced_by;
	class_extension_referenced_veps: SET OF
		view_exchange_protocol_identification;
	dictionary_supported_veps: SET OF
		view_exchange_protocol_identification;
	tmp: LOGICAL;
END_LOCAL;

IF (SIZEOF(class_extension) = 1)
THEN
	class_extension_referenced_veps :=
		list_to_set(class_extension[1]\model_class_extension
		.referenced_view_exchange_protocol);
	dictionary_supported_veps := lib\dictionary.supported_vep;
	tmp := (class_extension_referenced_veps <=
		dictionary_supported_veps);
	RETURN(('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.MODEL_CLASS_EXTENSION'
		IN TYPEOF(class_extension[1]))
		AND NOT(tmp));
ELSE
	RETURN(FALSE);
END_IF;

END_FUNCTION; -- referenced_veps_exist_in_supported_veps




FUNCTION referenced_protocols_exist_in_supported_protocols(
	lib: library; cl: class_BSU): LOGICAL;
LOCAL
	class_extension: SET [0:1] OF content_item :=
		cl\basic_semantic_unit.referenced_by;
END_LOCAL;

IF SIZEOF(class_extension) = 1
THEN
	RETURN(('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA' +
		'.MODEL_CLASS_EXTENSION' IN TYPEOF(class_extension))
		AND
		(SIZEOF(QUERY(pr <* class_extension[1]\model_class_extension
		.referenced_external_items | NOT(
		pr\external_item.used_protocol IN
		lib\dictionary.base_protocols)
		AND NOT(pr\external_item.used_protocol IN
		lib.linked_interfaces))) <> 0));
ELSE
	RETURN(FALSE);
END_IF;

END_FUNCTION; -- referenced_protocols_exist_in_supported_protocols




FUNCTION same_order_for_properties(
	first, current: LIST [1:?] OF property_value): BOOLEAN;

IF SIZEOF(first) <> SIZEOF(current)
THEN
	RETURN(FALSE);
END_IF;

REPEAT i := 1 TO SIZEOF(first);
	IF (first[i].prop_def <> current[i].prop_def)
	THEN
		RETURN(FALSE);
	END_IF;

	IF (('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA' +
		'.CONTEXT_DEPENDENT_PROPERTY_VALUE')
		IN TYPEOF(first[i]))
	THEN
		IF NOT(('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA' +
			'.CONTEXT_DEPENDENT_PROPERTY_VALUE')
			IN TYPEOF(current[i]))
		THEN
			RETURN(FALSE);
		END_IF;

		IF NOT same_order_for_properties(
			first[i]\context_dependent_property_value.the_context,
			current[i]\context_dependent_property_value.the_context)
		THEN
			RETURN(FALSE);
		END_IF;
	END_IF;

IF (('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA' +
	'.CONTEXT_DEPENDENT_PROPERTY_VALUE')
	IN TYPEOF(current[i]))
	THEN
		IF NOT(('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA' +
			'.CONTEXT_DEPENDENT_PROPERTY_VALUE')
			IN TYPEOF(first[i]))
		THEN
			RETURN(FALSE);
		END_IF;
	END_IF;

END_REPEAT;

RETURN(TRUE);

END_FUNCTION; -- same_order_for_properties




FUNCTION all_properties_are_applicable(
	expl: explicit_model_class_extension): LOGICAL;

LOCAL
	inst: dic_class_instance;
	prop_val: property_value;
	res: LOGICAL := TRUE;
END_LOCAL;

REPEAT i := 1 TO SIZEOF(expl.POPULATION);
	inst := expl.POPULATION[i];
	REPEAT j := 1 TO SIZEOF(inst.properties);
		prop_val := inst.properties[j];
		res := res AND applicable_properties(expl\
			content_item.dictionary_definition,
			[prop_val.prop_def]);
	END_REPEAT;
END_REPEAT;

RETURN(res);

END_FUNCTION; -- all_properties_are_applicable




FUNCTION same_string_values_translations_for_class_extension(
	class_ext: explicit_model_class_extension): LOGICAL;
LOCAL
	comp: SET OF translated_string_value := [];
	translated_property_values: LIST OF property_value := [];
END_LOCAL;

	REPEAT i := 1 TO SIZEOF(class_ext.POPULATION);
		translated_property_values := QUERY(prop_val <*
			class_ext.POPULATION[i].properties |
			'ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.' +
			'TRANSLATED_STRING_VALUE' IN
			TYPEOF(prop_val.its_value));
		IF (SIZEOF(translated_property_values) <> 0)
		THEN
			comp := comp + translated_property_values[1].its_value;
		END_IF;
	END_REPEAT;

	RETURN(same_translations(comp));

END_FUNCTION; -- same_string_values_translations_for_class_extension




FUNCTION required_values_are_non_dependent_p_det(
	fm_class_ext: explicit_functional_model_class_extension):
	LOGICAL;

LOCAL
	res: LOGICAL := TRUE;
	prop: property_bsu;
END_LOCAL;

IF (SIZEOF(fm_class_ext.required_item_values) <> 0)
THEN
	IF (SIZEOF(fm_class_ext\content_item.dictionary_definition.
		definition) = 1)
	THEN
		IF ('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA' +
			'.FM_CLASS_VIEW_OF') IN TYPEOF(fm_class_ext\content_item
			.dictionary_definition.definition[1])
		THEN
			REPEAT i := 1 TO SIZEOF(
					fm_class_ext.required_item_values);
				prop := fm_class_ext.required_item_values[i];

				IF (SIZEOF(prop.definition) = 1)
				THEN
					IF NOT('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA' +
						'.NON_DEPENDENT_P_DET' IN
						TYPEOF(prop.definition[1]))
					THEN
						res := FALSE;
					END_IF;
				ELSE
					res := res AND UNKNOWN;
				END_IF;

			END_REPEAT;
		ELSE
			res := FALSE;
		END_IF;
	ELSE
		res := UNKNOWN;
	END_IF;
END_IF;

RETURN(res);

END_FUNCTION; -- required_values_are_non_dependent_p_det



FUNCTION required_values_are_imported_properties(
	fm_class_ext: explicit_functional_model_class_extension):
	LOGICAL;

LOCAL
	res: LOGICAL := TRUE;
	prop: property_bsu;
END_LOCAL;

IF (SIZEOF(fm_class_ext.required_item_values) <> 0)
THEN
	IF (SIZEOF(fm_class_ext\content_item.dictionary_definition.
		definition) = 1)
	THEN
		IF ('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA' +
			'.FM_CLASS_VIEW_OF') IN TYPEOF(fm_class_ext\content_item
			.dictionary_definition.definition[1])
		THEN
			REPEAT i := 1 TO SIZEOF(
					fm_class_ext.required_item_values);
				prop := fm_class_ext.required_item_values[i];

				IF NOT(prop IN fm_class_ext\content_item.
					dictionary_definition.definition[1]\
					fm_class_view_of.
					imported_properties_from_item)
				THEN
					res := FALSE;
				END_IF;

			END_REPEAT;
		ELSE
			res := FALSE;
		END_IF;
	ELSE
		res := UNKNOWN;
	END_IF;
END_IF;

RETURN(res);

END_FUNCTION; -- required_valuees_are_imported_properties




FUNCTION unambiguous_view_specification(a_model:
	dic_f_model_instance): LOGICAL;
LOCAL
	cpt: INTEGER := 0;
	prop_val: property_value;
END_LOCAL;

IF (SIZEOF(a_model.class_def.definition) = 1)
THEN
	IF (SIZEOF(a_model.class_def.definition[1]\
		abstract_functional_model_class.created_view.definition) = 1)
	THEN
		REPEAT i := 1 TO SIZEOF(a_model.properties);
			prop_val := a_model.properties[i];
			IF ('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.' +
				'ENTITY_INSTANCE_TYPE' IN
				data_type_typeof(prop_val.prop_def))
			THEN
				IF (('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.' +
					'PROGRAM_REFERENCE' IN
					data_type_type_name(prop_val.prop_def))
					OR ('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.' +
					'REPRESENTATION_REFERENCE' IN
					data_type_type_name(prop_val.prop_def))
					OR ('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.' +
					'REPRESENTATION' IN
					data_type_type_name(prop_val.prop_def)))
				THEN
					cpt := cpt + 1;
				END_IF;
			END_IF;
		END_REPEAT;

		IF (NOT('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.' +
			'NON_INSTANTIABLE_FUNCTIONAL_VIEW_CLASS' IN TYPEOF(
			a_model.class_def.definition[1]\
			abstract_functional_model_class.created_view.
			definition[1])))
		THEN
			RETURN (cpt = 1);
		ELSE
			RETURN(cpt= 0);
		END_IF;
	ELSE
		RETURN(UNKNOWN);
	END_IF;
ELSE
	RETURN(UNKNOWN);
END_IF;

END_FUNCTION; -- unambiguous_view_specification





FUNCTION all_view_control_variables_belong_to_each_view(
	class_ext: explicit_model_class_extension): LOGICAL;
LOCAL
	created_view: class_bsu;
	cl: class_bsu;
	vcvs: SET OF property_bsu;
	i, max: INTEGER;
	result: LOGICAL := TRUE;
END_LOCAL;

cl := class_ext\content_item.dictionary_definition;

IF (SIZEOF(cl.definition) = 1)
THEN
	created_view := cl.definition[1]\
		abstract_functional_model_class.created_view;
	vcvs := list_to_set(functional_view_v_c_v(created_view));

	IF (SIZEOF(created_view.definition) = 1)
	THEN
		IF (SIZEOF(vcvs) > 0)
		THEN
			i := 1;
			max := SIZEOF(class_ext.POPULATION);
			REPEAT WHILE((i <= max) AND (result));
				result :=
				check_all_view_control_variables_belong_to_view(
					vcvs, class_ext.POPULATION[i]);
				i := i + 1;
			END_REPEAT;

		ELSE
			result := TRUE;
		END_IF;

	ELSE
		result := UNKNOWN;
	END_IF;

	RETURN(result);
ELSE
	RETURN(UNKNOWN);
END_IF;

END_FUNCTION; -- all_view_control_variables_belong_to_each_view





FUNCTION check_all_view_control_variables_belong_to_view(
	vcvs: SET OF property_bsu;
	a_view: dic_f_model_instance): LOGICAL;

LOCAL
	used_properties: SET OF property_bsu := [];
END_LOCAL;

REPEAT i := 1 TO SIZEOF(a_view.properties);
	used_properties := used_properties +
		a_view.properties[i].prop_def;
END_REPEAT;

RETURN(vcvs <= used_properties);

END_FUNCTION; -- check_all_view_control_variables_belong_to_view





FUNCTION all_vcvs_belong_to_instance_identification(
	class_ext: explicit_model_class_extension): LOGICAL;
LOCAL
	vcvs: SET OF property_bsu := [];
	created_view: class_bsu;
	cl: class_bsu;
END_LOCAL;

cl := class_ext\content_item.dictionary_definition;

IF (SIZEOF(cl.definition) = 1)
THEN
	created_view := cl.definition[1]\
		abstract_functional_model_class.created_view;
	vcvs := list_to_set(functional_view_v_c_v(created_view));

	IF (SIZEOF(created_view.definition) = 1)
	THEN
		RETURN(vcvs <= list_to_set(class_ext\
			explicit_model_class_extension.
			instance_identification));
	ELSE
		RETURN(UNKNOWN);
	END_IF;

ELSE
	RETURN(UNKNOWN);
END_IF;

END_FUNCTION; -- vcvs_and_required_properties_belong_to_identification




FUNCTION presentation_unit_is_correct(prop: property_BSU;
	to_unit: unit): LOGICAL;
LOCAL
	prop_domain: data_type;
	prop_typeof: SET OF STRING := [];
END_LOCAL;

IF (SIZEOF(prop\basic_semantic_unit.definition) = 0)
THEN
	RETURN(UNKNOWN);
END_IF;

prop_typeof := data_type_typeof(prop);

IF (prop_typeof = []) -- some DET not present
THEN
	RETURN(UNKNOWN);
END_IF;

prop_domain := data_type_of_BSU(prop)[1]; -- not empty

IF ('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.INT_MEASURE_TYPE' IN
	TYPEOF(prop_domain))
THEN
	RETURN(derive_dimensional_exponents(to_unit) =
		derive_dimensional_exponents(prop_domain\
		int_measure_type.unit.structured_representation));
END_IF;

IF ('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.REAL_MEASURE_TYPE' IN
	TYPEOF(prop_domain))
THEN
	RETURN(derive_dimensional_exponents(to_unit) =
		derive_dimensional_exponents(prop_domain\
		real_measure_type.unit.structured_representation));
END_IF;

IF ('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.LEVEL_TYPE' IN
	TYPEOF(prop_domain))
THEN
	IF ('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.INT_MEASURE_TYPE' IN
		TYPEOF(prop_domain\level_type.value_type))
	THEN
		RETURN(derive_dimensional_exponents(to_unit) =
			derive_dimensional_exponents(
			prop_domain\level_type.value_type
			.unit.structured_representation));
	END_IF;
	IF ('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.REAL_MEASURE_TYPE' IN
		TYPEOF(prop_domain\level_type.value_type))
	THEN
		RETURN(derive_dimensional_exponents(to_unit) =
			derive_dimensional_exponents(
			prop_domain\level_type.value_type
			.unit.structured_representation));
	END_IF;
END_IF;

RETURN(FALSE);

END_FUNCTION; -- presentation_unit_is_correct




FUNCTION data_type_of_BSU(type_spec: property_or_data_type_BSU):
	SET[0:1] OF data_type;
LOCAL
	res: BOOLEAN := FALSE;
	x: data_type;
END_LOCAL;

IF NOT EXISTS(type_spec)
THEN
	RETURN([]); -- type_spec is indeterminate
END_IF;

IF ('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.PROPERTY_BSU' IN
	TYPEOF(type_spec))
THEN
	IF NOT(SIZEOF(type_spec.definition) = 0)
	THEN
		x := type_spec.definition[1]\property_DET.domain;
		res := TRUE;
	END_IF;
ELSE
	IF NOT(SIZEOF(type_spec.definition) = 0)
	THEN
		x := type_spec.definition[1]
			\data_type_element.type_definition;
		res := TRUE;
	END_IF;
END_IF;

IF NOT(res)
THEN
	RETURN([]);
END_IF;

IF ('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.NAMED_TYPE' IN TYPEOF(x))
THEN
	IF NOT(SIZEOF(x\named_type.referred_type.definition) = 0)
	THEN
		RETURN(data_type_of_BSU(x\named_type.referred_type));
	ELSE
		RETURN([]);
	END_IF;
ELSE
	RETURN([x]);
END_IF;

END_FUNCTION; -- data_type_of_BSU



FUNCTION derive_dimensional_exponents (x : unit) : dimensional_exponents;

  LOCAL
    i      : INTEGER;
    result : dimensional_exponents := 
             dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0); 
  END_LOCAL;

  IF 'ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.DERIVED_UNIT' IN TYPEOF(x) THEN -- x is a derived unit
    REPEAT i := LOINDEX(x.elements) TO HIINDEX(x.elements);

      result.length_exponent                    := 
        result.length_exponent + 
        (x.elements[i].exponent * 
         x.elements[i].unit.dimensions.length_exponent);

      result.mass_exponent                      := 
        result.mass_exponent + 
        (x.elements[i].exponent * 
         x.elements[i].unit.dimensions.mass_exponent);

     result.time_exponent := 
        result.time_exponent + 
        (x.elements[i].exponent * 
         x.elements[i].unit.dimensions.time_exponent); 

      result.electric_current_exponent          := 
        result.electric_current_exponent + 
        (x.elements[i].exponent * 
         x.elements[i].unit.dimensions.electric_current_exponent);

      result.thermodynamic_temperature_exponent :=
        result.thermodynamic_temperature_exponent + 
        (x.elements[i].exponent * 
         x.elements[i].unit.dimensions.thermodynamic_temperature_exponent);
 
      result.amount_of_substance_exponent       :=
        result.amount_of_substance_exponent + 
        (x.elements[i].exponent * 
         x.elements[i].unit.dimensions.amount_of_substance_exponent);

      result.luminous_intensity_exponent        := 
        result.luminous_intensity_exponent + 
        (x.elements[i].exponent * 
         x.elements[i].unit.dimensions.luminous_intensity_exponent);
 
    END_REPEAT;
  ELSE -- x is a unitless or a named unit
    result := x.dimensions;
  END_IF;
  RETURN (result);
END_FUNCTION;



FUNCTION valid_units ( m : measure_with_unit ) : BOOLEAN ;

  IF 'ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.LENGTH_MEASURE' IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;

  IF 'ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.MASS_MEASURE' IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;

  IF 'ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.TIME_MEASURE' IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;

 IF 'ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.ELECTRIC_CURRENT_MEASURE' IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;

  IF 'ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.THERMODYNAMIC_TEMPERATURE_MEASURE'
  IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;

  IF 'ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.AMOUNT_OF_SUBSTANCE_MEASURE' IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;

  IF 'ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.LUMINOUS_INTENSITY_MEASURE' IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;

  IF 'ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.PLANE_ANGLE_MEASURE' IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;

  IF 'ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.SOLID_ANGLE_MEASURE' IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;

  IF 'ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.AREA_MEASURE' IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 2.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;

  IF 'ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.VOLUME_MEASURE' IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 3.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;

  IF 'ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.RATIO_MEASURE' IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;

  IF 'ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.POSITIVE_LENGTH_MEASURE' IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;

  IF 'ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.POSITIVE_PLANE_ANGLE_MEASURE' IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;

  RETURN (TRUE);

END_FUNCTION;

FUNCTION dimensions_for_si_unit (n : si_unit_name) : dimensional_exponents; 

  CASE n  OF
    metre          : RETURN (dimensional_exponents 
                             (1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0));
    gram           : RETURN (dimensional_exponents 
                             (0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0));
    second         : RETURN (dimensional_exponents
                             (0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0));
    ampere         : RETURN (dimensional_exponents
                             (0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0));
    kelvin         : RETURN (dimensional_exponents
                             (0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0));
    mole           : RETURN (dimensional_exponents
                             (0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0));
    candela        : RETURN (dimensional_exponents
                             (0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0));
    radian         : RETURN (dimensional_exponents
                             (0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0));
    steradian      : RETURN (dimensional_exponents
                             (0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0));
    hertz          : RETURN (dimensional_exponents
                             (0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0));
    newton         : RETURN (dimensional_exponents
                             (1.0, 1.0, -2.0, 0.0, 0.0, 0.0, 0.0));
    pascal         : RETURN (dimensional_exponents
                             (-1.0, 1.0, -2.0, 0.0, 0.0, 0.0, 0.0));
    joule          : RETURN (dimensional_exponents
                             (2.0, 1.0, -2.0, 0.0, 0.0, 0.0, 0.0));
    watt           : RETURN (dimensional_exponents
                             (2.0, 1.0, -3.0, 0.0, 0.0, 0.0, 0.0));
    coulomb        : RETURN (dimensional_exponents
                             (0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 0.0));
    volt           : RETURN (dimensional_exponents
                             (2.0, 1.0, -3.0, -1.0, 0.0, 0.0, 0.0));
    farad          : RETURN (dimensional_exponents
                             (-2.0, -1.0, 4.0, 1.0, 0.0, 0.0, 0.0));
    ohm            : RETURN (dimensional_exponents
                             (2.0, 1.0, -3.0, -2.0, 0.0, 0.0, 0.0));
    siemens        : RETURN (dimensional_exponents
                             (-2.0, -1.0, 3.0, 2.0, 0.0, 0.0, 0.0));
    weber          : RETURN (dimensional_exponents
                             (2.0, 1.0, -2.0, -1.0, 0.0, 0.0, 0.0));
    tesla          : RETURN (dimensional_exponents
                             (0.0, 1.0, -2.0, -1.0, 0.0, 0.0, 0.0));
    henry          : RETURN (dimensional_exponents
                             (2.0, 1.0, -2.0, -2.0, 0.0, 0.0, 0.0));
    degree_Celsius : RETURN (dimensional_exponents
                             (0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0));
    lumen          : RETURN (dimensional_exponents
                             (0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0));
    lux            : RETURN (dimensional_exponents
                             (-2.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0));
    becquerel      : RETURN (dimensional_exponents
                             (0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0));
    gray           : RETURN (dimensional_exponents
                             (2.0, 0.0, -2.0, 0.0, 0.0, 0.0, 0.0));
    sievert        : RETURN (dimensional_exponents
                             (2.0, 0.0, -2.0, 0.0, 0.0, 0.0, 0.0));
  END_CASE;      

	RETURN(?);
END_FUNCTION; 



FUNCTION dimension_of(item : geometric_representation_item) :
  dimension_count;
  LOCAL
    x : SET OF representation;
    y : representation_context;
  END_LOCAL;

  -- Find the set of representation in which the item is used. 

  x := using_representations(item);

  -- Determines the dimension_count of the 
  -- geometric_representation_context. Note that the 
  -- RULE compatible_dimension ensures that the context_of_items
  -- is of type geometric_representation_context and has
  -- the same dimension_count for all values of x.
  -- The SET x is non-empty since this is required by WR1 of
  -- representation_item.
    y := x[1].context_of_items;
    RETURN(y\geometric_representation_context.coordinate_space_dimension);

END_FUNCTION;



FUNCTION using_representations (item : founded_item_select)
  : SET OF representation;
  LOCAL
    results            : SET OF representation;
    result_bag         : BAG OF representation;
    intermediate_items : SET OF founded_item_select;
  END_LOCAL;
  -- Find the representations in which the item is used and add to the
  -- results set.
  results := [];
  result_bag :=
USEDIN(item,'ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.REPRESENTATION.ITEMS');
  IF SIZEOF(result_bag) > 0 THEN
    REPEAT i := 1 TO HIINDEX(result_bag);
      results := results + result_bag[i];
    END_REPEAT;
  END_IF;
  -- Find all representation_items or founded_items
  -- by which item is referenced directly or indirectly.
  intermediate_items := using_items(item,[]);
  -- If the set of intermediate items is not empty;
  IF SIZEOF(intermediate_items) > 0 THEN
    -- For each element in the set, add the
    -- representations of that element.
    REPEAT i := 1 TO HIINDEX(intermediate_items);
      result_bag := USEDIN(intermediate_items[i],
                    'ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.REPRESENTATION.ITEMS');
      IF SIZEOF(result_bag) > 0 THEN
        REPEAT j := 1 TO HIINDEX(result_bag);
          results := results + result_bag[j];
        END_REPEAT;
      END_IF;
    END_REPEAT;
  END_IF;
  -- Return the set of representation in which the input item is
  -- used directly and indirectly (through intervening
  -- representation_items or founded items).
  RETURN (results);
END_FUNCTION;



FUNCTION using_items (item : founded_item_select;
                      checked_items: SET OF founded_item_select)
                    : SET OF founded_item_select;
  LOCAL
    new_check_items    : SET OF founded_item_select;
    result_items       : SET OF founded_item_select;
    next_items         : SET OF founded_item_select;
  END_LOCAL;
  result_items := [];
  new_check_items := checked_items + item;
  -- Find the set of representation_items or founded_items
  -- in which item is used directly.
  next_items := QUERY(z <* bag_to_set( USEDIN(item , '')) |
    ('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.REPRESENTATION_ITEM' IN TYPEOF(z)) OR
    ('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.FOUNDED_ITEM'        IN TYPEOF(z)));
  -- If the set of next_items is not empty;
  IF SIZEOF(next_items) > 0 THEN
    -- For each element in the set, find the using_items recursively
    REPEAT i := 1 TO HIINDEX(next_items);
      -- Check for loop in data model, i.e. one of the next_items
      -- occurred earlier in the set of check_items;
      IF NOT(next_items[i] IN new_check_items) THEN
        result_items := result_items + next_items[i] +
                        using_items(next_items[i],new_check_items);
      END_IF;
    END_REPEAT;
  END_IF;
  -- return the set of representation_items or founded_items
  -- in which the input item is used directly and indirectly.
  RETURN (result_items);
END_FUNCTION;



FUNCTION bag_to_set (the_bag : BAG OF GENERIC : intype) : SET OF GENERIC : intype;

  LOCAL
    the_set: SET OF GENERIC : intype := [];
    i      : INTEGER;
  END_LOCAL;

  IF SIZEOF (the_bag) > 0 THEN
    REPEAT i := 1 TO HIINDEX (the_bag);
      the_set := the_set + the_bag [i];
    END_REPEAT;
  END_IF;

  RETURN (the_set);

END_FUNCTION;



FUNCTION normalise (arg : vector_or_direction) : vector_or_direction;
   LOCAL
     ndim   : INTEGER;
     v      : direction;
     result : vector_or_direction;
     vec    : vector;
     mag    : REAL;
   END_LOCAL;
   
   IF NOT EXISTS (arg) THEN
     result := ?;
     (* When function is called with invalid data a NULL result is returned *)
   ELSE
     ndim := arg.dim;
     IF 'ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.VECTOR' IN TYPEOF(arg) THEN
       BEGIN
             v := dummy_gri || direction(arg.orientation.direction_ratios);
         IF arg.magnitude = 0.0 THEN
           RETURN(?);
         ELSE
          vec := dummy_gri || vector (v, 1.0);
         END_IF;
       END;
     ELSE
       v := dummy_gri || direction (arg.direction_ratios);
     END_IF;
     mag := 0.0;
     REPEAT  i := 1 TO ndim;
       mag := mag + v.direction_ratios[i]*v.direction_ratios[i];
     END_REPEAT;
     IF mag > 0.0 THEN
       mag := SQRT(mag);
       REPEAT  i := 1 TO ndim;
         v.direction_ratios[i] := v.direction_ratios[i]/mag;
       END_REPEAT;
       IF 'ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.VECTOR' IN TYPEOF(arg) THEN
         vec.orientation := v;
         result := vec;
       ELSE
         result := v;
       END_IF;
     ELSE
       RETURN(?);
     END_IF;
   END_IF;
   RETURN (result);
 END_FUNCTION;



 FUNCTION build_2axes(ref_direction : direction) : LIST [2:2] OF direction;
   LOCAL
     d : direction := NVL(normalise(ref_direction),
                          dummy_gri || direction([1.0,0.0]));
   END_LOCAL;

   RETURN([d, orthogonal_complement(d)]);
 END_FUNCTION;



FUNCTION orthogonal_complement(vec : direction) : direction;
  LOCAL
    result :  direction ;
  END_LOCAL;

  IF (vec.dim <> 2) OR NOT EXISTS (vec) THEN
    RETURN(?);
  ELSE
    result := dummy_gri || direction([-vec.direction_ratios[2], vec.direction_ratios[1]]);
    RETURN(result);
  END_IF;
END_FUNCTION;



FUNCTION build_axes(axis, ref_direction : direction) :
                                          LIST [3:3] OF direction;
   LOCAL
     d1, d2 : direction;
   END_LOCAL;
  d1 := NVL(normalise(axis), dummy_gri || direction([0.0,0.0,1.0]));
  d2 := first_proj_axis(d1, ref_direction);
  RETURN([d2, normalise(cross_product(d1,d2)).orientation, d1]);
END_FUNCTION;



FUNCTION first_proj_axis(z_axis, arg : direction) : direction;
  LOCAL
    x_axis : direction;
    v      : direction;
    z      : direction;
    x_vec  : vector;
  END_LOCAL;
  
  IF (NOT EXISTS(z_axis)) THEN
    RETURN (?) ;
  ELSE
    z := normalise(z_axis);
    IF NOT EXISTS(arg) THEN
      IF (z.direction_ratios <> [1.0,0.0,0.0]) THEN
        v :=  dummy_gri || direction([1.0,0.0,0.0]);
      ELSE
        v := dummy_gri || direction([0.0,1.0,0.0]);
      END_IF;
    ELSE
      IF  (arg.dim <> 3) THEN
        RETURN (?) ;
      END_IF;
      IF ((cross_product(arg,z).magnitude) = 0.0) THEN
        RETURN (?);
      ELSE
        v := normalise(arg);
      END_IF;
    END_IF;
    x_vec := scalar_times_vector(dot_product(v, z), z);
    x_axis := vector_difference(v, x_vec).orientation;
    x_axis := normalise(x_axis);
  END_IF;
  RETURN(x_axis);
END_FUNCTION;



FUNCTION cross_product (arg1, arg2 : direction) : vector;
  LOCAL
    mag    : REAL;
    res    : direction;
    v1,v2  : LIST[3:3] OF REAL;
    result : vector;
  END_LOCAL;
  
  IF ( NOT EXISTS (arg1) OR (arg1.dim = 2)) OR
     ( NOT EXISTS (arg2) OR (arg2.dim = 2)) THEN
    RETURN(?);
  ELSE
    BEGIN
      v1  := normalise(arg1).direction_ratios;
      v2  := normalise(arg2).direction_ratios;
      res := dummy_gri || direction([(v1[2]*v2[3] - v1[3]*v2[2]),
	    (v1[3]*v2[1] - v1[1]*v2[3]), (v1[1]*v2[2] - v1[2]*v2[1])]);
      mag := 0.0;
      REPEAT i := 1 TO 3;
        mag := mag + res.direction_ratios[i]*res.direction_ratios[i];
      END_REPEAT;
      IF (mag > 0.0) THEN
        result := dummy_gri || vector(res, SQRT(mag));
      ELSE
        result := dummy_gri || vector(arg1, 0.0);
      END_IF;
      RETURN(result);
    END;
  END_IF;
END_FUNCTION;



FUNCTION scalar_times_vector (scalar : REAL; vec : vector_or_direction)
                                     : vector;
  LOCAL
    v      : direction;
    mag    : REAL;
    result : vector;
  END_LOCAL;

  IF NOT EXISTS (scalar) OR NOT EXISTS (vec) THEN
    RETURN (?) ;
   ELSE
    IF 'ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.VECTOR' IN TYPEOF (vec) THEN
      v   := dummy_gri || direction(vec.orientation.direction_ratios);
      mag := scalar * vec.magnitude;
    ELSE
      v   := dummy_gri || direction(vec.direction_ratios);
      mag := scalar;
    END_IF;
    IF (mag < 0.0 ) THEN
      REPEAT i := 1 TO SIZEOF(v.direction_ratios);
        v.direction_ratios[i] := -v.direction_ratios[i];
      END_REPEAT;
      mag := -mag;
    END_IF;
    result := dummy_gri || vector(normalise(v), mag);
  END_IF;
  RETURN (result);
END_FUNCTION;



FUNCTION dot_product(arg1, arg2 : direction) : REAL;
   LOCAL
     scalar : REAL;
     vec1, vec2: direction;
     ndim : INTEGER;
   END_LOCAL;
   
   IF NOT EXISTS (arg1) OR NOT EXISTS (arg2) THEN
     scalar := ?;
     (* When function is called with invalid data a NULL result is returned *)
   ELSE
     IF (arg1.dim <> arg2.dim) THEN
       scalar := ?;
     (* When function is called with invalid data a NULL result is returned *)
     ELSE
       BEGIN
         vec1   := normalise(arg1);
         vec2   := normalise(arg2);
         ndim   := arg1.dim;
         scalar := 0.0;
         REPEAT  i := 1 TO ndim;
           scalar := scalar +
                       vec1.direction_ratios[i]*vec2.direction_ratios[i];
         END_REPEAT;
       END;
     END_IF;
   END_IF;
   RETURN (scalar);
 END_FUNCTION;



FUNCTION vector_difference(arg1, arg2 : vector_or_direction) : vector;
  LOCAL
    result          : vector;
    res, vec1, vec2 : direction;
    mag, mag1, mag2 : REAL;
    ndim            : INTEGER;
  END_LOCAL;

  IF ((NOT EXISTS (arg1)) OR (NOT EXISTS (arg2))) OR (arg1.dim <> arg2.dim)
      THEN
    RETURN (?) ;
   ELSE
    BEGIN
      IF 'ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.VECTOR' IN TYPEOF(arg1) THEN
        mag1 := arg1.magnitude;
        vec1 := arg1.orientation;
      ELSE
        mag1 := 1.0;
        vec1 := arg1;
      END_IF;
      IF 'ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.VECTOR' IN TYPEOF(arg2) THEN
        mag2 := arg2.magnitude;
        vec2 := arg2.orientation;
      ELSE
        mag2 := 1.0;
        vec2 := arg2;
      END_IF;
      vec1 := normalise (vec1);
      vec2 := normalise (vec2);
      ndim := SIZEOF(vec1.direction_ratios);
      mag := 0.0;
      res := dummy_gri || direction(vec1.direction_ratios);
      REPEAT i := 1 TO ndim;
        res.direction_ratios[i] := mag1*vec1.direction_ratios[i] +
                                    mag2*vec2.direction_ratios[i];
        mag := mag + (res.direction_ratios[i]*res.direction_ratios[i]);
      END_REPEAT;
      IF (mag > 0.0 ) THEN
      result := dummy_gri || vector( res, SQRT(mag));
      ELSE
        result := dummy_gri || vector( vec1,  0.0);
      END_IF;
    END;
  END_IF;
  RETURN (result);
END_FUNCTION;




FUNCTION applicable_documents(cl: class_BSU;
	doc: AGGREGATE OF document_BSU): LOGICAL;

IF SIZEOF(doc) = 0
THEN
	RETURN(TRUE);
END_IF;

IF NOT EXISTS(cl)
THEN
	RETURN(UNKNOWN);
END_IF;

IF SIZEOF(cl.definition) = 0
THEN
	RETURN(UNKNOWN);
END_IF;

doc := doc - retrieve_documents(cl);

IF 'ISO13584_25_LIBRARY_IMPLICIT_SCHEMA' +
	'.A_PRIORI_SEMANTIC_RELATIONSHIP' IN TYPEOF(cl.definition[1])
THEN
	Doc := doc - cl.definition[1]\a_priori_semantic_relationship.
		referenced_documents;
END_IF;

IF SIZEOF(doc) = 0
THEN
	RETURN(TRUE);
ELSE
	IF EXISTS(cl.definition[1]\class.its_superclass)
	THEN
		RETURN(applicable_documents(cl.definition[1]
			\class.its_superclass, doc));
	ELSE
		RETURN(FALSE);
	END_IF;
END_IF;

END_FUNCTION; -- applicable_documents




FUNCTION retrieve_documents(cl: class_BSU): SET[0:?] OF document_BSU;
-- requires: { SIZEOF(cl.definition) <> O }

LOCAL
	s: SET[0:?] OF document_BSU := [];
END_LOCAL;

REPEAT i := 1 TO SIZEOF(cl.definition[1]\class.associated_items);
	IF 'ISO13584_25_LIBRARY_IMPLICIT_SCHEMA' +
		'.CLASS_DOCUMENT_RELATIONSHIP'
		IN TYPEOF(cl.definition[1]\class.associated_items[i])
	THEN
		s := s+ cl.definition[1]\class.associated_items[i]
			\class_document_relationship.related_tokens;
	END_IF;
END_REPEAT;

RETURN(s);

END_FUNCTION; -- retrieve_documents




FUNCTION all_views_available_for_components(cl: class_bsu): LOGICAL;
LOCAL
	components_views: SET OF LIST OF INTEGER := [];
	component_view: LIST OF INTEGER := [];
	components: SET OF LIST OF INTEGER := [];
	declared_views: SET OF LIST OF INTEGER := [];
	definition: fm_class_view_of;
	content: explicit_functional_model_class_extension;
END_LOCAL;

IF (SIZEOF(cl.definition) = 1)
THEN
	IF ('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.FM_CLASS_VIEW_OF'
		IN TYPEOF(cl.definition[1]))
	THEN
		definition := cl.definition[1];
	ELSE
		RETURN(UNKNOWN);
	END_IF;
ELSE
	RETURN(UNKNOWN);
END_IF;

IF (SIZEOF(cl.referenced_by) = 1)
THEN
	IF ('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.' +
		'EXPLICIT_FUNCTIONAL_MODEL_CLASS_EXTENSION'
		IN TYPEOF(cl.referenced_by[1]))
	THEN
		content := cl.referenced_by[1];
	ELSE
		RETURN(UNKNOWN);
	END_IF;
ELSE
	RETURN(UNKNOWN);
END_IF;
-- id x vcvs in model
components_views := available_components_views(cl);
-- id in item
components := get_dic_item_instances_from_required_item_properties(cl);
-- vcv tuples in declaration
declared_views := declared_created_views(cl);

IF (SIZEOF(components) <> 0)
THEN
	REPEAT i := 1 TO SIZEOF(components);
		REPEAT j := 1 TO SIZEOF(declared_views);
			component_view := components[i] + declared_views[j];
			IF NOT(component_view IN components_views)
			THEN
				RETURN(FALSE);
			END_IF;
		END_REPEAT;
	END_REPEAT;

	RETURN(TRUE);
ELSE
	RETURN(UNKNOWN);
END_IF;

END_FUNCTION; -- all_views_available_for_components




FUNCTION available_components_views(cl: class_bsu): SET OF LIST OF
INTEGER;
LOCAL
	required_props: LIST OF property_bsu := [];
	vcvs: LIST OF property_bsu := [];
	view_properties: LIST OF property_bsu := [];
	definition: fm_class_view_of;
	content: explicit_functional_model_class_extension;
	result: SET OF LIST OF INTEGER := [];
END_LOCAL;

	IF (SIZEOF(cl.definition) = 1)
	THEN
		IF ('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.FM_CLASS_VIEW_OF'
			IN TYPEOF(cl.definition[1]))
		THEN
			definition := cl.definition[1];
	ELSE
		RETURN([]);
	END_IF;
ELSE
	RETURN([]);
END_IF;

IF (SIZEOF(cl.referenced_by) = 1)
THEN
	IF ('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.' +
		'EXPLICIT_FUNCTIONAL_MODEL_CLASS_EXTENSION'
		IN TYPEOF(cl.referenced_by[1]))
	THEN
		content := cl.referenced_by[1];
	ELSE
		RETURN([]);
	END_IF;
ELSE
	RETURN([]);
END_IF;

vcvs := functional_view_v_c_v(definition\
	abstract_functional_model_class.created_view);

IF (SIZEOF(vcvs) <> 0)
THEN
	required_props := get_list_of_required_properties(definition,
		content.required_item_values);
	view_properties := required_props + vcvs;
	result := properties_projection_on_population(view_properties,
		content.POPULATION);
END_IF;

RETURN(result);

END_FUNCTION; -- available_components_views




FUNCTION get_list_of_required_properties(cl: fm_class_view_of;
	required_properties: SET OF property_bsu)
	: LIST OF property_bsu;
LOCAL
	result: LIST OF property_bsu := [];
END_LOCAL;

REPEAT i := 1 TO SIZEOF(cl.imported_properties_from_item);
	IF (cl.imported_properties_from_item[i] IN required_properties)
	THEN
		result := result + cl.imported_properties_from_item[i];
	END_IF;
END_REPEAT;

RETURN(result);

END_FUNCTION; -- get_list_of_required_properties




FUNCTION properties_projection_on_population(
	properties: LIST OF property_bsu;
	POPULATION: LIST OF dic_class_instance)
	: SET OF LIST OF primitive_value;
LOCAL
	result: SET OF LIST OF INTEGER := [];
	tuple: LIST OF INTEGER := [];
END_LOCAL;

REPEAT i := 1 TO SIZEOF(POPULATION);
	REPEAT j := 1 TO SIZEOF(properties);
		REPEAT k := 1 TO SIZEOF(POPULATION[i].properties);
			IF (POPULATION[i].properties[k].prop_def =
				properties[j])
			THEN
				tuple := tuple +
					POPULATION[i].properties[k].its_value;
			END_IF;
		END_REPEAT;
	END_REPEAT;
	result := result + tuple;
	tuple := [];
END_REPEAT;

RETURN(result);

END_FUNCTION; -- properties_projection_on_population




FUNCTION get_dic_item_instances_from_required_item_properties(
	cl: class_bsu): SET OF LIST OF primitive_value;
LOCAL
	required_props: LIST OF property_bsu := [];
	definition: fm_class_view_of;
	content: explicit_functional_model_class_extension;
	item_bsu: class_bsu;
	item_content: explicit_item_class_extension;
	result: SET OF LIST OF primitive_value := [];
END_LOCAL;

IF (SIZEOF(cl.definition) = 1)
THEN
	IF ('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.FM_CLASS_VIEW_OF'
		IN TYPEOF(cl.definition[1]))
	THEN
		definition := cl.definition[1];
		item_bsu := definition.view_of;
	ELSE
		RETURN([]);
	END_IF;
ELSE
	RETURN([]);
END_IF;

IF (SIZEOF(cl.referenced_by) = 1)
THEN
	IF ('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.' +
		'EXPLICIT_FUNCTIONAL_MODEL_CLASS_EXTENSION'
		IN TYPEOF(cl.referenced_by[1]))
	THEN
		content := cl.referenced_by[1];
	ELSE
		RETURN([]);
	END_IF;
ELSE
	RETURN([]);
END_IF;

IF (SIZEOF(item_bsu.referenced_by) = 1)
THEN
	IF ('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.' +
		'EXPLICIT_MODEL_CLASS_EXTENSION'
		IN TYPEOF(item_bsu.referenced_by[1]))
	THEN
		item_content := item_bsu.referenced_by[1];
	ELSE
		RETURN([]);
	END_IF;
ELSE
	RETURN([]);
END_IF;

required_props := get_list_of_required_properties(definition,
	content.required_item_values);
result := properties_projection_on_population(required_props,
	item_content.POPULATION);

RETURN(result);

END_FUNCTION; -- get_dic_item_instances_from_imported_item_properties




FUNCTION declared_created_views(cl: class_BSU):
	SET OF LIST OF INTEGER;

LOCAL
	res: SET OF LIST OF INTEGER:=[];
	v_c_vs: LIST OF view_control_variable_range;
END_LOCAL;

IF NOT computable_set_of_created_views_from_model(cl)
THEN
	RETURN([]);
END_IF;

v_c_vs := make_ordered_list_of_v_c_v_range(functional_view_v_c_v(
	cl.definition[1]\abstract_functional_model_class.created_view),
	cl.definition[1]\abstract_functional_model_class.v_c_v_range);

res := make_tuple(v_c_vs);

RETURN(res);

END_FUNCTION; -- declared_created_views




FUNCTION computable_set_of_created_views_from_model(
	cl: class_BSU): BOOLEAN;

IF NOT EXISTS(cl)
THEN
	RETURN(FALSE); -- the class itself is indeterminate
END_IF;

IF SIZEOF(cl.definition) = 0
THEN
	RETURN(FALSE);
END_IF;

IF SIZEOF(cl.referenced_by) = 0
THEN
	RETURN(FALSE);
END_IF;
IF NOT('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.'+
	'ABSTRACT_FUNCTIONAL_MODEL_CLASS' IN TYPEOF(cl.definition[1]))
THEN
	RETURN(FALSE);
END_IF;
IF NOT('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.'+
	'FUNCTIONAL_MODEL_CLASS_EXTENSION' IN TYPEOF(
	cl.referenced_by[1]))
	AND NOT ('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.'+
	'EXPLICIT_FUNCTIONAL_MODEL_CLASS_EXTENSION' IN TYPEOF(
	cl.referenced_by[1]))
THEN
	RETURN(FALSE);
END_IF;

IF SIZEOF(functional_view_v_c_v(cl.definition[1]
	\abstract_functional_model_class.created_view)) = 0
THEN
	RETURN(FALSE);
END_IF;

RETURN(all_v_c_v_range_available(functional_view_v_c_v(cl.definition[1]
	\abstract_functional_model_class.created_view)));

END_FUNCTION; -- computable_set_of_created_views_from_model




FUNCTION all_v_c_v_range_available(l: LIST OF property_BSU):
	BOOLEAN;
LOCAL
	res: BOOLEAN:= TRUE;
END_LOCAL;

REPEAT i := 1 TO SIZEOF(l);
	IF NOT(SIZEOF(data_type_non_quantitative_int_type(l[i])) = 1)
	THEN
		res := FALSE;
	END_IF;
END_REPEAT;

RETURN(res);

END_FUNCTION; -- all_v_c_v_range_available




FUNCTION make_ordered_list_of_v_c_v_range(
	l: LIST OF property_BSU;
	l_range: SET OF view_control_variable_range):
	LIST OF view_control_variable_range;
LOCAL
	y: view_control_variable_range;
	res: LIST OF view_control_variable_range:=[];
	s: SET[0:1] OF non_quantitative_int_type;
	x: non_quantitative_int_type;
END_LOCAL;

IF NOT all_v_c_v_range_available(l)
THEN
	RETURN([]);
END_IF;

REPEAT i := 1 TO SIZEOF(l);
	IF is_in_v_c_v_range(l[i], l_range)
	THEN
		res := res + get_v_c_v_range(l[i], l_range);
	ELSE
		s := data_type_non_quantitative_int_type(l[i]);
		x := s[1];
		y := view_control_variable_range(l[i],
			x.domain.its_values[1].value_code,
			x.domain.its_values[1].value_code +
			SIZEOF(x.domain.its_values) - 1);
		res := res + y;
	END_IF;
END_REPEAT;

RETURN(res);

END_FUNCTION; -- make_ordered_list_of_v_c_v_range




FUNCTION is_in_v_c_v_range(p: property_BSU;
	l: SET OF view_control_variable_range ): BOOLEAN;

IF (SIZEOF(QUERY(elt <* l | elt.parameter_type = p)) = 1)
THEN
	RETURN(TRUE);
ELSE
	RETURN(FALSE);
END_IF;

END_FUNCTION; -- is_in_v_c_v_range




FUNCTION get_v_c_v_range(p: property_BSU;
	l: SET OF view_control_variable_range):
	view_control_variable_range;

LOCAL
	x: SET OF view_control_variable_range;
END_LOCAL;

x := QUERY(elt <* l | elt.parameter_type = p);

RETURN(x[1]);

END_FUNCTION; -- get_v_c_v_range




FUNCTION make_tuple(l: LIST[1:?] OF view_control_variable_range):
	SET [1:?] OF LIST[1:?] OF INTEGER;

LOCAL
	result: SET OF LIST OF INTEGER := [];
	list_sub_tuple: SET OF LIST OF INTEGER;
END_LOCAL;

IF SIZEOF(l) = 1 THEN
	REPEAT i := l[1]\view_control_variable_range.range_lobound TO
		l[1]\view_control_variable_range.range_hibound;
		result := [[i]] + result;
	END_REPEAT;
ELSE
	list_sub_tuple := make_tuple(cdr_list(l));
	REPEAT i := 1 TO SIZEOF(list_sub_tuple);	-- for each subtuple
		REPEAT j := l[1]\view_control_variable_range.range_lobound
			TO l[1]\view_control_variable_range.range_hibound;
			-- creates one new tuple for each value of l[1]
			result := result + [j + list_sub_tuple[i]];
		END_REPEAT;
	END_REPEAT;
END_IF;

RETURN(result);

END_FUNCTION; -- make_tuple




FUNCTION cdr_list(l: LIST [2:?] OF GENERIC: type_elem):
	LIST OF GENERIC: type_elem;

LOCAL
	cdr: LIST OF GENERIC: type_elem := [];
END_LOCAL;

REPEAT i := 2 TO SIZEOF(l);
	cdr := cdr + l[i];
END_REPEAT;

RETURN(cdr);

END_FUNCTION; -- cdr_list

(*ES*)

	-- nested in string_for_derived_unit, by AM	
	FUNCTION string_for_derived_unit_element(
		u: derived_unit_element; neg_exp: BOOLEAN
		): STRING;



	LOCAL
		result: STRING;
	END_LOCAL;

	result := string_for_named_unit(u.unit);
	IF (u.exponent <> 0)
	THEN
		IF (u.exponent > 0) OR NOT neg_exp
		THEN
			result := result + '**' + FORMAT(
				ABS(u.exponent), '2I')[2];
		ELSE
			result := result + '**' + FORMAT(u.exponent, '2I')[2];
		END_IF;
	END_IF;
		RETURN(result);
	END_FUNCTION; -- string_for_derived_unit_element

FUNCTION string_for_derived_unit(u: derived_unit): STRING;


LOCAL
	pos, neg: SET OF derived_unit_element;
	us: STRING;
END_LOCAL;


pos := QUERY(ue <* u.elements | ue.exponent > 0);
neg := QUERY(ue <* u.elements | ue.exponent < 0);
us := '';
IF SIZEOF(pos) > 0 THEN

	REPEAT i := LOINDEX(pos) TO HIINDEX(pos);
		us := us + string_for_derived_unit_element(pos[i], FALSE);
		IF i <> HIINDEX(pos)
		THEN
			us := us + '.';
		END_IF;
	END_REPEAT;

	IF SIZEOF(neg) > 0
	THEN


		us := us + '/';

		IF SIZEOF(neg) > 1
		THEN
			us := us + '(';
		END_IF;

		REPEAT i := LOINDEX(neg) TO HIINDEX(neg);
			us := us + string_for_derived_unit_element(
				neg[i], FALSE);
			IF i <> HIINDEX(neg)
			THEN
				us := us + '.';
			END_IF;
		END_REPEAT;

		IF SIZEOF(neg) > 1
		THEN
			us := us + ')';
		END_IF;
	END_IF;
ELSE

	IF SIZEOF(neg) > 0 THEN
		REPEAT i := LOINDEX(neg) TO HIINDEX(neg);
			us := us + string_for_derived_unit_element(
				neg[i], TRUE);
			IF i <> HIINDEX(neg)
			THEN
				us := us + '.';
			END_IF;
		END_REPEAT;
	END_IF;
END_IF;

RETURN(us);

END_FUNCTION; -- string_for_derived_unit


FUNCTION string_for_named_unit(u: named_unit): STRING;

IF 'ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.SI_UNIT' IN TYPEOF(u) THEN
	RETURN(string_for_SI_unit(u));
ELSE
	IF 'ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.CONTEXT_DEPENDENT_UNIT' IN TYPEOF(u)
	THEN
		RETURN(u\context_dependent_unit.name);
	ELSE
		IF 'ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.CONVERSION_BASED_UNIT' IN TYPEOF(u)
		THEN
			RETURN(u\conversion_based_unit.name);
		ELSE
			IF 'ISO13584_25_LIBRARY_IMPLICIT_SCHEMA'
				+'.NON_SI_UNIT' IN TYPEOF(u)
			THEN
				RETURN(u\non_si_unit.name);
			ELSE
				RETURN('name_unknown');
			END_IF;
		END_IF;
	END_IF;
END_IF;

END_FUNCTION; -- string_for_named_unit


FUNCTION string_for_SI_unit(unit: si_unit): STRING;

LOCAL
	prefix_string, unit_string: STRING;
END_LOCAL;

IF EXISTS(unit.prefix) THEN
	CASE unit.prefix OF
		exa		: prefix_string := 'E';
		peta		: prefix_string := 'P';
		tera		: prefix_string := 'T';
		giga		: prefix_string := 'G';
		mega		: prefix_string := 'M';
		kilo		: prefix_string := 'k';
		hecto	: prefix_string := 'h';
		deca		: prefix_string := 'da';
		deci		: prefix_string := 'd';
		centi	: prefix_string := 'c';
		milli	: prefix_string := 'm';
		micro	: prefix_string := 'u';
		nano		: prefix_string := 'n';
		pico		: prefix_string := 'p';
		femto	: prefix_string := 'f';
		atto		: prefix_string := 'a';
	END_CASE;
ELSE
	prefix_string := '';
END_IF;

CASE unit.name OF
	metre			: unit_string:= 'm';
	gram				: unit_string := 'g';
	second			: unit_string := 's';
	ampere			: unit_string := 'A';
	kelvin			: unit_string := 'K';
	mole				: unit_string := 'mol';
	candela			: unit_string := 'cd';
	radian			: unit_string := 'rad';
	steradian			: unit_string := 'sr';
	hertz			: unit_string := 'Hz';
	newton			: unit_string := 'N';
	pascal			: unit_string := 'Pa';
	joule			: unit_string := 'J';
	watt				: unit_string := 'W';
	coulomb			: unit_string := 'C';
	volt				: unit_string := 'V';
	farad			: unit_string := 'F';
	ohm				: unit_string := 'Ohm';
	siemens			: unit_string := 'S';
	weber			: unit_string := 'Wb';
	tesla			: unit_string := 'T';
	henry			: unit_string := 'H';
	degree_Celsius		: unit_string := 'Cel';
	lumen			: unit_string := 'lm';
	lux				: unit_string := 'lx';
	becquerel			: unit_string := 'Bq';
	gray				: unit_string := 'Gy';
	sievert			: unit_string := 'Sv';
END_CASE;

RETURN(prefix_string + unit_string);

END_FUNCTION; -- string_for_SI_unit


FUNCTION string_for_unit(u: unit): STRING;
	IF 'ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.DERIVED_UNIT' IN TYPEOF(u)
	THEN
		RETURN(string_for_derived_unit(u));
	ELSE
		RETURN(string_for_named_unit(u));
	END_IF;
END_FUNCTION; -- string_for_unit



FUNCTION compatible_complete_types_and_value(
	dom: property_or_data_type_BSU; val: primitive_value): LOGICAL;

IF (data_type_typeof(dom) = [])
THEN
	RETURN(UNKNOWN);
END_IF ;

-- checking that values are primitive values but are not aggregate
-- values.
IF ('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.PRIMITIVE_VALUE'	IN TYPEOF(val))
	AND
	(NOT('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.' +
	'AGGREGATE_ENTITY_INSTANCE_VALUE' IN TYPEOF(val)))
THEN
	RETURN(compatible_type_and_value(dom, val));
END_IF;

IF 'ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.' +
	'AGGREGATE_ENTITY_INSTANCE_VALUE' IN TYPEOF(val)
THEN
	RETURN(compatible_aggregate_domain_and_aggregate_value(dom, val)) ;
END_IF;

-- neither primitive value nor aggregate value
RETURN(UNKNOWN) ;

END_FUNCTION; -- compatible_complete_types_and_value



FUNCTION compatible_aggregate_domain_and_aggregate_value(
	dom: property_or_data_type_BSU; val: aggregate_entity_instance_value): LOGICAL;

LOCAL
	the_data_type: data_type ;
END_LOCAL ;

-- Check the avalability of the final type of a property or a
-- data type BSU.
IF data_type_typeof(dom) = []
THEN (* the final domain of the type is not available *)
	RETURN(UNKNOWN);
END_IF;

-- Check that the final type of the property or  data type BSU
-- is an entity_instance_type whose
-- type_name_attribute references the aggregate_type entity

IF (NOT('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.ENTITY_INSTANCE_TYPE' IN data_type_typeof(dom)))
THEN
	RETURN(FALSE);
END_IF;

IF (NOT('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.AGGREGATE_TYPE' IN data_type_type_name(dom)))
THEN
	RETURN(FALSE);
END_IF;

-- Compute the final type of the dom property or data type BSU

the_data_type :=  data_type_final_type(dom)[1];

RETURN(compatible_aggregate_type_and_value(the_data_type, val));

END_FUNCTION; -- compatible_aggregate_domain_and_value



FUNCTION data_type_final_type(type_spec: property_or_data_type_BSU): SET [0:1] OF data_type;

LOCAL
	res: BOOLEAN := FALSE;
	x: data_type;
END_LOCAL;

IF NOT EXISTS(type_spec)
THEN
	RETURN([]); -- type_spec is indeterminate
END_IF;

IF ('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.PROPERTY_BSU' IN TYPEOF(type_spec))
THEN
	IF NOT(SIZEOF(type_spec.definition) = 0)
	THEN
		x := type_spec.definition[1]\property_DET.domain;
		res := TRUE;
	END_IF;
ELSE
	IF NOT(SIZEOF(type_spec.definition) = 0)
	THEN
		x := type_spec.definition[1]\data_type_element.type_definition;
		res := TRUE;
	END_IF;
END_IF;

IF NOT(res)
THEN
	RETURN([]);
END_IF;

IF ('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.NAMED_TYPE' IN TYPEOF(x))
THEN
	IF NOT(SIZEOF(x\named_type.referred_type.definition) = 0)
	THEN
		RETURN(data_type_final_type(x\named_type.referred_type));
	ELSE
		RETURN([]);
	END_IF;
ELSE
	RETURN([x]);
END_IF;

END_FUNCTION; -- data_type_final_type



FUNCTION compatible_aggregate_type_and_value(
	the_data_type: entity_instance_type_for_aggregate; val: aggregate_entity_instance_value): LOGICAL;
LOCAL
    elements: LIST OF null_or_primitive_value;
	type_of_elements: data_type;
	result: LOGICAL;
	tmp: LIST OF primitive_value := [];
END_LOCAL;

elements := val.the_value.values;

-- Compute type of elements contained in the aggregate
IF ('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.NAMED_TYPE' IN TYPEOF(the_data_type.type_structure.value_type))
THEN
	IF (data_type_typeof(the_data_type.type_structure.value_type\named_type.referred_type) = [])
	THEN (* the final domain of the type of elements is not available *)
		RETURN(UNKNOWN);
	END_IF;
	type_of_elements := data_type_final_type(the_data_type.type_structure.value_type\named_type.referred_type)[1];
ELSE
    type_of_elements := the_data_type.type_structure.value_type;
END_IF ;


-- check that a value aggregate is compatible with its type aggregate declaration
IF ('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.LIST_VALUE' IN TYPEOF (val.the_value))
    AND NOT('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.LIST_TYPE' IN TYPEOF(the_data_type.type_structure))
THEN
    RETURN(FALSE);
END_IF;

IF ('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.BAG_VALUE' IN TYPEOF (val.the_value))
    AND NOT('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.BAG_TYPE' IN TYPEOF(the_data_type.type_structure))
THEN
    RETURN(FALSE);
END_IF;

IF ('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.SET_VALUE' IN TYPEOF (val.the_value))
    AND NOT('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.SET_TYPE' IN TYPEOF(the_data_type.type_structure))
THEN
    RETURN(FALSE);
END_IF;

IF ('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.ARRAY_VALUE' IN TYPEOF (val.the_value))
    AND NOT('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.ARRAY_TYPE' IN TYPEOF(the_data_type.type_structure))
THEN
    RETURN(FALSE);
END_IF;

-- check that that low and high bounds of the values are compatible
-- with the type declaration.
IF (('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.LIST_VALUE' IN TYPEOF (val.the_value))
		OR ('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.BAG_VALUE' IN TYPEOF (val.the_value))
		OR ('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.SET_VALUE' IN TYPEOF (val.the_value)))
	AND (
	(EXISTS(the_data_type.type_structure.bound_1))
	AND NOT
	(SIZEOF(elements) >= the_data_type.type_structure.bound_1)
	)
THEN
	RETURN(FALSE) ;
END_IF ;

IF (('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.LIST_VALUE' IN TYPEOF (val.the_value))
		OR ('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.BAG_VALUE' IN TYPEOF (val.the_value))
		OR ('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.SET_VALUE' IN TYPEOF (val.the_value)))
	AND (
	(EXISTS(the_data_type.type_structure.bound_2))
	AND NOT
	(SIZEOF(elements) <= the_data_type.type_structure.bound_2))
THEN
	RETURN(FALSE);
END_IF;

-- For array data type and values, check that size of the storage list
-- of values is size compatible with the type declaration.
IF ('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.ARRAY_VALUE' IN TYPEOF(val.the_value))
THEN
    IF (NOT(val.the_value\array_value.bound_1 = the_data_type.type_structure.bound_1) OR
		NOT(val.the_value\array_value.bound_2 = the_data_type.type_structure.bound_2))
    THEN
        RETURN(FALSE);
    END_IF;
END_IF;

-- In case of a list or array of unique values, check that no value is duplicated
IF ('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.LIST_VALUE' IN TYPEOF (val.the_value))
    OR ('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.ARRAY_VALUE' IN TYPEOF (val.the_value))
THEN
    IF (the_data_type.type_structure.uniqueness)
    THEN
    	REPEAT i := 1 TO SIZEOF(val.the_value.values);
    		IF NOT('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.NULL_VALUE' IN TYPEOF(val.the_value.values[i]))
    		THEN
    			tmp := tmp + val.the_value.values[i];
    		END_IF;
    	END_REPEAT;
    	
        IF NOT(VALUE_UNIQUE(tmp))
        THEN
        	RETURN(FALSE);
        END_IF;
    END_IF;
END_IF;

-- For an array where optional values are not allowed, check that no null_value is provided
IF ('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.ARRAY_VALUE' IN TYPEOF(val.the_value))
THEN
    IF NOT(the_data_type.type_structure.are_optional)
    THEN
        REPEAT i := 1 TO SIZEOF(val.the_value.values);
            IF ('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.NULL_VALUE' IN TYPEOF(val.the_value.values[i]))
            THEN
                RETURN(FALSE);
            END_IF;
        END_REPEAT;
    END_IF;
END_IF;

-- Check for value/type compatibility for all the elements contained in the aggregate
result := TRUE;

REPEAT i := 1 TO SIZEOF(elements);
	IF NOT('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.NULL_VALUE' IN TYPEOF(elements[i]))
    THEN
        IF ('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.ENTITY_INSTANCE_TYPE_FOR_AGGREGATE' IN TYPEOF(type_of_elements))
        THEN
            IF('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.AGGREGATE_ENTITY_INSTANCE_VALUE' IN TYPEOF(elements[i]))
            THEN
            	result := result AND compatible_aggregate_type_and_value(type_of_elements, elements[i]);
            ELSE
                RETURN(FALSE);
            END_IF;
        ELSE
            result := result AND compatible_final_type_and_value(type_of_elements, elements[i]);
        END_IF;

        IF NOT(result)
        THEN
        	RETURN(FALSE);
        END_IF;
	END_IF;
END_REPEAT;

RETURN(result);

END_FUNCTION; -- compatible_aggregate_type_type_and_value_type



FUNCTION compatible_final_type_and_value(typ: data_type; val: primitive_value): LOGICAL;

IF ('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.INTEGER_VALUE' IN TYPEOF(val))
THEN
	RETURN(('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.INT_TYPE'
		IN TYPEOF(typ)) OR
		(('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.NUMBER_TYPE'
		IN TYPEOF(typ))
		AND NOT('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.REAL_TYPE'
		IN TYPEOF(typ))));
END_IF;

IF ('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.REAL_VALUE' IN TYPEOF(val))
THEN
	RETURN(('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.REAL_TYPE'
		IN TYPEOF(typ)) OR
		(('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.NUMBER_TYPE'
		IN TYPEOF(typ))
		AND NOT('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.INT_TYPE'
		IN TYPEOF(typ))));
END_IF;

IF ('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.NUMBER_VALUE' IN TYPEOF(val))
THEN
	RETURN('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.NUMBER_TYPE'
		IN TYPEOF(typ));
END_IF;

IF ('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.BOOLEAN_VALUE' IN TYPEOF(val))
THEN
	RETURN('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.BOOLEAN_TYPE'
		IN TYPEOF(typ));
END_IF;

IF ('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.TRANSLATABLE_STRING_VALUE' IN
TYPEOF(val))
THEN
	RETURN('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.STRING_TYPE'
		IN TYPEOF(typ));
END_IF;

IF 'ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.ENTITY_INSTANCE_VALUE'
	IN TYPEOF(val)
THEN
	IF 'ISO13584_25_LIBRARY_IMPLICIT_SCHEMA' +
		'.UNCONTROLLED_ENTITY_INSTANCE_VALUE' IN TYPEOF(val)
	THEN
		RETURN(UNKNOWN);
	END_IF;
	IF ('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.ENTITY_INSTANCE_TYPE'
		IN TYPEOF(typ))
        AND (typ\entity_instance_type.type_name <= TYPEOF(val))
	THEN
		RETURN(TRUE);
	ELSE
		RETURN(FALSE);
	END_IF;
END_IF;

IF 'ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.DIC_CLASS_INSTANCE'
	IN TYPEOF(val)
THEN
	IF ('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.CLASS_INSTANCE_TYPE'
		IN TYPEOF(typ))
	THEN
		RETURN(compatible_class_and_class(typ\class_instance_type.domain,
			val\dic_class_instance.class_def));
	ELSE
		RETURN(FALSE);
	END_IF;
END_IF;

IF 'ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.LEVEL_SPEC_VALUE' IN TYPEOF(val)
THEN
	IF ('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.LEVEL_TYPE'
		IN TYPEOF(typ))
	THEN
		RETURN(compatible_level_type_and_instance(
			typ\level_type.levels,
			TYPEOF(typ\level_type.value_type),
			val));
	ELSE
		RETURN(FALSE);
	END_IF;
END_IF;

RETURN(FALSE);

END_FUNCTION; -- compatible_final_type_and_value



FUNCTION visible_properties(cl: class_BSU;
	prop: AGGREGATE OF property_BSU): LOGICAL;

LOCAL
	ok: BOOLEAN := TRUE;
END_LOCAL;

IF NOT EXISTS(cl)
THEN
	RETURN(UNKNOWN);
END_IF;

REPEAT i := 1 TO SIZEOF(prop);
	IF NOT(prop[i] IN compute_known_visible_properties(cl))
		THEN ok := FALSE;
	END_IF;
END_REPEAT;

IF NOT(ok) AND NOT(all_class_descriptions_reachable(cl))
	THEN RETURN(UNKNOWN);
END_IF;

IF NOT(ok) AND all_class_descriptions_reachable(cl)
	THEN RETURN(FALSE);
END_IF;

RETURN(TRUE);

END_FUNCTION; -- visible_properties


FUNCTION visible_types(cl: class_BSU;
	typ: AGGREGATE OF data_type_BSU): LOGICAL;

LOCAL
	ok: BOOLEAN := TRUE;
END_LOCAL;

IF NOT EXISTS(cl)
THEN
	RETURN(UNKNOWN);
END_IF;

REPEAT i := 1 TO SIZEOF(typ);
IF NOT(typ[i] IN compute_known_visible_data_types(cl))
	THEN ok := FALSE;
END_IF;
END_REPEAT;

IF NOT(ok) AND NOT(all_class_descriptions_reachable(cl))
	THEN RETURN(UNKNOWN);
END_IF;

IF NOT(ok) AND all_class_descriptions_reachable(cl)
	THEN RETURN(FALSE);
END_IF;

RETURN(TRUE);

END_FUNCTION; -- visible_types


FUNCTION applicable_types(cl: class_BSU;
	typ: AGGREGATE OF data_type_BSU): LOGICAL;

IF SIZEOF(typ) = 0
THEN
	RETURN(TRUE);
END_IF;

IF NOT EXISTS(cl)
THEN
	RETURN(UNKNOWN);
END_IF;

IF SIZEOF(cl.definition) = 0
THEN
	RETURN(UNKNOWN);
END_IF;

typ := typ - cl.definition[1]\class.defined_types;

IF ('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA' +
	'.A_PRIORI_SEMANTIC_RELATIONSHIP' IN TYPEOF(cl.definition[1]))
THEN
	typ := typ -
		cl.definition[1]\a_priori_semantic_relationship
		.referenced_data_types;
END_IF;

IF SIZEOF(typ) = 0
THEN
	RETURN(TRUE);
ELSE
	IF EXISTS(cl.definition[1]\class.its_superclass)
	THEN
		RETURN(applicable_types(cl.definition[1]
			\class.its_superclass, typ));
	ELSE
		RETURN(FALSE);
	END_IF;
END_IF;

END_FUNCTION; -- applicable_types


FUNCTION supplier_associated_http_files(sup_BSU: supplier_BSU):
	SET OF http_file;

LOCAL
	sup: supplier_element;
	files: SET OF http_file := [];
END_LOCAL;

IF SIZEOF(sup_BSU.definition) > 0
	THEN sup := sup_BSU.definition[1];
ELSE
	RETURN(files);
END_IF;

REPEAT i := 1 TO SIZEOF(sup.associated_items);
-- supplier_BSU_relationship
	REPEAT j := 1 TO SIZEOF(sup.associated_items[i].related_tokens);
	--supplier_related_BSU
		REPEAT k := 1 TO SIZEOF(sup.associated_items[i]
				.related_tokens[j].referenced_by); --content_item

			IF ('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.EXTERNAL_ITEM'IN
				TYPEOF(sup.associated_items[i]
				.related_tokens[j].referenced_by[k]))
			THEN
				REPEAT l := 1 TO SIZEOF(sup.associated_items[i]
					.related_tokens[j].referenced_by[k]
					\external_item.content.consists_of);
					--language_specific_content

					REPEAT m := 1 TO SIZEOF(
						sup.associated_items[i]
						.related_tokens[j].referenced_by[k]
						\external_item.content
						.consists_of[l].content_files);
						-- external_file_unit
						IF
						('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.HTTP_FILE'
							IN TYPEOF(sup.associated_items[i]
							.related_tokens[j].referenced_by[k]
							\external_item.content
							.consists_of[l].content_files[m]))
						THEN
							files := files +
							sup.associated_items[i]
							.related_tokens[j].referenced_by[k]
							\external_item.content
							.consists_of[l].content_files[m];
						END_IF; -- http_file
					END_REPEAT; -- m
				END_REPEAT; -- l
			END_IF; -- external_item
		END_REPEAT; -- k
	END_REPEAT; -- j
END_REPEAT; -- i

RETURN(files);

END_FUNCTION; -- supplier_associated_http_files




FUNCTION compliant_http_protocol_25(ef : external_file_protocol)
 								: BOOLEAN;
LOCAL
 	ok: BOOLEAN := TRUE;
END_LOCAL ;

IF (('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA'
 	+ '.HTTP_PROTOCOL' IN TYPEOF(ef)) AND
 	(ef.organisation.id = 'IAB') AND
 	(ef.organisation.name = 'Internet Architecture Board') AND
 	(ef.protocol_name = 'HTTP') AND
 	(ef.designation.preferred_name
 	= 'Hypertext Transfer Protocol') )
THEN
 	IF 'ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.TRANSLATED_LABEL'
 		IN TYPEOF(ef.designation.short_name)
 	THEN
 		REPEAT i:= 1 TO SIZEOF(ef.designation.short_name
 					\translated_label.labels);
 			IF (ef.designation.short_name\translated_label.labels[i]
 				LIKE 'RFC####&')
 			THEN
 				ok := ok AND TRUE;
 			ELSE
 				ok := OK AND FALSE;
 			END_IF;
 		END_REPEAT ;
 		RETURN(OK) ;
 	ELSE
 		IF ef.designation.short_name
 				LIKE 'RFC####&'
 		THEN
 			RETURN(TRUE);
 		ELSE
 			RETURN(FALSE);
 		END_IF;
 	END_IF ;
 ELSE
 	RETURN(FALSE);
 END_IF;

 END_FUNCTION; -- compliant_http_protocol_25

 FUNCTION compliant_8859_1_protocol_25(ef : external_file_protocol)
 			:BOOLEAN;

 IF (('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA'
 	+ '.STANDARD_DATA_PROTOCOL' IN TYPEOF(ef)) AND
 	(ef.organisation.id = 'ISO') AND
 	(ef.organisation.name
 	= 'International Organisation for Standardization') AND
 	(ef.protocol_name = 'ISO_8859_1') AND
 	(ef.designation.preferred_name
 	= 'Latin alphabet No 1') AND
 	(ef.designation.short_name = 'ISO 8859-1'))
 THEN
 	RETURN(TRUE);
 ELSE
 	RETURN(FALSE);
 END_IF;
 END_FUNCTION; -- compliant_8859_1_protocol_25

 FUNCTION compliant_external_file_protocol_25(
 				S : SET [0:?] OF external_file_protocol)
 				: BOOLEAN;

 REPEAT i := 1 TO SIZEOF(S) ;
 	IF NOT (compliant_8859_1_protocol_25 (S[i])
 			OR compliant_http_protocol_25 (S[i]))
 	THEN
 		RETURN(FALSE);
 	END_IF;
 END_REPEAT;

 RETURN(TRUE);

 END_FUNCTION; -- compliant_external_file_protocol_25

 FUNCTION is_correct_liim_25_application_value
 			(liim_id : library_iim_identification): BOOLEAN;

 IF EXISTS(liim_id\data_exchange_specification_identification.application)
 	AND
 	((liim_id\data_exchange_specification_identification.application[1]='1')
 			OR
 	 (liim_id\data_exchange_specification_identification.application[1]='2')
 			OR
 	 (liim_id\data_exchange_specification_identification.application[1]='3')
 			OR
 	 (liim_id\data_exchange_specification_identification.application[1]='4'))
 	AND
 	((liim_id\data_exchange_specification_identification.application
 		LIKE '#'))
 THEN
 	RETURN(TRUE);
 ELSE
 	RETURN(FALSE);
 END_IF;
END_FUNCTION; -- is_correct_liim_25_application_value


--RR: the whole function added, copied from ISO13584_f_m_iim_library_implicit_schema, not sure if it is allowed to interface from it.

FUNCTION data_type_non_quantitative_code_type(
	type_spec: property_or_data_type_BSU):
	SET [0:1] OF non_quantitative_code_type;
LOCAL
	res: BOOLEAN := FALSE;
	s: SET [0:1] OF non_quantitative_code_type := [];
	x: data_type;
END_LOCAL;

IF NOT EXISTS(type_spec)
THEN
	RETURN([]); -- type_spec is indeterminate
END_IF;

IF ('ISO13584_F_M_IIM_LIBRARY_IMPLICIT_SCHEMA.PROPERTY_BSU' IN
	TYPEOF(type_spec))
THEN
	IF NOT(SIZEOF(type_spec.definition) = 0)
	THEN
		x := type_spec.definition[1]\property_DET.domain;
		res := TRUE;
	END_IF;
ELSE
	IF NOT(SIZEOF(type_spec.definition) = 0)
	THEN
		x := type_spec.definition[1]\
		data_type_element.type_definition;
		res := TRUE;
	END_IF;
END_IF;

IF res
THEN
	IF ('ISO13584_F_M_IIM_LIBRARY_IMPLICIT_SCHEMA'+
		'.NON_QUANTITATIVE_CODE_TYPE') IN TYPEOF(x)
	THEN
		s := s + x;
		RETURN(s);
	END_IF;

	IF ('ISO13584_F_M_IIM_LIBRARY_IMPLICIT_SCHEMA.NAMED_TYPE')

		IN TYPEOF(x)
	THEN
		s := data_type_non_quantitative_code_type(
			x\named_type.referred_type);
		RETURN(s);
	END_IF;
END_IF;

RETURN([]);

END_FUNCTION; -- data_type_non_quantitative_code_type






(* ===================================================================================== *)
(* GLOBAL RULES																			 *)
(* Wed Jul 04 17:17:27 2001                                                              *)
(* ===================================================================================== *)

RULE single_language_assignment FOR(global_language_assignment);
WHERE
	SIZEOF(global_language_assignment) <= 1;
END_RULE; -- single_language_assignment






RULE imported_documents_are_visible_or_applicable_rule FOR(
	a_priori_semantic_relationship, document_element);
WHERE
	WR1: QUERY(rel <* a_priori_semantic_relationship
		| QUERY(doc <* rel.referenced_documents
		| QUERY(cl <* rel.referenced_classes
		| NOT visible_documents(cl, [doc])
		AND NOT applicable_documents(cl, [doc]))
		= rel.referenced_classes) = [])
		= a_priori_semantic_relationship;
END_RULE; -- imported_documents_are_visible_or_applicable_rule






RULE unique_http_directory_name_per_supplier_rule FOR(
	http_class_directory);
WHERE
	WR1: QUERY(dir_1 <* http_class_directory
		| QUERY(dir_2 <* http_class_directory
		| (dir_1.name = dir_2.name) AND
		(dir_1.class.defined_by = dir_2.class.defined_by))
		<> [dir_1] )
		= [];
END_RULE; -- unique_http_directory_name_per_supplier_rule






RULE no_http_directory_for_supplier_related_file_rule FOR(
	http_file, supplier_bsu_related_content);
WHERE
	WR1: QUERY(http_f <* http_file |
		(('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA' +
		'.SUPPLIER_BSU_RELATED_CONTENT'
		IN TYPEOF(http_f\external_file_unit.unit_of
		.content_of.content_of))
	AND EXISTS(http_f.http_directory))) = [];
END_RULE; -- no_http_directory_for_supplier_related_file_rule






RULE http_directory_refers_to_bsu_related_class_rule FOR(
	http_file, class_bsu_related_content);
WHERE
	WR1: QUERY(http_f <* http_file |
		(('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA' +
		'.CLASS_BSU_RELATED_CONTENT'
		IN TYPEOF(http_f\external_file_unit.unit_of
		.content_of.content_of))
		AND (http_f.http_directory.class <> http_f\
		external_file_unit.unit_of.content_of.content_of
		\content_item.dictionary_definition.name_scope))) = [];
END_RULE; -- http_directory_refers_to_bsu_related_class_rule






RULE http_directory_refers_to_class_extension_rule FOR(
	http_file, class_extension_external_item );
WHERE
	WR1: QUERY(http_f <* http_file |
		('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA' +
		'.CLASS_EXTENSION_EXTERNAL_ITEM'
		IN TYPEOF(http_f\external_file_unit.unit_of
		.content_of.content_of))
		AND (http_f.http_directory.class <> http_f\
		external_file_unit.unit_of.content_of.content_of
		\class_extension_external_item.belongs_to
		\content_item.dictionary_definition)) = [];
END_RULE; -- http_directory_refers_to_class_extension_rule






RULE assert_oneof_for_library_rule FOR(library);
WHERE
	WR1: QUERY(temp <* library |
		NOT('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA'
		+ '.LIBRARY_IN_STANDARD_FORMAT'
		IN TYPEOF(temp))
		AND('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA'
		+ '.DICTIONARY_IN_STANDARD_FORMAT'
		IN TYPEOF(temp))) = [];

END_RULE; -- assert_oneof_for_library_rule






RULE all_views_available_for_each_component_rule FOR (
	explicit_item_class_extension,
	explicit_functional_model_class_extension);
WHERE
	WR1: QUERY(a_model <* explicit_functional_model_class_extension |
		NOT(all_views_available_for_components(a_model\content_item
		.dictionary_definition))) = [];

END_RULE; -- all_views_available_for_each_component_rule


(*ES*)


RULE valued_properties_are_allowed_for_explicit_spec_rule FOR
	(lib_item_instance, explicit_item_class_extension);
LOCAL
	allowed_valued_properties: LOGICAL := TRUE;
END_LOCAL;

REPEAT i := 1 TO SIZEOF(lib_item_instance);
	IF SIZEOF(lib_item_instance[i]\dic_class_instance.class_def
		.referenced_by) = 1
	THEN
		IF ('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA' +
			'.EXPLICIT_ITEM_CLASS_EXTENSION' IN
			TYPEOF(lib_item_instance[i]\dic_class_instance.
			class_def.referenced_by[1]))
		THEN
			allowed_valued_properties := allowed_valued_properties
			AND (QUERY(prop <* lib_item_instance[i].properties
			| NOT((applicable_properties(
			lib_item_instance[i]\dic_class_instance
			.class_def, [prop.prop_def])))) = []);
		END_IF;
	END_IF;
END_REPEAT;

WHERE
	WR1: allowed_valued_properties;
END_RULE; -- valued_properties_are_allowed_for_explicit_spec_rule


RULE identification_properties_are_valued_for_explicit_spec_rule FOR
	(lib_item_instance, explicit_item_class_extension);
LOCAL
	valued_identification_properties: LOGICAL := TRUE;
END_LOCAL;

REPEAT i := 1 TO SIZEOF(lib_item_instance);
	IF SIZEOF(lib_item_instance[i]\dic_class_instance.
		class_def.referenced_by) = 1
	THEN
		IF ('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA' +
			'.EXPLICIT_ITEM_CLASS_EXTENSION' IN
			TYPEOF(lib_item_instance[i]\dic_class_instance.
			class_def.referenced_by[1]))
		THEN
			valued_identification_properties :=
			valued_identification_properties
			AND (QUERY(prop <*
			lib_item_instance[i]\dic_class_instance.
			class_def.referenced_by[1].instance_identification
			| NOT(prop IN collects_assigned_instance_properties
			(list_to_set(lib_item_instance[i]\
			dic_class_instance.properties)))) = []);
		END_IF;
	END_IF;
END_REPEAT;

WHERE
	WR1: valued_identification_properties;
END_RULE; --identification_properties_are_valued_for_explicit_spec_rule


RULE fm_valued_properties_are_allowed_for_explicit_spec_rule FOR(
	lib_f_model_instance,
	explicit_functional_model_class_extension);
LOCAL
	allowed_valued_properties: LOGICAL := TRUE;
END_LOCAL;

REPEAT i := 1 TO SIZEOF(lib_f_model_instance);
	IF SIZEOF(lib_f_model_instance[i]\dic_class_instance.
		class_def.referenced_by) = 1
	THEN
		IF ('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA' +
			'.EXPLICIT_FUNCTIONAL_MODEL_CLASS_EXTENSION' IN
			TYPEOF(lib_f_model_instance[i]\dic_class_instance.
			class_def.referenced_by[1]))
		THEN
			allowed_valued_properties := allowed_valued_properties
			AND(QUERY(prop <* lib_f_model_instance[i].properties
			| NOT((applicable_properties(
			lib_f_model_instance[i]\dic_class_instance.
			class_def, [prop.prop_def])))) = []);
		END_IF;
	END_IF;
END_REPEAT;

WHERE
	WR1: allowed_valued_properties;
END_RULE; -- fm_valued_properties_are_allowed_for_explicit_spec_rule


RULE fm_free_properties_are_valued_for_explicit_spec_rule FOR(
	lib_f_model_instance, explicit_functional_model_class_extension);
LOCAL
	valued_free_properties: LOGICAL := TRUE;
END_LOCAL;

REPEAT i := 1 TO SIZEOF(lib_f_model_instance);
	IF SIZEOF(lib_f_model_instance[i]\dic_class_instance.
		class_def.referenced_by) = 1
	THEN
		IF ('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA' +
			'.EXPLICIT_FUNCTIONAL_MODEL_CLASS_EXTENSION' IN
			TYPEOF(lib_f_model_instance[i]\dic_class_instance.
			class_def.referenced_by[1]))
		THEN
			valued_free_properties := valued_free_properties
			AND (QUERY(prop <* lib_f_model_instance[i]\
			dic_class_instance.class_def.referenced_by[1].
			instance_identification |
			NOT(prop IN collects_assigned_instance_properties(
			list_to_set(lib_f_model_instance[i]\
			dic_class_instance.properties)))) = []);
		END_IF;
	END_IF;
END_REPEAT;

WHERE
	WR: valued_free_properties;
END_RULE; -- fm_free_properties_are_valued_for_explicit_spec_rule


RULE representation_properties_for_model_and_view_rule
	FOR(property_DET);
WHERE
	WR1: QUERY(prop <* property_DET
		| (SIZEOF(prop.identified_by.name_scope.definition) = 1)
		AND (('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA'
		+'.FUNCTIONAL_MODEL_CLASS' IN TYPEOF(
		prop.identified_by.name_scope.definition))
		OR ('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA'
		+'.FUNCTIONAL_VIEW_CLASS' IN TYPEOF(
		prop.identified_by.name_scope.definition)))
		AND NOT('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA'
		+'.REPRESENTATION_P_DET' IN TYPEOF(prop))
		) = [];
END_RULE; -- representation_properties_for_model_and_view_rule



RULE allowed_named_type_usage_rule FOR(class);
LOCAL
	named_type_usage_allowed: LOGICAL := TRUE;
	is_app: LOGICAL;
	prop: property_bsu;
	cl: class;
	dtnt: SET[0:1] OF data_type_bsu := [];
END_LOCAL;

REPEAT i := 1 TO SIZEOF(class);
	cl := class[i];
	REPEAT j := 1 TO SIZEOF(class[i].described_by);
		prop := cl.described_by[j];
		dtnt := data_type_named_type(prop);

		IF (SIZEOF(dtnt) = 1) THEN
			is_app := applicable_types(cl.identified_by, dtnt);
			IF (NOT is_app) THEN
				named_type_usage_allowed := FALSE;
			END_IF;
		END_IF;
	END_REPEAT;
END_REPEAT;

WHERE
	WR1: named_type_usage_allowed;
END_RULE; -- allowed_named_type_usage_rule


RULE supplier_associated_items_rule FOR(supplier_element);
WHERE
	WR1: QUERY(temp <* supplier_element
		| (SIZEOF(temp.associated_items) > 1)
		OR ((SIZEOF(temp.associated_items) = 1)
		AND NOT('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.'
		+'SUPPLIER_PROGRAM_LIBRARY_RELATIONSHIP'
		IN TYPEOF(temp.associated_items)))) = [];
END_RULE; -- supplier_associated_items_rule


RULE class_associated_items_rule FOR(class);
WHERE
	WR1: QUERY(temp <* class | (SIZEOF(temp.associated_items) > 2)
		OR ((SIZEOF(temp.associated_items) = 1)
		AND NOT(('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA'
		+'.CLASS_TABLE_RELATIONSHIP' IN
		TYPEOF(temp.associated_items[1]))
		OR ('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA'
		+'.CLASS_DOCUMENT_RELATIONSHIP'
		IN TYPEOF(temp.associated_items[1]))))
		OR ((SIZEOF(temp.associated_items) = 2)
		AND NOT((('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA'
		+ '.CLASS_TABLE_RELATIONSHIP'
		IN TYPEOF(temp.associated_items[1]))
		AND ('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA'
		+'.CLASS_DOCUMENT_RELATIONSHIP'
		IN TYPEOF(temp.associated_items[2])))
		OR (('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA'
		+'.CLASS_TABLE_RELATIONSHIP'
		IN TYPEOF(temp.associated_items[2]))
		AND ('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA'
		+ '.CLASS_DOCUMENT_RELATIONSHIP'
		IN TYPEOF(temp.associated_items[1]))))))
		= [];
END_RULE; -- class_associated_items_rule


RULE assert_oneof_for_class_rule FOR(class);
WHERE
	WR1: QUERY(cl <* class |
		('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.ITEM_CLASS'
		IN TYPEOF(cl))
		AND (('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA'
		+'.ABSTRACT_FUNCTIONAL_MODEL_CLASS') IN TYPEOF(cl))) = [];
	WR2: QUERY(cl <* class |
		('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.ITEM_CLASS'
		IN TYPEOF(cl))
		AND (('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA'
		+ '.FUNCTIONAL_VIEW_CLASS') IN TYPEOF(cl))) = [];
	WR3: QUERY(cl <* class |
		(('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA'
		+ '.ABSTRACT_FUNCTIONAL_MODEL_CLASS')
		IN TYPEOF(cl))
		AND (('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA'
		+'.FUNCTIONAL_VIEW_CLASS') IN TYPEOF(cl))) = [];
END_RULE; -- assert_oneof_for_class_rule


RULE imported_properties_are_visible_or_applicable_rule FOR(
	a_priori_semantic_relationship, property_DET);
WHERE
	WR1: QUERY(rel <* a_priori_semantic_relationship
		| QUERY(prop <* rel.referenced_properties
		| QUERY(cl <* rel.referenced_classes
		| NOT visible_properties(cl, [prop])
		AND NOT applicable_properties(cl, [prop]))
		= rel.referenced_classes) = [])
		= a_priori_semantic_relationship;
END_RULE; -- imported_properties_are_visible_or_applicable_rule


RULE imported_data_types_are_visible_or_applicable_rule FOR(
	a_priori_semantic_relationship, data_type_element);
WHERE
	WR1: QUERY(rel <* a_priori_semantic_relationship
		| QUERY(typ <* rel.referenced_data_types
		| QUERY(cl <* rel.referenced_classes
		| NOT visible_types(cl, [typ])
		AND NOT applicable_types(cl, [typ]))
		= rel.referenced_classes) = [])
		= a_priori_semantic_relationship;
END_RULE; -- imported_data_types_are_visible_or_applicable_rule


RULE unique_http_file_name_per_supplier_element_rule FOR(
	supplier_BSU);
WHERE
	WR1: QUERY(sup_BSU <* supplier_BSU | (SIZEOF
		(sup_BSU.definition) = 1) AND
		(QUERY(fil_1 <* supplier_associated_http_files(sup_BSU)
		| QUERY(fil_2 <* supplier_associated_http_files(sup_BSU)
		| fil_1.http_file_name = fil_2.http_file_name)
		<> [fil_1] ) <> [] ) )
		= [];
END_RULE; -- unique_http_file_name_per_supplier_element_rule


RULE illustration_is_not_a_referenced_graphics_rule FOR(
	graphics);
WHERE
	WR1: QUERY(icon <* graphics |
		('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.REFERENCED_GRAPHICS'
		IN TYPEOF(icon))
		AND ('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.ILLUSTRATION'
		IN TYPEOF(icon))) = [];
END_RULE; -- illustration_is_not_a_referenced_graphics_rule


RULE allowed_aggregate_values FOR (property_value, aggregate_entity_instance_value,
	entity_instance_type_for_aggregate) ;
WHERE
	WR1: QUERY (prop <* property_value |
		NOT(compatible_complete_types_and_value(
				prop.prop_def, prop.its_value))) = [];
END_RULE; -- allowed_aggregate_values


RULE assert_ONEOF FOR(named_unit);
WHERE
	QUERY(u <* named_unit |
		('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.NON_SI_UNIT'
		IN TYPEOF(u)) AND
		('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.SI_UNIT' IN TYPEOF(u))
		OR ('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.NON_SI_UNIT'
		IN TYPEOF(u)) AND
		('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.CONTEXT_DEPENDENT_UNIT' IN TYPEOF(u))
		OR ('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.NON_SI_UNIT'
		IN TYPEOF(u)) AND
		('ISO13584_25_LIBRARY_IMPLICIT_SCHEMA.CONVERSION_BASED_UNIT' IN TYPEOF(u))
		) = [];
END_RULE; -- assert_ONEOF


RULE allowed_reference_to_LIIM_25_rule FOR (
 	library_iim_identification);
WHERE
	WR1: QUERY( liim_id <* library_iim_identification |
 		((liim_id\data_exchange_specification_identification.status = 'WD')
 			OR
 		(liim_id\data_exchange_specification_identification.status = 'CD')
 			OR
 		(liim_id\data_exchange_specification_identification.status = 'DIS')
 			OR
 		(liim_id\data_exchange_specification_identification.status = 'FDIS')
 			OR
 		(liim_id\data_exchange_specification_identification.status = 'IS')
 			OR
 		(liim_id\data_exchange_specification_identification.status = 'TS')
 			OR
 		(liim_id\data_exchange_specification_identification.status = 'PAS')
 			OR
 		(liim_id\data_exchange_specification_identification.status = 'ITA')
 		)
 		AND
 		(liim_id\data_exchange_specification_identification.name
 		= 'ISO_13584_25')
 		AND
 		is_correct_liim_25_application_value(liim_id)
 		AND
 		(QUERY( efp <* liim_id\data_exchange_specification_identification
 		.external_file_protocols
 		| NOT(compliant_external_file_protocol_25([efp]))
 		) = []))
 		= QUERY( liim_id <* library_iim_identification |
 		(liim_id\data_exchange_specification_identification.name =
 		'ISO_13584_25'));
END_RULE; -- allowed_reference_to_LIIM_25_rule

RULE no_global_language_with_present_translations FOR(
global_language_assignment, present_translations);
WHERE
	WR1: (SIZEOF(global_language_assignment) = 1)
	XOR (SIZEOF(present_translations) = 1);
END_RULE; -- no_global_language_with_present_translations

END_SCHEMA; -- ISO13584_25_library_implicit_schema




























