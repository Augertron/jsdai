/*
 * $Id$
 *
 * JSDAI(TM), a way to implement STEP, ISO 10303
 * Copyright (C) 1997-2008, LKSoftWare GmbH, Germany
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License
 * version 3 as published by the Free Software Foundation (AGPL v3).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * JSDAI is a registered trademark of LKSoftWare GmbH, Germany
 * This software is also available under commercial licenses.
 * See also http://www.jsdai.net/
 */

package jsdai.lang;

import java.io.File;
import java.io.FileInputStream;
import java.io.InputStream;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Set;

import jsdai.dictionary.CEntity_definition;

class PhFileReader {

  /**
   * An instance of the <code>Scanner</code> class used while reading
   * an exchange structure.
   */
  private Scanner scan;

  /**
   * The field representing a token in an exchange structure.
   */
  private final Token token;

  Reader_error_table error_table;

  /**
   * The largest number encountered in the names of instances of an exchange
   * structure being read.
   */
  private long largest_identifier = -1;

  /**
   * The level of SCOPE structure (see "ISO 10303-21::9.3 Scope structure")
   * to which instances that are currently under processing belong.
   * If <code>inside_scope = 0</code>, then instances are outside any scope.
   * If instances currently being read from the exchange structure are found
   * between lines <code>#1 = &SCOPE</code> (here a positive integer different
   * than 1 may appear) and <code>ENDSCOPE</code>, then at this moment of the
   * reading process <code>inside_scope</code> is equal to 1. Higher levels of
   * nesting are defined similarly.
   */
  private int inside_scope = 0;

  /**
   * Has value 'true' when to represent an instance currently being read the
   * external mapping form was used.
   */
  private boolean complex_entity;

  /**
   * Has value 'true' if an instance currently being read is of user defined
   * entity type.
   */
  private boolean user_defined_entity;

  /**
   * Has value 'true' when data sections are processed (and 'false' when the
   * header is processed).
   */
  private boolean data_section_processing;

  /**
   * Has value 'true' if an instance that references itself is found.
   */
  private boolean autoreference_found;

  CEntity zero_inst = null;

  /**
   * The name of an entity whose instance is expected to appear next in the exchange
   * structure. This field is used when reading the header of the structure.
   * An order in which instances appear in the header is defined in "ISO 10303-21".
   */
  private String expect_entity;

  /**
   * The name of the repository to which the exchange structure shall be imported.
   */
  private String repo_name;

  /**
   * The repository to which the exchange structure is imported.
   * This repository is returned by <code>importClearTextEncoding</code> method
   * of <code>SdaiSession</code> class.
   */
  private SdaiRepository file_repo;

  private SdaiSession active_session;

  /**
   * The name of the exchange structure.
   */
  private String phys_file;

  /**
   * The empty string.
   */
  static final String nullString = "";

  /**
   * An array used to read values of string type.
   */
  private char[] chars;

  /**
   * The field which represents information delivered by 'file_description'
   * entity instance in the header of the exchange structure.
   */
  private FILE_DESCRIPTION file_description;

  /**
   * The field which represents information delivered by a 'file_population'
   * entity instance in the header of the exchange structure.
   */
  private FILE_POPULATION file_pop;

  private FILE_POPULATION[] populations;

  private int populations_count;

  private final int POPULATIONS_ARRAY_SIZE = 16;

  /**
   * The alphabet of ISO 8859-1.
   */
  static char[] iso8859_1 = { 0x00A0, //	NO-BREAK SPACE
      0x00A1, //	INVERTED EXCLAMATION MARK
      0x00A2, //	CENT SIGN
      0x00A3, //	POUND SIGN
      0x00A4, //	CURRENCY SIGN
      0x00A5, //	YEN SIGN
      0x00A6, //	BROKEN BAR
      0x00A7, //	SECTION SIGN
      0x00A8, //	DIAERESIS
      0x00A9, //	COPYRIGHT SIGN
      0x00AA, //	FEMININE ORDINAL INDICATOR
      0x00AB, //	LEFT-POINTING DOUBLE ANGLE QUOTATION MARK
      0x00AC, //	NOT SIGN
      0x00AD, //	SOFT HYPHEN
      0x00AE, //	REGISTERED SIGN
      0x00AF, //	MACRON
      0x00B0, //	DEGREE SIGN
      0x00B1, //	PLUS-MINUS SIGN
      0x00B2, //	SUPERSCRIPT TWO
      0x00B3, //	SUPERSCRIPT THREE
      0x00B4, //	ACUTE ACCENT
      0x00B5, //	MICRO SIGN
      0x00B6, //	PILCROW SIGN
      0x00B7, //	MIDDLE DOT
      0x00B8, //	CEDILLA
      0x00B9, //	SUPERSCRIPT ONE
      0x00BA, //	MASCULINE ORDINAL INDICATOR
      0x00BB, //	RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK
      0x00BC, //	VULGAR FRACTION ONE QUARTER
      0x00BD, //	VULGAR FRACTION ONE HALF
      0x00BE, //	VULGAR FRACTION THREE QUARTERS
      0x00BF, //	INVERTED QUESTION MARK
      0x00C0, //	LATIN CAPITAL LETTER A WITH GRAVE
      0x00C1, //	LATIN CAPITAL LETTER A WITH ACUTE
      0x00C2, //	LATIN CAPITAL LETTER A WITH CIRCUMFLEX
      0x00C3, //	LATIN CAPITAL LETTER A WITH TILDE
      0x00C4, //	LATIN CAPITAL LETTER A WITH DIAERESIS
      0x00C5, //	LATIN CAPITAL LETTER A WITH RING ABOVE
      0x00C6, //	LATIN CAPITAL LETTER AE
      0x00C7, //	LATIN CAPITAL LETTER C WITH CEDILLA
      0x00C8, //	LATIN CAPITAL LETTER E WITH GRAVE
      0x00C9, //	LATIN CAPITAL LETTER E WITH ACUTE
      0x00CA, //	LATIN CAPITAL LETTER E WITH CIRCUMFLEX
      0x00CB, //	LATIN CAPITAL LETTER E WITH DIAERESIS
      0x00CC, //	LATIN CAPITAL LETTER I WITH GRAVE
      0x00CD, //	LATIN CAPITAL LETTER I WITH ACUTE
      0x00CE, //	LATIN CAPITAL LETTER I WITH CIRCUMFLEX
      0x00CF, //	LATIN CAPITAL LETTER I WITH DIAERESIS
      0x00D0, //	LATIN CAPITAL LETTER ETH (Icelandic)
      0x00D1, //	LATIN CAPITAL LETTER N WITH TILDE
      0x00D2, //	LATIN CAPITAL LETTER O WITH GRAVE
      0x00D3, //	LATIN CAPITAL LETTER O WITH ACUTE
      0x00D4, //	LATIN CAPITAL LETTER O WITH CIRCUMFLEX
      0x00D5, //	LATIN CAPITAL LETTER O WITH TILDE
      0x00D6, //	LATIN CAPITAL LETTER O WITH DIAERESIS
      0x00D7, //	MULTIPLICATION SIGN
      0x00D8, //	LATIN CAPITAL LETTER O WITH STROKE
      0x00D9, //	LATIN CAPITAL LETTER U WITH GRAVE
      0x00DA, //	LATIN CAPITAL LETTER U WITH ACUTE
      0x00DB, //	LATIN CAPITAL LETTER U WITH CIRCUMFLEX
      0x00DC, //	LATIN CAPITAL LETTER U WITH DIAERESIS
      0x00DD, //	LATIN CAPITAL LETTER Y WITH ACUTE
      0x00DE, //	LATIN CAPITAL LETTER THORN (Icelandic)
      0x00DF, //	LATIN SMALL LETTER SHARP S (German)
      0x00E0, //	LATIN SMALL LETTER A WITH GRAVE
      0x00E1, //	LATIN SMALL LETTER A WITH ACUTE
      0x00E2, //	LATIN SMALL LETTER A WITH CIRCUMFLEX
      0x00E3, //	LATIN SMALL LETTER A WITH TILDE
      0x00E4, //	LATIN SMALL LETTER A WITH DIAERESIS
      0x00E5, //	LATIN SMALL LETTER A WITH RING ABOVE
      0x00E6, //	LATIN SMALL LETTER AE
      0x00E7, //	LATIN SMALL LETTER C WITH CEDILLA
      0x00E8, //	LATIN SMALL LETTER E WITH GRAVE
      0x00E9, //	LATIN SMALL LETTER E WITH ACUTE
      0x00EA, //	LATIN SMALL LETTER E WITH CIRCUMFLEX
      0x00EB, //	LATIN SMALL LETTER E WITH DIAERESIS
      0x00EC, //	LATIN SMALL LETTER I WITH GRAVE
      0x00ED, //	LATIN SMALL LETTER I WITH ACUTE
      0x00EE, //	LATIN SMALL LETTER I WITH CIRCUMFLEX
      0x00EF, //	LATIN SMALL LETTER I WITH DIAERESIS
      0x00F0, //	LATIN SMALL LETTER ETH (Icelandic)
      0x00F1, //	LATIN SMALL LETTER N WITH TILDE
      0x00F2, //	LATIN SMALL LETTER O WITH GRAVE
      0x00F3, //	LATIN SMALL LETTER O WITH ACUTE
      0x00F4, //	LATIN SMALL LETTER O WITH CIRCUMFLEX
      0x00F5, //	LATIN SMALL LETTER O WITH TILDE
      0x00F6, //	LATIN SMALL LETTER O WITH DIAERESIS
      0x00F7, //	DIVISION SIGN
      0x00F8, //	LATIN SMALL LETTER O WITH STROKE
      0x00F9, //	LATIN SMALL LETTER U WITH GRAVE
      0x00FA, //	LATIN SMALL LETTER U WITH ACUTE
      0x00FB, //	LATIN SMALL LETTER U WITH CIRCUMFLEX
      0x00FC, //	LATIN SMALL LETTER U WITH DIAERESIS
      0x00FD, //	LATIN SMALL LETTER Y WITH ACUTE
      0x00FE, //	LATIN SMALL LETTER THORN (Icelandic)
      0x00FF //	LATIN SMALL LETTER Y WITH DIAERESIS
  };

  /**
   * The alphabet of ISO 8859-2.
   */
  static char[] iso8859_2 = { 0x00A0, //	NO-BREAK SPACE
      0x0104, //	LATIN CAPITAL LETTER A WITH OGONEK
      0x02D8, //	BREVE
      0x0141, //	LATIN CAPITAL LETTER L WITH STROKE
      0x00A4, //	CURRENCY SIGN
      0x013D, //	LATIN CAPITAL LETTER L WITH CARON
      0x015A, //	LATIN CAPITAL LETTER S WITH ACUTE
      0x00A7, //	SECTION SIGN
      0x00A8, //	DIAERESIS
      0x0160, //	LATIN CAPITAL LETTER S WITH CARON
      0x015E, //	LATIN CAPITAL LETTER S WITH CEDILLA
      0x0164, //	LATIN CAPITAL LETTER T WITH CARON
      0x0179, //	LATIN CAPITAL LETTER Z WITH ACUTE
      0x00AD, //	SOFT HYPHEN
      0x017D, //	LATIN CAPITAL LETTER Z WITH CARON
      0x017B, //	LATIN CAPITAL LETTER Z WITH DOT ABOVE
      0x00B0, //	DEGREE SIGN
      0x0105, //	LATIN SMALL LETTER A WITH OGONEK
      0x02DB, //	OGONEK
      0x0142, //	LATIN SMALL LETTER L WITH STROKE
      0x00B4, //	ACUTE ACCENT
      0x013E, //	LATIN SMALL LETTER L WITH CARON
      0x015B, //	LATIN SMALL LETTER S WITH ACUTE
      0x02C7, //	CARON
      0x00B8, //	CEDILLA
      0x0161, //	LATIN SMALL LETTER S WITH CARON
      0x015F, //	LATIN SMALL LETTER S WITH CEDILLA
      0x0165, //	LATIN SMALL LETTER T WITH CARON
      0x017A, //	LATIN SMALL LETTER Z WITH ACUTE
      0x02DD, //	DOUBLE ACUTE ACCENT
      0x017E, //	LATIN SMALL LETTER Z WITH CARON
      0x017C, //	LATIN SMALL LETTER Z WITH DOT ABOVE
      0x0154, //	LATIN CAPITAL LETTER R WITH ACUTE
      0x00C1, //	LATIN CAPITAL LETTER A WITH ACUTE
      0x00C2, //	LATIN CAPITAL LETTER A WITH CIRCUMFLEX
      0x0102, //	LATIN CAPITAL LETTER A WITH BREVE
      0x00C4, //	LATIN CAPITAL LETTER A WITH DIAERESIS
      0x0139, //	LATIN CAPITAL LETTER L WITH ACUTE
      0x0106, //	LATIN CAPITAL LETTER C WITH ACUTE
      0x00C7, //	LATIN CAPITAL LETTER C WITH CEDILLA
      0x010C, //	LATIN CAPITAL LETTER C WITH CARON
      0x00C9, //	LATIN CAPITAL LETTER E WITH ACUTE
      0x0118, //	LATIN CAPITAL LETTER E WITH OGONEK
      0x00CB, //	LATIN CAPITAL LETTER E WITH DIAERESIS
      0x011A, //	LATIN CAPITAL LETTER E WITH CARON
      0x00CD, //	LATIN CAPITAL LETTER I WITH ACUTE
      0x00CE, //	LATIN CAPITAL LETTER I WITH CIRCUMFLEX
      0x010E, //	LATIN CAPITAL LETTER D WITH CARON
      0x0110, //	LATIN CAPITAL LETTER D WITH STROKE
      0x0143, //	LATIN CAPITAL LETTER N WITH ACUTE
      0x0147, //	LATIN CAPITAL LETTER N WITH CARON
      0x00D3, //	LATIN CAPITAL LETTER O WITH ACUTE
      0x00D4, //	LATIN CAPITAL LETTER O WITH CIRCUMFLEX
      0x0150, //	LATIN CAPITAL LETTER O WITH DOUBLE ACUTE
      0x00D6, //	LATIN CAPITAL LETTER O WITH DIAERESIS
      0x00D7, //	MULTIPLICATION SIGN
      0x0158, //	LATIN CAPITAL LETTER R WITH CARON
      0x016E, //	LATIN CAPITAL LETTER U WITH RING ABOVE
      0x00DA, //	LATIN CAPITAL LETTER U WITH ACUTE
      0x0170, //	LATIN CAPITAL LETTER U WITH DOUBLE ACUTE
      0x00DC, //	LATIN CAPITAL LETTER U WITH DIAERESIS
      0x00DD, //	LATIN CAPITAL LETTER Y WITH ACUTE
      0x0162, //	LATIN CAPITAL LETTER T WITH CEDILLA
      0x00DF, //	LATIN SMALL LETTER SHARP S
      0x0155, //	LATIN SMALL LETTER R WITH ACUTE
      0x00E1, //	LATIN SMALL LETTER A WITH ACUTE
      0x00E2, //	LATIN SMALL LETTER A WITH CIRCUMFLEX
      0x0103, //	LATIN SMALL LETTER A WITH BREVE
      0x00E4, //	LATIN SMALL LETTER A WITH DIAERESIS
      0x013A, //	LATIN SMALL LETTER L WITH ACUTE
      0x0107, //	LATIN SMALL LETTER C WITH ACUTE
      0x00E7, //	LATIN SMALL LETTER C WITH CEDILLA
      0x010D, //	LATIN SMALL LETTER C WITH CARON
      0x00E9, //	LATIN SMALL LETTER E WITH ACUTE
      0x0119, //	LATIN SMALL LETTER E WITH OGONEK
      0x00EB, //	LATIN SMALL LETTER E WITH DIAERESIS
      0x011B, //	LATIN SMALL LETTER E WITH CARON
      0x00ED, //	LATIN SMALL LETTER I WITH ACUTE
      0x00EE, //	LATIN SMALL LETTER I WITH CIRCUMFLEX
      0x010F, //	LATIN SMALL LETTER D WITH CARON
      0x0111, //	LATIN SMALL LETTER D WITH STROKE
      0x0144, //	LATIN SMALL LETTER N WITH ACUTE
      0x0148, //	LATIN SMALL LETTER N WITH CARON
      0x00F3, //	LATIN SMALL LETTER O WITH ACUTE
      0x00F4, //	LATIN SMALL LETTER O WITH CIRCUMFLEX
      0x0151, //	LATIN SMALL LETTER O WITH DOUBLE ACUTE
      0x00F6, //	LATIN SMALL LETTER O WITH DIAERESIS
      0x00F7, //	DIVISION SIGN
      0x0159, //	LATIN SMALL LETTER R WITH CARON
      0x016F, //	LATIN SMALL LETTER U WITH RING ABOVE
      0x00FA, //	LATIN SMALL LETTER U WITH ACUTE
      0x0171, //	LATIN SMALL LETTER U WITH DOUBLE ACUTE
      0x00FC, //	LATIN SMALL LETTER U WITH DIAERESIS
      0x00FD, //	LATIN SMALL LETTER Y WITH ACUTE
      0x0163, //	LATIN SMALL LETTER T WITH CEDILLA
      0x02D9 //	DOT ABOVE
  };

  /**
   * The alphabet of ISO 8859-3.
   */
  static char[] iso8859_3 = { 0x00A0, //	NO-BREAK SPACE
      0x0126, //	LATIN CAPITAL LETTER H WITH STROKE
      0x02D8, //	BREVE
      0x00A3, //	POUND SIGN
      0x00A4, //	CURRENCY SIGN
      0x0000, //	DOES NOT EXIST
      0x0124, //	LATIN CAPITAL LETTER H WITH CIRCUMFLEX
      0x00A7, //	SECTION SIGN
      0x00A8, //	DIAERESIS
      0x0130, //	LATIN CAPITAL LETTER I WITH DOT ABOVE
      0x015E, //	LATIN CAPITAL LETTER S WITH CEDILLA
      0x011E, //	LATIN CAPITAL LETTER G WITH BREVE
      0x0134, //	LATIN CAPITAL LETTER J WITH CIRCUMFLEX
      0x00AD, //	SOFT HYPHEN
      0x0000, //	DOES NOT EXIST
      0x017B, //	LATIN CAPITAL LETTER Z WITH DOT ABOVE
      0x00B0, //	DEGREE SIGN
      0x0127, //	LATIN SMALL LETTER H WITH STROKE
      0x00B2, //	SUPERSCRIPT TWO
      0x00B3, //	SUPERSCRIPT THREE
      0x00B4, //	ACUTE ACCENT
      0x00B5, //	MICRO SIGN
      0x0125, //	LATIN SMALL LETTER H WITH CIRCUMFLEX
      0x00B7, //	MIDDLE DOT
      0x00B8, //	CEDILLA
      0x0131, //	LATIN SMALL LETTER DOTLESS I
      0x015F, //	LATIN SMALL LETTER S WITH CEDILLA
      0x011F, //	LATIN SMALL LETTER G WITH BREVE
      0x0135, //	LATIN SMALL LETTER J WITH CIRCUMFLEX
      0x00BD, //	VULGAR FRACTION ONE HALF
      0x0000, //	DOES NOT EXIST
      0x017C, //	LATIN SMALL LETTER Z WITH DOT ABOVE
      0x00C0, //	LATIN CAPITAL LETTER A WITH GRAVE
      0x00C1, //	LATIN CAPITAL LETTER A WITH ACUTE
      0x00C2, //	LATIN CAPITAL LETTER A WITH CIRCUMFLEX
      0x0000, //	DOES NOT EXIST
      0x00C4, //	LATIN CAPITAL LETTER A WITH DIAERESIS
      0x010A, //	LATIN CAPITAL LETTER C WITH DOT ABOVE
      0x0108, //	LATIN CAPITAL LETTER C WITH CIRCUMFLEX
      0x00C7, //	LATIN CAPITAL LETTER C WITH CEDILLA
      0x00C8, //	LATIN CAPITAL LETTER E WITH GRAVE
      0x00C9, //	LATIN CAPITAL LETTER E WITH ACUTE
      0x00CA, //	LATIN CAPITAL LETTER E WITH CIRCUMFLEX
      0x00CB, //	LATIN CAPITAL LETTER E WITH DIAERESIS
      0x00CC, //	LATIN CAPITAL LETTER I WITH GRAVE
      0x00CD, //	LATIN CAPITAL LETTER I WITH ACUTE
      0x00CE, //	LATIN CAPITAL LETTER I WITH CIRCUMFLEX
      0x00CF, //	LATIN CAPITAL LETTER I WITH DIAERESIS
      0x0000, //	DOES NOT EXIST
      0x00D1, //	LATIN CAPITAL LETTER N WITH TILDE
      0x00D2, //	LATIN CAPITAL LETTER O WITH GRAVE
      0x00D3, //	LATIN CAPITAL LETTER O WITH ACUTE
      0x00D4, //	LATIN CAPITAL LETTER O WITH CIRCUMFLEX
      0x0120, //	LATIN CAPITAL LETTER G WITH DOT ABOVE
      0x00D6, //	LATIN CAPITAL LETTER O WITH DIAERESIS
      0x00D7, //	MULTIPLICATION SIGN
      0x011C, //	LATIN CAPITAL LETTER G WITH CIRCUMFLEX
      0x00D9, //	LATIN CAPITAL LETTER U WITH GRAVE
      0x00DA, //	LATIN CAPITAL LETTER U WITH ACUTE
      0x00DB, //	LATIN CAPITAL LETTER U WITH CIRCUMFLEX
      0x00DC, //	LATIN CAPITAL LETTER U WITH DIAERESIS
      0x016C, //	LATIN CAPITAL LETTER U WITH BREVE
      0x015C, //	LATIN CAPITAL LETTER S WITH CIRCUMFLEX
      0x00DF, //	LATIN SMALL LETTER SHARP S
      0x00E0, //	LATIN SMALL LETTER A WITH GRAVE
      0x00E1, //	LATIN SMALL LETTER A WITH ACUTE
      0x00E2, //	LATIN SMALL LETTER A WITH CIRCUMFLEX
      0x0000, //	DOES NOT EXIST
      0x00E4, //	LATIN SMALL LETTER A WITH DIAERESIS
      0x010B, //	LATIN SMALL LETTER C WITH DOT ABOVE
      0x0109, //	LATIN SMALL LETTER C WITH CIRCUMFLEX
      0x00E7, //	LATIN SMALL LETTER C WITH CEDILLA
      0x00E8, //	LATIN SMALL LETTER E WITH GRAVE
      0x00E9, //	LATIN SMALL LETTER E WITH ACUTE
      0x00EA, //	LATIN SMALL LETTER E WITH CIRCUMFLEX
      0x00EB, //	LATIN SMALL LETTER E WITH DIAERESIS
      0x00EC, //	LATIN SMALL LETTER I WITH GRAVE
      0x00ED, //	LATIN SMALL LETTER I WITH ACUTE
      0x00EE, //	LATIN SMALL LETTER I WITH CIRCUMFLEX
      0x00EF, //	LATIN SMALL LETTER I WITH DIAERESIS
      0x0000, //	DOES NOT EXIST
      0x00F1, //	LATIN SMALL LETTER N WITH TILDE
      0x00F2, //	LATIN SMALL LETTER O WITH GRAVE
      0x00F3, //	LATIN SMALL LETTER O WITH ACUTE
      0x00F4, //	LATIN SMALL LETTER O WITH CIRCUMFLEX
      0x0121, //	LATIN SMALL LETTER G WITH DOT ABOVE
      0x00F6, //	LATIN SMALL LETTER O WITH DIAERESIS
      0x00F7, //	DIVISION SIGN
      0x011D, //	LATIN SMALL LETTER G WITH CIRCUMFLEX
      0x00F9, //	LATIN SMALL LETTER U WITH GRAVE
      0x00FA, //	LATIN SMALL LETTER U WITH ACUTE
      0x00FB, //	LATIN SMALL LETTER U WITH CIRCUMFLEX
      0x00FC, //	LATIN SMALL LETTER U WITH DIAERESIS
      0x016D, //	LATIN SMALL LETTER U WITH BREVE
      0x015D, //	LATIN SMALL LETTER S WITH CIRCUMFLEX
      0x02D9 //	DOT ABOVE
  };

  /**
   * The alphabet of ISO 8859-4.
   */
  static char[] iso8859_4 = { 0x00A0, //	NO-BREAK SPACE
      0x0104, //	LATIN CAPITAL LETTER A WITH OGONEK
      0x0138, //	LATIN SMALL LETTER KRA
      0x0156, //	LATIN CAPITAL LETTER R WITH CEDILLA
      0x00A4, //	CURRENCY SIGN
      0x0128, //	LATIN CAPITAL LETTER I WITH TILDE
      0x013B, //	LATIN CAPITAL LETTER L WITH CEDILLA
      0x00A7, //	SECTION SIGN
      0x00A8, //	DIAERESIS
      0x0160, //	LATIN CAPITAL LETTER S WITH CARON
      0x0112, //	LATIN CAPITAL LETTER E WITH MACRON
      0x0122, //	LATIN CAPITAL LETTER G WITH CEDILLA
      0x0166, //	LATIN CAPITAL LETTER T WITH STROKE
      0x00AD, //	SOFT HYPHEN
      0x017D, //	LATIN CAPITAL LETTER Z WITH CARON
      0x00AF, //	MACRON
      0x00B0, //	DEGREE SIGN
      0x0105, //	LATIN SMALL LETTER A WITH OGONEK
      0x02DB, //	OGONEK
      0x0157, //	LATIN SMALL LETTER R WITH CEDILLA
      0x00B4, //	ACUTE ACCENT
      0x0129, //	LATIN SMALL LETTER I WITH TILDE
      0x013C, //	LATIN SMALL LETTER L WITH CEDILLA
      0x02C7, //	CARON
      0x00B8, //	CEDILLA
      0x0161, //	LATIN SMALL LETTER S WITH CARON
      0x0113, //	LATIN SMALL LETTER E WITH MACRON
      0x0123, //	LATIN SMALL LETTER G WITH CEDILLA
      0x0167, //	LATIN SMALL LETTER T WITH STROKE
      0x014A, //	LATIN CAPITAL LETTER ENG
      0x017E, //	LATIN SMALL LETTER Z WITH CARON
      0x014B, //	LATIN SMALL LETTER ENG
      0x0100, //	LATIN CAPITAL LETTER A WITH MACRON
      0x00C1, //	LATIN CAPITAL LETTER A WITH ACUTE
      0x00C2, //	LATIN CAPITAL LETTER A WITH CIRCUMFLEX
      0x00C3, //	LATIN CAPITAL LETTER A WITH TILDE
      0x00C4, //	LATIN CAPITAL LETTER A WITH DIAERESIS
      0x00C5, //	LATIN CAPITAL LETTER A WITH RING ABOVE
      0x00C6, //	LATIN CAPITAL LETTER AE
      0x012E, //	LATIN CAPITAL LETTER I WITH OGONEK
      0x010C, //	LATIN CAPITAL LETTER C WITH CARON
      0x00C9, //	LATIN CAPITAL LETTER E WITH ACUTE
      0x0118, //	LATIN CAPITAL LETTER E WITH OGONEK
      0x00CB, //	LATIN CAPITAL LETTER E WITH DIAERESIS
      0x0116, //	LATIN CAPITAL LETTER E WITH DOT ABOVE
      0x00CD, //	LATIN CAPITAL LETTER I WITH ACUTE
      0x00CE, //	LATIN CAPITAL LETTER I WITH CIRCUMFLEX
      0x012A, //	LATIN CAPITAL LETTER I WITH MACRON
      0x0110, //	LATIN CAPITAL LETTER D WITH STROKE
      0x0145, //	LATIN CAPITAL LETTER N WITH CEDILLA
      0x014C, //	LATIN CAPITAL LETTER O WITH MACRON
      0x0136, //	LATIN CAPITAL LETTER K WITH CEDILLA
      0x00D4, //	LATIN CAPITAL LETTER O WITH CIRCUMFLEX
      0x00D5, //	LATIN CAPITAL LETTER O WITH TILDE
      0x00D6, //	LATIN CAPITAL LETTER O WITH DIAERESIS
      0x00D7, //	MULTIPLICATION SIGN
      0x00D8, //	LATIN CAPITAL LETTER O WITH STROKE
      0x0172, //	LATIN CAPITAL LETTER U WITH OGONEK
      0x00DA, //	LATIN CAPITAL LETTER U WITH ACUTE
      0x00DB, //	LATIN CAPITAL LETTER U WITH CIRCUMFLEX
      0x00DC, //	LATIN CAPITAL LETTER U WITH DIAERESIS
      0x0168, //	LATIN CAPITAL LETTER U WITH TILDE
      0x016A, //	LATIN CAPITAL LETTER U WITH MACRON
      0x00DF, //	LATIN SMALL LETTER SHARP S
      0x0101, //	LATIN SMALL LETTER A WITH MACRON
      0x00E1, //	LATIN SMALL LETTER A WITH ACUTE
      0x00E2, //	LATIN SMALL LETTER A WITH CIRCUMFLEX
      0x00E3, //	LATIN SMALL LETTER A WITH TILDE
      0x00E4, //	LATIN SMALL LETTER A WITH DIAERESIS
      0x00E5, //	LATIN SMALL LETTER A WITH RING ABOVE
      0x00E6, //	LATIN SMALL LETTER AE
      0x012F, //	LATIN SMALL LETTER I WITH OGONEK
      0x010D, //	LATIN SMALL LETTER C WITH CARON
      0x00E9, //	LATIN SMALL LETTER E WITH ACUTE
      0x0119, //	LATIN SMALL LETTER E WITH OGONEK
      0x00EB, //	LATIN SMALL LETTER E WITH DIAERESIS
      0x0117, //	LATIN SMALL LETTER E WITH DOT ABOVE
      0x00ED, //	LATIN SMALL LETTER I WITH ACUTE
      0x00EE, //	LATIN SMALL LETTER I WITH CIRCUMFLEX
      0x012B, //	LATIN SMALL LETTER I WITH MACRON
      0x0111, //	LATIN SMALL LETTER D WITH STROKE
      0x0146, //	LATIN SMALL LETTER N WITH CEDILLA
      0x014D, //	LATIN SMALL LETTER O WITH MACRON
      0x0137, //	LATIN SMALL LETTER K WITH CEDILLA
      0x00F4, //	LATIN SMALL LETTER O WITH CIRCUMFLEX
      0x00F5, //	LATIN SMALL LETTER O WITH TILDE
      0x00F6, //	LATIN SMALL LETTER O WITH DIAERESIS
      0x00F7, //	DIVISION SIGN
      0x00F8, //	LATIN SMALL LETTER O WITH STROKE
      0x0173, //	LATIN SMALL LETTER U WITH OGONEK
      0x00FA, //	LATIN SMALL LETTER U WITH ACUTE
      0x00FB, //	LATIN SMALL LETTER U WITH CIRCUMFLEX
      0x00FC, //	LATIN SMALL LETTER U WITH DIAERESIS
      0x0169, //	LATIN SMALL LETTER U WITH TILDE
      0x016B, //	LATIN SMALL LETTER U WITH MACRON
      0x02D9, //	DOT ABOVE
  };

  /**
   * The alphabet of ISO 8859-5.
   */
  static char[] iso8859_5 = { 0x00A0, //	NO-BREAK SPACE
      0x0401, //	CYRILLIC CAPITAL LETTER IO
      0x0402, //	CYRILLIC CAPITAL LETTER DJE
      0x0403, //	CYRILLIC CAPITAL LETTER GJE
      0x0404, //	CYRILLIC CAPITAL LETTER UKRAINIAN IE
      0x0405, //	CYRILLIC CAPITAL LETTER DZE
      0x0406, //	CYRILLIC CAPITAL LETTER BYELORUSSIAN-UKRAINIAN I
      0x0407, //	CYRILLIC CAPITAL LETTER YI
      0x0408, //	CYRILLIC CAPITAL LETTER JE
      0x0409, //	CYRILLIC CAPITAL LETTER LJE
      0x040A, //	CYRILLIC CAPITAL LETTER NJE
      0x040B, //	CYRILLIC CAPITAL LETTER TSHE
      0x040C, //	CYRILLIC CAPITAL LETTER KJE
      0x00AD, //	SOFT HYPHEN
      0x040E, //	CYRILLIC CAPITAL LETTER SHORT U
      0x040F, //	CYRILLIC CAPITAL LETTER DZHE
      0x0410, //	CYRILLIC CAPITAL LETTER A
      0x0411, //	CYRILLIC CAPITAL LETTER BE
      0x0412, //	CYRILLIC CAPITAL LETTER VE
      0x0413, //	CYRILLIC CAPITAL LETTER GHE
      0x0414, //	CYRILLIC CAPITAL LETTER DE
      0x0415, //	CYRILLIC CAPITAL LETTER IE
      0x0416, //	CYRILLIC CAPITAL LETTER ZHE
      0x0417, //	CYRILLIC CAPITAL LETTER ZE
      0x0418, //	CYRILLIC CAPITAL LETTER I
      0x0419, //	CYRILLIC CAPITAL LETTER SHORT I
      0x041A, //	CYRILLIC CAPITAL LETTER KA
      0x041B, //	CYRILLIC CAPITAL LETTER EL
      0x041C, //	CYRILLIC CAPITAL LETTER EM
      0x041D, //	CYRILLIC CAPITAL LETTER EN
      0x041E, //	CYRILLIC CAPITAL LETTER O
      0x041F, //	CYRILLIC CAPITAL LETTER PE
      0x0420, //	CYRILLIC CAPITAL LETTER ER
      0x0421, //	CYRILLIC CAPITAL LETTER ES
      0x0422, //	CYRILLIC CAPITAL LETTER TE
      0x0423, //	CYRILLIC CAPITAL LETTER U
      0x0424, //	CYRILLIC CAPITAL LETTER EF
      0x0425, //	CYRILLIC CAPITAL LETTER HA
      0x0426, //	CYRILLIC CAPITAL LETTER TSE
      0x0427, //	CYRILLIC CAPITAL LETTER CHE
      0x0428, //	CYRILLIC CAPITAL LETTER SHA
      0x0429, //	CYRILLIC CAPITAL LETTER SHCHA
      0x042A, //	CYRILLIC CAPITAL LETTER HARD SIGN
      0x042B, //	CYRILLIC CAPITAL LETTER YERU
      0x042C, //	CYRILLIC CAPITAL LETTER SOFT SIGN
      0x042D, //	CYRILLIC CAPITAL LETTER E
      0x042E, //	CYRILLIC CAPITAL LETTER YU
      0x042F, //	CYRILLIC CAPITAL LETTER YA
      0x0430, //	CYRILLIC SMALL LETTER A
      0x0431, //	CYRILLIC SMALL LETTER BE
      0x0432, //	CYRILLIC SMALL LETTER VE
      0x0433, //	CYRILLIC SMALL LETTER GHE
      0x0434, //	CYRILLIC SMALL LETTER DE
      0x0435, //	CYRILLIC SMALL LETTER IE
      0x0436, //	CYRILLIC SMALL LETTER ZHE
      0x0437, //	CYRILLIC SMALL LETTER ZE
      0x0438, //	CYRILLIC SMALL LETTER I
      0x0439, //	CYRILLIC SMALL LETTER SHORT I
      0x043A, //	CYRILLIC SMALL LETTER KA
      0x043B, //	CYRILLIC SMALL LETTER EL
      0x043C, //	CYRILLIC SMALL LETTER EM
      0x043D, //	CYRILLIC SMALL LETTER EN
      0x043E, //	CYRILLIC SMALL LETTER O
      0x043F, //	CYRILLIC SMALL LETTER PE
      0x0440, //	CYRILLIC SMALL LETTER ER
      0x0441, //	CYRILLIC SMALL LETTER ES
      0x0442, //	CYRILLIC SMALL LETTER TE
      0x0443, //	CYRILLIC SMALL LETTER U
      0x0444, //	CYRILLIC SMALL LETTER EF
      0x0445, //	CYRILLIC SMALL LETTER HA
      0x0446, //	CYRILLIC SMALL LETTER TSE
      0x0447, //	CYRILLIC SMALL LETTER CHE
      0x0448, //	CYRILLIC SMALL LETTER SHA
      0x0449, //	CYRILLIC SMALL LETTER SHCHA
      0x044A, //	CYRILLIC SMALL LETTER HARD SIGN
      0x044B, //	CYRILLIC SMALL LETTER YERU
      0x044C, //	CYRILLIC SMALL LETTER SOFT SIGN
      0x044D, //	CYRILLIC SMALL LETTER E
      0x044E, //	CYRILLIC SMALL LETTER YU
      0x044F, //	CYRILLIC SMALL LETTER YA
      0x2116, //	NUMERO SIGN
      0x0451, //	CYRILLIC SMALL LETTER IO
      0x0452, //	CYRILLIC SMALL LETTER DJE
      0x0453, //	CYRILLIC SMALL LETTER GJE
      0x0454, //	CYRILLIC SMALL LETTER UKRAINIAN IE
      0x0455, //	CYRILLIC SMALL LETTER DZE
      0x0456, //	CYRILLIC SMALL LETTER BYELORUSSIAN-UKRAINIAN I
      0x0457, //	CYRILLIC SMALL LETTER YI
      0x0458, //	CYRILLIC SMALL LETTER JE
      0x0459, //	CYRILLIC SMALL LETTER LJE
      0x045A, //	CYRILLIC SMALL LETTER NJE
      0x045B, //	CYRILLIC SMALL LETTER TSHE
      0x045C, //	CYRILLIC SMALL LETTER KJE
      0x00A7, //	SECTION SIGN
      0x045E, //	CYRILLIC SMALL LETTER SHORT U
      0x045F //	CYRILLIC SMALL LETTER DZHE
  };

  /**
   * The alphabet of ISO 8859-6.
   */
  static char[] iso8859_6 = { 0x00A0, //	NO-BREAK SPACE
      0x0000, //	DOES NOT EXIST
      0x0000, //	DOES NOT EXIST
      0x0000, //	DOES NOT EXIST
      0x00A4, //	CURRENCY SIGN
      0x0000, //	DOES NOT EXIST
      0x0000, //	DOES NOT EXIST
      0x0000, //	DOES NOT EXIST
      0x0000, //	DOES NOT EXIST
      0x0000, //	DOES NOT EXIST
      0x0000, //	DOES NOT EXIST
      0x0000, //	DOES NOT EXIST
      0x060C, //	ARABIC COMMA
      0x00AD, //	SOFT HYPHEN
      0x0000, //	DOES NOT EXIST
      0x0000, //	DOES NOT EXIST
      0x0000, //	DOES NOT EXIST
      0x0000, //	DOES NOT EXIST
      0x0000, //	DOES NOT EXIST
      0x0000, //	DOES NOT EXIST
      0x0000, //	DOES NOT EXIST
      0x0000, //	DOES NOT EXIST
      0x0000, //	DOES NOT EXIST
      0x0000, //	DOES NOT EXIST
      0x0000, //	DOES NOT EXIST
      0x0000, //	DOES NOT EXIST
      0x0000, //	DOES NOT EXIST
      0x061B, //	ARABIC SEMICOLON
      0x0000, //	DOES NOT EXIST
      0x0000, //	DOES NOT EXIST
      0x0000, //	DOES NOT EXIST
      0x061F, //	ARABIC QUESTION MARK
      0x0000, //	DOES NOT EXIST
      0x0621, //	ARABIC LETTER HAMZA
      0x0622, //	ARABIC LETTER ALEF WITH MADDA ABOVE
      0x0623, //	ARABIC LETTER ALEF WITH HAMZA ABOVE
      0x0624, //	ARABIC LETTER WAW WITH HAMZA ABOVE
      0x0625, //	ARABIC LETTER ALEF WITH HAMZA BELOW
      0x0626, //	ARABIC LETTER YEH WITH HAMZA ABOVE
      0x0627, //	ARABIC LETTER ALEF
      0x0628, //	ARABIC LETTER BEH
      0x0629, //	ARABIC LETTER TEH MARBUTA
      0x062A, //	ARABIC LETTER TEH
      0x062B, //	ARABIC LETTER THEH
      0x062C, //	ARABIC LETTER JEEM
      0x062D, //	ARABIC LETTER HAH
      0x062E, //	ARABIC LETTER KHAH
      0x062F, //	ARABIC LETTER DAL
      0x0630, //	ARABIC LETTER THAL
      0x0631, //	ARABIC LETTER REH
      0x0632, //	ARABIC LETTER ZAIN
      0x0633, //	ARABIC LETTER SEEN
      0x0634, //	ARABIC LETTER SHEEN
      0x0635, //	ARABIC LETTER SAD
      0x0636, //	ARABIC LETTER DAD
      0x0637, //	ARABIC LETTER TAH
      0x0638, //	ARABIC LETTER ZAH
      0x0639, //	ARABIC LETTER AIN
      0x063A, //	ARABIC LETTER GHAIN
      0x0000, //	DOES NOT EXIST
      0x0000, //	DOES NOT EXIST
      0x0000, //	DOES NOT EXIST
      0x0000, //	DOES NOT EXIST
      0x0000, //	DOES NOT EXIST
      0x0640, //	ARABIC TATWEEL
      0x0641, //	ARABIC LETTER FEH
      0x0642, //	ARABIC LETTER QAF
      0x0643, //	ARABIC LETTER KAF
      0x0644, //	ARABIC LETTER LAM
      0x0645, //	ARABIC LETTER MEEM
      0x0646, //	ARABIC LETTER NOON
      0x0647, //	ARABIC LETTER HEH
      0x0648, //	ARABIC LETTER WAW
      0x0649, //	ARABIC LETTER ALEF MAKSURA
      0x064A, //	ARABIC LETTER YEH
      0x064B, //	ARABIC FATHATAN
      0x064C, //	ARABIC DAMMATAN
      0x064D, //	ARABIC KASRATAN
      0x064E, //	ARABIC FATHA
      0x064F, //	ARABIC DAMMA
      0x0650, //	ARABIC KASRA
      0x0651, //	ARABIC SHADDA
      0x0652, //	ARABIC SUKUN
      0x0000, //	DOES NOT EXIST
      0x0000, //	DOES NOT EXIST
      0x0000, //	DOES NOT EXIST
      0x0000, //	DOES NOT EXIST
      0x0000, //	DOES NOT EXIST
      0x0000, //	DOES NOT EXIST
      0x0000, //	DOES NOT EXIST
      0x0000, //	DOES NOT EXIST
      0x0000, //	DOES NOT EXIST
      0x0000, //	DOES NOT EXIST
      0x0000, //	DOES NOT EXIST
      0x0000, //	DOES NOT EXIST
      0x0000 //	DOES NOT EXIST
  };

  /**
   * The alphabet of ISO 8859-7.
   */
  static char[] iso8859_7 = { 0x00A0, //	NO-BREAK SPACE
      0x2018, //	LEFT SINGLE QUOTATION MARK
      0x2019, //	RIGHT SINGLE QUOTATION MARK
      0x00A3, //	POUND SIGN
      0x0000, //	DOES NOT EXIST
      0x0000, //	DOES NOT EXIST
      0x00A6, //	BROKEN BAR
      0x00A7, //	SECTION SIGN
      0x00A8, //	DIAERESIS
      0x00A9, //	COPYRIGHT SIGN
      0x0000, //	DOES NOT EXIST
      0x00AB, //	LEFT-POINTING DOUBLE ANGLE QUOTATION MARK
      0x00AC, //	NOT SIGN
      0x00AD, //	SOFT HYPHEN
      0x0000, //	DOES NOT EXIST
      0x2015, //	HORIZONTAL BAR
      0x00B0, //	DEGREE SIGN
      0x00B1, //	PLUS-MINUS SIGN
      0x00B2, //	SUPERSCRIPT TWO
      0x00B3, //	SUPERSCRIPT THREE
      0x0384, //	GREEK TONOS
      0x0385, //	GREEK DIALYTIKA TONOS
      0x0386, //	GREEK CAPITAL LETTER ALPHA WITH TONOS
      0x00B7, //	MIDDLE DOT
      0x0388, //	GREEK CAPITAL LETTER EPSILON WITH TONOS
      0x0389, //	GREEK CAPITAL LETTER ETA WITH TONOS
      0x038A, //	GREEK CAPITAL LETTER IOTA WITH TONOS
      0x00BB, //	RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK
      0x038C, //	GREEK CAPITAL LETTER OMICRON WITH TONOS
      0x00BD, //	VULGAR FRACTION ONE HALF
      0x038E, //	GREEK CAPITAL LETTER UPSILON WITH TONOS
      0x038F, //	GREEK CAPITAL LETTER OMEGA WITH TONOS
      0x0390, //	GREEK SMALL LETTER IOTA WITH DIALYTIKA AND TONOS
      0x0391, //	GREEK CAPITAL LETTER ALPHA
      0x0392, //	GREEK CAPITAL LETTER BETA
      0x0393, //	GREEK CAPITAL LETTER GAMMA
      0x0394, //	GREEK CAPITAL LETTER DELTA
      0x0395, //	GREEK CAPITAL LETTER EPSILON
      0x0396, //	GREEK CAPITAL LETTER ZETA
      0x0397, //	GREEK CAPITAL LETTER ETA
      0x0398, //	GREEK CAPITAL LETTER THETA
      0x0399, //	GREEK CAPITAL LETTER IOTA
      0x039A, //	GREEK CAPITAL LETTER KAPPA
      0x039B, //	GREEK CAPITAL LETTER LAMDA
      0x039C, //	GREEK CAPITAL LETTER MU
      0x039D, //	GREEK CAPITAL LETTER NU
      0x039E, //	GREEK CAPITAL LETTER XI
      0x039F, //	GREEK CAPITAL LETTER OMICRON
      0x03A0, //	GREEK CAPITAL LETTER PI
      0x03A1, //	GREEK CAPITAL LETTER RHO
      0x0000, //	DOES NOT EXIST
      0x03A3, //	GREEK CAPITAL LETTER SIGMA
      0x03A4, //	GREEK CAPITAL LETTER TAU
      0x03A5, //	GREEK CAPITAL LETTER UPSILON
      0x03A6, //	GREEK CAPITAL LETTER PHI
      0x03A7, //	GREEK CAPITAL LETTER CHI
      0x03A8, //	GREEK CAPITAL LETTER PSI
      0x03A9, //	GREEK CAPITAL LETTER OMEGA
      0x03AA, //	GREEK CAPITAL LETTER IOTA WITH DIALYTIKA
      0x03AB, //	GREEK CAPITAL LETTER UPSILON WITH DIALYTIKA
      0x03AC, //	GREEK SMALL LETTER ALPHA WITH TONOS
      0x03AD, //	GREEK SMALL LETTER EPSILON WITH TONOS
      0x03AE, //	GREEK SMALL LETTER ETA WITH TONOS
      0x03AF, //	GREEK SMALL LETTER IOTA WITH TONOS
      0x03B0, //	GREEK SMALL LETTER UPSILON WITH DIALYTIKA AND TONOS
      0x03B1, //	GREEK SMALL LETTER ALPHA
      0x03B2, //	GREEK SMALL LETTER BETA
      0x03B3, //	GREEK SMALL LETTER GAMMA
      0x03B4, //	GREEK SMALL LETTER DELTA
      0x03B5, //	GREEK SMALL LETTER EPSILON
      0x03B6, //	GREEK SMALL LETTER ZETA
      0x03B7, //	GREEK SMALL LETTER ETA
      0x03B8, //	GREEK SMALL LETTER THETA
      0x03B9, //	GREEK SMALL LETTER IOTA
      0x03BA, //	GREEK SMALL LETTER KAPPA
      0x03BB, //	GREEK SMALL LETTER LAMDA
      0x03BC, //	GREEK SMALL LETTER MU
      0x03BD, //	GREEK SMALL LETTER NU
      0x03BE, //	GREEK SMALL LETTER XI
      0x03BF, //	GREEK SMALL LETTER OMICRON
      0x03C0, //	GREEK SMALL LETTER PI
      0x03C1, //	GREEK SMALL LETTER RHO
      0x03C2, //	GREEK SMALL LETTER FINAL SIGMA
      0x03C3, //	GREEK SMALL LETTER SIGMA
      0x03C4, //	GREEK SMALL LETTER TAU
      0x03C5, //	GREEK SMALL LETTER UPSILON
      0x03C6, //	GREEK SMALL LETTER PHI
      0x03C7, //	GREEK SMALL LETTER CHI
      0x03C8, //	GREEK SMALL LETTER PSI
      0x03C9, //	GREEK SMALL LETTER OMEGA
      0x03CA, //	GREEK SMALL LETTER IOTA WITH DIALYTIKA
      0x03CB, //	GREEK SMALL LETTER UPSILON WITH DIALYTIKA
      0x03CC, //	GREEK SMALL LETTER OMICRON WITH TONOS
      0x03CD, //	GREEK SMALL LETTER UPSILON WITH TONOS
      0x03CE, //	GREEK SMALL LETTER OMEGA WITH TONOS
      0x0000 //	DOES NOT EXIST
  };

  /**
   * The alphabet of ISO 8859-8.
   */
  static char[] iso8859_8 = { 0x00A0, //	NO-BREAK SPACE
      0x0000, //	DOES NOT EXIST
      0x00A2, //	CENT SIGN
      0x00A3, //	POUND SIGN
      0x00A4, //	CURRENCY SIGN
      0x00A5, //	YEN SIGN
      0x00A6, //	BROKEN BAR
      0x00A7, //	SECTION SIGN
      0x00A8, //	DIAERESIS
      0x00A9, //	COPYRIGHT SIGN
      0x00D7, //	MULTIPLICATION SIGN
      0x00AB, //	LEFT-POINTING DOUBLE ANGLE QUOTATION MARK
      0x00AC, //	NOT SIGN
      0x00AD, //	SOFT HYPHEN
      0x00AE, //	REGISTERED SIGN
      0x203E, //	OVERLINE
      0x00B0, //	DEGREE SIGN
      0x00B1, //	PLUS-MINUS SIGN
      0x00B2, //	SUPERSCRIPT TWO
      0x00B3, //	SUPERSCRIPT THREE
      0x00B4, //	ACUTE ACCENT
      0x00B5, //	MICRO SIGN
      0x00B6, //	PILCROW SIGN
      0x00B7, //	MIDDLE DOT
      0x00B8, //	CEDILLA
      0x00B9, //	SUPERSCRIPT ONE
      0x00F7, //	DIVISION SIGN
      0x00BB, //	RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK
      0x00BC, //	VULGAR FRACTION ONE QUARTER
      0x00BD, //	VULGAR FRACTION ONE HALF
      0x00BE, //	VULGAR FRACTION THREE QUARTERS
      0x0000, //	DOES NOT EXIST
      0x0000, //	DOES NOT EXIST
      0x0000, //	DOES NOT EXIST
      0x0000, //	DOES NOT EXIST
      0x0000, //	DOES NOT EXIST
      0x0000, //	DOES NOT EXIST
      0x0000, //	DOES NOT EXIST
      0x0000, //	DOES NOT EXIST
      0x0000, //	DOES NOT EXIST
      0x0000, //	DOES NOT EXIST
      0x0000, //	DOES NOT EXIST
      0x0000, //	DOES NOT EXIST
      0x0000, //	DOES NOT EXIST
      0x0000, //	DOES NOT EXIST
      0x0000, //	DOES NOT EXIST
      0x0000, //	DOES NOT EXIST
      0x0000, //	DOES NOT EXIST
      0x0000, //	DOES NOT EXIST
      0x0000, //	DOES NOT EXIST
      0x0000, //	DOES NOT EXIST
      0x0000, //	DOES NOT EXIST
      0x0000, //	DOES NOT EXIST
      0x0000, //	DOES NOT EXIST
      0x0000, //	DOES NOT EXIST
      0x0000, //	DOES NOT EXIST
      0x0000, //	DOES NOT EXIST
      0x0000, //	DOES NOT EXIST
      0x0000, //	DOES NOT EXIST
      0x0000, //	DOES NOT EXIST
      0x0000, //	DOES NOT EXIST
      0x0000, //	DOES NOT EXIST
      0x0000, //	DOES NOT EXIST
      0x2017, //	DOUBLE LOW LINE
      0x05D0, //	HEBREW LETTER ALEF
      0x05D1, //	HEBREW LETTER BET
      0x05D2, //	HEBREW LETTER GIMEL
      0x05D3, //	HEBREW LETTER DALET
      0x05D4, //	HEBREW LETTER HE
      0x05D5, //	HEBREW LETTER VAV
      0x05D6, //	HEBREW LETTER ZAYIN
      0x05D7, //	HEBREW LETTER HET
      0x05D8, //	HEBREW LETTER TET
      0x05D9, //	HEBREW LETTER YOD
      0x05DA, //	HEBREW LETTER FINAL KAF
      0x05DB, //	HEBREW LETTER KAF
      0x05DC, //	HEBREW LETTER LAMED
      0x05DD, //	HEBREW LETTER FINAL MEM
      0x05DE, //	HEBREW LETTER MEM
      0x05DF, //	HEBREW LETTER FINAL NUN
      0x05E0, //	HEBREW LETTER NUN
      0x05E1, //	HEBREW LETTER SAMEKH
      0x05E2, //	HEBREW LETTER AYIN
      0x05E3, //	HEBREW LETTER FINAL PE
      0x05E4, //	HEBREW LETTER PE
      0x05E5, //	HEBREW LETTER FINAL TSADI
      0x05E6, //	HEBREW LETTER TSADI
      0x05E7, //	HEBREW LETTER QOF
      0x05E8, //	HEBREW LETTER RESH
      0x05E9, //	HEBREW LETTER SHIN
      0x05EA, //	HEBREW LETTER TAV
      0x0000, //	DOES NOT EXIST
      0x0000, //	DOES NOT EXIST
      0x0000, //	DOES NOT EXIST
      0x0000, //	DOES NOT EXIST
      0x0000 //	DOES NOT EXIST
  };

  /**
   * The alphabet of ISO 8859-9.
   */
  static char[] iso8859_9 = { 0x00A0, //	NO-BREAK SPACE
      0x00A1, //	INVERTED EXCLAMATION MARK
      0x00A2, //	CENT SIGN
      0x00A3, //	POUND SIGN
      0x00A4, //	CURRENCY SIGN
      0x00A5, //	YEN SIGN
      0x00A6, //	BROKEN BAR
      0x00A7, //	SECTION SIGN
      0x00A8, //	DIAERESIS
      0x00A9, //	COPYRIGHT SIGN
      0x00AA, //	FEMININE ORDINAL INDICATOR
      0x00AB, //	LEFT-POINTING DOUBLE ANGLE QUOTATION MARK
      0x00AC, //	NOT SIGN
      0x00AD, //	SOFT HYPHEN
      0x00AE, //	REGISTERED SIGN
      0x00AF, //	MACRON
      0x00B0, //	DEGREE SIGN
      0x00B1, //	PLUS-MINUS SIGN
      0x00B2, //	SUPERSCRIPT TWO
      0x00B3, //	SUPERSCRIPT THREE
      0x00B4, //	ACUTE ACCENT
      0x00B5, //	MICRO SIGN
      0x00B6, //	PILCROW SIGN
      0x00B7, //	MIDDLE DOT
      0x00B8, //	CEDILLA
      0x00B9, //	SUPERSCRIPT ONE
      0x00BA, //	MASCULINE ORDINAL INDICATOR
      0x00BB, //	RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK
      0x00BC, //	VULGAR FRACTION ONE QUARTER
      0x00BD, //	VULGAR FRACTION ONE HALF
      0x00BE, //	VULGAR FRACTION THREE QUARTERS
      0x00BF, //	INVERTED QUESTION MARK
      0x00C0, //	LATIN CAPITAL LETTER A WITH GRAVE
      0x00C1, //	LATIN CAPITAL LETTER A WITH ACUTE
      0x00C2, //	LATIN CAPITAL LETTER A WITH CIRCUMFLEX
      0x00C3, //	LATIN CAPITAL LETTER A WITH TILDE
      0x00C4, //	LATIN CAPITAL LETTER A WITH DIAERESIS
      0x00C5, //	LATIN CAPITAL LETTER A WITH RING ABOVE
      0x00C6, //	LATIN CAPITAL LETTER AE
      0x00C7, //	LATIN CAPITAL LETTER C WITH CEDILLA
      0x00C8, //	LATIN CAPITAL LETTER E WITH GRAVE
      0x00C9, //	LATIN CAPITAL LETTER E WITH ACUTE
      0x00CA, //	LATIN CAPITAL LETTER E WITH CIRCUMFLEX
      0x00CB, //	LATIN CAPITAL LETTER E WITH DIAERESIS
      0x00CC, //	LATIN CAPITAL LETTER I WITH GRAVE
      0x00CD, //	LATIN CAPITAL LETTER I WITH ACUTE
      0x00CE, //	LATIN CAPITAL LETTER I WITH CIRCUMFLEX
      0x00CF, //	LATIN CAPITAL LETTER I WITH DIAERESIS
      0x011E, //	LATIN CAPITAL LETTER G WITH BREVE
      0x00D1, //	LATIN CAPITAL LETTER N WITH TILDE
      0x00D2, //	LATIN CAPITAL LETTER O WITH GRAVE
      0x00D3, //	LATIN CAPITAL LETTER O WITH ACUTE
      0x00D4, //	LATIN CAPITAL LETTER O WITH CIRCUMFLEX
      0x00D5, //	LATIN CAPITAL LETTER O WITH TILDE
      0x00D6, //	LATIN CAPITAL LETTER O WITH DIAERESIS
      0x00D7, //	MULTIPLICATION SIGN
      0x00D8, //	LATIN CAPITAL LETTER O WITH STROKE
      0x00D9, //	LATIN CAPITAL LETTER U WITH GRAVE
      0x00DA, //	LATIN CAPITAL LETTER U WITH ACUTE
      0x00DB, //	LATIN CAPITAL LETTER U WITH CIRCUMFLEX
      0x00DC, //	LATIN CAPITAL LETTER U WITH DIAERESIS
      0x0130, //	LATIN CAPITAL LETTER I WITH DOT ABOVE
      0x015E, //	LATIN CAPITAL LETTER S WITH CEDILLA
      0x00DF, //	LATIN SMALL LETTER SHARP S
      0x00E0, //	LATIN SMALL LETTER A WITH GRAVE
      0x00E1, //	LATIN SMALL LETTER A WITH ACUTE
      0x00E2, //	LATIN SMALL LETTER A WITH CIRCUMFLEX
      0x00E3, //	LATIN SMALL LETTER A WITH TILDE
      0x00E4, //	LATIN SMALL LETTER A WITH DIAERESIS
      0x00E5, //	LATIN SMALL LETTER A WITH RING ABOVE
      0x00E6, //	LATIN SMALL LETTER AE
      0x00E7, //	LATIN SMALL LETTER C WITH CEDILLA
      0x00E8, //	LATIN SMALL LETTER E WITH GRAVE
      0x00E9, //	LATIN SMALL LETTER E WITH ACUTE
      0x00EA, //	LATIN SMALL LETTER E WITH CIRCUMFLEX
      0x00EB, //	LATIN SMALL LETTER E WITH DIAERESIS
      0x00EC, //	LATIN SMALL LETTER I WITH GRAVE
      0x00ED, //	LATIN SMALL LETTER I WITH ACUTE
      0x00EE, //	LATIN SMALL LETTER I WITH CIRCUMFLEX
      0x00EF, //	LATIN SMALL LETTER I WITH DIAERESIS
      0x011F, //	LATIN SMALL LETTER G WITH BREVE
      0x00F1, //	LATIN SMALL LETTER N WITH TILDE
      0x00F2, //	LATIN SMALL LETTER O WITH GRAVE
      0x00F3, //	LATIN SMALL LETTER O WITH ACUTE
      0x00F4, //	LATIN SMALL LETTER O WITH CIRCUMFLEX
      0x00F5, //	LATIN SMALL LETTER O WITH TILDE
      0x00F6, //	LATIN SMALL LETTER O WITH DIAERESIS
      0x00F7, //	DIVISION SIGN
      0x00F8, //	LATIN SMALL LETTER O WITH STROKE
      0x00F9, //	LATIN SMALL LETTER U WITH GRAVE
      0x00FA, //	LATIN SMALL LETTER U WITH ACUTE
      0x00FB, //	LATIN SMALL LETTER U WITH CIRCUMFLEX
      0x00FC, //	LATIN SMALL LETTER U WITH DIAERESIS
      0x0131, //	LATIN SMALL LETTER DOTLESS I
      0x015F, //	LATIN SMALL LETTER S WITH CEDILLA
      0x00FF //	LATIN SMALL LETTER Y WITH DIAERESIS
  };

  /**
   * The alphabet of ISO 8859.
   */
  private static char[][] iso8859 = { iso8859_1, iso8859_2, iso8859_3, iso8859_4, iso8859_5, iso8859_6, iso8859_7, iso8859_8, iso8859_9 };

  /**
   * The constants indicating the type of tokens.
   */
  static final int EOF = -1; // previously it was 0
  static final int ERROR = 1;
  static final int LPAREN = 2;
  static final int RPAREN = 3;
  static final int SLASH = 4;
  static final int SEMICOLON = 5;
  static final int COMMA = 6;
  static final int EQUALS = 7;
  static final int LOGICAL = 8;
  static final int MISSING = 11;
  static final int REDEFINE = 12;
  static final int SCOPE = 13;
  static final int ENDSEC = 14;
  static final int ISO_BEGIN = 15;
  static final int ISO_END = 16;
  static final int DATA = 17;
  static final int HEADER = 18;
  static final int ENDSCOPE = 19;
  static final int BINARY = 20;
  static final int INSTANCE_NAME = 21;
  static final int INTEGER = 22;
  static final int REAL = 23;
  static final int STRING = 24;
  static final int ENUM = 25;
  static final int USER_DEFINED_KEYWORD = 26;
  static final int ENTITY_NAME = 27;
  static final int COMMENT = 28;

  /**
   * The strings describing types of tokens.
   * The specific string for a token is taken at the index that is equal
   * to the constant indicating the type of that token. An exception is
   * 'LOGICAL' type which is represented by 3 strings (one for each possible
   * logical value).
   */
  private static final String[] token_image = { "<EOF>", " ", "\"(\"", "\")\"", "\"/\"", "\";\"", "\",\"", "\"=\"", "\".T.\"", "\".U.\"", "\".F.\"", "\"$\"",
      "\"*\"", "\"SCOPE\"", "\"ENDSEC\"", "\"ISO-10303-21\"", "\"END-ISO-10303-21\"", "\"DATA\"", "\"HEADER\"", "\"ENDSCOPE\"", "<BINARY>",
      "<INSTANCE_NAME>", "<INTEGER>", "<REAL>", "<STRING>", "<ENUM>", "<USER_DEFINED_KEYWORD>", "<ENTITY_NAME>", "<COMMENT>" };

  /**
   * The constant strings used in the comments within instances of the entity
   * 'file_population' in the header of the exchange structure.
   */
  static final String[] SCH_INST_HIDDEN_FIELDS = { "schema_instance.name", "schema_instance.change_date", "schema_instance.validation_date",
      "schema_instance.validation_result", "schema_instance.validation_level", "schema_instance.description", "schema_instance.author",
      "schema_instance.organization", "schema_instance.preprocessor_version", "schema_instance.originating_system", "schema_instance.authorization",
      "schema_instance.language", "schema_instance.context_identifiers", "schema_instance.included_schema_instances" };

  /**
   * The constants representing special symbols as java byte fields.
   * These constants are used extensively during reading/writing exchange
   * structures.
   */
  static final byte DOT = (byte) '.';
  static final byte APOSTROPHE = (byte) '\'';
  static final byte QUOTATION_MARK = (byte) '\"';
  static final byte LEFT_PARENTHESIS = (byte) '(';
  static final byte RIGHT_PARENTHESIS = (byte) ')';
  static final byte DOLLAR_SIGN = (byte) '$';
  static final byte ASTERISK = (byte) '*';
  static final byte SPECIAL = (byte) '#';
  static final byte COMMA_b = (byte) ',';
  static final byte EQUAL = (byte) '=';
  static final byte SEMICOLON_b = (byte) ';';
  static final byte COLON = (byte) ':';
  static final byte MINUS = (byte) '-';
  static final byte PLUS = (byte) '+';
  static final byte UNDERSCORE = (byte) '_';
  static final byte EXCLAMATION_MARK = (byte) '!';
  static final byte CONJUNCTION = (byte) '&';
  static final byte SLASH_b = (byte) '/';
  static final byte BACKSLASH = (byte) '\\';
  static final byte SPACE = (byte) ' ';
  static final byte QUESTION_MARK = (byte) '?';
  static final byte CAPITAL_S = (byte) 'S';
  static final byte CAPITAL_P = (byte) 'P';
  static final byte CAPITAL_X = (byte) 'X';
  static final byte ZERO = (byte) '0';
  static final byte TWO = (byte) '2';
  static final byte FOUR = (byte) '4';

  /**
   * The byte representation of special string tokens encountered in the exchange
   * structures.
   */
  static final byte keywords[][] = {
      { (byte) 'D', (byte) 'A', (byte) 'T', (byte) 'A' },
      { (byte) 'E', (byte) 'N', (byte) 'D', (byte) 'S', (byte) 'C', (byte) 'O', (byte) 'P', (byte) 'E' },
      { (byte) 'E', (byte) 'N', (byte) 'D', (byte) 'S', (byte) 'E', (byte) 'C' },
      { (byte) 'H', (byte) 'E', (byte) 'A', (byte) 'D', (byte) 'E', (byte) 'R' },
      { (byte) 'S', (byte) 'C', (byte) 'O', (byte) 'P', (byte) 'E' },
      { (byte) 'I', (byte) 'S', (byte) 'O', (byte) '-', (byte) '1', (byte) '0', (byte) '3', (byte) '0', (byte) '3', (byte) '-', (byte) '2', (byte) '1' },
      { (byte) 'E', (byte) 'N', (byte) 'D', (byte) '-', (byte) 'I', (byte) 'S', (byte) 'O', (byte) '-', (byte) '1', (byte) '0', (byte) '3', (byte) '0',
          (byte) '3', (byte) '-', (byte) '2', (byte) '1' } };

  /**
   * The constant indicating the type of value: the case of defined type.
   */
  static final int TYPED_PARAMETER = 51;

  /**
   * The constant indicating the type of value: reference to an entity instance.
   */
  static final int ENTITY_REFERENCE = 52;

  /**
   * The constant indicating the type of value: reference to an entity instance
   * which will be found later while reading an exchange structure (forward reference).
   */
  static final int ENTITY_REFERENCE_SPECIAL = 53;

  /**
   * The constant indicating the type of value: the case of aggregate.
   */
  static final int EMBEDDED_LIST = 54;

  /**
   * The constant indicating the type of value: the case of boolean.
   */
  static final int BOOLEAN = 9;

  /**
   * The constants indicating the type of an error.
   */
  static final int ONLY_SIGN_IS_SPECIFIED = 11;
  static final int INTEGER_NUMBER_IS_TOO_LARGE = 12;
  static final int BAD_REAL_LITERAL = 13;
  static final int UNTERMINATED_STRING = 14;
  static final int UNTERMINATED_BINARY = 15;
  static final int UNTERMINATED_ENUMERATION = 16;
  static final int INCORRECT_ENUMERATION = 17;
  static final int INVALID_USER_DEFINED_ENTITY_NAME = 18;
  static final int ZERO_INSTANCE_IDENTIFIER = 19;
  static final int INCORRECT_INSTANCE_IDENTIFIER = 20;
  static final int UNMATCHED_CLOSE_COMMENT = 21;
  static final int UNTERMINATED_COMMENT = 22;
  static final int ILLEGAL_LOWERCASE = 23;
  static final int UNEXPECTED_CHARACTER = 24; // %@^~
  static final int UNMATCHED_INPUT = 25;
  static final int INTERNAL_ERROR = 29;
  static final int BAD_INPUT_STREAM = 30;
  static final int UNEXPECTED_ENTITY = 41;
  static final int INCORRECT_VALUE = 42;
  static final int TOO_LESS_VALUES = 43;
  static final int IMPROPER_LIST_ITEM = 44;
  static final int LIST_CANNOT_BE_EMPTY = 45;
  static final int SCHEMA_NOT_PROVIDED = 47;
  static final int WRONG_TOKEN = 48;
  static final int ENTITY_EXPECTED = 49;
  static final int WRONG_VALUE_IN_HEADER = 50;
  static final int TYPED_PARAMETER_IN_HEADER = 51;
  static final int INVALID_STRING_IN_DSECTION = 52;
  static final int TOO_MANY_VALUES_IN_DSECTION = 53;
  static final int DICTIONARY_MODEL_NOT_FOUND = 81;
  static final int DUPLICATE_INSTANCE = 82;
  static final int ILLEGAL_ACCESS = 86;
  static final int CLASS_NOT_FOUND = 87;
  static final int INVALID_SECTION_NAME = 89;

  /**
   * The constant that controls the amount of the information printed.
   */
  private final byte PRINT_IN_PARSER = 0;

  /**
   * The initial length of the internal array 'instance_name'.
   */
  private final int COMPLEX_ENTITY_NAME_LENGTH = 512;

  /**
   * The initial length of the internal array 'chars'.
   */
  private final int NUMBER_OF_CHARACTERS_IN_STRING = 128;

  /**
   * The initial length of the internal arrays 'partial_values' and
   * 'used_ent_values' in this class and arrays 'complex_name' and
   * 'ref2partial_values' in Create_instance.
   */
  static final int NAMES_ARRAY_SIZE = 16;

  private final int BOUND_ON_WARNINGS_COUNT = 10;

  /**
   * An internal array to which forward references (type indicator is
   * ENTITY_REFERENCE_SPECIAL) from the entity instance under consideration
   * are temporary stored. Afterwards, when the latter instance is created,
   * a pointer to this instance is added to the inverse list of each element
   * in this array.
   */
  private CLateBindingEntity array_of_inverse[] = new CLateBindingEntity[SdaiSession.NUMBER_OF_VALUES];

  /**
   * The length of the internal array 'array_of_inverse'.
   */
  private int length_of_array_of_inverse;

  /**
   * An object of the class representing the values of an entity instance.
   * The values are read from an exchange structure and stored to this object.
   */
  private final ComplexEntityValue entity_values = new ComplexEntityValue();

  /**
   * An internal array used to store objects of the class <code>EntityValue</code> representing the subsets of values of an
   * instance corresponding to
   * simple entity types from which entity data type of the instance is composed.
   * Usually, these objects are taken from the array <code>entityValues</code> of <code>ComplexEntityValue</code>.
   */
  private EntityValue[] partial_values;

  private EntityValue[] begin_ent_values;

  /**
   * An internal array used to mark (by 1) those objects of the class <code>EntityValue</code> within the array
   * <code>entityValues</code> of <code>ComplexEntityValue</code> which have values in the complex entity
   * instance. Values of some simple entity types may be missing due to some
   * reason (for example, a bug in coding) in the external mapping of an instance
   * in the exchange structure. This array also helps to reoder values of
   * simple entity types when these values appear in the external mapping
   * in a wrong order (are ordered by mistake not alphabetically).
   */
  private int[] used_ent_values;

  /**
   * An internal array used to store the names of simple entity types within
   * an entity data type for which an encoding of an instance in the external
   * mapping mode in the exchange structure was found.
   */
  private PartialEntityName complex_name[] = new PartialEntityName[SdaiSession.NUMBER_OF_ITEMS_IN_COMPLEX_ENTITY];

  private PartialEntityName[] saved_ent_name;

  private static final int PARTIAL_ENTITIES_COUNT = 16;

  /**
   * The name of an entity instance in the form of the byte array. If the instance
   * is complex, then to concatenate the names of simple entity types the
   * symbol '$" is used.
   */
  private byte instance_name[] = new byte[COMPLEX_ENTITY_NAME_LENGTH];

  /**
   * The length of the internal array 'instance_name'.
   */
  private int instance_name_length;
  int enl_instance_name_length;

  byte req_instance_name[];
  int req_instance_name_length;
  boolean inst_is_required;

  /**
   * An object of the class <code>Create_instance</code> used to create
   * entity instances whose coding is read from the exchange structure.
   */
//	private Create_instance create = new Create_instance(this);
  private final Create_instance create;

  /**
   * An object of the class <code>Binary_tree</code> used to process references
   * between entity instances whose coding is read from the exchange structure.
   * It helps to compile all the data contained in the exchange structure in one pass.
   */
  private Binary_tree tree;

  /**
   * A data dictionary model for Express schema which is underlying for a model
   * to which all instances read from a data section of the exchange structure are
   * stored.
   */
  private SdaiModel model_dic;

  /**
   * A model to which all instances read from a data section of the exchange
   * structure are stored.
   */
  private SdaiModel model_app;

  // The set of SdaiModels read from physical file. The set contains SdaiModel objects
  Set modelSet;

  private boolean aggr_violation;
  private boolean inst_values_violation;

  /**
   * The constructor of this class. Used in <code>SdaiSession</code>.
   */
  PhFileReader() throws SdaiException, java.io.IOException {
    create = new Create_instance(this);
    token = new Token();
    for (int m = 0; m < SdaiSession.NUMBER_OF_ITEMS_IN_COMPLEX_ENTITY; m++) {
      complex_name[m] = new PartialEntityName();
    }
    error_table = new Reader_error_table();
    autoreference_found = false;
    if (chars == null) {
      chars = new char[NUMBER_OF_CHARACTERS_IN_STRING];
    }
    StaticFields staticFields = StaticFields.get();
    staticFields.importing = false;
  }

  /**
   * Reads an exchange structure. The file is submitted through the parameter <code>source_location</code>, and the data from it
   * are stored into a repository
   * whose name is given by the second parameter. The last parameter represents
   * the schema instance for data dictionary (this is a field of the class <code>SdaiSession</code>). This method does the main
   * job of the <code>SdaiSession</code> method <code>importClearTextEncoding</code>.
   */
  final SdaiRepository exchange_file(SdaiSession session, String name, Object source_location, Object destination_location, SchemaInstance schema_instance)
      throws SdaiException, java.io.IOException {
//long time1, time2, time3 = 0, time4 = 0;
//long time5, time6, time7 , time8, time9, time10;
//time1 = System.currentTimeMillis();
//time5 = System.currentTimeMillis();
    int i;
    long time_before_reading = 0, time_after_reading;
    long time_in_sec;

    active_session = session;
    StaticFields staticFields = StaticFields.get();
    staticFields.importing = true;
    try {
      repo_name = name;
      phys_file = source_location.toString();
      largest_identifier = -1;
      if (PRINT_IN_PARSER >= 0 && source_location instanceof String) {
        if (session.logWriterSession != null) {
          session.printlnSession("--- Exchange structure: " + phys_file);
        }
        else {
          SdaiSession.println("--- Exchange structure: " + phys_file);
        }
      }
      InputStream input;
      String locationString;
      if (source_location instanceof String) {
        locationString = (String) source_location;
        input = new FileInputStream(locationString);
      }
      else if (source_location instanceof InputStream) {
        locationString = null;
        input = (InputStream) source_location;
      }
      else {
        throw new SdaiException(SdaiException.VT_NVLD);
      }
      if (PRINT_IN_PARSER >= 0) {
        time_before_reading = System.currentTimeMillis();
      }
      if (scan == null) {
        scan = new Scanner(input, session);
      }
      else {
        scan.attach_stream(input, session);
      }
      tree = new Binary_tree();
      modelSet = new HashSet();

      try {
        consume_token(ISO_BEGIN);
        scan.begin_or_end_expected = false;
        consume_token(SEMICOLON);
        data_section_processing = false;
        header_section(session, locationString, destination_location);
        data_section_processing = true;
        scan.begin_or_end_expected = true;
        scan.get_token(token);
        scan.begin_or_end_expected = false;
        if (token.type == ERROR) {
          scanning_exception(token, -1, null);
        }
        int section_count = 0;
        while (token.type == DATA) {
          section_count++;
          if (section_count > 1 && SdaiCommon.feature_level == 0) {
            String base = SdaiSession.line_separator + AdditionalMessages.FL_OMZE;
            throw new SdaiException(SdaiException.SY_ERR, base);
          }
          file_repo.importing = true;
          data_section(schema_instance, file_repo);
          file_repo.importing = false;
          model_app.sort_inside_extents();
          scan.begin_or_end_expected = true;
          scan.get_token(token);
          scan.begin_or_end_expected = false;
          if (token.type == ERROR) {
            scanning_exception(token, -1, null);
          }
        }
        if (zero_inst != null) {
          replace_zero_id(session);
        }
        //<--VV--030310--
        //file_repo.largest_identifier = largest_identifier;
        file_repo.setNextPersistentLabel(largest_identifier + 1);
        //--VV--030310-->
        if (token.type != ISO_END) {
          parsing_exception(token, WRONG_TOKEN, AdditionalMessages.RD_TOKE, token_image[ISO_END]);
        }
        consume_token(SEMICOLON);
        tree.check_unresolved();
        for (Iterator mi = modelSet.iterator(); mi.hasNext(); ) {
          SdaiModel model = (SdaiModel) mi.next();
          model.renumberPersistentLabels();
        }
      }
      finally {
        if (locationString != null) {
          input.close();
        }
        modelSet = null;
      }
      if (PRINT_IN_PARSER >= 0) {
        time_after_reading = System.currentTimeMillis();
        time_in_sec = (time_after_reading - time_before_reading) / 1000;
        if (session.logWriterSession != null) {
          session.printlnSession("--- Imported to the repository: " + file_repo.name);
          session.printlnSession("--- Reading time=" + time_in_sec + "sec");
        }
        else {
          SdaiSession.println("--- Imported to the repository: " + file_repo.name);
          SdaiSession.println("--- Reading time=" + time_in_sec + "sec");
        }
      }
      int j, k;
      boolean found;
      SdaiModel mod;
      for (j = 0; j < file_repo.languages_count; j++) {
        found = false;
        SECTION_LANGUAGE language = file_repo.languages[j];
        if (language.section == null) {
          file_repo.language = language.default_language;
          continue;
        }
        file_repo.internal_usage = true;
        mod = file_repo.findSdaiModel(language.section);
        file_repo.internal_usage = false;
        if (mod != null) {
          mod.language = language.default_language;
          found = true;
        }
        if (!found) {
          action_exception(INVALID_SECTION_NAME, null, null);
        }
      }
      for (j = 0; j < file_repo.contexts_count; j++) {
        found = false;
        SECTION_CONTEXT context = file_repo.contexts[j];
        if (context.section == null) {
          file_repo.context_identifiers = context.context_identifiers;
          continue;
        }
        file_repo.internal_usage = true;
        mod = file_repo.findSdaiModel(context.section);
        file_repo.internal_usage = false;
        if (mod != null) {
          mod.context_identifiers = context.context_identifiers;
          found = true;
        }
        if (!found) {
          action_exception(INVALID_SECTION_NAME, null, null);
        }
      }
      for (j = 0; j < file_repo.schemas.myLength; j++) {
        SchemaInstance sch_inst = (SchemaInstance) file_repo.schemas.myData[j];
        if (sch_inst.moved_data_status == 1) {
          sch_inst.moveDataAfterImportClearTextEncoding();
        }
      }
      file_repo.modified = false;
      create_schema_instances();
      include_schema_instances(session);
    }
    finally {
      tree = null;
      staticFields.importing = false;
      staticFields.current_instance_identifier = -1;
    }
    entity_values.unset_ComplexEntityValue();
    return file_repo;
    /*
     * System.out.println("    !!!!!PhFileReader    forw_count = " + forw_count);
     * System.out.println("    !!!!!PhFileReader    inv_added_count = " + inv_added_count);
     * System.out.println("    !!!!!PhFileReader    tree_insert_count = " + tree_insert_count);
     * System.out.println("    !!!!!PhFileReader    tree_replace_count = " + tree_replace_count);
     * System.out.println("    ^^^^^PhFileReader    time_insert_first = " + time_insert_first);
     * System.out.println("    ^^^^^PhFileReader    time_insert_second = " + time_insert_second);
     * System.out.println("    ^^^^^PhFileReader    time_replace = " + time_replace);
     * System.out.println("    ^^^^^PhFileReader    time_data_entity = " + time_data_entity);
     * long diff = time2 - time1;
     * System.out.println("    ^^^^^PhFileReader    exchange_file = " + diff);
     * diff = time6 - time5;
     * System.out.println("    ^^^^^PhFileReader    first_part = " + diff);
     * diff = time7 - time6;
     * System.out.println("    ^^^^^PhFileReader    second_part = " + diff);
     * diff = time8 - time7;
     * System.out.println("    ^^^^^PhFileReader    sorting = " + diff);
     * diff = time9 - time8;
     * System.out.println("    ^^^^^PhFileReader    third_part = " + diff);
     */
  }

  final private void replace_zero_id(SdaiSession session) throws SdaiException {
    largest_identifier++;
    zero_inst.instance_identifier = largest_identifier;
    if (session != null && session.logWriterSession != null) {
      session.printlnSession(AdditionalMessages.RD_ZEID + largest_identifier);
    }
    else {
      SdaiSession.println(AdditionalMessages.RD_ZEID + largest_identifier);
    }
    SdaiModel mod = zero_inst.owning_model;
    SchemaData sch_data = mod.underlying_schema.modelDictionary.schemaData;
    int index_to_entity = sch_data.findEntityExtentIndex((CEntity_definition) zero_inst.getInstanceType());
    if (index_to_entity < 0) {
      throw new SdaiException(SdaiException.SY_ERR);
    }
    int ln = mod.lengths[index_to_entity];
    System.arraycopy(mod.instances_sim[index_to_entity], 1, mod.instances_sim[index_to_entity], 0, ln - 1);
    mod.instances_sim[index_to_entity][ln - 1] = zero_inst;
    zero_inst = null;
  }

  /**
   * Creates a schema instance for each instance of the entity 'file_population'
   * encountered in the exchange structure.
   */
  final private void create_schema_instances() throws SdaiException {
    int j;
    for (int i = 0; i < populations_count; i++) {
      FILE_POPULATION file_pop = populations[i];
      SdaiModel dict_model = SdaiSession.systemRepository.get_schema_model(file_pop);
      if (dict_model.getMode() == SdaiModel.NO_ACCESS) {
        dict_model.startReadOnlyAccess();
      }
      String sch_inst_name;
      if (file_pop.name != null) {
        sch_inst_name = file_pop.name;
      }
      else {
        int sch_count = file_repo.schema_count + 1;
        sch_inst_name = "schema" + sch_count;
      }
      file_pop.final_name = sch_inst_name;
//System.out.println("  PhFileReader   file_repo: " + file_repo.name +
//"  sch_inst_name: " + sch_inst_name +
//"   dict_model: " + dict_model.name);
      SchemaInstance sch_inst = file_repo.createSchemaInstance(sch_inst_name, dict_model.described_schema);
      sch_inst.created = true;
      if (file_pop.governed_sections == null) {
        for (j = 0; j < file_repo.models.myLength; j++) {
          SdaiModel mod = (SdaiModel) file_repo.models.myData[j];
          sch_inst.addSdaiModel(mod);
          if (mod.modified_outside_contents) {
            mod.modified_outside_contents_by_import = true;
            mod.modified_outside_contents = false;
          }
        }
      }
      else {

        Object[] myDataA = null;
        if (file_pop.governed_sections.myLength > 1) {
          myDataA = (Object[]) file_pop.governed_sections.myData;
        }
        for (j = 0; j < file_pop.governed_sections.myLength; j++) {
          String section_name;
          if (file_pop.governed_sections.myLength == 1) {
            section_name = (String) file_pop.governed_sections.myData;
          }
          else {
            section_name = (String) myDataA[j];
          }
          file_repo.internal_usage = true;
          SdaiModel mod = file_repo.findSdaiModel(section_name);
          file_repo.internal_usage = false;
          if (mod != null) {
            sch_inst.addSdaiModel(mod);
            if (mod.modified_outside_contents) {
              mod.modified_outside_contents_by_import = true;
              mod.modified_outside_contents = false;
            }
          }
          else {
            printWarningToLogo(active_session, AdditionalMessages.RD_WSPO, section_name);
          }
        }
      }
      if (file_pop.change_date != null) {
        sch_inst.change_date = file_repo.session.cal.timeStampToLong(file_pop.change_date);
      }
      else {
        sch_inst.change_date = -1;
      }
      if (file_pop.validation_date != null) {
        sch_inst.validation_date = file_repo.session.cal.timeStampToLong(file_pop.validation_date);
      }
      else {
        sch_inst.validation_date = -1;
      }
      if (file_pop.validation_result >= 0) {
        sch_inst.validation_result = file_pop.validation_result;
      }
      sch_inst.validation_level = file_pop.validation_level;
      sch_inst.description = file_pop.description;
      sch_inst.author = file_pop.author;
      sch_inst.organization = file_pop.organization;
      sch_inst.preprocessor_version = file_pop.preprocessor_version;
      sch_inst.originating_system = file_pop.originating_system;
      sch_inst.authorization = file_pop.authorization;
      sch_inst.language = file_pop.language;
      sch_inst.context_identifiers = file_pop.context_identifiers;
      sch_inst.modified_by_import = sch_inst.modified;
      sch_inst.modified = false;
    }
  }

  final private void include_schema_instances(SdaiSession session) throws SdaiException {
    SchemaInstance own_sch_inst;
    for (int i = 0; i < populations_count; i++) {
      FILE_POPULATION file_pop = populations[i];
      if (file_pop.included_schema_instances == null) {
        continue;
      }
      String sch_inst_name;
      own_sch_inst = null;
      A_string aggr = file_pop.included_schema_instances;
      for (int j = 1; j <= aggr.myLength; j++) {
        sch_inst_name = aggr.getByIndex(j);
        SchemaInstance sch_inst = file_repo.findSchemaInstance(sch_inst_name);
        if (sch_inst == null) {
          printWarningToLogoSchiInst(session, AdditionalMessages.RD_UNSI, file_pop.final_name, sch_inst_name);
          continue;
        }
        if (own_sch_inst == null) {
          own_sch_inst = file_repo.findSchemaInstance(file_pop.final_name);
          own_sch_inst.included_schemas = new ASchemaInstance(SdaiSession.setType0toN, own_sch_inst);
        }
        own_sch_inst.included_schemas.addUnorderedRO(sch_inst);
      }
    }
  }

  /**
   * Reads the header of the exchange structure. According to ISO 10303-21,
   * first of all, instances of the entities <code>file_description</code>, <code>file_name</code> and <code>file_schema</code>
   * are processed.
   * Then, instances of the entities <code>section_language</code>, <code>section_context</code> and
   * <code>file_population</code> in any order
   * are read. Finally, user defined header instances (if any) are considered.
   */
  final private void header_section(SdaiSession session, String source_location, Object destination_location) throws SdaiException, java.io.IOException {
    String entity_in_header;
    boolean[] defaults = { false, false };
    consume_token(HEADER);
    consume_token(SEMICOLON);
    expect_entity = "FILE_DESCRIPTION";
    header_entity(null, defaults, session, source_location, destination_location);
    expect_entity = "FILE_NAME";
    header_entity(null, defaults, session, source_location, destination_location);
    scan.get_token(token);
    if (token.type == ERROR) {
      scanning_exception(token, -1, null);
    }
    boolean found_FILE_SCHEMA = false;
    if (token.type != ENDSEC) {
      entity_in_header = new String(token.string, 0, token.length);
      if (entity_in_header.equals("FILE_SCHEMA")) {
        found_FILE_SCHEMA = true;
        expect_entity = "FILE_SCHEMA";
        header_entity(entity_in_header, defaults, session, source_location, destination_location);
      }
    }
    if (found_FILE_SCHEMA) {
      scan.get_token(token);
      if (token.type == ERROR) {
        scanning_exception(token, -1, null);
      }
    }
    else {
      file_repo.file_schema = new FILE_SCHEMA(file_repo);
      printWarningToLogo(session, phys_file);
    }
    populations_count = 0;
    if (token.type != ENDSEC) {
      entity_in_header = new String(token.string, 0, token.length);
      while (entity_in_header.equals("SECTION_LANGUAGE") || entity_in_header.equals("SECTION_CONTEXT") || entity_in_header.equals("FILE_POPULATION")) {
        expect_entity = entity_in_header;
        header_entity(entity_in_header, defaults, session, source_location, destination_location);
        scan.get_token(token);
        if (token.type == ERROR) {
          scanning_exception(token, -1, null);
        }
        entity_in_header = new String(token.string, 0, token.length);
      }
      expect_entity = " ";
      file_repo.user_defined_instances_count = 0;
      while (token.type == USER_DEFINED_KEYWORD) {
        opt_header_entity(file_repo);
        scan.get_token(token);
        if (token.type == ERROR) {
          scanning_exception(token, -1, null);
        }
      }
    }
    if (token.type != ENDSEC) {
      parsing_exception(token, WRONG_TOKEN, AdditionalMessages.RD_TOKE, token_image[ENDSEC]);
    }
    consume_token(SEMICOLON);
  }

  /**
   * Reads an encoding of a user defined header instance from the exchange
   * structure. The instance created is put into the array <code>user_defined_instances</code> of the repository to which the
   * exchange structure is imported.
   */
  final private void opt_header_entity(SdaiRepository repo) throws SdaiException, java.io.IOException {
    expect_entity = "user_defined";
    $HEADER_USER_DEFINED_ENTITY user_entity_in_header = new $HEADER_USER_DEFINED_ENTITY();
    user_entity_in_header.name = new String(token.string, 0, token.length);
    consume_token(LPAREN);
    if (entity_values.entityValues[0] == null) {
      entity_values.entityValues[0] = new EntityValue(active_session);
    }
    parameters(entity_values.entityValues[0]);
    if (token.type != RPAREN) {
      parsing_exception(token, WRONG_TOKEN, AdditionalMessages.RD_TOKE, token_image[RPAREN]);
    }
    consume_token(SEMICOLON);

    int res = user_entity_in_header.write(entity_values.entityValues[0]);
    if (res > 0) {
      parsing_exception(token, res, null, null);
    }
    if (repo.user_defined_instances == null) {
      repo.user_defined_instances = new $HEADER_USER_DEFINED_ENTITY[repo.USER_DEFINED_INSTANCES_ARRAY_SIZE];
    }
    else if (repo.user_defined_instances_count >= repo.user_defined_instances.length) {
      int new_length = repo.user_defined_instances.length * 2;
      $HEADER_USER_DEFINED_ENTITY[] new_array = new $HEADER_USER_DEFINED_ENTITY[new_length];
      System.arraycopy(repo.user_defined_instances, 0, new_array, 0, repo.user_defined_instances.length);
      repo.user_defined_instances = new_array;
    }
    repo.user_defined_instances[repo.user_defined_instances_count++] = user_entity_in_header;
  }

  /**
   * Reads an encoding of a header instance different than user defined from
   * the exchange structure. The extracted data are written into the
   * repository to which the exchange structure is imported.
   */
  final private void header_entity(String ent, boolean[] defaults, SdaiSession session, String source_location, Object destination_location)
      throws SdaiException, java.io.IOException {
    String entity_in_header;
    String str;
    int i;
    int new_length;

//		populations_count = 0;
    if (entity_values.entityValues[0] == null) {
      entity_values.entityValues[0] = new EntityValue(session);
    }
    if (ent != null) {
      entity_in_header = ent;
    }
    else {
      consume_token(ENTITY_NAME);
      entity_in_header = new String(token.string, 0, token.length);
    }
    consume_token(LPAREN);
    if (expect_entity.equals("FILE_POPULATION")) {
      file_pop = new FILE_POPULATION(file_repo);
      scan.file_population_comments = true;
    }
    parameters(entity_values.entityValues[0]);
    if (expect_entity.equals("FILE_POPULATION")) {
      scan.file_population_comments = false;
    }
    if (token.type != RPAREN) {
      parsing_exception(token, WRONG_TOKEN, AdditionalMessages.RD_TOKE, token_image[RPAREN]);
    }
    consume_token(SEMICOLON);

    if (ent == null && expect_entity != " " && !expect_entity.equals(entity_in_header)) {
      parsing_exception(token, UNEXPECTED_ENTITY, AdditionalMessages.RD_ENTE, expect_entity);
    }

    int integ;
    if (expect_entity.equals("FILE_DESCRIPTION")) {
      file_description = new FILE_DESCRIPTION(null);
      integ = file_description.write(entity_values.entityValues[0]);
      if (integ > 0) {
        parsing_exception(token, integ, null, null);
      }
      if (PRINT_IN_PARSER > 0) {
        file_description.print();
      }
    }
    else if (expect_entity.equals("FILE_NAME")) {
      FILE_NAME file_name = new FILE_NAME(null);
      integ = file_name.write(entity_values.entityValues[0]);
      if (integ > 0) {
        parsing_exception(token, integ, null, null);
      }
      if (PRINT_IN_PARSER > 0) {
        file_name.print();
      }
      if (repo_name == null) {
        repo_name = file_name.repository_name;
      }
      String newRepositoryFormat = session.props.getProperty("new.repository.format", "DIR");
      String loc = "SdaiRepository/";
      if (destination_location instanceof String) {
        loc = (String) destination_location;
      }

      int current = -1;
      if ((loc == null && newRepositoryFormat.equalsIgnoreCase("SDAI"))
          || (loc != null && (!loc.endsWith(SdaiSession.DIRECTORY_SUFFIX) && !loc.endsWith(File.separator)))) {
        // Deriving repository name from location
        if (repo_name == null || repo_name.length() == 0) {
          if (loc != null) {
            int lastIndex = loc.lastIndexOf(File.separatorChar);
            if (lastIndex > -1) {
              repo_name = loc.substring(lastIndex + 1);
            }
            else {
              repo_name = loc;
            }

            lastIndex = repo_name.lastIndexOf('.');
            if (lastIndex > 0) {
              repo_name = repo_name.substring(0, lastIndex);
            }
          }
        }
        if (loc == null) {
          loc = repo_name + SdaiSession.SDAI_FILE_EXTENSION;
        }
        // Adding repos_path to the start of location if file name without path is specified
        if (loc.lastIndexOf(File.separator) < 0) {
          loc = session.repos_path + File.separator + loc;
        }
        // Adding sequence numbers for repeating repository names
        boolean bFreeNameFound = false;
        boolean bNameExists;
        String current_name;
        while (!bFreeNameFound) {
          current++;

          if (current > 0) {
            current_name = repo_name + "_" + String.valueOf(current);
          }
          else {
            current_name = repo_name;
          }
          bNameExists = false;
          for (i = 0; i < session.known_servers.myLength; i++) {
            SdaiRepository existingRepository = (SdaiRepository) session.known_servers.myData[i];
            String existingLocation = (String) existingRepository.location;
            if (current == 0 && loc.equals(existingLocation)) {
              throw new SdaiException(SdaiException.RP_DUP, existingRepository, AdditionalMessages.AX_NAME + repo_name + " location: " + loc);
            }
            if (existingRepository.name.equals(current_name)) {
              bNameExists = true;
              break;
            }
          }
          if (!bNameExists) {
            bFreeNameFound = true;
            repo_name = current_name;
          }
        }
        destination_location = loc;
      }
      file_repo = get_repository(session, repo_name, source_location, destination_location);
      file_name.author.owner = file_repo;
      file_name.organization.owner = file_repo;
      file_repo.file_name = file_name;
      file_description.description.owner = file_repo;
      file_repo.description = file_description.description;
      file_repo.implementation_level = file_description.implementation_level;
      file_repo.languages_count = 0;
      file_repo.contexts_count = 0;
      if ((loc == null && newRepositoryFormat.equalsIgnoreCase("SDAI"))
          || (loc != null && (!loc.endsWith(SdaiSession.DIRECTORY_SUFFIX) && !loc.endsWith(File.separator)))) {
        if (current > 0) {
          ((SdaiRepositoryZipImpl) file_repo).nameWithRecurrenceNumber = true;
        }
      }
    }
    else if (expect_entity.equals("FILE_SCHEMA")) {
      FILE_SCHEMA file_schema = new FILE_SCHEMA(file_repo);
      integ = file_schema.write(entity_values.entityValues[0]);
      if (integ > 0) {
        parsing_exception(token, integ, null, null);
      }
      if (PRINT_IN_PARSER > 0) {
        file_schema.print();
      }
      file_repo.file_schema = file_schema;
    }
    else if (expect_entity.equals("SECTION_LANGUAGE")) {
      if (defaults[0] == false || entity_values.entityValues[0].values[0].tag != MISSING) {
        if (entity_values.entityValues[0].values[0].tag == MISSING) {
          defaults[0] = true;
        }
        SECTION_LANGUAGE sect_language = new SECTION_LANGUAGE();
        integ = sect_language.write(entity_values.entityValues[0]);
        if (integ > 0) {
          parsing_exception(token, integ, null, null);
        }
        if (PRINT_IN_PARSER > 0) {
          sect_language.print();
        }
        if (file_repo.languages == null) {
          file_repo.languages = new SECTION_LANGUAGE[file_repo.LANGUAGES_ARRAY_SIZE];
        }
        else if (file_repo.languages_count >= file_repo.languages.length) {
          file_repo.enlarge_languages();
        }
        file_repo.languages[file_repo.languages_count++] = sect_language;
      }
    }
    else if (expect_entity.equals("SECTION_CONTEXT")) {
      if (defaults[1] == false || entity_values.entityValues[0].values[1].tag != MISSING) {
        if (entity_values.entityValues[0].values[1].tag == MISSING) {
          defaults[1] = true;
        }
        SECTION_CONTEXT sect_context = new SECTION_CONTEXT(file_repo);
        integ = sect_context.write(entity_values.entityValues[0]);
        if (integ > 0) {
          parsing_exception(token, integ, null, null);
        }
        if (PRINT_IN_PARSER > 0) {
          sect_context.print();
        }
        if (file_repo.contexts == null) {
          file_repo.contexts = new SECTION_CONTEXT[file_repo.CONTEXTS_ARRAY_SIZE];
        }
        else if (file_repo.contexts_count >= file_repo.contexts.length) {
          file_repo.enlarge_contexts();
        }
        file_repo.contexts[file_repo.contexts_count++] = sect_context;
      }
    }
    else if (expect_entity.equals("FILE_POPULATION")) {
      integ = file_pop.write(entity_values.entityValues[0]);
      if (integ > 0) {
        parsing_exception(token, integ, null, null);
      }
      if (PRINT_IN_PARSER > 0) {
        file_pop.print();
      }
      if (populations == null) {
        populations = new FILE_POPULATION[POPULATIONS_ARRAY_SIZE];
      }
      else if (populations_count >= populations.length) {
        new_length = populations.length * 2;
        FILE_POPULATION[] new_array = new FILE_POPULATION[new_length];
        System.arraycopy(populations, 0, new_array, 0, populations.length);
        populations = new_array;
      }
      populations[populations_count++] = file_pop;
    }

  }

  /**
   * Returns a repository for a given name to which the exchange structure will
   * be imported. The repository is that already existing (of course, in the virtual
   * mode) or a new one created within this method.
   */
  final private SdaiRepository get_repository(SdaiSession session, String name, String source_location, Object destination_location) throws SdaiException {
    if (destination_location instanceof SdaiRepository) {
      return (SdaiRepository) destination_location;
    }
    SdaiRepository repository = null;
    for (int i = 0; i < session.known_servers.myLength; i++) {
      SdaiRepository rep = (SdaiRepository) session.known_servers.myData[i];
      if (rep.name.equals(name)) {
        repository = rep;
        break;
      }
    }
    if (repository != null) {
      if (repository.virtual) {
        repository.promoteVirtualToOrdinary(destination_location, true);
      }
      else {
        throw new SdaiException(SdaiException.RP_DUP, repository, AdditionalMessages.AX_NAME + name);
      }
    }
    else {
      String loc = destination_location instanceof String ? (String) destination_location : null;
      if ((loc != null && (!loc.endsWith(SdaiSession.DIRECTORY_SUFFIX) && !loc.endsWith(File.separator)))) {
        repository = new SdaiRepositoryZipImpl(session, name, loc, false);
      }
      else {
        repository = session.createSdaiRepositoryImpl(name, loc, false);
      }
    }
    repository.active = true;
    repository.created_or_imported = true;
    repository.physical_file_name = source_location != null ? source_location : name;
    return repository;
  }

  /**
   * Reads parameters of the encoding of an instance of one of the following types:
   * - header entity instance (within <code>header_entity</code> method);
   * - header user-defined entity instance (within <code>opt_header_entity</code> method);
   * - user-defined entity instance (within <code>entity_instance_RHS</code> method);
   * - entity instance in external mapping mode (within <code>entity_instance_RHS</code> method).
   * This method is also used to read data section parameters (such parameters exist
   * if the exchange structure contains more than one data section).
   */
  private final void parameters(EntityValue pval) throws SdaiException, java.io.IOException {
    int index = -1;
    StaticFields staticFields;
    scan.get_token(token);
    if (token.type == ERROR) {
      staticFields = StaticFields.get();
      scanning_exception(token, staticFields.current_instance_identifier, null);
    }
    else if (token.type == COMMENT) {
      go_through_comments(token);
    }
    if (token.type == LPAREN || token.type == ENTITY_NAME || (8 <= token.type && token.type <= 12) || (20 <= token.type && token.type <= 25)) {
      index++;
      if (pval.values == null) {
        pval.values = new Value[SdaiSession.NUMBER_OF_VALUES];
      }
      else if (index >= pval.values.length) {
        pval.enlarge(index + 1);
      }
      if (pval.values[index] == null) {
        pval.values[index] = new Value();
      }
      if (data_section_processing) {
        aggr_violation = false;
        pval.values[index].types_count = 0;
        parameter(pval.values[index]);
        if (aggr_violation) {
          pval.values[index].types_count = 1;
          inst_values_violation = true;
        }
      }
      else {
        parameter_in_header(pval.values[index]);
      }
      scan.get_token(token);
      if (token.type == ERROR) {
        staticFields = StaticFields.get();
        scanning_exception(token, staticFields.current_instance_identifier, null);
      }
      else if (token.type == COMMENT) {
        go_through_comments(token);
      }

      int warn_count = 0;
      while (token.type != RPAREN) {
        while (token.type == COMMA) {
          scan.get_token(token);
          if (token.type == ERROR) {
            staticFields = StaticFields.get();
            scanning_exception(token, staticFields.current_instance_identifier, null);
          }
          else if (token.type == COMMENT) {
            go_through_comments(token);
          }
          index++;
          if (index >= pval.values.length) {
            pval.enlarge(index + 1);
          }
          if (pval.values[index] == null) {
            pval.values[index] = new Value();
          }
          if (data_section_processing) {
            aggr_violation = false;
            pval.values[index].types_count = 0;
            parameter(pval.values[index]);
            if (aggr_violation) {
              pval.values[index].types_count = 1;
              inst_values_violation = true;
            }
          }
          else {
            parameter_in_header(pval.values[index]);
          }
          scan.get_token(token);
          if (token.type == ERROR) {
            staticFields = StaticFields.get();
            scanning_exception(token, staticFields.current_instance_identifier, new String(token.string));
          }
          else if (token.type == COMMENT) {
            go_through_comments(token);
          }
        }
        if (token.type == RPAREN || warn_count >= BOUND_ON_WARNINGS_COUNT) {
          break;
        }
        parsing_warning(active_session, token, WRONG_TOKEN, AdditionalMessages.RD_TOKE, token_image[RPAREN]);
        warn_count++;
        while (token.type != COMMA && token.type != RPAREN) {
          scan.get_token(token);
          if (token.type == ERROR) {
            staticFields = StaticFields.get();
            parsing_exception(token, AdditionalMessages.RD_CORP, AdditionalMessages.RD_INST,
                Long.toString(staticFields.current_instance_identifier));
          }
          else if (token.type == COMMENT) {
            go_through_comments(token);
          }
          if (token.type != COMMA && token.type != RPAREN) {
            if (warn_count >= BOUND_ON_WARNINGS_COUNT) {
              break;
            }
            parsing_warning(active_session, token, WRONG_TOKEN, AdditionalMessages.RD_TOKE, token_image[RPAREN]);
            warn_count++;
          }
        }
        if (token.type != COMMA && warn_count >= BOUND_ON_WARNINGS_COUNT) {
          break;
        }
      }

    }
    pval.count = index + 1;
  }

  /**
   * Reads the comments within an encoding of <code>file_population</code> instances. In this specific case these comments bear
   * some useful information.
   */
  private final void go_through_comments(Token token) throws SdaiException, java.io.IOException {
    while (token.type == COMMENT) {
      process_comment_file_population(token);
      scan.get_token(token);
      if (token.type == ERROR) {
        StaticFields staticFields = StaticFields.get();
        scanning_exception(token, staticFields.current_instance_identifier, null);
      }
    }
  }

  /**
   * Processes a comment encountered within an encoding of a <code>file_population</code> instance.
   */
  private final void process_comment_file_population(Token token) throws SdaiException {
    int i;
    int first_ind = -1, last_ind = -1;
    String com = new String(token.string, 0, token.length);
    int last_comma = com.lastIndexOf(COMMA_b);
    if (last_comma < 0) {
      return;
    }
    for (i = last_comma + 1; i < token.length; i++) {
      if (token.string[i] != SPACE) {
        first_ind = i;
        break;
      }
    }
    if (first_ind < 0) {
      printCommentError(AdditionalMessages.RD_WCPO, com);
      return;
    }
    for (i = token.length - 1; i > last_comma; i--) {
      if (token.string[i] != SPACE) {
        last_ind = i;
        break;
      }
    }
    if (last_ind < 0 || last_ind < first_ind) {
      printCommentError(AdditionalMessages.RD_WCPO, com);
      return;
    }
    String key = com.substring(first_ind, last_ind + 1);
    if (key.equals(SCH_INST_HIDDEN_FIELDS[0])) { //		"name"
      file_pop.name = process_string(token, com, 0, last_comma);
    }
    else if (key.equals(SCH_INST_HIDDEN_FIELDS[1])) { //		"change_date"
      file_pop.change_date = process_string(token, com, 0, last_comma);
    }
    else if (key.equals(SCH_INST_HIDDEN_FIELDS[2])) { //		"validation_date"
      file_pop.validation_date = process_string(token, com, 0, last_comma);
    }
    else if (key.equals(SCH_INST_HIDDEN_FIELDS[3])) { //		"validation_result"
      file_pop.validation_result = process_logical(token, com, last_comma);
    }
    else if (key.equals(SCH_INST_HIDDEN_FIELDS[4])) { //		"validation_level"
      file_pop.validation_level = process_digit(token, com, last_comma);
    }
    else if (key.equals(SCH_INST_HIDDEN_FIELDS[5])) { //		"description"
      file_pop.description = new A_string(SdaiSession.listTypeSpecial, file_repo);
      process_aggregate(token, com, last_comma, file_pop.description);
    }
    else if (key.equals(SCH_INST_HIDDEN_FIELDS[6])) { //		"author"
      file_pop.author = new A_string(SdaiSession.listTypeSpecial, file_repo);
      process_aggregate(token, com, last_comma, file_pop.author);
    }
    else if (key.equals(SCH_INST_HIDDEN_FIELDS[7])) { //		"organization"
      file_pop.organization = new A_string(SdaiSession.listTypeSpecial, file_repo);
      process_aggregate(token, com, last_comma, file_pop.organization);
    }
    else if (key.equals(SCH_INST_HIDDEN_FIELDS[8])) { //		"preprocessor_version"
      file_pop.preprocessor_version = process_string(token, com, 0, last_comma);
    }
    else if (key.equals(SCH_INST_HIDDEN_FIELDS[9])) { //		"originating_system"
      file_pop.originating_system = process_string(token, com, 0, last_comma);
    }
    else if (key.equals(SCH_INST_HIDDEN_FIELDS[10])) { //		"authorization"
      file_pop.authorization = process_string(token, com, 0, last_comma);
    }
    else if (key.equals(SCH_INST_HIDDEN_FIELDS[11])) { //		"language"
      file_pop.language = process_string(token, com, 0, last_comma);
    }
    else if (key.equals(SCH_INST_HIDDEN_FIELDS[12])) { //		"context_identifiers"
      file_pop.context_identifiers = new A_string(SdaiSession.listTypeSpecial, file_repo);
      process_aggregate(token, com, last_comma, file_pop.context_identifiers);
    }
    else if (key.equals(SCH_INST_HIDDEN_FIELDS[13])) { //		"included_schema_instances"
      file_pop.included_schema_instances = new A_string(SdaiSession.listTypeSpecial, file_repo);
      process_aggregate(token, com, last_comma, file_pop.included_schema_instances);
    }
  }

  /**
   * Prints a warning message related to processing of comments within <code>file_population</code> instances to log file.
   */
  private final void printCommentError(String message, String com) throws SdaiException {
    String str;
    if (file_pop.name != null) {
      str = file_pop.name;
    }
    else {
      str = "";
    }
    printWarningToLogo(active_session, message, str, com);
  }

  /**
   * Extracts the string from the comment encountered within an encoding of a <code>file_population</code> instance.
   */
  private final String process_string(Token token, String com, int st_ind, int c_ind) throws SdaiException {
    int i;
    int first_ind = -1, last_ind = -1;
    for (i = st_ind; i < c_ind; i++) {
      if (token.string[i] == APOSTROPHE) {
        first_ind = i + 1;
        break;
      }
    }
    if (first_ind < 0) {
      printCommentError(AdditionalMessages.RD_WCPO, com);
      return null;
    }
    for (i = c_ind - 1; i > st_ind; i--) {
      if (token.string[i] == APOSTROPHE) {
        last_ind = i;
        break;
      }
    }
    if (last_ind < 0 || last_ind < first_ind) {
      printCommentError(AdditionalMessages.RD_WCPO, com);
      return null;
    }
    else if (last_ind == first_ind) {
      return "";
    }
    return com.substring(first_ind, last_ind);
  }

  /**
   * Extracts the logical value from the comment encountered within an encoding of a <code>file_population</code> instance.
   */
  private final int process_logical(Token token, String com, int c_ind) throws SdaiException {
    int ind = -1;
    for (int i = 0; i < c_ind; i++) {
      if (token.string[i] == DOT) {
        ind = i + 1;
        break;
      }
    }
    if (ind < 0) {
      printCommentError(AdditionalMessages.RD_WLFP, com);
      return 0;
    }
    if (token.string[ind] == 'F') {
      return 1;
    }
    else if (token.string[ind] == 'T') {
      return 2;
    }
    else if (token.string[ind] == 'U') {
      return 3;
    }
    else {
      printCommentError(AdditionalMessages.RD_WLFP, com);
      return 0;
    }
  }

  /**
   * Extracts the digit from the comment encountered within an encoding of a <code>file_population</code> instance.
   */
  private final int process_digit(Token token, String com, int c_ind) throws SdaiException {
    int ind = -1;
    for (int i = 0; i < c_ind; i++) {
      if (token.string[i] != SPACE) {
        ind = i;
        break;
      }
    }
    if (ind < 0) {
      printCommentError(AdditionalMessages.RD_WDFP, com);
      return 0;
    }
    if (token.string[ind + 1] != SPACE || token.string[ind + 1] != COMMA_b) {
// print warning
    }
    int dig = token.string[ind] - '0';
    if (dig < 0 || dig > 4) {
      printCommentError(AdditionalMessages.RD_WDFP, com);
      return 0;
    }
    return dig;
  }

  /**
   * Processes the aggregate in the comment encountered within an encoding of a <code>file_population</code> instance.
   */
  private final void process_aggregate(Token token, String com, int c_ind, A_string aggr) throws SdaiException {
    int ind;
    int start_ind = -1;
    int end_ind;
    int count = 0;
    String str;
    for (int i = 0; i < c_ind; i++) {
      if (token.string[i] == LEFT_PARENTHESIS) {
        start_ind = i;
        break;
      }
    }
    if (start_ind < 0) {
      printCommentError(AdditionalMessages.RD_WAFP, com);
      return;
    }
    start_ind++;
    ind = start_ind;
    while (token.string[ind] != RIGHT_PARENTHESIS) {
      int ap_count = 0;
      while ((token.string[ind] != COMMA_b || ap_count < 2) && token.string[ind] != RIGHT_PARENTHESIS) {
        if (token.string[ind] == APOSTROPHE) {
          ap_count++;
        }
        ind++;
        if (ind >= c_ind) {
          printCommentError(AdditionalMessages.RD_WAFP, com);
          break;
        }
      }
      if (ind >= c_ind) {
        printCommentError(AdditionalMessages.RD_WAFP, com);
        break;
      }
      end_ind = ind;
      if (start_ind + 3 <= end_ind) {
        str = process_string(token, com, start_ind, end_ind);
        if (str == null) {
          printCommentError(AdditionalMessages.RD_WAFP, com);
        }
        else {
          aggr.addByIndexPrivate(count + 1, str);
          count++;
        }
      }
      else {
//				printCommentError(AdditionalMessages.RD_WAFP, com);
      }
      start_ind = end_ind + 1;
      if (token.string[ind] == COMMA_b) {
        ind++;
      }
    }
//System.out.println(" 00000 PhFileReader   aggr.myLength: " + aggr.myLength);
  }

  /**
   * Reads parameters of the encoding of an instance in internal mapping mode
   * (within <code>entity_instance_RHS</code> method).
   */
  private final void parameters(CEntity_definition def, long instance_identifier) throws SdaiException, java.io.IOException {
    int count_of_values;
    int count_of_attributes, count_of_partial_values = -1;
    int index_to_partial_types;
    int index, count;
    CEntity_definition partial_def;
    EntityValue partial_entity_values = null;

    StaticFields staticFields;
    scan.get_token(token);
    if (token.type == ERROR) {
      staticFields = StaticFields.get();
      scanning_exception(token, staticFields.current_instance_identifier, null);
    }
    if (token.type == LPAREN || token.type == ENTITY_NAME || (8 <= token.type && token.type <= 12) || (20 <= token.type && token.type <= 25)) {
      boolean too_many = false;
      index_to_partial_types = 0;
      index = def.externalMappingIndexing[0];
      partial_def = def.partialEntityTypes[index];
      if (SdaiSession.debug2) {
        System.out.println(" index1 = " + index + "   name = " + partial_def.getCorrectName());
      }
      count_of_values = 1;
      count = partial_def.noOfPartialAttributes;
      if (SdaiSession.debug2) {
        System.out.println("def: " + def.getCorrectName() + "   ext_map_length: " + def.externalMappingIndexing.length);
      }
      if (SdaiSession.debug2) {
        System.out.println("partial_def: " + partial_def.getCorrectName() + "   ident: #" + partial_def.instance_identifier);
      }
      entity_values.entityValues[index].count = count;
      if (SdaiSession.debug2) {
        System.out.println("partial values index = " + index + "    count_of_attributes = " + count);
      }
      count_of_attributes = count;
      if (SdaiSession.debug2) {
        System.out.println("count_of_attributes = " + count_of_attributes);
      }
      if (SdaiSession.debug2) {
        System.out.println("count_of_values = " + count_of_values);
      }
      if (SdaiSession.debug2) {
        System.out.println("def.externalMappingIndexing.length = " + def.externalMappingIndexing.length);
      }
      while (count_of_values > count_of_attributes) {
        index_to_partial_types++;
        if (index_to_partial_types >= def.externalMappingIndexing.length) {
          too_many = true;
          EntityValue.printWarningToLogo(active_session, AdditionalMessages.RD_DFEX, instance_identifier);
          break;
        }
        index = def.externalMappingIndexing[index_to_partial_types];
        partial_def = def.partialEntityTypes[index];
        if (SdaiSession.debug2) {
          System.out.println("partial_def 2 : " + partial_def.getCorrectName());
        }
        if (SdaiSession.debug2) {
          System.out.println(" index2 = " + index + "   name = " + partial_def.getCorrectName());
        }
        count = partial_def.noOfPartialAttributes;
        entity_values.entityValues[index].count = count;
        if (SdaiSession.debug2) {
          System.out.println("partial values index 2 = " + index + "    count_of_attributes = " + count);
        }
        count_of_attributes += count;
      }
      if (!too_many) {
        partial_entity_values = entity_values.entityValues[index];
        if (partial_entity_values.values == null) {
          if (SdaiSession.NUMBER_OF_VALUES >= count) {
            partial_entity_values.values = new Value[SdaiSession.NUMBER_OF_VALUES];
          }
          else {
            partial_entity_values.values = new Value[count];
          }
        }
        else if (partial_entity_values.values.length < count) {
          partial_entity_values.enlarge(count);
        }
        partial_entity_values.def = partial_def;
        count_of_partial_values = 0;
        if (partial_entity_values.values[0] == null) {
          partial_entity_values.values[0] = new Value();
        }
        aggr_violation = false;
        parameter(partial_entity_values.values[0]);
        if (aggr_violation) {
          partial_entity_values.values[0].check_aggregate(((CEntityDefinition) def).attributes[0], instance_identifier,
              take_entity_name_for_exception(), active_session);
        }
      }
      else if (token.type == ENTITY_NAME || token.type == LPAREN) {
        parameter(null);
      }
      scan.get_token(token);
      if (token.type == ERROR) {
        staticFields = StaticFields.get();
        scanning_exception(token, staticFields.current_instance_identifier, null);
      }

      int warn_count = 0;
      while (token.type != RPAREN) {
        while (token.type == COMMA) {
          scan.get_token(token);
          if (token.type == ERROR) {
            staticFields = StaticFields.get();
            scanning_exception(token, staticFields.current_instance_identifier, null);
          }
          count_of_values++;
          if (count_of_values > count_of_attributes && !too_many) {
            while (count_of_values > count_of_attributes) {
              index_to_partial_types++;
              if (index_to_partial_types >= def.externalMappingIndexing.length) {
                too_many = true;
                break;
              }
              index = def.externalMappingIndexing[index_to_partial_types];
              partial_def = def.partialEntityTypes[index];
              count = partial_def.noOfPartialAttributes;
              if (SdaiSession.debug2) {
                System.out.println(" count_of_values = " + count_of_values);
              }
              if (SdaiSession.debug2) {
                System.out.println(" count_of_attributes = " + count_of_attributes);
              }
              if (SdaiSession.debug2) {
                System.out.println(" index3 = " + index + "   name = " + partial_def.getCorrectName() + "    count = " + count);
              }
              if (SdaiSession.debug2) {
                System.out.println("  entity_values.entityValues[1].count = " + entity_values.entityValues[1].count);
              }
              entity_values.entityValues[index].count = count;
              count_of_attributes += count;
            }
            if (!too_many) {
              partial_entity_values = entity_values.entityValues[index];
              if (partial_entity_values.values == null) {
                if (SdaiSession.NUMBER_OF_VALUES >= count) {
                  partial_entity_values.values = new Value[SdaiSession.NUMBER_OF_VALUES];
                }
                else {
                  partial_entity_values.values = new Value[count];
                }
              }
              else if (partial_entity_values.values.length < count) {
                partial_entity_values.enlarge(count);
              }
              count_of_partial_values = -1;
              partial_entity_values.def = partial_def;
            }
          }
          if (!too_many) {
            count_of_partial_values++;
            if (partial_entity_values.values[count_of_partial_values] == null) {
              partial_entity_values.values[count_of_partial_values] = new Value();
            }
            aggr_violation = false;
            parameter(partial_entity_values.values[count_of_partial_values]);
            if (aggr_violation) {
              partial_entity_values.values[count_of_partial_values].check_aggregate(((CEntityDefinition) def).attributes[count_of_values - 1],
                  instance_identifier, take_entity_name_for_exception(), active_session);
            }
          }
          else if (token.type == ENTITY_NAME || token.type == LPAREN) {
            parameter(null);
          }
          scan.get_token(token);
          if (token.type == ERROR) {
            staticFields = StaticFields.get();
            scanning_exception(token, staticFields.current_instance_identifier, new String(token.string));
          }
        }
        if (token.type == RPAREN || warn_count >= BOUND_ON_WARNINGS_COUNT) {
          break;
        }
        parsing_warning(active_session, token, WRONG_TOKEN, AdditionalMessages.RD_TOKE, token_image[RPAREN]);
        warn_count++;
        while (token.type != COMMA && token.type != RPAREN) {
          scan.get_token(token);
          if (token.type == ERROR) {
            staticFields = StaticFields.get();
            parsing_exception(token, AdditionalMessages.RD_CORP, AdditionalMessages.RD_INST,
                Long.toString(staticFields.current_instance_identifier));
          }
          if (token.type != COMMA && token.type != RPAREN) {
            if (warn_count >= BOUND_ON_WARNINGS_COUNT) {
              break;
            }
            parsing_warning(active_session, token, WRONG_TOKEN, AdditionalMessages.RD_TOKE, token_image[RPAREN]);
            warn_count++;
          }
        }
        if (token.type != COMMA && warn_count >= BOUND_ON_WARNINGS_COUNT) {
          break;
        }
      }
      boolean too_less = false;
      if (count_of_partial_values < partial_entity_values.count - 1) {
        for (int j = count_of_partial_values + 1; j < partial_entity_values.count; j++) {
          if (partial_entity_values.values[j] == null) {
            partial_entity_values.values[j] = new Value();
          }
          partial_entity_values.values[j].tag = MISSING;
          too_less = true;
        }
      }
      if (index_to_partial_types < def.externalMappingIndexing.length - 1) {
        for (int i = index_to_partial_types + 1; i < def.externalMappingIndexing.length; i++) {
          index = def.externalMappingIndexing[i];
          partial_def = def.partialEntityTypes[index];
          if (SdaiSession.debug2) {
            System.out.println(" index4 = " + index + "   name = " + partial_def.getCorrectName());
          }
          count = partial_def.noOfPartialAttributes;
          partial_entity_values = entity_values.entityValues[index];
          if (partial_entity_values.values == null) {
            if (SdaiSession.NUMBER_OF_VALUES >= count) {
              partial_entity_values.values = new Value[SdaiSession.NUMBER_OF_VALUES];
            }
            else {
              partial_entity_values.values = new Value[count];
            }
          }
          else if (partial_entity_values.values.length < count) {
            partial_entity_values.enlarge(count);
          }
          partial_entity_values.count = count;
          partial_entity_values.def = partial_def;
          for (int j = 0; j < count; j++) {
            if (partial_entity_values.values[j] == null) {
              partial_entity_values.values[j] = new Value();
            }
            partial_entity_values.values[j].tag = MISSING;
            too_less = true;
          }
        }
      }
      if (too_less) {
        EntityValue.printWarningToLogo(active_session, AdditionalMessages.RD_VLEA, instance_identifier);
      }
      if (too_many) {
        EntityValue.printWarningToLogo(active_session, AdditionalMessages.RD_VEXA, instance_identifier);
      }
    }
  }

  /**
   * Reads parameters of the encoding of an instance in internal mapping mode
   * (within <code>entity_instance_RHS</code> method) in the case when by some
   * reasons JSDAI failed to create an instance for the entity name found in
   * the encoding (instances are created by <code>object</code> method in <code>Create_instance</code> class).
   */
  private final void parameters() throws SdaiException, java.io.IOException {
    StaticFields staticFields;
    int count_of_values = 0;
    if (entity_values.entityValues[0] == null) {
      entity_values.entityValues[0] = new EntityValue(active_session);
    }
    EntityValue partial_entity_values = entity_values.entityValues[0];
    scan.get_token(token);
    if (token.type == ERROR) {
      staticFields = StaticFields.get();
      scanning_exception(token, staticFields.current_instance_identifier, null);
    }
    if (token.type == LPAREN || token.type == ENTITY_NAME || (8 <= token.type && token.type <= 12) || (20 <= token.type && token.type <= 25)) {
      if (partial_entity_values.values == null) {
        partial_entity_values.values = new Value[SdaiSession.NUMBER_OF_VALUES];
      }
      if (partial_entity_values.values[0] == null) {
        partial_entity_values.values[0] = new Value();
      }
      parameter(partial_entity_values.values[0]);
      count_of_values++;
      scan.get_token(token);
      if (token.type == ERROR) {
        staticFields = StaticFields.get();
        scanning_exception(token, staticFields.current_instance_identifier, null);
      }
      while (token.type == COMMA) {
        scan.get_token(token);
        if (token.type == ERROR) {
          staticFields = StaticFields.get();
          scanning_exception(token, staticFields.current_instance_identifier, null);
        }
        count_of_values++;
        if (partial_entity_values.values.length < count_of_values) {
          partial_entity_values.enlarge(count_of_values);
        }
        if (partial_entity_values.values[count_of_values - 1] == null) {
          partial_entity_values.values[count_of_values - 1] = new Value();
        }
        parameter(partial_entity_values.values[count_of_values - 1]);
        scan.get_token(token);
        if (token.type == ERROR) {
          staticFields = StaticFields.get();
          scanning_exception(token, staticFields.current_instance_identifier, new String(token.string));
        }
      }
    }
  }

  /**
   * Reads parameters representing elements of an aggregate in the encoding
   * of an instance. Speaking differently, processes the text of the exchange
   * structure enclosed between left parenthesis and right parenthesis on the
   * right-hand side of the instance description. In the case of nested
   * aggregates the method can be invoked recursively.
   */
  private final void embedded_list(Value value) throws SdaiException, java.io.IOException {
    StaticFields staticFields;
    int index_in_list = -1;
    scan.get_token(token);
    if (token.type == ERROR) {
      staticFields = StaticFields.get();
      scanning_exception(token, staticFields.current_instance_identifier, null);
    }
    if (value != null && value.nested_values == null) {
      value.nested_values = new Value[SdaiSession.NUMBER_OF_VALUES];
    }
    if (token.type == LPAREN || token.type == ENTITY_NAME || (8 <= token.type && token.type <= 12) || (20 <= token.type && token.type <= 25)) {
      if (token.type != REDEFINE) {
        if (value != null) {
          index_in_list++;
//					if (index_in_list >= value.nested_values.length) {
//						value.enlarge();
//					}
          if (value.nested_values[index_in_list] == null) {
            value.nested_values[index_in_list] = new Value();
          }
        }
        if (data_section_processing) {
          if (value != null) {
            parameter(value.nested_values[index_in_list]);
          }
          else if (token.type == ENTITY_NAME || token.type == LPAREN) {
            parameter(null);
          }
        }
        else {
          parameter_in_header(value.nested_values[index_in_list]);
        }
      }
      scan.get_token(token);
      if (token.type == ERROR) {
        staticFields = StaticFields.get();
        scanning_exception(token, staticFields.current_instance_identifier, null);
      }

      int warn_count = 0;
      while (token.type != RPAREN) {
        while (token.type == COMMA) {
          scan.get_token(token);
          if (token.type == ERROR) {
            staticFields = StaticFields.get();
            scanning_exception(token, staticFields.current_instance_identifier, null);
          }
          if (token.type != REDEFINE) {
            if (value != null) {
              index_in_list++;
              if (index_in_list >= value.nested_values.length) {
                value.enlarge();
              }
              if (value.nested_values[index_in_list] == null) {
                value.nested_values[index_in_list] = new Value();
              }
            }
            if (data_section_processing) {
              if (value != null) {
                parameter(value.nested_values[index_in_list]);
                if (index_in_list > 0) {
                  boolean res = is_non_conforming(value.nested_values[index_in_list - 1], value.nested_values[index_in_list]);
                  if (res) {
                    aggr_violation = true;
                  }
                }
              }
              else if (token.type == ENTITY_NAME || token.type == LPAREN) {
                parameter(null);
              }
            }
            else {
              parameter_in_header(value.nested_values[index_in_list]);
            }
          }
          scan.get_token(token);
          if (token.type == ERROR) {
            staticFields = StaticFields.get();
            parsing_exception(token, AdditionalMessages.RD_CORP, AdditionalMessages.RD_INST,
                Long.toString(staticFields.current_instance_identifier));
          }
        }
        if (token.type == RPAREN || warn_count >= BOUND_ON_WARNINGS_COUNT) {
          break;
        }
        parsing_warning(active_session, token, WRONG_TOKEN, AdditionalMessages.RD_TOKE, token_image[RPAREN]);
        warn_count++;
        while (token.type != COMMA && token.type != RPAREN) {
          scan.get_token(token);
          if (token.type == ERROR) {
            staticFields = StaticFields.get();
            parsing_exception(token, AdditionalMessages.RD_CORP, AdditionalMessages.RD_INST,
                Long.toString(staticFields.current_instance_identifier));
          }
          if (token.type != COMMA && token.type != RPAREN) {
            if (warn_count >= BOUND_ON_WARNINGS_COUNT) {
              break;
            }
            parsing_warning(active_session, token, WRONG_TOKEN, AdditionalMessages.RD_TOKE, token_image[RPAREN]);
            warn_count++;
          }
        }
        if (token.type != COMMA && warn_count >= BOUND_ON_WARNINGS_COUNT) {
          break;
        }
      }

    }
    if (value != null) {
      value.integer = index_in_list + 1;
      value.length = index_in_list + 1;
    }
  }

  private final boolean is_non_conforming(Value value_prev, Value value_next) throws SdaiException, java.io.IOException {
    switch (value_prev.tag) {
      case INTEGER:
      case REAL:
        if (value_next.tag == INTEGER || value_next.tag == REAL) {
          return false;
        }
        return true;
      case LOGICAL:
      case ENUM:
      case STRING:
      case BINARY:
        if (value_next.tag != value_prev.tag) {
          return true;
        }
        return false;
      case ENTITY_REFERENCE:
      case ENTITY_REFERENCE_SPECIAL:
        if (value_next.tag == ENTITY_REFERENCE || value_next.tag == ENTITY_REFERENCE_SPECIAL) {
          return false;
        }
        return true;
    }
    return false;
  }

  /**
   * Writes the parameter taken from the encoding of an instance (as variable <code>token</code>) to the object of class
   * <code>Value</code> submitted
   * as an argument to this method. The method is applied to reading instances
   * in data sections (but not in the header).
   */
  private final void parameter(Value value) throws SdaiException, java.io.IOException {
//long time1, time2;
    StaticFields staticFields;
    switch (token.type) {
      case MISSING:
        value.tag = MISSING;
        break;
      case REDEFINE:
        value.tag = REDEFINE;
        break;
      case INTEGER:
        value.tag = INTEGER;
        value.integer = token.integer;
        break;
      case REAL:
        value.tag = REAL;
        value.real = token.real;
        break;
      case LOGICAL:
        value.tag = LOGICAL;
        value.integer = token.integer;
        break;
      case ENUM:
        value.tag = ENUM;
        value.string = getStringBasicLatin();
        break;
      case STRING:
        value.tag = STRING;
        value.string = getString();
        break;
      case BINARY:
        value.tag = BINARY;
        value.reference = new Binary(token.string, token.length);
        break;
      case ENTITY_NAME:
        if (value != null) {
          value.tag = TYPED_PARAMETER;
          value.string = getStringBasicLatin();
          value.integer = 1;
        }
        consume_token(LPAREN);
        if (value != null) {
          if (value.nested_values == null) {
            value.nested_values = new Value[SdaiSession.NUMBER_OF_VALUES];
          }
          if (value.nested_values[0] == null) {
            value.nested_values[0] = new Value();
          }
        }
        scan.get_token(token);
        if (token.type == ERROR) {
          staticFields = StaticFields.get();
          scanning_exception(token, staticFields.current_instance_identifier, null);
        }
        if (value != null) {
          parameter(value.nested_values[0]);
        }
        else if (token.type == ENTITY_NAME || token.type == LPAREN) {
          parameter(null);
        }
        consume_token(RPAREN);
        break;
      case INSTANCE_NAME:
//						if (inside_scope > 0) break;
        value.tag = ENTITY_REFERENCE;
        staticFields = StaticFields.get();
        if (token.integer == staticFields.current_instance_identifier) {
          value.integer = -1;
          autoreference_found = true;
          break;
        }
        value.integer = token.integer;
        boolean found = tree.insert(null, value.integer);
//time2 = System.currentTimeMillis();time_insert_first += (time2 - time1);
        value.reference = tree.reference_node.content;
        if (value.reference instanceof CLateBindingEntity) {
          CLateBindingEntity forward = (CLateBindingEntity) tree.reference_node.content;
          if (length_of_array_of_inverse >= array_of_inverse.length) {
            enlarge_array_of_inverse();
          }
          array_of_inverse[length_of_array_of_inverse] = forward;
          length_of_array_of_inverse++;
          value.tag = ENTITY_REFERENCE_SPECIAL;
        }
        break;
      case LPAREN:
        if (value != null) {
          value.tag = EMBEDDED_LIST;
        }
        embedded_list(value);
        if (token.type != RPAREN) {
          parsing_exception(token, WRONG_TOKEN, AdditionalMessages.RD_TOKE, token_image[RPAREN]);
        }
        break;
    }
  }

  /**
   * Writes the parameter taken from the encoding of an instance (as variable <code>token</code>) to the object of class
   * <code>Value</code> submitted
   * as an argument to this method. The method is applied to reading instances
   * in header only (not in data sections).
   */
  private final void parameter_in_header(Value value) throws SdaiException, java.io.IOException {
    switch (token.type) {
      case MISSING:
        value.tag = MISSING;
        break;
      case REDEFINE:
        parsing_exception(token, WRONG_VALUE_IN_HEADER, null, null);
      case INTEGER:
        value.tag = INTEGER;
        value.integer = token.integer;
        break;
      case REAL:
        value.tag = REAL;
        value.real = token.real;
        break;
      case LOGICAL:
        value.tag = LOGICAL;
        value.integer = token.integer;
        break;
      case ENUM:
        value.tag = ENUM;
        value.string = getStringBasicLatin();
        break;
      case STRING:
        value.tag = STRING;
        value.string = getString();
        break;
      case BINARY:
        value.tag = BINARY;
        value.reference = new Binary(token.string, token.length);
        break;
      case ENTITY_NAME:
        value.tag = TYPED_PARAMETER;
        value.string = getStringBasicLatin();
        value.integer = 1;
        consume_token(LPAREN);
        if (value.nested_values == null) {
          value.nested_values = new Value[SdaiSession.NUMBER_OF_VALUES];
        }
        if (value.nested_values[0] == null) {
          value.nested_values[0] = new Value();
        }
        parameter(value.nested_values[0]);
        consume_token(RPAREN);
        break;
      case INSTANCE_NAME:
        parsing_exception(token, WRONG_VALUE_IN_HEADER, null, null);
      case LPAREN:
        value.tag = EMBEDDED_LIST;
        embedded_list(value);
        if (token.type != RPAREN) {
          parsing_exception(token, WRONG_TOKEN, AdditionalMessages.RD_TOKE, token_image[RPAREN]);
        }
        break;
    }
  }

  /**
   * Reads parameters of the data section (that is, those given in parenthesis
   * after keyword <code>DATA</code>, see ammendment to "ISO 10303-21"). This
   * method is activated only for an exchange structure containing more than one
   * data section.
   */
  private final String[] data_section_parameters(SdaiRepository repository) throws SdaiException, java.io.IOException {
    int error = 0;
    if (entity_values.entityValues[0] == null) {
      entity_values.entityValues[0] = new EntityValue(active_session);
    }
    parameters(entity_values.entityValues[0]);
    if (token.type != RPAREN) {
      parsing_exception(token, WRONG_TOKEN, AdditionalMessages.RD_TOKE, token_image[RPAREN]);
    }
    consume_token(SEMICOLON);
    String[] strs = new String[3];
    if (entity_values.entityValues[0].count < 2) {
      error = TOO_LESS_VALUES;
    }
    else if (entity_values.entityValues[0].values[0].tag != STRING) {
      error = INCORRECT_VALUE;
    }
    else {
      strs[0] = entity_values.entityValues[0].values[0].string;
    }
    strs[2] = null;
    if (error > 0) {
      parsing_exception(token, error, null, null);
    }
    Value value = entity_values.entityValues[0].values[1];
    if (value.tag != EMBEDDED_LIST) {
      parsing_exception(token, INCORRECT_VALUE, null, null);
    }
    Value value_in_list = value.nested_values[0];
    if (value_in_list.tag == STRING) {
      String str = value_in_list.string;
      strs[2] = str;
//			A_string ident = repository.file_schema.schema_identifiers;
      A_string ident = repository.file_schema.schema_identifiers_short;
      boolean found = false;
      String id;
      for (int i = 1; i <= ident.myLength; i++) {
        id = ident.getByIndex(i);
        if (id.equals(str)) {
          found = true;
          break;
        }
        else if (repository.verify_schema_name(id, str) != null) {
          found = true;
          break;
        }
      }
      if (found) {
        strs[1] = str;
      }
      else {
        error = INVALID_STRING_IN_DSECTION;
      }
    }
    else {
      error = IMPROPER_LIST_ITEM;
    }
    if (value.integer > 1) {
      error = TOO_MANY_VALUES_IN_DSECTION;
    }
    if (error > 0) {
      parsing_exception(token, error, null, null);
    }
    return strs;
  }

  /**
   * Reads a data section. More specifically:
   * - takes parameters of the data section in the case when the exchange
   * structure contains more than one data section;
   * - extracts the data dictionary model representing Express schema that is
   * underlying for the data section being considered;
   * - prepares a model for application data (either promotes an existing
   * virtual one to the state of an ordinary model or creates a new one);
   * the read-write access of the model is started;
   * - finds or creates a schema instance with which the application data
   * model is associated;
   * - reads encoding of instances from the data section in the exchange
   * structure and creates entity instances which are put into application
   * data model.
   */
  private final void data_section(SchemaInstance schema_instance, SdaiRepository repository) throws SdaiException, java.io.IOException {
    long time_dictionary_creation = 0;
    long time_before_invocation, time_after_invocation;
    String[] strs = null;
    String name_searched = null, model_name = null, or_name = null;
    int count = repository.model_count + 1;
    scan.get_token(token);
    if (token.type == ERROR) {
      scanning_exception(token, -1, null);
    }
    A_string s_ids_orig;
    boolean found = false;
    if (token.type == LPAREN) {
      strs = data_section_parameters(repository);
      if (strs[1] != null) {
        model_dic = SdaiSession.systemRepository.get_schema_model(strs[1]);
      }
      if (model_dic == null) {
        name_searched = strs[1] + SdaiSession.DICTIONARY_NAME_SUFIX;
      }
      else {
        name_searched = model_dic.name;
        found = true;
      }
      model_name = strs[0];
      or_name = strs[2];
      if (or_name == null) {
        s_ids_orig = repository.file_schema.schema_identifiers;
        if (s_ids_orig.myLength == 1) {
          or_name = (String) s_ids_orig.myData;
        }
      }
    }
    else if (token.type != SEMICOLON) {
      parsing_exception(token, WRONG_TOKEN, AdditionalMessages.RD_TOKE, token_image[SEMICOLON]);
    }
    else {
      s_ids_orig = repository.file_schema.schema_identifiers;
      if (s_ids_orig.myLength == 1) {
        or_name = (String) s_ids_orig.myData;
      }
      else if (s_ids_orig.myLength > 1) {
        // Workaround for bug #2526
        // The right way would be to have method
        // String[] getOriginalSchemaNames()
//				or_name = (String)((Object[])s_ids_orig.myData)[0];
        or_name = s_ids_orig.getByIndex(1);
      }
      model_dic = repository.get_schema_model();
      if (model_dic != null) {
        name_searched = model_dic.name;
        found = true;
      }
      else {
        A_string s_ids = repository.file_schema.schema_identifiers_short;
        Object[] myDataA;
        String express;
        if (s_ids.myLength == 1) {
          express = (String) s_ids.myData;
        }
        else if (s_ids.myLength == 2) {
          myDataA = (Object[]) s_ids.myData;
          express = (String) myDataA[0];
        }
        else {
          ListElement element;
          if (s_ids.myLength <= CAggregate.SHORT_AGGR) {
            element = (ListElement) s_ids.myData;
          }
          else {
            myDataA = (Object[]) s_ids.myData;
            element = (ListElement) myDataA[0];
          }
          express = (String) element.object;
        }
        name_searched = express + SdaiSession.DICTIONARY_NAME_SUFIX;
      }
      model_name = "default";
    }
    ASdaiModel set = SdaiSession.systemRepository.models;
    SdaiModel m;
    int i;
    if (!found) {
      for (i = 0; i < set.myLength; i++) {
        m = (SdaiModel) set.myData[i];
        if (m.name.equals(name_searched)) {
          model_dic = m;
          found = true;
          break;
        }
      }
    }
    if (!found || model_dic.described_schema == null) {
      time_before_invocation = System.currentTimeMillis();
      SdaiModel new_dict = SdaiSession.systemRepository.findDictionarySdaiModel(name_searched);
      time_after_invocation = System.currentTimeMillis();
      time_dictionary_creation += (time_after_invocation - time_before_invocation);
      if (!found) {
        model_dic = new_dict;
        found = true;
      }
    }
    if (found) {
      if (model_dic.getMode() == SdaiModel.NO_ACCESS) {
        time_before_invocation = System.currentTimeMillis();
        model_dic.startReadOnlyAccess();
        time_after_invocation = System.currentTimeMillis();
        time_dictionary_creation += (time_after_invocation - time_before_invocation);
      }
      repository.internal_usage = true;
      model_app = repository.findSdaiModel(model_name);
      repository.internal_usage = false;
      if (model_app != null) {
        if (model_app.underlying_schema == null && model_app.dictionary == null) {
          model_app.promoteVirtualToOrdinary(model_dic);
        }
        else {
          throw new SdaiException(SdaiException.MO_DUP, model_app, AdditionalMessages.AX_NAME + model_name);
        }
      }
      else {
        if (SdaiSession.debug2) {
          System.out.println("   repository name = " + repository.name);
        }
        if (SdaiSession.debug2) {
          System.out.println("  schema name in Reader = " + model_dic.described_schema.getName(null));
        }
        model_app = repository.createSdaiModel(model_name, model_dic.described_schema);
//System.out.println("PhFileReader  model_app: " + model_app.name + "    its repo name: " + model_app.repository.name +
//"    its repo: " + model_app.repository + "  session: " + model_app.repository.getSession());
        model_app.created = true;
      }
      modelSet.add(model_app);
      model_app.modified_by_import = true;
      if (strs != null) {
        model_app.schema_name = strs[1];
      }
      model_app.startReadWriteAccess();
      model_app.inst_deleted_permanently = true;
      model_app.original_name = or_name;

      int impl_level = 0;
      boolean impl_lev_found = true;
      boolean numeric = true;
      int k;
      int dig;
      int semicolon_pos = file_repo.implementation_level.indexOf(';');
      if (semicolon_pos <= 0) {
        for (k = 0; k < file_repo.implementation_level.length(); k++) {
          dig = file_repo.implementation_level.charAt(k) - '0';
          if (dig < 0 || dig > 9) {
            numeric = false;
          }
        }
        if (numeric) {
          if (file_repo.implementation_level.length() == 1) {
            impl_level = file_repo.implementation_level.charAt(0) - '0';
          }
          else {
            impl_level = Integer.parseInt(file_repo.implementation_level);
          }
        }
        else {
          impl_lev_found = false;
        }
      }
      else {
        for (k = 0; k < semicolon_pos; k++) {
          dig = file_repo.implementation_level.charAt(k) - '0';
          if (dig < 0 || dig > 9) {
            numeric = false;
          }
        }
        if (numeric) {
          for (k = semicolon_pos + 1; k < file_repo.implementation_level.length(); k++) {
            dig = file_repo.implementation_level.charAt(k) - '0';
            if (dig < 0 || dig > 9) {
              numeric = false;
            }
          }
        }
        if (numeric) {
          if (semicolon_pos == 1) {
            impl_level = file_repo.implementation_level.charAt(0) - '0';
          }
          else {
            String str = file_repo.implementation_level.substring(0, semicolon_pos);
            impl_level = Integer.parseInt(str);
          }
        }
        else {
          impl_lev_found = false;
        }
      }
      if (!impl_lev_found) {
        AdditionalMessages.printWarningToLogo(repository.session, AdditionalMessages.RD_WRIL);
        impl_level = 2;
      }

      if (impl_level <= 2 && populations_count <= 0) {
        SchemaInstance sch_inst;
        SchemaInstance appl_schema_instance = null;
        for (int j = 0; j < repository.schemas.myLength; j++) {
          sch_inst = (SchemaInstance) repository.schemas.myData[j];
          if (sch_inst.native_schema == model_dic.described_schema || sch_inst.dictionary == model_dic) {
            appl_schema_instance = sch_inst;
            break;
          }
        }
        if (appl_schema_instance == null) {
          int sch_count = repository.schema_count + 1;
          appl_schema_instance = repository.createSchemaInstance("schema" + sch_count, model_dic.described_schema);
          appl_schema_instance.created = true;
          appl_schema_instance.modified_by_import = appl_schema_instance.modified;
          appl_schema_instance.modified = false;
        }
        boolean saved_value = appl_schema_instance.modified;
        appl_schema_instance.modified = false;
        appl_schema_instance.addSdaiModel(model_app);
        if (appl_schema_instance.modified) {
          appl_schema_instance.modified_by_import = true;
        }
        appl_schema_instance.modified = saved_value;
        model_app.modified_outside_contents_by_import = model_app.modified_outside_contents;
        model_app.modified_outside_contents = false;
        if (appl_schema_instance.moved_data_status <= 0) {
          appl_schema_instance.moved_data_status = 1;
        }
      }
    }
    else {
      action_exception(DICTIONARY_MODEL_NOT_FOUND, AdditionalMessages.RD_MODL, name_searched);
    }

    scan.get_token(token);
    if (token.type == ERROR) {
      scanning_exception(token, -1, null);
    }
    if (token.type == ENDSEC) {
      consume_token(SEMICOLON);
      return;
    }
    else if (token.type != INSTANCE_NAME) {
      parsing_exception(token, WRONG_TOKEN, AdditionalMessages.RD_TOKE, token_image[INSTANCE_NAME]);
    }
//CEntity_definition edef = (CEntity_definition)model_dic.repository.getSessionIdentifier("#2118");
//System.out.println("  READER entity: " + edef.getName(null) + "   ident: #" + edef.instance_identifier);
//System.out.println("  READER partial_attrs = " + edef.noOfPartialAttributes);
    data_entity();
    scan.get_token(token);
    if (token.type == ERROR) {
      scanning_exception(token, -1, null);
    }
    while (token.type == INSTANCE_NAME) {
      data_entity();
      scan.get_token(token);
      if (token.type == ERROR) {
        scanning_exception(token, -1, null);
      }
    }
    if (token.type != ENDSEC) {
      parsing_exception(token, WRONG_TOKEN, AdditionalMessages.RD_TOKE, token_image[ENDSEC]);
    }
    consume_token(SEMICOLON);
//		SdaiSession.println("--- Dictionary creation time=" + time_dictionary_creation/1000 + "sec");
  }

  /**
   * Creates an instance from its encoding in the exchange structure. More
   * specifically:
   * - creates an instance of the needed entity data type;
   * - collects values into the object of class <code>ComplexEntityValue</code> (field <code>entity_values</code> in the current
   * class);
   * - inserts the created instance into a binary tree which is a data structure
   * used for storing the objects of the following two types:
   * 1) entity instances;
   * 2) references to not existing at the current moment entity instances
   * (so-called forward references); the type of these objects is <code>CLateBindingEntity</code>. In the case when the entity
   * instance
   * is just created and for it an object of <code>CLateBindingEntity</code> in the binary tree already exists, the latter is
   * replaced by the former.
   * This mechanism allows to read an exchange structure in one pass;
   * - assigns the values (taken from <code>entity_values</code>) to the attributes
   * of the created entity instance.
   */
  private final void data_entity() throws SdaiException, java.io.IOException {
    int i;
    long instance_identifier, saved_instance_identifier;
//long time1, time2;
//long time3, time4;

    instance_identifier = token.integer;
//if (instance_identifier == 16) Value.prnt = true; else Value.prnt = false;
    StaticFields staticFields = StaticFields.get();
    staticFields.current_instance_identifier = instance_identifier;
    consume_token(EQUALS);
    scan.get_token(token);
    if (token.type == ERROR) {
      scanning_exception(token, instance_identifier, null);
    }
    if (token.type == SCOPE) {
      saved_instance_identifier = instance_identifier;
      inside_scope++;
      scan.get_token(token);
      if (token.type == ERROR) {
        scanning_exception(token, saved_instance_identifier, null);
      }
      if (token.type != INSTANCE_NAME) {
        parsing_exception(token, WRONG_TOKEN, AdditionalMessages.RD_TOKE, token_image[INSTANCE_NAME]);
      }
      data_entity();
      scan.get_token(token);
      if (token.type == ERROR) {
        scanning_exception(token, saved_instance_identifier, null);
      }
      while (token.type == INSTANCE_NAME) {
        data_entity();
        scan.get_token(token);
        if (token.type == ERROR) {
          scanning_exception(token, saved_instance_identifier, null);
        }
      }
      if (token.type != ENDSCOPE) {
        parsing_exception(token, WRONG_TOKEN, AdditionalMessages.RD_TOKE, token_image[ENDSCOPE]);
      }
      scan.get_token(token);
      if (token.type == ERROR) {
        scanning_exception(token, saved_instance_identifier, null);
      }
      if (token.type == SLASH) {
        entity_export();
        scan.get_token(token);
        if (token.type == ERROR) {
          scanning_exception(token, saved_instance_identifier, null);
        }
      }
      inside_scope--;
      instance_identifier = saved_instance_identifier;
    }

    length_of_array_of_inverse = 0;
    instance_name_length = 0;
    CEntity created_instance = entity_instance_RHS(staticFields, instance_identifier);
    if (created_instance == null) {
      return;
    }
    if (instance_identifier == 0 && zero_inst == null) {
      zero_inst = created_instance;
    }
    if (user_defined_entity) {
      EntityValue.printWarningToLogo(active_session, AdditionalMessages.RD_UDEN, instance_identifier);
      return;
    }
//		if (inside_scope == 0) {
    if (largest_identifier < instance_identifier) {
      largest_identifier = instance_identifier;
    }
    CLateBindingEntity forward;
//		for (i = 0; i < length_of_array_of_inverse; i++) {
//			forward = array_of_inverse[i];
//			forward.inverseAdd((CEntity)created_instance);
//		}
    created_instance.instance_identifier = instance_identifier;
    boolean found = tree.insert(created_instance, instance_identifier);
//time2 = System.currentTimeMillis();time_insert_second += (time2 - time1);
    if (found) {
      forward = tree.replace(created_instance);
//time2 = System.currentTimeMillis();time_replace += (time2 - time1);
      if (forward == null) {
        String entity_name_for_exception = take_entity_name_for_exception();
        action_exception(token, DUPLICATE_INSTANCE, instance_identifier, entity_name_for_exception);
      }
    }
    if (SdaiSession.debug2) {
      print_entity_values(instance_identifier);
    }
    if (autoreference_found) {
      resolve_autoreference(created_instance);
    }
//if (instance_identifier == 891) print_entity_values(instance_identifier);
    created_instance.setAll(entity_values);
//if (instance_identifier==211)
    created_instance.instance_position = CEntity.INS_MASK | created_instance.instance_position; //--VV-- Instance state tracking --
//		}
//time4 = System.currentTimeMillis();time_data_entity += (time4 - time3);
  }

  /**
   * Processes the right-hand side (entity name and parameters) in the encoding
   * of a (data section) entity instance. More specifically, creates an instance
   * of the required entity data type and puts the parameters into <code>entity_values</code>.
   */
  private final CEntity entity_instance_RHS(StaticFields staticFields, long instance_identifier) throws SdaiException, java.io.IOException {
    int number_of_items_in_complex_instance;
    CEntity created_instance = null;
    CEntity_definition def;
    if (token.type == USER_DEFINED_KEYWORD || token.type == ENTITY_NAME) {
      complex_entity = false;
      if (token.type == ENTITY_NAME) {
        try {
          created_instance = create.object(token.string, token.length, model_dic, model_app, instance_identifier, 1, 1);
          staticFields.c_instance = created_instance;
        }
        catch (java.lang.IllegalAccessException ex) {
          String entity_name_for_exception = take_entity_name_for_exception();
          action_exception(token, ILLEGAL_ACCESS, instance_identifier, entity_name_for_exception);
        }
        catch (java.lang.InstantiationException ex) {
          String entity_name_for_exception = take_entity_name_for_exception();
          action_exception(token, CLASS_NOT_FOUND, instance_identifier, entity_name_for_exception);
        }
        if (created_instance == null) {
          def = null;
        }
        else {
          def = (CEntity_definition) created_instance.getInstanceType();
          entity_values.def = def;
          if (def.noOfPartialEntityTypes > entity_values.entityValues.length) {
            entity_values.enlarge(def.noOfPartialEntityTypes);
          }
          else {
            for (int i = 0; i < def.noOfPartialEntityTypes; i++) {
              if (entity_values.entityValues[i] == null) {
                entity_values.entityValues[i] = new EntityValue(active_session);
              }
            }
          }
        }
        consume_token(LPAREN);
        if (created_instance == null) {
          parameters();
        }
        else {
          parameters(def, instance_identifier);
        }
        if (token.type != RPAREN) {
          parsing_exception(token, WRONG_TOKEN, AdditionalMessages.RD_TOKE, token_image[RPAREN]);
        }
//				print_entity_values(instance_identifier);
        user_defined_entity = false;
      }
      else {
        if (complex_name[0].entity_name.length < token.length) {
          complex_name[0].enlarge_entity_name(token.length, token.string);
        }
        consume_token(LPAREN);
        created_instance = new $USER_DEFINED_ENTITY();
        (($USER_DEFINED_ENTITY) created_instance).name = new String(token.string, 0, token.length);
        if (entity_values.entityValues[0] == null) {
          entity_values.entityValues[0] = new EntityValue(active_session);
        }
        parameters(entity_values.entityValues[0]);
        if (token.type != RPAREN) {
          parsing_exception(token, WRONG_TOKEN, AdditionalMessages.RD_TOKE, token_image[RPAREN]);
        }
        user_defined_entity = true;
      }
    }
    else if (token.type == LPAREN) {
      complex_entity = true;
      instance_name_length = 0;
      consume_token(ENTITY_NAME);
      instance_name_length += (token.length + 1);
      if (complex_name[0].entity_name.length < token.length) {
        complex_name[0].enlarge_entity_name(token.length, token.string);
      }
      else {
        System.arraycopy(token.string, 0, complex_name[0].entity_name, 0, token.length);
        complex_name[0].length_of_entity_name = token.length;
      }
      consume_token(LPAREN);
      if (entity_values.entityValues[0] == null) {
        entity_values.entityValues[0] = new EntityValue(active_session);
      }
      parameters(entity_values.entityValues[0]);
      number_of_items_in_complex_instance = 1;
      if (token.type != RPAREN) {
        parsing_exception(token, WRONG_TOKEN, AdditionalMessages.RD_TOKE, token_image[RPAREN]);
      }
      scan.get_token(token);
      while (token.type == ENTITY_NAME) {
        instance_name_length += (token.length + 1);
        if (number_of_items_in_complex_instance >= complex_name.length) {
          enlarge_complex_name();
        }
        if (complex_name[number_of_items_in_complex_instance].entity_name.length < token.length) {
          complex_name[number_of_items_in_complex_instance].enlarge_entity_name(token.length, token.string);
        }
        else {
          System.arraycopy(token.string, 0, complex_name[number_of_items_in_complex_instance].entity_name, 0, token.length);
          complex_name[number_of_items_in_complex_instance].length_of_entity_name = token.length;
        }
        consume_token(LPAREN);
        if (number_of_items_in_complex_instance >= entity_values.entityValues.length) {
          entity_values.enlarge(number_of_items_in_complex_instance + 1);
        }
        else {
          if (entity_values.entityValues[number_of_items_in_complex_instance] == null) {
            entity_values.entityValues[number_of_items_in_complex_instance] = new EntityValue(active_session);
          }
        }
        parameters(entity_values.entityValues[number_of_items_in_complex_instance]);
        number_of_items_in_complex_instance++;
        if (token.type != RPAREN) {
          parsing_exception(token, WRONG_TOKEN, AdditionalMessages.RD_TOKE, token_image[RPAREN]);
        }
        scan.get_token(token);
      }
      instance_name_length--;
      take_name(number_of_items_in_complex_instance);
      try {
        created_instance = create.object(instance_name, instance_name_length, model_dic, model_app, instance_identifier,
            number_of_items_in_complex_instance, number_of_items_in_complex_instance);
        staticFields.c_instance = created_instance;
      }
      catch (java.lang.IllegalAccessException ex) {
        String entity_name_for_exception = take_entity_name_for_exception();
        action_exception(token, ILLEGAL_ACCESS, instance_identifier, entity_name_for_exception);
      }
      catch (java.lang.InstantiationException ex) {
        String entity_name_for_exception = take_entity_name_for_exception();
        action_exception(token, CLASS_NOT_FOUND, instance_identifier, entity_name_for_exception);
      }
      if (created_instance != null) {
        def = (CEntity_definition) created_instance.getInstanceType();
        entity_values.def = def;
//if (def==null)
//System.out.println("PhFileReader def is NULL  entity class name: " + created_instance.getClass().getName());
        int tot_attr_count = 0;
        for (int i = 0; i < def.noOfPartialEntityTypes; i++) {
          entity_values.entityValues[i].def = def.partialEntityTypes[i];
          if (entity_values.entityValues[i].count != def.partialEntityTypes[i].noOfPartialAttributes) {
            EntityValue.printWarningToLogo(active_session, AdditionalMessages.RD_VADI, instance_identifier);
          }
// Below is a new code
          if (!inst_values_violation) {
            continue;
          }
          for (int j = 0; j < entity_values.entityValues[i].count; j++) {
            Value val = entity_values.entityValues[i].values[j];
            if (val.types_count == 0) {
              continue;
            }
            val.check_aggregate(((CEntityDefinition) def).attributes[tot_attr_count + j], instance_identifier, take_entity_name_for_exception(),
                active_session);
            val.types_count = 0;
          }
          tot_attr_count += def.partialEntityTypes[i].noOfPartialAttributes;
        }
        inst_values_violation = false;
      }
      if (token.type != RPAREN) {
        parsing_exception(token, WRONG_TOKEN, AdditionalMessages.RD_TOKE, token_image[RPAREN]);
      }
    }
    else {
      parsing_exception(token, ENTITY_EXPECTED, null, null);
    }
    consume_token(SEMICOLON);
    return created_instance;
  }

  /**
   * Reads the data contained in the export list attached to a scope structure
   * (see "ISO 10303-21::9.3 Scope structure").
   */
  private final void entity_export() throws SdaiException, java.io.IOException {
    consume_token(INSTANCE_NAME);
    scan.get_token(token);
    while (token.type == COMMA) {
      consume_token(INSTANCE_NAME);
      scan.get_token(token);
    }
    if (token.type != SLASH) {
      parsing_exception(token, WRONG_TOKEN, AdditionalMessages.RD_TOKE, token_image[SLASH]);
    }
  }

  /**
   * Checks if the current token read from the exchange structure is of the
   * specified type. If not, then <code>SdaiException</code> is thrown.
   */
  final private void consume_token(int type) throws SdaiException, java.io.IOException {
    scan.get_token(token);
    if (token.type == ERROR) {
      scanning_exception(token, -1, null);
    }
    if (token.type != type) {
      if (type == ISO_BEGIN) {
        parsing_warning(active_session, token, WRONG_TOKEN, AdditionalMessages.RD_TOKE, token_image[type]);
      }
      else {
        parsing_exception(token, WRONG_TOKEN, AdditionalMessages.RD_TOKE, token_image[type]);
      }
    }
  }

  /**
   * Constructs the so-called java name of the complex entity.
   * Having this name, a complex entity instance is created.
   */
  final private void take_name(int number_of_items_in_complex_instance) throws SdaiException {
    int i, j, k;

    if (instance_name_length > instance_name.length) {
      int new_length = instance_name.length * 2;
      if (new_length < instance_name_length) {
        new_length = instance_name_length;
      }
      instance_name = new byte[new_length];
    }
    for (i = 0, k = -1; i < number_of_items_in_complex_instance; i++) {
      for (j = 0; j < complex_name[i].length_of_entity_name; j++) {
        k++;
        instance_name[k] = complex_name[i].entity_name[j];
      }
      if (i < number_of_items_in_complex_instance - 1) {
        k++;
        instance_name[k] = (byte) '$';
      }
    }
  }

  /**
   * Puts simple entity data types in the alphabetical order within the complex entity
   * being considered. Violations of the order may (by mistake) happen
   * when external mapping mode for an instance is used. In addition, objects
   * of <code>EntityValue</code> within <code>entity_values</code> are reordered
   * accordingly, and the so-called java name of the complex entity is constructed.
   * This method is invoked in <code>Create_instance</code> class.
   */
  byte[] remedy_complex_name(int number_of_items_in_complex_instance) throws SdaiException {
    int i, j, k;
    boolean order_changed = false;
    for (i = 0; i < number_of_items_in_complex_instance; i++) {
      for (j = i; j > 0 && compare_names(j - 1, j) > 0; j--) {
        PartialEntityName name = complex_name[j - 1];
        complex_name[j - 1] = complex_name[j];
        complex_name[j] = name;
        EntityValue evalue = entity_values.entityValues[j - 1];
        entity_values.entityValues[j - 1] = entity_values.entityValues[j];
        entity_values.entityValues[j] = evalue;
        order_changed = true;
      }
    }
    if (enl_instance_name_length > instance_name.length) {
      int new_length = instance_name.length * 2;
      if (new_length < enl_instance_name_length) {
        new_length = enl_instance_name_length;
      }
      instance_name = new byte[new_length];
    }
    for (i = 0, k = -1; i < number_of_items_in_complex_instance; i++) {
      for (j = 0; j < complex_name[i].length_of_entity_name; j++) {
        k++;
        instance_name[k] = complex_name[i].entity_name[j];
      }
      if (i < number_of_items_in_complex_instance - 1) {
        k++;
        instance_name[k] = (byte) '$';
      }
    }
    if (order_changed) {
      return instance_name;
    }
    else {
      return null;
    }
  }

  byte[] extendComplexName(SdaiModel mod, int items_count, CEntityDefinition[] sep_defs, int[] sep_def_inds, int sep_count, long instance_identifier)
      throws SdaiException {
    save_entity_values(items_count);
    if (saved_ent_name == null) {
      if (PARTIAL_ENTITIES_COUNT >= items_count) {
        saved_ent_name = new PartialEntityName[PARTIAL_ENTITIES_COUNT];
      }
      else {
        saved_ent_name = new PartialEntityName[items_count];
      }
    }
    else if (saved_ent_name.length < items_count) {
      saved_ent_name = new PartialEntityName[items_count];
    }
    System.arraycopy(complex_name, 0, saved_ent_name, 0, items_count);
    int ext_count = separateDefValues(items_count, sep_defs, sep_def_inds, sep_count, instance_identifier);
    if (ext_count < 0) {
      return null;
    }
    int count = items_count;
    enl_instance_name_length = instance_name_length;
    SchemaData sch_data = mod.underlying_schema.modelDictionary.schemaData;
    for (int i = items_count; i < ext_count; i++) {
      CEntityDefinition def = entity_values.entityValues[i].def;
      if (count >= complex_name.length) {
        enlarge_complex_name();
      }
      int index_to_entity = sch_data.findEntityExtentIndex(def);
      if (index_to_entity < 0) {
        System.arraycopy(saved_ent_name, 0, complex_name, 0, items_count);
        return null;
      }
      byte[] b_name = sch_data.bNames[index_to_entity];
//String str = new String(b_name, 0, b_name.length);
//System.out.println("PhFileReader *****  b_name: " + str);
      if (complex_name[count].entity_name.length < b_name.length) {
        complex_name[count].enlarge_entity_name(b_name.length, b_name);
      }
      else {
        System.arraycopy(b_name, 0, complex_name[count].entity_name, 0, b_name.length);
        complex_name[count].length_of_entity_name = b_name.length;
      }
      enl_instance_name_length += (b_name.length + 1);
      count++;
    }
    remedy_complex_name(count);
    return instance_name;
  }

  void restoreComplexName(int items_count) throws SdaiException {
    int i, j;
    int m = items_count;
    for (i = 0; i < items_count; i++) {
      boolean missing = true;
      for (j = 0; j < items_count; j++) {
        if (complex_name[i] == saved_ent_name[j]) {
          missing = false;
          break;
        }
      }
      if (missing) {
        complex_name[m] = complex_name[i];
        m++;
      }
    }
    System.arraycopy(saved_ent_name, 0, complex_name, 0, items_count);
    req_instance_name_length = enl_instance_name_length;
    if (req_instance_name == null) {
      if (COMPLEX_ENTITY_NAME_LENGTH >= req_instance_name_length) {
        req_instance_name = new byte[COMPLEX_ENTITY_NAME_LENGTH];
      }
      else {
        req_instance_name = new byte[req_instance_name_length];
      }
    }
    else if (req_instance_name_length > req_instance_name.length) {
      int new_length = req_instance_name.length * 2;
      if (new_length < req_instance_name_length) {
        new_length = req_instance_name_length;
      }
      req_instance_name = new byte[new_length];
    }
    inst_is_required = true;
    for (i = 0; i < req_instance_name_length; i++) {
      req_instance_name[i] = instance_name[i];
    }
    int k = -1;
    for (i = 0; i < items_count; i++) {
      for (j = 0; j < complex_name[i].length_of_entity_name; j++) {
        k++;
        instance_name[k] = complex_name[i].entity_name[j];
      }
      if (i < items_count - 1) {
        k++;
        instance_name[k] = (byte) '$';
      }
    }
  }

  void setNameLength() throws SdaiException {
    instance_name_length = enl_instance_name_length;
  }

  void save_entity_values(int items_count) throws SdaiException {
    if (partial_values == null) {
      if (items_count <= NAMES_ARRAY_SIZE) {
        partial_values = new EntityValue[NAMES_ARRAY_SIZE];
      }
      else {
        partial_values = new EntityValue[items_count];
      }
    }
    else if (items_count > partial_values.length) {
      enlarge_partial_values(items_count);
    }
    for (int i = 0; i < items_count; i++) {
      partial_values[i] = entity_values.entityValues[i];
    }
  }

  void restore_entity_values(int items_count) throws SdaiException {
    int i, j, k;
    if (begin_ent_values == null) {
      if (items_count <= NAMES_ARRAY_SIZE) {
        begin_ent_values = new EntityValue[NAMES_ARRAY_SIZE];
      }
      else {
        begin_ent_values = new EntityValue[items_count];
      }
    }
    else if (items_count > begin_ent_values.length) {
      enlarge_begin_ent_values(items_count);
    }
    if (used_ent_values == null) {
      if (items_count <= NAMES_ARRAY_SIZE) {
        used_ent_values = new int[NAMES_ARRAY_SIZE];
      }
      else {
        used_ent_values = new int[items_count];
      }
    }
    else if (items_count > used_ent_values.length) {
      enlarge_used_ent_values(items_count);
    }
    for (i = 0; i < items_count; i++) {
      begin_ent_values[i] = entity_values.entityValues[i];
      used_ent_values[i] = 0;
    }
    for (i = 0; i < items_count; i++) {
      entity_values.entityValues[i] = partial_values[i];
    }
    for (i = 0; i < items_count; i++) {
      for (j = 0; j < items_count; j++) {
        if (partial_values[i] == begin_ent_values[j]) {
          used_ent_values[j] = -1;
          partial_values[i] = null;
          break;
        }
      }
    }
    for (i = 0, k = -1; i < items_count; i++) {
      if (used_ent_values[i] < 0) {
        continue;
      }
      for (j = k + 1; j < items_count; j++) {
        if (partial_values[j] != null) {
          k = j;
          break;
        }
      }
      used_ent_values[i] = k;
    }
    for (i = 0; i < items_count; i++) {
      if (used_ent_values[i] < 0) {
        continue;
      }
      EntityValue target = partial_values[used_ent_values[i]];
      for (j = items_count; j < entity_values.entityValues.length; j++) {
        if (entity_values.entityValues[j] == target) {
          entity_values.entityValues[j] = begin_ent_values[i];
        }
      }
    }
  }

  int separateDefValues(CEntityDefinition def, int items_count, int ln, int def_index, long instance_identifier) throws SdaiException {
    int i, j;
    int val_count = entity_values.entityValues[def_index].count;
    int enl_ln = ln + def.noOfPartialEntityTypes;
    if (enl_ln > entity_values.entityValues.length) {
      entity_values.enlarge(enl_ln);
    }
    else {
      for (i = ln; i < enl_ln; i++) {
        if (entity_values.entityValues[i] == null) {
          entity_values.entityValues[i] = new EntityValue(active_session);
        }
      }
    }
    boolean too_less = false;
    int accum_count = 0;
    int index;
    if (used_ent_values == null) {
      if (def.noOfPartialEntityTypes <= NAMES_ARRAY_SIZE) {
        used_ent_values = new int[NAMES_ARRAY_SIZE];
      }
      else {
        used_ent_values = new int[def.noOfPartialEntityTypes];
      }
    }
    else if (def.noOfPartialEntityTypes > used_ent_values.length) {
      enlarge_used_ent_values(def.noOfPartialEntityTypes);
    }
    CEntity_definition partial_def;
    for (i = 0; i < def.noOfPartialEntityTypes; i++) {
      index = def.externalMappingIndexing[i];
      partial_def = def.partialEntityTypes[index];
      if (findPartialEntity(items_count, partial_def, def)) {
        used_ent_values[index] = -1;
      }
      else {
        used_ent_values[index] = 0;
      }
    }
    for (i = 0, j = 0; i < def.noOfPartialEntityTypes; i++) {
      if (used_ent_values[i] == -1) {
        j++;
        enl_ln--;
      }
      else {
        used_ent_values[i] = j;
      }
    }
    for (i = 0; i < def.noOfPartialEntityTypes; i++) {
      index = def.externalMappingIndexing[i];
      if (used_ent_values[index] < 0) {
        continue;
      }
      partial_def = def.partialEntityTypes[index];
      int count = partial_def.noOfPartialAttributes;
      int index_mod = index - used_ent_values[index];
      EntityValue partial_entity_values = entity_values.entityValues[ln + index_mod];
      partial_entity_values.count = count;
      partial_entity_values.def = partial_def;
      if (partial_entity_values.values == null) {
        if (SdaiSession.NUMBER_OF_VALUES >= count) {
          partial_entity_values.values = new Value[SdaiSession.NUMBER_OF_VALUES];
        }
        else {
          partial_entity_values.values = new Value[count];
        }
      }
      else if (partial_entity_values.values.length < count) {
        partial_entity_values.enlarge(count);
      }
      for (j = 0; j < count; j++) {
        if (accum_count >= val_count) {
          too_less = true;
          if (partial_entity_values.values[j] == null) {
            partial_entity_values.values[j] = new Value();
          }
          partial_entity_values.values[j].tag = MISSING;
        }
        else {
          if (partial_entity_values.values[j] == null) {
            partial_entity_values.values[j] = new Value();
          }
//					partial_entity_values.values[j] = entity_values.entityValues[def_index].values[accum_count++];
          partial_entity_values.values[j].copyValueStepFile(entity_values.entityValues[def_index].values[accum_count]);
          accum_count++;
        }
      }
    }
    if (too_less) {
      EntityValue.printWarningToLogo(active_session, AdditionalMessages.RD_VLEA, instance_identifier);
    }
    if (accum_count < val_count) {
      EntityValue.printWarningToLogo(active_session, AdditionalMessages.RD_VEXA, instance_identifier);
    }
    index = -1;
    CEntity_definition parent_def = (CEntity_definition) complex_name[def_index].def;
    EntityValue ev_saved = entity_values.entityValues[def_index];
    for (i = ln; i < enl_ln; i++) {
      EntityValue ev = entity_values.entityValues[i];
      if (parent_def == ev.def) {
        entity_values.entityValues[def_index] = ev;
        index = i;
        break;
      }
    }
    if (index < 0) {
      return -1;
    }
    for (i = index; i < enl_ln - 1; i++) {
      entity_values.entityValues[i] = entity_values.entityValues[i + 1];
    }
    entity_values.entityValues[enl_ln - 1] = ev_saved;
    return enl_ln - 1;
  }

  boolean findPartialEntity(int items_count, CEntityDefinition partial_def, CEntityDefinition except) throws SdaiException {
    for (int i = 0; i < items_count; i++) {
      if (complex_name[i].def == except) {
        continue;
      }
      if (partial_def == complex_name[i].def) {
        return true;
      }
    }
    return false;
  }

  int separateDefValues(int items_count, CEntityDefinition[] sep_defs, int[] sep_def_inds, int sep_count, long instance_identifier) throws SdaiException {
    int ev_count = items_count;
    for (int i = 0; i < sep_count; i++) {
      ev_count = separateDefValues(sep_defs[i], items_count, ev_count, sep_def_inds[i], instance_identifier);
      if (ev_count < 0) {
        break;
      }
    }
    return ev_count;
  }

  /**
   * Updates <code>entity_values</code> to represent the values of the entity
   * whose definition is given by the first parameter. This method is invoked
   * in the cases when JSDAI library does not contain entity whose instance
   * is found in the exchange structure. If this happens, JSDAI tries to select
   * another entity which is most similar to the missing one. The latter is
   * replaced by the selected entity. The current method transfers the values
   * of the attributes of the missing entity to the attributes of the
   * substitute. The new attributes of the substitute (that does not appear in
   * the missing entity) remain unset, whereas the values of those in the
   * missing entity but not in its substitute are ignored. All these operations
   * result in a new <code>entity_values</code>.
   * This method is invoked in <code>Create_instance</code> class.
   */
  void update_complex_entity_values(CEntityDefinition def, int[] ref2partial_values) throws SdaiException {
    int i, j;
//print_entity_values(240);
    int part_types_count = def.noOfPartialEntityTypes;
    if (partial_values == null) {
      if (part_types_count <= NAMES_ARRAY_SIZE) {
        partial_values = new EntityValue[NAMES_ARRAY_SIZE];
      }
      else {
        partial_values = new EntityValue[part_types_count];
      }
    }
    else if (part_types_count > partial_values.length) {
      enlarge_partial_values(part_types_count);
    }
    if (part_types_count > entity_values.entityValues.length) {
      entity_values.enlarge(part_types_count);
    }
    int ent_values_count = entity_values.entityValues.length;
    for (i = 0; i < ent_values_count; i++) {
      if (entity_values.entityValues[i] == null) {
        entity_values.entityValues[i] = new EntityValue(active_session);
      }
    }
    if (used_ent_values == null) {
      if (ent_values_count <= NAMES_ARRAY_SIZE) {
        used_ent_values = new int[NAMES_ARRAY_SIZE];
      }
      else {
        used_ent_values = new int[ent_values_count];
      }
    }
    else if (ent_values_count > used_ent_values.length) {
      enlarge_used_ent_values(ent_values_count);
    }
    for (i = 0; i < ent_values_count; i++) {
      used_ent_values[i] = 0;
    }
    for (i = 0; i < part_types_count; i++) {
      if (ref2partial_values[i] >= 0) {
        partial_values[i] = entity_values.entityValues[ref2partial_values[i]];
        used_ent_values[ref2partial_values[i]] = 1;
      }
    }
    for (i = 0; i < part_types_count; i++) {
      if (ref2partial_values[i] >= 0) {
        continue;
      }
      for (j = 0; j < ent_values_count; j++) {
        if (used_ent_values[j] == 0) {
          partial_values[i] = entity_values.entityValues[j];
          used_ent_values[j] = 1;
          break;
        }
      }
    }
    int k = ent_values_count - 1;
    for (i = ent_values_count - 1; i >= 0; i--) {
      if (used_ent_values[i] == 0) {
        entity_values.entityValues[k] = entity_values.entityValues[i];
        k--;
      }
    }
    for (i = 0; i < part_types_count; i++) {
      entity_values.entityValues[i] = partial_values[i];
      if (ref2partial_values[i] >= 0) {
        continue;
      }
      CEntityDefinition partial_def = def.partialEntityTypes[i];
      EntityValue entity_val = entity_values.entityValues[i];
      if (entity_val.values == null) {
        if (SdaiSession.NUMBER_OF_VALUES >= partial_def.noOfPartialAttributes) {
          entity_val.values = new Value[SdaiSession.NUMBER_OF_VALUES];
        }
        else {
          entity_val.values = new Value[partial_def.noOfPartialAttributes];
        }
      }
      else if (entity_val.values.length < partial_def.noOfPartialAttributes) {
        entity_val.enlarge(partial_def.noOfPartialAttributes);
      }
      entity_val.count = partial_def.noOfPartialAttributes;
      for (j = 0; j < partial_def.noOfPartialAttributes; j++) {
        if (entity_val.values[j] == null) {
          entity_val.values[j] = new Value();
        }
        entity_val.values[j].tag = MISSING;
      }
    }
//print_entity_values(241);
  }

  /**
   * Establishes references of an entity instance to itself. This method is
   * invoked in the cases when the variable <code>autoreference_found</code> is set to <code>true</code>.
   */
  final private void resolve_autoreference(CEntity instance) {
    for (int i = 0; i < entity_values.def.noOfPartialEntityTypes; i++) {
      EntityValue partval = entity_values.entityValues[i];
      for (int j = 0; j < partval.count; j++) {
        check_value(partval.values[j], instance);
      }
    }
    autoreference_found = false;
  }

  /**
   * Checks if the entity instance should reference itself. If so, then this
   * reference is settled.
   */
  final private void check_value(Value val, CEntity instance) {
    Value value_next;
    switch (val.tag) {
      case TYPED_PARAMETER:
        value_next = val.nested_values[0];
        check_value(value_next, instance);
        break;
      case ENTITY_REFERENCE:
        if (val.integer < 0) {
          StaticFields staticFields = StaticFields.get();
          val.integer = (int) staticFields.current_instance_identifier;
          val.reference = instance;
        }
        break;
      case EMBEDDED_LIST:
        for (int i = 0; i < val.length; i++) {
          value_next = val.nested_values[i];
          check_value(value_next, instance);
        }
        break;
      default:
        break;
    }
  }

  /**
   * Returns an internal array used to store the names of simple entity types
   * within a complex entity data type.
   * This method is invoked in <code>Create_instance</code> class.
   */
  PartialEntityName[] get_complex_name() {
    return complex_name;
  }

  /**
   * Compares two simple entity names within a complex entity type. Returns
   * value 1 if the first name is alphabetically larger, -1 if the first is
   * smaller, and 0 if the names coincide.
   */
  final private int compare_names(int first, int second) {
    int ln;
    int used_if_included;
    if (complex_name[first].length_of_entity_name < complex_name[second].length_of_entity_name) {
      used_if_included = -1;
      ln = complex_name[first].length_of_entity_name;
    }
    else if (complex_name[first].length_of_entity_name == complex_name[second].length_of_entity_name) {
      used_if_included = 0;
      ln = complex_name[first].length_of_entity_name;
    }
    else {
      used_if_included = 1;
      ln = complex_name[second].length_of_entity_name;
    }
    for (int i = 0; i < ln; i++) {
      if (complex_name[first].entity_name[i] < complex_name[second].entity_name[i]) {
        return -1;
      }
      else if (complex_name[first].entity_name[i] > complex_name[second].entity_name[i]) {
        return 1;
      }
    }
    return used_if_included;
  }

  /**
   * Returns the string described by the current token assuming
   * that all symbols are from the basic Latin alphabet.
   */
  final private String getStringBasicLatin() {
    if (token.length == 0) {
      return nullString;
    }
    else {
      return (new String(token.string, 0, token.length)).intern();
    }
  }

  /**
   * Returns the string described by the current token assuming that
   * to encode it the character sets of ISO 8859 and/or ISO 10646 might be used.
   */
  final private String getString() throws SdaiException {
    if (token.length == 0) {
      return nullString;
    }
    else {
      return analyse_string().intern();
    }
  }

  /**
   * Returns the string described by the current token assuming that
   * to encode it the character sets of ISO 8859 and/or ISO 10646 might be used.
   */
  final private String analyse_string() throws SdaiException {
    int i;
    int k = 0;
    int count = 0;
    int to_string = -1;
    int code;
    int mult;
    int numb = 0;
    byte bt;
    boolean iso10646 = false;
    String base, current_str;
    StaticFields staticFields;
    if (token.length > chars.length) {
      int new_length = chars.length * 2;
      if (new_length < token.length) {
        new_length = token.length;
      }
      chars = new char[new_length];
    }
//current_str = new String(token.string, 0, token.length);
//System.out.println("PhFileReader   ******   current_str: " + current_str);
    if (token.integer == 0) {
      if (token.length > 0) {
        return new String(token.string, 0, token.length);
      }
      else {
        return nullString;
      }
    }
    while (k < token.length) {
      if (token.string[k] == BACKSLASH) {
        k++;
        if (token.string[k] == BACKSLASH) {
          chars[count] = (char) token.string[k];
          count++;
          k++;
          continue;
        }
        switch (token.string[k]) {
          case CAPITAL_S:
            k++;
            if (token.string[k] != BACKSLASH) {
//							string_exception(AdditionalMessages.RD_WRST, new String(token.string, 0, k));
              string_warning(active_session, AdditionalMessages.RD_WRIS, new String(token.string, 0, k + 1), token, k + 1);
            }
            else {
              k++;
            }
            code = token.string[k];
            if (to_string >= 0) {
              code = iso8859[to_string][code - 32];
              if (code <= 0) {
//								string_exception(AdditionalMessages.RD_INCH, new String(token.string, 0, k));
                string_warning(active_session, AdditionalMessages.RD_INCS, new String(token.string, 0, k + 1), token, k + 1);
                code = iso8859[to_string][0];
              }
            }
            else {
              code += 128;
            }
            chars[count] = (char) code;
            count++;
            k++;
            break;
          case CAPITAL_P:
            k++;
            if (token.string[k] < 'A' || token.string[k] > 'I') {
//							string_exception(AdditionalMessages.RD_WRST, new String(token.string, 0, k));
              string_warning(active_session, AdditionalMessages.RD_WRIS, new String(token.string, 0, k + 1), token, k + 1);
              to_string = 0;
            }
            else {
              to_string = token.string[k] - 'A';
            }
            k++;
            if (token.string[k] != BACKSLASH) {
//							string_exception(AdditionalMessages.RD_WRST, new String(token.string, 0, k));
              string_warning(active_session, AdditionalMessages.RD_WRIS, new String(token.string, 0, k + 1), token, k + 1);
            }
            else {
              k++;
            }
            break;
          case CAPITAL_X:
            k++;
            switch (token.string[k]) {
              case BACKSLASH:
                code = 0;
                mult = 1;
                for (i = 0; i < 2; i++) {
                  bt = token.string[k + 2 - i];
                  if (bt >= '0' && bt <= '9') {
                    numb = bt - '0';
                  }
                  else if (bt >= 'A' && bt <= 'F') {
                    numb = bt - 'A' + 10;
                  }
                  else {
//										string_exception(AdditionalMessages.RD_WRST, new String(token.string, 0, k + 2 - i));
                    string_warning(active_session, AdditionalMessages.RD_WRIS, new String(token.string, 0, k + 3 - i), token, k + 3 - i);
                    numb = 0;
                  }
                  code += (mult * numb);
                  mult *= 16;
                }
                chars[count] = (char) code;
                count++;
                k += 3;
                break;
              case ZERO:
                k++;
                if (token.string[k] != BACKSLASH) {
//									string_exception(AdditionalMessages.RD_WRST, new String(token.string, 0, k));
                  string_warning(active_session, AdditionalMessages.RD_WRIS, new String(token.string, 0, k + 1), token, k + 1);
                }
                else {
                  k++;
                }
                if (iso10646) {
                  iso10646 = false;
                }
                else {
//									string_exception(AdditionalMessages.RD_WRST, new String(token.string, 0, k));
                  string_warning(active_session, AdditionalMessages.RD_WRIS, new String(token.string, 0, k), token, k);
                }
                break;
              case TWO:
                k++;
                if (token.string[k] != BACKSLASH) {
//									string_exception(AdditionalMessages.RD_WRST, new String(token.string, 0, k));
                  string_warning(active_session, AdditionalMessages.RD_WRIS, new String(token.string, 0, k + 1), token, k + 1);
                }
                else {
                  k++;
                }
                iso10646 = true;
                while (true) {
                  if (k >= token.length) {
                    break;
                  }
                  mult = 1;
                  bt = token.string[k];
                  if (!((bt >= '0' && bt <= '9') || (bt >= 'A' && bt <= 'F'))) {
                    break;
                  }
                  code = 0;
                  for (i = 0; i < 4; i++) {
                    bt = token.string[k + 3 - i];
                    if (bt >= '0' && bt <= '9') {
                      numb = bt - '0';
                    }
                    else if (bt >= 'A' && bt <= 'F') {
                      numb = bt - 'A' + 10;
                    }
                    else {
//											string_exception(AdditionalMessages.RD_WRST, new String(token.string, 0, k + 3 - i));
                      string_warning(active_session, AdditionalMessages.RD_WRIS, new String(token.string, 0, k + 4 - i), token, k + 4 - i);
                      numb = 0;
                    }
                    code += (mult * numb);
                    mult *= 16;
                  }
                  chars[count] = (char) code;
                  count++;
                  k += 4;
                }
                if (k >= token.length || token.string[k] != BACKSLASH) {
                  iso10646 = false;
                  staticFields = StaticFields.get();
                  EntityValue.printWarningToLogo(active_session, AdditionalMessages.RD_CDEM, staticFields.current_instance_identifier);
                }
                break;
              case FOUR:
                k++;
                if (token.string[k] != BACKSLASH) {
//									string_exception(AdditionalMessages.RD_WRST, new String(token.string, 0, k));
                  string_warning(active_session, AdditionalMessages.RD_WRIS, new String(token.string, 0, k + 1), token, k + 1);
                }
                else {
                  k++;
                }
                iso10646 = true;
                while (true) {
                  if (k >= token.length) {
                    break;
                  }
                  mult = 1;
                  bt = token.string[k];
                  if (!((bt >= '0' && bt <= '9') || (bt >= 'A' && bt <= 'F'))) {
                    break;
                  }
                  code = 0;
                  for (i = 0; i < 8; i++) {
                    bt = token.string[k + 7 - i];
                    if (bt >= '0' && bt <= '9') {
                      numb = bt - '0';
                    }
                    else if (bt >= 'A' && bt <= 'F') {
                      numb = bt - 'A' + 10;
                    }
                    else {
//											string_exception(AdditionalMessages.RD_WRST, new String(token.string, 0, k + 7 - i));
                      string_warning(active_session, AdditionalMessages.RD_WRIS, new String(token.string, 0, k + 8 - i), token, k + 8 - i);
                      numb = 0;
                    }
                    code += (mult * numb);
                    mult *= 16;
                  }
                  chars[count] = (char) code;
                  count++;
                  k += 8;
                }
                if (k >= token.length || token.string[k] != BACKSLASH) {
                  iso10646 = false;
                  staticFields = StaticFields.get();
                  EntityValue.printWarningToLogo(active_session, AdditionalMessages.RD_CDEM, staticFields.current_instance_identifier);
                }
                break;
              default:
//								string_exception(AdditionalMessages.RD_WRST, new String(token.string, 0, k));
                string_warning(active_session, AdditionalMessages.RD_WRIS, new String(token.string, 0, k + 1), token, k + 1);
                code = 0;
                mult = 1;
                for (i = 0; i < 2; i++) {
                  bt = token.string[k + 1 - i];
                  if (bt >= '0' && bt <= '9') {
                    numb = bt - '0';
                  }
                  else if (bt >= 'A' && bt <= 'F') {
                    numb = bt - 'A' + 10;
                  }
                  else {
                    string_warning(active_session, AdditionalMessages.RD_WRIS, new String(token.string, 0, k + 2 - i), token, k + 2 - i);
                    numb = 0;
                  }
                  code += (mult * numb);
                  mult *= 16;
                }
                chars[count] = (char) code;
                count++;
                k += 2;
            }
            break;
          default:
            string_warning(active_session, AdditionalMessages.RD_WRIS, new String(token.string, 0, k + 1), token, k + 1);
//						string_exception(AdditionalMessages.RD_WRST, new String(token.string, 0, k + 1), token);
            chars[count] = (char) BACKSLASH;
            count++;
            continue;
        }
      }
      else {
        chars[count] = (char) token.string[k];
        count++;
        k++;
      }
    }
    if (count > 0) {
      return new String(chars, 0, count);
    }
    else {
      return nullString;
    }
  }

  /**
   * Increases the size of the auxiliary array 'complex_name' twice.
   */
  final void enlarge_complex_name() {
    int new_length = complex_name.length * 2;
    PartialEntityName[] new_complex_name = new PartialEntityName[new_length];
    System.arraycopy(complex_name, 0, new_complex_name, 0, complex_name.length);
    for (int i = complex_name.length; i < new_length; i++) {
      new_complex_name[i] = new PartialEntityName();
    }
    complex_name = new_complex_name;
  }

  /**
   * Increases the size of the auxiliary array 'array_of_inverse' twice.
   */
  final private void enlarge_array_of_inverse() {
    int new_length = array_of_inverse.length * 2;
    CLateBindingEntity new_array_of_inverse[] = new CLateBindingEntity[new_length];
    System.arraycopy(array_of_inverse, 0, new_array_of_inverse, 0, array_of_inverse.length);
    array_of_inverse = new_array_of_inverse;
  }

  /**
   * Increases the size of the auxiliary array 'partial_values' either twice
   * or to satisfy the required demand, whichever of these two values is larger.
   */
  final private void enlarge_partial_values(int demand) {
    int new_length = partial_values.length * 2;
    if (new_length < demand) {
      new_length = demand;
    }
    partial_values = new EntityValue[new_length];
  }

  final private void enlarge_begin_ent_values(int demand) {
    int new_length = begin_ent_values.length * 2;
    if (new_length < demand) {
      new_length = demand;
    }
    begin_ent_values = new EntityValue[new_length];
  }

  /**
   * Increases the size of the auxiliary array 'used_ent_values' either twice
   * or to satisfy the required demand, whichever of these two values is larger.
   */
  final private void enlarge_used_ent_values(int demand) {
    int new_length = used_ent_values.length * 2;
    if (new_length < demand) {
      new_length = demand;
    }
    used_ent_values = new int[new_length];
  }

  /**
   * Returns the name of the instance currently being read from the exchange
   * structure.
   */
  final private String take_entity_name_for_exception() throws SdaiException {
    if (complex_entity) {
      return new String(instance_name, 0, instance_name_length);
    }
    else if (!user_defined_entity) {
      return entity_values.def.name;
    }
    else {
      return new String(complex_name[0].entity_name, 0, complex_name[0].length_of_entity_name);
    }
  }

  /**
   * Throws an <code>SdaiException</code> in the case when an error while scanning
   * of the exchange structure was encountered.
   */
  final private void scanning_exception(Token token, long inst_ident, String str) throws SdaiException {
    int line = token.line + 1;
    String base = SdaiSession.line_separator + AdditionalMessages.RD_SCAN + (String) error_table.messages.get(new Integer(token.integer)) /*
     * +
     * SdaiSession
     * .
     * line_separator
     * +
     * AdditionalMessages
     * .
     * RD_PHFI
     * +
     * phys_file
     */;
    if (inst_ident > 0) {
      base = base + SdaiSession.line_separator + AdditionalMessages.RD_INST + inst_ident;
    }
    base = base + SdaiSession.line_separator + "   Line: " + line + SdaiSession.line_separator + "   Column: " + token.column;
    if (str != null) {
      base = base + SdaiSession.line_separator + AdditionalMessages.RD_WTOK + str;
    }
    throw new SdaiException(SdaiException.SY_ERR, base);
  }

  /**
   * Throws an <code>SdaiException</code> in the case when an error while parsing
   * of the exchange structure was encountered.
   */
  final private void parsing_exception(Token token, int error_index, String str1, String str2) throws SdaiException {
    int line = token.line + 1;
    String base = SdaiSession.line_separator + AdditionalMessages.RD_PARS + (String) error_table.messages.get(new Integer(error_index)) +
//			SdaiSession.line_separator + AdditionalMessages.RD_PHFI + phys_file +
        SdaiSession.line_separator + "   Line: " + line + SdaiSession.line_separator + "   Column: " + token.column;
    StaticFields staticFields = StaticFields.get();
    long id = staticFields.current_instance_identifier;
    if (id > 0) {
      String str = SdaiSession.line_separator + "   Instance: #" + id;
      base = base + str;
    }
    if (str2 != null) {
      base = base + SdaiSession.line_separator + str1 + str2;
    }
    throw new SdaiException(SdaiException.SY_ERR, base);
  }

  final private void parsing_warning(Token token, int error_index, String str1, String str2, SdaiSession session) throws SdaiException {
    int line = token.line + 1;
    String base = AdditionalMessages.RD_PARS + (String) error_table.messages.get(new Integer(error_index)) + SdaiSession.line_separator + "   Line: "
        + line + SdaiSession.line_separator + "   Column: " + token.column;
    if (str2 != null) {
      base = base + SdaiSession.line_separator + str1 + str2;
    }
    if (session != null && session.logWriterSession != null) {
      session.printlnSession(base);
    }
    else {
      SdaiSession.println(base);
    }
  }

  /**
   * Throws an <code>SdaiException</code> in the case when an error while parsing
   * of the exchange structure was encountered.
   */
  final private void parsing_exception(Token token, String error_text, String str1, String str2) throws SdaiException {
    int line = token.line + 1;
    String base = SdaiSession.line_separator + AdditionalMessages.RD_PARS + error_text +
//			SdaiSession.line_separator + AdditionalMessages.RD_PHFI + phys_file +
        SdaiSession.line_separator + "   Line: " + line + SdaiSession.line_separator + "   Column: " + token.column;
    if (str2 != null) {
      base = base + SdaiSession.line_separator + str1 + str2;
    }
    throw new SdaiException(SdaiException.SY_ERR, base);
  }

  /**
   * Throws an <code>SdaiException</code> in the case when an error while processing
   * some information read from the exchange structure was encountered.
   * The information processed is not related with the instances in a data section
   * of the exchange structure.
   */
  final private void action_exception(int error_index, String str1, String str2) throws SdaiException {
    String base = SdaiSession.line_separator + AdditionalMessages.RD_ERR + (String) error_table.messages.get(new Integer(error_index)) /*
     * +
     * SdaiSession
     * .
     * line_separator
     * +
     * AdditionalMessages
     * .
     * RD_PHFI
     * +
     * phys_file
     */;
    if (str2 != null) {
      base = base + SdaiSession.line_separator + str1 + str2;
    }
    throw new SdaiException(SdaiException.SY_ERR, base);
  }

  /**
   * Throws an <code>SdaiException</code> in the case when an error while processing
   * some information read from the exchange structure was encountered.
   * The information processed is related with instances in a data section of the
   * exchange structure.
   */
  final private void action_exception(Token token, int error_index, long instance, String entity_name) throws SdaiException {
    int line = token.line + 1;
    String base = SdaiSession.line_separator + AdditionalMessages.RD_ERR + (String) error_table.messages.get(new Integer(error_index))
        +
//			SdaiSession.line_separator + AdditionalMessages.RD_PHFI + phys_file +
        SdaiSession.line_separator + "   Line: " + line + SdaiSession.line_separator + "   Column: " + token.column + SdaiSession.line_separator
        + AdditionalMessages.RD_INST + instance + SdaiSession.line_separator + AdditionalMessages.RD_ENT + entity_name;
    throw new SdaiException(SdaiException.SY_ERR, base);
  }

  /**
   * Throws an <code>SdaiException</code> in the case when an error while
   * analysing the string was encountered.
   */
  final private void string_exception(String error_message, String str) throws SdaiException {
    String base = SdaiSession.line_separator + error_message + SdaiSession.line_separator + AdditionalMessages.RD_WSTR + str;
    throw new SdaiException(SdaiException.SY_ERR, base);
  }

  final private void string_exception(String error_message, String str, Token token) throws SdaiException {
    int line = token.line + 1;
    String base = SdaiSession.line_separator + error_message + SdaiSession.line_separator + AdditionalMessages.RD_WSTR + str + SdaiSession.line_separator
        + "   Line: " + line + SdaiSession.line_separator + "   Column: " + token.column;
    throw new SdaiException(SdaiException.SY_ERR, base);
  }

  final private void string_warning(SdaiSession session, String warning_message, String str, Token token, int shift) throws SdaiException {
    int line = token.line + 1;
    int column = token.column + shift;
    String text = warning_message + SdaiSession.line_separator + AdditionalMessages.RD_WSTR + str + SdaiSession.line_separator + "   Line: " + line
        + SdaiSession.line_separator + "   Column: " + column;
    if (session != null && session.logWriterSession != null) {
      session.printlnSession(text);
    }
    else {
      SdaiSession.println(text);
    }
  }

  final private void parsing_warning(SdaiSession session, Token token, int error_index, String str1, String str2) throws SdaiException {
    int line = token.line + 1;
    String str = null;
    switch (token.type) {
      case INTEGER:
        str = Integer.toString(token.integer);
        break;
      case REAL:
        str = Double.toString(token.real);
        break;
      case LOGICAL:
        str = Integer.toString(token.integer);
        break;
      case ENUM:
        str = getStringBasicLatin();
        break;
      case STRING:
        str = getString();
        break;
      case ENTITY_NAME:
        str = getStringBasicLatin();
        break;
      case INSTANCE_NAME:
        str = "#" + token.integer;
        break;
      case LPAREN:
        str = "(";
        break;
    }
    String text = AdditionalMessages.RD_PARS + (String) error_table.messages.get(new Integer(error_index)) + SdaiSession.line_separator + "   Line: "
        + line + SdaiSession.line_separator + "   Column: " + token.column;
    if (str != null) {
      text = text + SdaiSession.line_separator + AdditionalMessages.RD_WTOK + str;
    }
    if (str2 != null) {
      text = text + SdaiSession.line_separator + str1 + str2;
    }
    if (session != null && session.logWriterSession != null) {
      session.printlnSession(text);
    }
    else {
      SdaiSession.println(text);
    }
  }

  /**
   * Prints a warning message to logo file.
   */
  private static void printWarningToLogo(SdaiSession session, String text, String section_name) throws SdaiException {
    if (session != null && session.logWriterSession != null) {
      session.printlnSession(text + SdaiSession.line_separator +
//				AdditionalMessages.RD_PHFI + phys_file + SdaiSession.line_separator +
          AdditionalMessages.RD_SENA + section_name);
    }
    else {
      SdaiSession.println(text + SdaiSession.line_separator +
//				AdditionalMessages.RD_PHFI + phys_file + SdaiSession.line_separator +
          AdditionalMessages.RD_SENA + section_name);
    }
  }

  /**
   * Prints a warning message to logo file.
   */
  private static void printWarningToLogo(SdaiSession session, String text, String file_pop, String wrong_token) throws SdaiException {
    if (session != null && session.logWriterSession != null) {
      session.printlnSession(text + SdaiSession.line_separator +
//				AdditionalMessages.RD_PHFI + phys_file + SdaiSession.line_separator +
          AdditionalMessages.RD_FPOP + file_pop + SdaiSession.line_separator + AdditionalMessages.RD_WTOK + wrong_token);
    }
    else {
      SdaiSession.println(text + SdaiSession.line_separator +
//				AdditionalMessages.RD_PHFI + phys_file + SdaiSession.line_separator +
          AdditionalMessages.RD_FPOP + file_pop + SdaiSession.line_separator + AdditionalMessages.RD_WTOK + wrong_token);
    }
  }

  static void printWarningToLogoSchiInst(SdaiSession session, String text, String schema, String included_schema) throws SdaiException {
    if (session != null && session.logWriterSession != null) {
      session.printlnSession(text + SdaiSession.line_separator + AdditionalMessages.BF_SCH + schema + SdaiSession.line_separator
          + AdditionalMessages.BF_ISCH + included_schema);
    }
    else {
      SdaiSession.println(text + SdaiSession.line_separator + AdditionalMessages.BF_SCH + schema + SdaiSession.line_separator
          + AdditionalMessages.BF_ISCH + included_schema);
    }
  }

  /**
   * Prints a warning message to logo file.
   */
  private static void printWarningToLogo(SdaiSession session, String file_name) throws SdaiException {
    String base = AdditionalMessages.RD_OSC1 + file_name + AdditionalMessages.RD_OSC2;
    if (session != null && session.logWriterSession != null) {
      session.printlnSession(base);
    }
    else {
      SdaiSession.println(base);
    }
  }

  /**
   * A method for debugging purposes. Used to print the contents of
   * ComplexEntityValue.
   */
  private void print_entity_values(long instance_identifier) throws SdaiException {
    int count = entity_values.def.noOfPartialEntityTypes;
    System.out.println("INSTANCE: #" + instance_identifier);
    for (int i = 0; i < count; i++) {
      EntityValue partval = entity_values.entityValues[i];
      String def_name = entity_values.def.partialEntityTypes[i].name;
      System.out.println("****** partial entity no. " + i + "   entity: " + def_name);
      for (int j = 0; j < partval.count; j++) {
        print_value(partval.values[j]);
        System.out.println("");
      }
    }
  }

  /**
   * A method for debugging purposes.
   */
  private void print_value(Value val) {
    Value value_next;
    String str;
    switch (val.tag) {
      case MISSING:
        System.out.print("$  ");
        break;
      case REDEFINE:
        System.out.print("*  ");
        break;
      case INTEGER:
        System.out.print(val.integer + "  ");
        break;
      case REAL:
        System.out.print(val.real + "  ");
        break;
      case LOGICAL:
        if (val.integer == 0) {
          System.out.print(".F.  ");
        }
        else if (val.integer == 1) {
          System.out.print(".T.  ");
        }
        else {
          System.out.print(".U.  ");
        }
        break;
      case ENUM:
        System.out.print("." + val.string + ".  ");
        break;
      case STRING:
        System.out.print("'" + val.string + "'  ");
        break;
      case BINARY:
        System.out.print("\"" + BINARY + "\"  ");
        break;
      case TYPED_PARAMETER:
        System.out.print(val.string + "(");
        value_next = val.nested_values[0];
        print_value(value_next);
        System.out.print(")  ");
        break;
      case ENTITY_REFERENCE:
        Object ref = val.reference;
        String ref_class = ref.getClass().getName();
        System.out.print(ref_class + "  ");
//				System.out.print("REF  ");
        break;
      case ENTITY_REFERENCE_SPECIAL:
        System.out.print("REF FORWARD  ");
        break;
      case EMBEDDED_LIST:
        System.out.print("(");
        for (int i = 0; i < val.length; i++) {
          value_next = val.nested_values[i];
          print_value(value_next);
        }
        System.out.print(")  ");
        break;
    }
  }

}
