/*
 * $Id$
 *
 * JSDAI(TM), a way to implement STEP, ISO 10303
 * Copyright (C) 1997-2008, LKSoftWare GmbH, Germany
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License
 * version 3 as published by the Free Software Foundation (AGPL v3).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * JSDAI is a registered trademark of LKSoftWare GmbH, Germany
 * This software is also available under commercial licenses.
 * See also http://www.jsdai.net/
 */

// %modified: 1016210368822 %

/* Generated By:JJTree: Do not edit this line. X_UnaryOp.java */
package jsdai.expressCompiler;

import jsdai.lang.*;
import jsdai.SExtended_dictionary_schema.*;

import java.util.*;

public class X_UnaryOp
    extends SimpleNode {

  // + = 1, - = 2, NOT = 3
  int operation;
  String operand;

  public X_UnaryOp(int id) {
    super(id);
  }

  public X_UnaryOp(Compiler2 p, int id) {
    super(p, id);
  }

  /**
   * Accept the visitor.
   **/
  public Object jjtAccept(Compiler2Visitor visitor, Object data)
      throws SdaiException {
    return visitor.visit(this, data);
  }

  /**
   * Accept the visitor.
   **/
  public Object childrenAccept(Compiler2Visitor visitor, Object data)
      throws SdaiException {
    JavaClass jc = (JavaClass) data;
    String op_type_str = "default";
    String operator_str = "DefaultUnaryOperator";
    int operand_1_type;
    int operand_2_type;
    int result_type = 0;
    EEntity exact_result_type = null;

    if (jc.flag_value) {
      if (children != null) {

        // additional java code forwarded, if present
        variable_names = new Vector();
        variable_declarations = new Vector();
        statements = new Vector();
        initializing_code = new Vector();

        for (int i = 0; i < children.length; ++i) {
          children[i].jjtAccept(visitor, data);

          if (jc != null) {
            if (jc.active) {
              if (((SimpleNode) children[i]).java_contains_statements) {
                java_contains_statements = true;

                // variable_declaration += "\n" + ((SimpleNode)children[i]).variable_declaration;
                for (int j = 0; j < ((SimpleNode) children[i]).variable_names.size(); j++) {
                  variable_names.add(((SimpleNode) children[i]).variable_names.elementAt(j));
                }

                for (int j = 0; j < ((SimpleNode) children[i]).variable_declarations.size(); j++) {
                  variable_declarations.add(((SimpleNode) children[i]).variable_declarations.elementAt(j));
                }

                for (int j = 0; j < ((SimpleNode) children[i]).statements.size(); j++) {
                  statements.add(((SimpleNode) children[i]).statements.elementAt(j));
                }

                // initializing_code += "\n" + ((SimpleNode)children[i]).initializing_code;
                for (int j = 0; j < ((SimpleNode) children[i]).initializing_code.size(); j++) {
                  initializing_code.add(((SimpleNode) children[i]).initializing_code.elementAt(j));
                }
              } // if contains statements

              //                     operand = jc.generated_java;
              //                     jc.generated_java = "";
            } // jc active

          } // jc not null

        } // for - loop through children

      } // if children

      operand = jc.generated_java;
      jc.generated_java = "";

      if (jc != null) {
        if (jc.active) {

          // let's say here we analyze the types of operands, and if numeric, then:
          //               jc.generated_java = "(";
          jc.generated_java = operand;

          // operand_1_type = operand_types[0]; // probably not needed
          //               for (int i = 0; i < children.length - 1; ++i) {
          // operand_2_type = operand_types[i+1]; // probably not needed
          // System.out.println("###_#- Operand 1: " + operand_1_type + ", operand 2: " + operand_2_type);
          switch (operation) {
            case 1:
              operator_str = "";
              break;

            case 2:
              operator_str = "negation";
              break;

            case 3:
              operator_str = "NOT";
              break;

            default:
              printActive("XP - UnaryOP - default operator", jc);
              operator_str = "UnaryDefault";
              break;
          }

          //                  jc.generated_java = op_type_str + operator_str + "(" + cast_1 + jc.generated_java + ", " + cast_2 + operands[i+1] + ")";
          //                jc.generated_java = op_type_str + operator_str + "(" + jc.generated_java + ", " + operands[i+1] + ")";
          String value_instance_string;
          String alloc_type_str;

          if ((jc.flag_alloc_type) && ((jc.alloc_type_depth + 1) == jc.indent)) {
            alloc_type_str = jc.alloc_type;
            jc.flag_alloc_type = false;
            jc.alloc_type = "";
          }
          else {
            // could be NUMERIC or LOGICAL
            if (operation == 2) {
              alloc_type_str = "ExpressTypes.NUMBER_TYPE";
            }
            else if (operation == 3) {
              alloc_type_str = "ExpressTypes.LOGICAL_TYPE";
            }
            else {
              alloc_type_str = "";
            }
          }

          //                if ((jc.flag_alloc_type) && ((jc.alloc_type_depth + 1) == jc.indent) && (i == children.length-2)) {
          //                     alloc_type_str = jc.alloc_type;
          //                   jc.flag_alloc_type = false;
          //                   jc.alloc_type = "";
          //                  } else {
          //                     alloc_type_str = "";
          //                  }
          if ((jc.flag_non_temporary_value_instance) && ((jc.assignment_depth + 1) == jc.indent)) {
            value_instance_string = jc.value_instance;
            jc.flag_non_temporary_value_instance = false;
            jc.value_instance = "";
          }
          else {
            value_instance_string = "Value.alloc(" + alloc_type_str + ").";
          }

          //                if ((jc.flag_non_temporary_value_instance) && ((jc.assignment_depth + 1) == jc.indent) && (i == children.length-2)) {
          //                   value_instance_string = jc.value_instance;
          //                   jc.flag_non_temporary_value_instance = false;
          //                   jc.value_instance = "";
          //                } else {
          //                   value_instance_string = "Value.alloc(" + alloc_type_str + ").";
          //                }
// 					if(operation == 3) // NOT
// 							jc.generated_java = value_instance_string + operator_str + "(" + operand + ").getLogical()";
// 					else
          jc.generated_java = value_instance_string + operator_str + "(" + operand + ")";

          //               } // for children
        }
      }
    }
    else { // old stuff
    }

    if (jc != null) {
      if (jc.active) {

        // jc.type_of_operand = result_type;
      }
    }

    // } // if not value
    return data;
  }
}
