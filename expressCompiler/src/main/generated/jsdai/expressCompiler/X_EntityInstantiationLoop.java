/*
 * $Id$
 *
 * JSDAI(TM), a way to implement STEP, ISO 10303
 * Copyright (C) 1997-2008, LKSoftWare GmbH, Germany
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License
 * version 3 as published by the Free Software Foundation (AGPL v3).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * JSDAI is a registered trademark of LKSoftWare GmbH, Germany
 * This software is also available under commercial licenses.
 * See also http://www.jsdai.net/
 */

/* Generated By:JJTree: Do not edit this line. X_EntityInstantiationLoop.java */

package jsdai.expressCompiler;

import java.util.*;
import java.io.*;

import jsdai.lang.*;
import jsdai.SExtended_dictionary_schema.*;

public class X_EntityInstantiationLoop extends SimpleNode {

  String variable_id;
  int variable_uid;

  jsdai.SExtended_dictionary_schema.EMap_definition map_definition;
  jsdai.SExtended_dictionary_schema.EMap_or_view_partition partition;

  static boolean flag_generate_execute_in_nodes = true;

  public X_EntityInstantiationLoop(int id) {
    super(id);
  }

  public X_EntityInstantiationLoop(Compiler2 p, int id) {
    super(p, id);
  }

  /**
   * Accept the visitor.
   **/
  public Object jjtAccept(Compiler2Visitor visitor, Object data) throws jsdai.lang.SdaiException {
    return visitor.visit(this, data);
  }

  public Object childrenAccept_own(Compiler2Visitor visitor, Object data) throws jsdai.lang.SdaiException {
    JavaClass jc = (JavaClass) data;
    PrintWriter pw = jc.pw;

    switch (jc.secondary) {
      case 0: // ----------------------------------------------------------------------------------
      default:

        pw.println("// variable_id: " + variable_id);
        pw.println("// variable_uid: " + variable_uid);

        // variable_id: _implicit_1_
        // variable_uid: 1

        break; // case 0, default ------------------------------------------------------------
    } // switch jc.secondary

    return data;
  }

// =====================================================================================================================

  public Object childrenAccept(Compiler2Visitor visitor, Object data) throws jsdai.lang.SdaiException {

    JavaClass jc = (JavaClass) data;
    PrintWriter pw = jc.pw;

    switch (jc.secondary) {
      case 1: // invoking on supertype map, print the WHERE rule expression only, in BindingHeader or directly if not present (not root)

        jc.asp = jc.parent.asp;

        // ----------------- case 1 begins ------------------------------------------------------------------------------
//			System.out.println("MapDecl node - secondary case 1");
//			pw.println("// ############# secondary case 1");
        if (children != null) {
          for (int i = 0; i < children.length; i++) {
            if (children[i] instanceof X_BindingHeader) { // that has to be the root supertype

              jc.identified_by = false;

              if (((X_BindingHeader) children[i]).partition == jc.reference) {

                //						jc.ind = ind;
                //System.out.println("IN SUPERTYPE - Oh YES, invoking!");
// 	pw.println("// INVOKING IN SUPERTYPE -------- YES YES YES - TO BindingHeader!!!!!!!!!!!!!!");
                children[i].jjtAccept(visitor, data);
              }

            }
            else if (children[i] instanceof X_SubtypeBindingHeader) { // that has to be intermediate supertype, itself a subtype, explicit partitions present

              jc.identified_by = false;

              String child_partition_name = ((X_SubtypeBindingHeader) children[i]).partition.getName(null);
              String required_partition_name = ((EMap_partition) jc.reference).getName(null);

//						if (((X_SubtypeBindingHeader)children[i]).partition == jc.reference) {

              //				pw.println("(");
              if (child_partition_name.equalsIgnoreCase(required_partition_name)) {
//					pw.println(")"); 

//					pw.println("&&"); 

                children[i].jjtAccept(visitor, data);
              }

            }
            else if (children[i] instanceof X_WhereClause) {
              // intermediate sub-supertypes, need to test, especially with multiple partitions

              jc.identified_by = false;
              children[i].jjtAccept(visitor, data);

            }
          }
        }
        // ----------------- case 1 ends --------------------------------------------------------------------------------
        break;
      case 2: // invoking on supertype map, processing map attributes

//			System.out.println("MapDecl node - secondary case 2");
        pw.println("// ############# secondary case 2 - interested in MapAttributeDeclaration");

        // need source parameters from the root
        jc.asp = jc.parent.asp;
        jc.attribute_mappings = jc.parent.attribute_mappings;

        if (children != null) {
          boolean first_for_this_partition = true;
          for (int i = 0; i < children.length; i++) {

//-------------begin

            if (children[i] instanceof X_MapAttributeDeclaration) {

//			System.out.println("MapDecl node - secondary case 2 - MapAttributeDeclaration found: " + children[i]);
//			pw.println("// ############# secondary case 2 - MapAttributeDeclaration found: " + children[i]);

//2?					attributes_present = true;
              // define variables in X_MapAttributeDeclaration in first pass
//					jc.first_pass = true; 
              jc.first_pass = false;
//2?					jc.first_pass = first_for_this_partition;

              // System.out.println("child: " + children[i] + ", partition: " + mp_name + ", is 1st pass: " + jc.first_pass);

//					EMap_partition child_partition = ((X_MapAttributeDeclaration)children[i]).partition;
              EMap_partition child_partition = (EMap_partition) ((X_MapAttributeDeclaration) children[i]).partition;
              String child_partition_name = null;
              if (child_partition == null) {
                child_partition_name = "default";
              }
              else {
                child_partition_name = child_partition.getName(null);
              }
              if (child_partition_name.equalsIgnoreCase("_implicit_partition_")) {
                child_partition_name = "default";
              }
              String current_partition_name = ((EMap_partition) jc.reference).getName(null);
              if (current_partition_name.equalsIgnoreCase("_implicit_partition_")) {
                current_partition_name = "default";
              }

//			System.out.println("// ############# secondary case 2 - child partition: " + child_partition_name + ", current partition: " + ((EMap_partition)jc.reference).getName(null));
//			pw.println("// ############# secondary case 2 - child partition: " + child_partition_name + ", current partition: " + ((EMap_partition)jc.reference).getName(null));

//if (true) {
//						if (((X_MapAttributeDeclaration)children[i]).partition == mp) { 

//						if (((X_MapAttributeDeclaration)children[i]).partition.getName(null).equalsIgnoreCase(((EMap_partition)jc.reference).getName(null))) {
//						if (child_partition_name.equalsIgnoreCase(((EMap_partition)jc.reference).getName(null))) { 
              if (child_partition_name.equalsIgnoreCase(current_partition_name)) {
                if (first_for_this_partition) {
//2								if (jc.identified_by == false) {
//2									pw.println("\t\tfor(int j=0; j < binding_inst_extent.size(); j++){ ");
//2								}
//2								((X_MapAttributeDeclaration)children[i]).targets = new HashSet();
                  first_for_this_partition = false;
                  // is it perhaps the same as jc.first_pass ?
                }

                children[i].jjtAccept(visitor, data);
              }
//						jc.first_pass = false;

            } // MapAttributeDeclaration

//-------------end

          } // for - children
        } // children not NULL

        jc.parent.attribute_mappings = jc.attribute_mappings;
        break;
      case 0:
      default:
        // ------------------ the main case begins here, non-supertype (and with supertypes main subtype, if not moved to a separate later) ---------------
//			System.out.println("MapDecl node - primary case 0");
        pw.println("// ############# primary case 0");

        if (flag_generate_execute_in_nodes) {

          String map_name = map_definition.getName(null);
          String map_class_name = "M" + map_name.substring(0, 1).toUpperCase() + map_name.substring(1).toLowerCase();

//		pw.println("public class " + map_class_name + " {");

//		pw.println("");
//		pw.println("\t/*---------------------- methods to execute maps for each target --------------------*/");
          // ? for each target or everything together?
//		pw.println("");

          ATarget_parameter atp = map_definition.getTarget_parameters(null, null);

          jsdai.lang.SdaiIterator tpi = atp.createIterator();

          String etar_type = "";

          // need other approach for execute handling
          //		while (tpi.next()) {
          tpi.next();
          ETarget_parameter tp = (ETarget_parameter) atp.getCurrentMemberObject(tpi); //here
          String tp_name = tp.getName(null);
          EEntity_definition tp_extent = tp.getExtent(null);
          String tp_extent_name = tp_extent.getName(null);
          String atar_type =
              getEntityPackage(tp_extent, jc.model) + "A" + tp_extent_name.substring(0, 1).toUpperCase() + tp_extent_name.substring(1).toLowerCase();
          etar_type = getEntityPackage(tp_extent, jc.model) + "E" + tp_extent_name.substring(0, 1).toUpperCase() + tp_extent_name.substring(1).toLowerCase();
//RR			pw.println("\tpublic " +atar_type +" execute(SdaiContext _context) throws SdaiException {");
//			pw.println("\tpublic void  execute(SdaiContext _context) throws SdaiException {");
          //TODO: select appopriate partition: suspended, because em-planer doesn't use partitions - always call default partition.
//			pw.println("");
//			pw.println("\t\tSdaiModel src_model = _context.src_model;");
//			pw.println("\t\tSdaiModel tar_model = _context.tar_model;");
//			pw.println("\t\tVector instances_partition_default;");
//RR			pw.println("\t\tHashtable target_instances;");
//			pw.println("\t\tHashtable target_instances = new Hashtable();");
//			pw.println("");
//			pw.println("\t\t_context.mapHashTable = new Hashtable();");
//			pw.println("");

// let's remove for now
/*
			pw.println("\t\t" +atar_type +" aggr_" +tp_name +"= new "+atar_type +"();");
			pw.println("");
			pw.println("\t\tif ( _context.mapHashTable.contains(this)){");
			pw.println("\t\t\ttarget_instances = (Hashtable)_context.mapHashTable.get(this);");
			pw.println("\t\t\tIterator it = target_instances.entrySet().iterator();");
			pw.println("\t\t\twhile(it.hasNext()){");
			pw.println("\t\t\t\taggr_" +tp_name +".addUnordered(it.next(), null);");
			pw.println("\t\t\t}");
			pw.println("\t\t\treturn aggr_" +tp_name +";");
			pw.println("\t\t}else{");
			pw.println("\t\t\ttarget_instances = new Hashtable();");
			pw.println("\t\t\t_context.mapHashTable.put(this, target_instances);");
			pw.println("\t\t}");

*/

//			pw.println("\t\tSystem.out.println(\"processing partition..\");");
//			pw.println("\t\tSystem.out.println(\"processing partitions..\");");
//			pw.println("\t\taggr_" +tp_name +" = (" +atar_type +")processPartition_default(src_model, tar_model, target_instances);");

//			pw.println("\t\taggr_" +tp_name +" = (" +atar_type +")processPartition_default(src_model, tar_model, target_instances, _context);");

          AMap_partition am_p = map_definition.getPartitions(null, null);
          SdaiIterator mp_i = am_p.createIterator();
          while (mp_i.next()) {
            EMap_partition m_p = (EMap_partition) am_p.getCurrentMemberObject(mp_i);
            String m_p_name = m_p.getName(null);
// System.out.println("partition: " + m_p_name);				
//pw.println("\t//---partition: " + m_p_name);
            if (m_p_name.equalsIgnoreCase("_implicit_partition_")) {
              m_p_name = "default";
            }
//RR				pw.println("\t\taggr_" +tp_name +" = (" +atar_type +")processPartition_" + m_p_name + "(src_model, tar_model, target_instances, _context);");
//				pw.println("\t\tprocessPartition_" + m_p_name + "(src_model, tar_model, target_instances, _context);");
          }

//RR			pw.println("\t\treturn aggr_" +tp_name +";");
//			pw.println("\t\treturn;");
//			pw.println("\t}");
          //		}

//		pw.println("");
//		pw.println("\t/*---------------------- methods to execute maps for each partition --------------------*/");
//		pw.println("");

          if (false) {
//	if (map_definition.testSuper_type(null)) {

            // ------------------ begin -----------------------------------------------------------

            // get the first non-subtype map, because only partitions of this map contain source parameters

            jsdai.SExtended_dictionary_schema.EMap_definition map_definition_root;

            map_definition_root = getRootSupertypeMap(map_definition);

//    jsdai.expressCompiler.JavaBackend.generateJavaExpressionSecondary(pw, map_definition_root, jc.sd, null, jc.model, 1, jc, null);

            AMap_partition ampr = map_definition_root.getPartitions(null, null);
            SdaiIterator mpri = ampr.createIterator();

            AMap_partition amp = map_definition.getPartitions(null, null);
            SdaiIterator mpi = amp.createIterator();

            boolean first_for_this_partition = true;
            while (mpri.next()) {
              EMap_partition mp = (EMap_partition) ampr.getCurrentMemberObject(mpri);
              jc.partition = mp;
              String mp_name = mp.getName(null);
              first_for_this_partition = true;
              // ...
              // only default partition supported - em-planner doesn't need others
              // ...

              if (mp_name.equalsIgnoreCase("_implicit_partition_")) {
                mp_name = "default";
              }

//			pw.println("\tpublic AEntity processPartition_" +mp_name +"(SdaiModel src_model, SdaiModel tar_model, Hashtable target_instances) throws SdaiException {");
              pw.println("\tpublic AEntity processPartition_" + mp_name
                  + "(SdaiModel src_model, SdaiModel tar_model, Hashtable target_instances, SdaiContext _context) throws SdaiException {");

              // FROM part, generate source binding extent
              pw.println("\t// FROM part, generate source binding extent");
              ASource_parameter asp = mp.getSource_parameters(null, null);
              System.out.println("source parameters: " + asp);
              jc.asp = asp; // save reference for src parameters to be used in Identified_by node
              SdaiIterator spi = asp.createIterator();
              int ind = 0;
              String add_instances = "";

              pw.println("\t\tVector binding_inst_extent = new Vector();");
              pw.println("\t\tVector binding_inst = new Vector();");
              pw.println("\t\tHashtable src_id_map = new Hashtable();");

              // if it is a subtype, then we need to get source parameters from supertype, etc
              // let's have a separate handling of subtype maps

              while (spi.next()) {
                ind++;
                ESource_parameter sp = (ESource_parameter) asp.getCurrentMemberObject(spi);
                String sp_name = sp.getName(null);

                EEntity_or_view_definition sp_extent = (EEntity_or_view_definition) sp.getExtent(null);
                String sp_extent_name = sp_extent.getName(null);
                String sp_package = getEntityPackage(sp_extent, jc.model);
                String normalized_name = sp_extent_name.substring(0, 1).toUpperCase() + sp_extent_name.substring(1).toLowerCase();
                String esrc_type = sp_package + "E" + normalized_name;
                String asrc_type = sp_package + "A" + normalized_name;

                pw.println("\t\t" + asrc_type + " a" + ind + "_inst = (" + asrc_type + ")src_model.getInstances(" + esrc_type + ".class);");
              }

              spi.beginning();
              ind = 0;
              while (spi.next()) {
                ind++;
                ESource_parameter sp = (ESource_parameter) asp.getCurrentMemberObject(spi);
                String sp_name = sp.getName(null);

                EEntity_or_view_definition sp_extent = (EEntity_or_view_definition) sp.getExtent(null);
                String sp_extent_name = sp_extent.getName(null);
                String sp_package = getEntityPackage(sp_extent, jc.model);
                String normalized_name = sp_extent_name.substring(0, 1).toUpperCase() + sp_extent_name.substring(1).toLowerCase();
                String esrc_type = sp_package + "E" + normalized_name;
                String csrc_type = sp_package + "C" + normalized_name;
                String asrc_type = sp_package + "A" + normalized_name;

                //						tabByIndex(ind, pw); pw.println(asrc_type +" a" +ind +"_inst = (" +asrc_type +")src_model.getInstances(" +esrc_type +".class);");
                pw.println("");
                tabByIndex(ind, pw);
                pw.println("for (int i" + ind + " = 1; i" + ind + " < a" + ind + "_inst.getMemberCount()+1; i" + ind + "++) {");
                tabByIndex(ind, pw);
                pw.println("\tValue " + sp_name + " = Value.alloc(" + csrc_type + ".definition).set(_context, a" + ind + "_inst.getByIndex(i" + ind + "));");
                add_instances = tabByIndexToString(asp.getMemberCount(), pw, add_instances);
                add_instances += "\tbinding_inst.addElement(" + sp_name + ");\n";
                if (asp.getMemberCount() < 2) {
                  tabByIndex(ind, pw);
                  pw.println("\tbinding_inst.addElement(\"\");");
                }
                if (ind == asp.getMemberCount()) {
                  tabByIndex(ind, pw);
                  pw.println("\tbinding_inst = new Vector();");
                  pw.println(add_instances);
                }
                tabByIndex(ind, pw);
                pw.println("\tsrc_id_map.put(\"" + sp_name + "\", new Integer(" + (ind - 1) + "));");
              }

              //
              // WHERE part
              //

              if (children != null) {

                boolean attributes_present = false;

                for (int i = 0; i < children.length; i++) {
                  // possible children:
                  // X_BindingHeader (includes inside optional clauses: From clause, local declarations, WHERE clause, Identified_by clause, Ordered_by clause)
                  // X_MapAttributeDeclaration
                  // etc

                  // so move actions for all this stuff into the children nodes (BindingHeader etc)

// System.out.println("current child: " + children[i] + ", current partition: " + mp.getName(null));

                  if (children[i] instanceof X_BindingHeader) {
// System.out.println("current child - BindingHeader, partition: " + ((X_BindingHeader)children[i]).partition.getName(null));
                    jc.identified_by = false;
                    if (((X_BindingHeader) children[i]).partition == mp) {
                      jc.ind = ind;
// System.out.println("Oh YES, invoking!");
// 	pw.println("// INVOKING -------- YES YES YES - TO BindingHeader!!!!!!!!!!!!!!");
                      children[i].jjtAccept(visitor, data);
                    }
                  }
                  else if (children[i] instanceof X_MapAttributeDeclaration) {

                    attributes_present = true;
                    jc.first_pass = true; // define variables in X_MapAttributeDeclaration in first pass
                    jc.first_pass = first_for_this_partition;

                    // System.out.println("child: " + children[i] + ", partition: " + mp_name + ", is 1st pass: " + jc.first_pass);
                    if (((X_MapAttributeDeclaration) children[i]).partition == mp) {
                      if (first_for_this_partition) {
                        if (jc.identified_by == false) {
                          pw.println("\t\tfor(int j=0; j < binding_inst_extent.size(); j++){ ");
                        }
                        ((X_MapAttributeDeclaration) children[i]).targets = new HashSet();
                        first_for_this_partition = false;
                        // is it perhaps the same as jc.first_pass ?
                      }

                      children[i].jjtAccept(visitor, data);
                    }
//						jc.first_pass = false;

                  }
//				} else // MapAttributeDeclaration
//				if (children[i] instanceof X_EntityInstantiationLoop) {
//					attributes_present = true;
//				} // X_EntityInstantiationLoop

                } // for
                if (!attributes_present) {
                  // better move from attribute, but temporarily, duplicate these things here

                  // this whole thing is inside the loop through partitions, so it is ok
                  // we way need to handle the following cases:
                  // 1. no source parameters (no FROM clause) - just generate 1 instance
                  // 2. 1 source parameter
                  // 3. multiple source parameters
                  // 4. if source parameters, also WHERE clause present or not
                  // 5 IDENTIFIED_BY clause present or not

                  ATarget_parameter atp2 = map_definition.getTarget_parameters(null, null);
                  jsdai.lang.SdaiIterator tpi2 = atp2.createIterator();
                  while (tpi2.next()) {
                    ETarget_parameter tp2 = (ETarget_parameter) atp2.getCurrentMemberObject(tpi2);

                    if (jc.identified_by == false) {
                      pw.println("\t\tfor(int j=0; j < binding_inst_extent.size(); j++){ ");

                      jsdai.SExtended_dictionary_schema.ETarget_parameter target_parameter = tp2;
                      String tar_par_name = target_parameter.getName(null);
                      String plain_target_name = tar_par_name;
                      Vector src_par_names = new Vector();
                      Vector src_par_orders = new Vector();
                      // target instance should be created only once - when first encountered target_parameter
                      HashSet targets = new HashSet();  // this is stupid, it does not do that, just so that it is compileable

                      SdaiIterator spi2 = jc.asp.createIterator();
                      while (spi2.next()) {
                        ESource_parameter sp2 = (ESource_parameter) jc.asp.getCurrentMemberObject(spi2);
                        String sp_name2 = sp2.getName(null);
                        src_par_names.add(sp_name2);
                      }

                      tar_par_name += "_" + jc.target_par_count;
                      jc.target_par_count++;
//							pw.println("\t\t\tValue expr_" +tar_par_name +" = Value.alloc().unset();");

//							pw.println("\t\t\tValue last_expr_" +tar_par_name +" = Value.alloc().unset();");
                      pw.println("");

                      for (int si = 0; si < src_par_names.size(); si++) {
                        //							pw.println("\t\tint src_par_id_" +(String)src_par_names.get(si) +";");
                        //							pw.println("\t\t\tValue " +(String)src_par_names.get(si) +";");
                        first_for_this_partition = false;

                      }

                      if (!targets.contains(plain_target_name)) {
                        EEntity_definition target_type = target_parameter.getExtent(null);
                        String tar_extent_name = target_type.getName(null);
                        String normalized_name = tar_extent_name.substring(0, 1).toUpperCase() + tar_extent_name.substring(1).toLowerCase();
                        String tar_package = getEntityPackage(target_type);
                        String etar_type2 = tar_package + "E" + normalized_name;
                        String ctar_type2 = tar_package + "C" + normalized_name;

                        pw.println("\t\t\t" + etar_type2 + " " + plain_target_name + "_inst = (" + etar_type2 + ")tar_model.createEntityInstance(" + etar_type2
                            + ".class);");
//								pw.println("\t\t\tValue " +plain_target_name +" = Value.alloc(" +ctar_type2 +".definition).set(_context, " +plain_target_name +"_inst);");
                        targets.add(plain_target_name);
                      }
//String gen_target_attr = "KUKU-HAHA";
//							pw.println("\t\t\t" +gen_target_attr +" expr_" +tar_par_name +");"); //  d.setName();

                    }
                    else { // no identified_by
                      // identified_by present
                      // TODO
                    }

                  } // while - through target parameters

                } // if attributes NOT present - constant partition

              } // if children NOT null (children include binding header)


/*

			int i=0;  // change into the loop, needed for multiple partitions

			if(children[i] instanceof X_WhereClause){
				pw.println("\t\t\t// WHERE clause");
				tabByIndex(ind, pw); pw.print("\tif(");
				children[i].jjtAccept(visitor, data);
				pw.println("){"); 
				tabByIndex(ind, pw); pw.println("\t\tbinding_inst_extent.addElement(binding_inst);");
				tabByIndex(ind, pw); pw.println("\t}");
				i++; // generate next clause
			}else{
				tabByIndex(ind, pw); pw.println("\tbinding_inst_extent.addElement(binding_inst);");
				//								children[i].jjtAccept(visitor, data);
			}

*/
	
	
/*	
	
			while(ind > 0){
				tabByIndex(ind, pw); pw.println("}");
				ind--;
			}

*/



/*

			//
			// IDENTIFIED_BY expression, classification to eq class
			//
			if(i < children.length){
				if(children[i] instanceof X_IdentifiedByClause){
					pw.println("\t\t// IDENTIFIED_BY clause");
					children[i].jjtAccept(visitor, data);
					i++;
				}
			}
			pw.println("");

*/


/*

			//
			// SELECT part
			//
			// evaluate expression parts for the bindings of the same eq class and set appopriate values
			//
			// TODO: error handling in case of incompatible result of expression with left side of select statement
			// TODO: control by numeric increment, control by iteration over aggregate (
			//
			if(i > 0 && children[i-1] instanceof X_IdentifiedByClause){
				pw.println("\t\t// Evaluating expression parts for the bindings of the same eq class and setting appopriate values");
				pw.println("\t\tIterator iter = alist.iterator();");
				pw.println("\t\tfor(int i = 0; i < alist.size() ; i++) {");
				pw.println("\t\t\tint inst_num = 0;");
				// don't do checking, rely on the size
				pw.println("\t\t\tVector eq_class = (Vector)iter.next();");

				jc.identified_by = true;
			}else{
				pw.println("\t\tfor(int j=0; j < binding_inst_extent.size(); j++){ ");
			}


*/

              // this is handling of MapAttributeDeclarations, a separate loop through the children, as of now



/*


			if (children != null) {
				jc.first_pass = true; // define variables in X_MapAttributeDeclaration in first pass

//				for (int l = i; l < children.length; ++l) {
        // could do also from 1, actually better switch to that, because there are changes about i value, making a loop
				for (int l = 0; l < children.length; ++l) {
	System.out.println("child: " + children[l] + ", partition: " + mp_name + ", is 1st pass: " + jc.first_pass);	
					if (children[l] instanceof X_MapAttributeDeclaration) {
						if (((X_MapAttributeDeclaration)children[l]).partition == mp) { 
							if (first_for_this_partition) {
								((X_MapAttributeDeclaration)children[l]).targets = new HashSet();
								first_for_this_partition = false;
								// is it perhaps the same as jc.first_pass ?
							}
						
							children[l].jjtAccept(visitor, data);
						}
					}
				}
				jc.first_pass = false;
			} // if children not NULL

			pw.println("\t\t}");

*/

// moved into the partition loop
              pw.println("\t\t}");
              pw.println("\t\treturn tar_model.getInstances(" + etar_type + ".class);");
              pw.println("\t}");

            } // loop through partitions

            // ------------------ end -------------------------------------------------------------
          }
          else if (map_definition.testSuper_type(null)) {
            // new subtype map implementation ------------------- begins --------------------------------------------------------

            // FROM clause and source parameters are present only in the partitions of the root supertype, not in any of subtypes
            // so we need to get to the root supertype to get source parameters from there

            jsdai.SExtended_dictionary_schema.EMap_definition map_definition_root;
            map_definition_root = getRootSupertypeMap(map_definition);

//    jsdai.expressCompiler.JavaBackend.generateJavaExpressionSecondary(pw, map_definition_root, jc.sd, null, jc.model, 1, jc, null);

            // may not be needed, we we'll use the root partitions, at least for source parameters, etc
            AMap_partition amp = map_definition.getPartitions(null, null);
            SdaiIterator mpi = amp.createIterator();

            AMap_partition ampr = map_definition_root.getPartitions(null, null);
            SdaiIterator mpri = ampr.createIterator();

            boolean first_for_this_partition = true;
//		while (mpi.next()) {
            while (mpri.next()) {
//			EMap_partition mp = (EMap_partition)amp.getCurrentMemberObject(mpi);
              EMap_partition mp = (EMap_partition) ampr.getCurrentMemberObject(mpri);
              jc.partition = mp;
              String mp_name = mp.getName(null);
              first_for_this_partition = true;
              // ...
              // only default partition supported - em-planner doesn't need others
              // ...

              if (mp_name.equalsIgnoreCase("_implicit_partition_")) {
                mp_name = "default";
              }

//			pw.println("\tpublic AEntity processPartition_" +mp_name +"(SdaiModel src_model, SdaiModel tar_model, Hashtable target_instances) throws SdaiException {");
              pw.println("\tpublic AEntity processPartition_" + mp_name
                  + "(SdaiModel src_model, SdaiModel tar_model, Hashtable target_instances, SdaiContext _context) throws SdaiException {");

              // FROM part, generate source binding extent
              pw.println("\t// FROM part, generate source binding extent");

              ASource_parameter asp = mp.getSource_parameters(null, null);
              System.out.println("source parameters: " + asp);
              jc.asp = asp; // save reference for src parameters to be used in Identified_by node
              SdaiIterator spi = asp.createIterator();
              int ind = 0;
              String add_instances = "";

              pw.println("\t\tVector binding_inst_extent = new Vector();");
              pw.println("\t\tVector binding_inst = new Vector();");
              pw.println("\t\tHashtable src_id_map = new Hashtable();");

              // if it is a subtype, then we need to get source parameters from supertype, etc
              // let's have a separate handling of subtype maps

              while (spi.next()) {
                ind++;
                ESource_parameter sp = (ESource_parameter) asp.getCurrentMemberObject(spi);
                String sp_name = sp.getName(null);

                EEntity_or_view_definition sp_extent = (EEntity_or_view_definition) sp.getExtent(null);
                String sp_extent_name = sp_extent.getName(null);
                String sp_package = getEntityPackage(sp_extent, jc.model);
                String normalized_name = sp_extent_name.substring(0, 1).toUpperCase() + sp_extent_name.substring(1).toLowerCase();
                String esrc_type = sp_package + "E" + normalized_name;
                String asrc_type = sp_package + "A" + normalized_name;

                pw.println("\t\t" + asrc_type + " a" + ind + "_inst = (" + asrc_type + ")src_model.getInstances(" + esrc_type + ".class);");
              }

              spi.beginning();
              ind = 0;
              while (spi.next()) {
                ind++;
                ESource_parameter sp = (ESource_parameter) asp.getCurrentMemberObject(spi);
                String sp_name = sp.getName(null);

                EEntity_or_view_definition sp_extent = (EEntity_or_view_definition) sp.getExtent(null);
                String sp_extent_name = sp_extent.getName(null);
                String sp_package = getEntityPackage(sp_extent, jc.model);
                String normalized_name = sp_extent_name.substring(0, 1).toUpperCase() + sp_extent_name.substring(1).toLowerCase();
                String esrc_type = sp_package + "E" + normalized_name;
                String csrc_type = sp_package + "C" + normalized_name;
                String asrc_type = sp_package + "A" + normalized_name;

                //						tabByIndex(ind, pw); pw.println(asrc_type +" a" +ind +"_inst = (" +asrc_type +")src_model.getInstances(" +esrc_type +".class);");
                pw.println("");
                tabByIndex(ind, pw);
                pw.println("for (int i" + ind + " = 1; i" + ind + " < a" + ind + "_inst.getMemberCount()+1; i" + ind + "++) {");
                tabByIndex(ind, pw);
                pw.println("\tValue " + sp_name + " = Value.alloc(" + csrc_type + ".definition).set(_context, a" + ind + "_inst.getByIndex(i" + ind + "));");
                add_instances = tabByIndexToString(asp.getMemberCount(), pw, add_instances);
                add_instances += "\tbinding_inst.addElement(" + sp_name + ");\n";
                if (asp.getMemberCount() < 2) {
                  tabByIndex(ind, pw);
                  pw.println("\tbinding_inst.addElement(\"\");");
                }
                if (ind == asp.getMemberCount()) {
                  tabByIndex(ind, pw);
                  pw.println("\tbinding_inst = new Vector();");
                  pw.println(add_instances);
                }
                tabByIndex(ind, pw);
                pw.println("\tsrc_id_map.put(\"" + sp_name + "\", new Integer(" + (ind - 1) + "));");
              }

              //
              // WHERE part
              //

              // in subtype map there will not be binding header node, just directly WHERE clause,
              // at least with default implicit partition

              if (children != null) {

                boolean attributes_present = false;

                jc.attribute_mappings = new HashSet();

                for (int i = 0; i < children.length; i++) {
                  // possible children:
                  // X_BindingHeader (includes inside optional clauses: From clause, local declarations, WHERE clause, Identified_by clause, Ordered_by clause)
                  // X_MapAttributeDeclaration
                  // etc

                  // so move actions for all this stuff into the children nodes (BindingHeader etc)

// System.out.println("current child: " + children[i] + ", current partition: " + mp.getName(null));

                  if (children[i] instanceof X_BindingHeader) {
// System.out.println("current child - BindingHeader, partition: " + ((X_BindingHeader)children[i]).partition.getName(null) + ", current partition: " + mp.getName(null));
                    jc.identified_by = false;
                    if (((X_BindingHeader) children[i]).partition == mp) {
                      jc.ind = ind;
                      // System.out.println("Oh YES, invoking!");
                      pw.println("// INVOKING -------- YES YES YES - TO BindingHeader!!!!!!!!!!!!!!");
                      children[i].jjtAccept(visitor, data);
                    }
                  }
                  else if (children[i] instanceof X_SubtypeBindingHeader) {
                    // in the main subtype branch (secondary = 0) this should be the same as directly WhereClause node,
                    // currently internal implementation in the node just returns the where clause expression
                    // may have to extend for other things, identified_by not supported yet

                    if (((X_SubtypeBindingHeader) children[i]).partition.getName(null).equalsIgnoreCase(mp.getName(null))) {

                      tabByIndex(ind, pw);
                      pw.print("\tif(");
//					pw.println("("); 

                      jsdai.SExtended_dictionary_schema.EMap_definition md_current = map_definition;
                      for (; ; ) {
                        if (md_current.testSuper_type(null)) {
                          md_current = md_current.getSuper_type(null);
                          pw.println("(");
                          jsdai.expressCompiler.JavaBackend.generateJavaExpressionSecondary(pw, md_current, jc.sd, null, jc.model, 1, jc, mp);
                          pw.println(")");
                          pw.println("&&");
                        }
                        else {
                          break;
                        }
                      }

//					pw.println(")"); 

//					pw.println("&&"); 
                      pw.println("(");
                      children[i].jjtAccept(visitor, data);
                      pw.println(")");
                      pw.println("){");
                      tabByIndex(ind, pw);
                      pw.println("\t\tbinding_inst_extent.addElement(binding_inst); // where clause");
                      tabByIndex(ind, pw);
                      pw.println("\t}");
                      // i++; // generate next clause
                      while (ind > 0) {
                        tabByIndex(ind, pw);
                        pw.println("}");
                        ind--;
                      }

                    } // if right partition

                  }
                  else if (children[i] instanceof X_WhereClause) {
                    // after SubtypeBindingHeader node was introduced, WhereClause cannot occur directly, so the code below is obsolete
                    // try to put the where rule here then
//---------------start					

                    pw.println("\t\t\t// WHERE clause");
                    tabByIndex(ind, pw);
                    pw.print("\tif(");
                    pw.println("(");

// also add from root types, in this case just from the root, but we need to implement support for longer chains as well					

                    jsdai.SExtended_dictionary_schema.EMap_definition md_current = map_definition;
                    for (; ; ) {
                      if (md_current.testSuper_type(null)) {
                        md_current = md_current.getSuper_type(null);
                        jsdai.expressCompiler.JavaBackend.generateJavaExpressionSecondary(pw, md_current, jc.sd, null, jc.model, 1, jc, mp);
                      }
                      else {
                        break;
                      }
                    }

//    jsdai.expressCompiler.JavaBackend.generateJavaExpressionSecondary(pw, map_definition_root, jc.sd, null, jc.model, 1, jc, mp);

//---------------

/*
     do  a loop

			jsdai.SExtended_dictionary_schema.EMap_definition md = null;
			if (map_definition.testSuper_type(null)) {
				md = getRootSupertypeMap(map_definition.getSuper_type(null));
			} else {
				md = map_definition;
			}

*/

//---------------
                    pw.println(")");

                    pw.println("&&");
                    pw.println("(");
                    children[i].jjtAccept(visitor, data);
                    pw.println(")");
                    pw.println("){");
                    tabByIndex(ind, pw);
                    pw.println("\t\tbinding_inst_extent.addElement(binding_inst); // where clause");
                    tabByIndex(ind, pw);
                    pw.println("\t}");
                    // i++; // generate next clause
                    while (ind > 0) {
                      tabByIndex(ind, pw);
                      pw.println("}");
                      ind--;
                    }

//---------------end
                  }
                  else if (children[i] instanceof X_MapAttributeDeclaration) {

                    attributes_present = true;
                    jc.first_pass = true; // define variables in X_MapAttributeDeclaration in first pass
                    jc.first_pass = first_for_this_partition;

                    // System.out.println("child: " + children[i] + ", partition: " + mp_name + ", is 1st pass: " + jc.first_pass);

//if (true) {
//						if (((X_MapAttributeDeclaration)children[i]).partition == mp) { 
//						if (((X_MapAttributeDeclaration)children[i]).partition.getName(null).equalsIgnoreCase(mp.getName(null))) { 
// System.out.println("<><>partition: " + ((X_MapAttributeDeclaration)children[i]).partition);

//					EMap_partition child_partition = ((X_MapAttributeDeclaration)children[i]).partition;
                    EMap_partition child_partition = (EMap_partition) ((X_MapAttributeDeclaration) children[i]).partition;
                    String child_partition_name = null;
                    if (child_partition == null) {
                      child_partition_name = "default";
                    }
                    else {
                      child_partition_name = child_partition.getName(null);
                    }
                    if (child_partition_name.equalsIgnoreCase("_implicit_partition_")) {
                      child_partition_name = "default";
                    }
// System.out.println("<><>child partition: " + child_partition_name);

//						if (((X_MapAttributeDeclaration)children[i]).partition.getName(null).equalsIgnoreCase(mp_name) { 
// if (true) {
                    if (child_partition_name.equalsIgnoreCase(mp_name)) {

                      if (first_for_this_partition) {
                        if (jc.identified_by == false) {
                          pw.println("\t\tfor(int j=0; j < binding_inst_extent.size(); j++){ ");
                        }
                        ((X_MapAttributeDeclaration) children[i]).targets = new HashSet();
                        first_for_this_partition = false;
                        // is it perhaps the same as jc.first_pass ?
                      }

                      children[i].jjtAccept(visitor, data);
                    }
//						jc.first_pass = false;

                  } // MapAttributeDeclaration

                } // for - children
                // let's take also attributes from supertypes

                jsdai.SExtended_dictionary_schema.EMap_definition md_current = map_definition;
                for (; ; ) {
                  if (md_current.testSuper_type(null)) {
                    md_current = md_current.getSuper_type(null);
                    jsdai.expressCompiler.JavaBackend.generateJavaExpressionSecondary(pw, md_current, jc.sd, null, jc.model, 2, jc, mp);
                  }
                  else {
                    break;
                  }
                }

                if (!attributes_present) {
                  // better move from attribute, but temporarily, duplicate these things here

                  // this whole thing is inside the loop through partitions, so it is ok
                  // we way need to handle the following cases:
                  // 1. no source parameters (no FROM clause) - just generate 1 instance
                  // 2. 1 source parameter
                  // 3. multiple source parameters
                  // 4. if source parameters, also WHERE clause present or not
                  // 5 IDENTIFIED_BY clause present or not

                  ATarget_parameter atp2 = map_definition.getTarget_parameters(null, null);
                  jsdai.lang.SdaiIterator tpi2 = atp2.createIterator();
                  while (tpi2.next()) {
                    ETarget_parameter tp2 = (ETarget_parameter) atp2.getCurrentMemberObject(tpi2);

                    if (jc.identified_by == false) {
                      pw.println("\t\tfor(int j=0; j < binding_inst_extent.size(); j++){ ");

                      jsdai.SExtended_dictionary_schema.ETarget_parameter target_parameter = tp2;
                      String tar_par_name = target_parameter.getName(null);
                      String plain_target_name = tar_par_name;
                      Vector src_par_names = new Vector();
                      Vector src_par_orders = new Vector();
                      // target instance should be created only once - when first encountered target_parameter
                      HashSet targets = new HashSet();  // this is stupid, it does not do that, just so that it is compileable

                      SdaiIterator spi2 = jc.asp.createIterator();
                      while (spi2.next()) {
                        ESource_parameter sp2 = (ESource_parameter) jc.asp.getCurrentMemberObject(spi2);
                        String sp_name2 = sp2.getName(null);
                        src_par_names.add(sp_name2);
                      }

                      tar_par_name += "_" + jc.target_par_count;
                      jc.target_par_count++;
//							pw.println("\t\t\tValue expr_" +tar_par_name +" = Value.alloc().unset();");

//							pw.println("\t\t\tValue last_expr_" +tar_par_name +" = Value.alloc().unset();");
                      pw.println("");

                      for (int si = 0; si < src_par_names.size(); si++) {
                        //							pw.println("\t\tint src_par_id_" +(String)src_par_names.get(si) +";");
                        //							pw.println("\t\t\tValue " +(String)src_par_names.get(si) +";");
                        first_for_this_partition = false;

                      }

                      if (!targets.contains(plain_target_name)) {
                        EEntity_definition target_type = target_parameter.getExtent(null);
                        String tar_extent_name = target_type.getName(null);
                        String normalized_name = tar_extent_name.substring(0, 1).toUpperCase() + tar_extent_name.substring(1).toLowerCase();
                        String tar_package = getEntityPackage(target_type);
                        String etar_type2 = tar_package + "E" + normalized_name;
                        String ctar_type2 = tar_package + "C" + normalized_name;

                        pw.println("\t\t\t" + etar_type2 + " " + plain_target_name + "_inst = (" + etar_type2 + ")tar_model.createEntityInstance(" + etar_type2
                            + ".class);");
//								pw.println("\t\t\tValue " +plain_target_name +" = Value.alloc(" +ctar_type2 +".definition).set(_context, " +plain_target_name +"_inst);");
                        targets.add(plain_target_name);
                      }
//String gen_target_attr = "KUKU-HAHA";
//							pw.println("\t\t\t" +gen_target_attr +" expr_" +tar_par_name +");"); //  d.setName();

                    }
                    else { // no identified_by
                      // identified_by present
                      // TODO
                    }

                  } // while - through target parameters

                } // if attributes NOT present - constant partition

              } // if children NOT null (children include binding header)
              jc.attribute_mappings = null;


/*

			int i=0;  // change into the loop, needed for multiple partitions

			if(children[i] instanceof X_WhereClause){
				pw.println("\t\t\t// WHERE clause");
				tabByIndex(ind, pw); pw.print("\tif(");
				children[i].jjtAccept(visitor, data);
				pw.println("){"); 
				tabByIndex(ind, pw); pw.println("\t\tbinding_inst_extent.addElement(binding_inst);");
				tabByIndex(ind, pw); pw.println("\t}");
				i++; // generate next clause
			}else{
				tabByIndex(ind, pw); pw.println("\tbinding_inst_extent.addElement(binding_inst);");
				//								children[i].jjtAccept(visitor, data);
			}

*/
	
	
/*	
	
			while(ind > 0){
				tabByIndex(ind, pw); pw.println("}");
				ind--;
			}

*/



/*

			//
			// IDENTIFIED_BY expression, classification to eq class
			//
			if(i < children.length){
				if(children[i] instanceof X_IdentifiedByClause){
					pw.println("\t\t// IDENTIFIED_BY clause");
					children[i].jjtAccept(visitor, data);
					i++;
				}
			}
			pw.println("");

*/


/*

			//
			// SELECT part
			//
			// evaluate expression parts for the bindings of the same eq class and set appopriate values
			//
			// TODO: error handling in case of incompatible result of expression with left side of select statement
			// TODO: control by numeric increment, control by iteration over aggregate (
			//
			if(i > 0 && children[i-1] instanceof X_IdentifiedByClause){
				pw.println("\t\t// Evaluating expression parts for the bindings of the same eq class and setting appopriate values");
				pw.println("\t\tIterator iter = alist.iterator();");
				pw.println("\t\tfor(int i = 0; i < alist.size() ; i++) {");
				pw.println("\t\t\tint inst_num = 0;");
				// don't do checking, rely on the size
				pw.println("\t\t\tVector eq_class = (Vector)iter.next();");

				jc.identified_by = true;
			}else{
				pw.println("\t\tfor(int j=0; j < binding_inst_extent.size(); j++){ ");
			}


*/

              // this is handling of MapAttributeDeclarations, a separate loop through the children, as of now



/*


			if (children != null) {
				jc.first_pass = true; // define variables in X_MapAttributeDeclaration in first pass

//				for (int l = i; l < children.length; ++l) {
        // could do also from 1, actually better switch to that, because there are changes about i value, making a loop
				for (int l = 0; l < children.length; ++l) {
	System.out.println("child: " + children[l] + ", partition: " + mp_name + ", is 1st pass: " + jc.first_pass);	
					if (children[l] instanceof X_MapAttributeDeclaration) {
						if (((X_MapAttributeDeclaration)children[l]).partition == mp) { 
							if (first_for_this_partition) {
								((X_MapAttributeDeclaration)children[l]).targets = new HashSet();
								first_for_this_partition = false;
								// is it perhaps the same as jc.first_pass ?
							}
						
							children[l].jjtAccept(visitor, data);
						}
					}
				}
				jc.first_pass = false;
			} // if children not NULL

			pw.println("\t\t}");

*/

// moved into the partition loop
              pw.println("\t\t}");
              pw.println("\t\treturn tar_model.getInstances(" + etar_type + ".class);");
              pw.println("\t}");

            } // loop through partitions

            // new subtype map implementation ------------------- ends -------------------------------------------------------------
          }
          else { //  not a subtype map

            AMap_partition amp = map_definition.getPartitions(null, null);
            SdaiIterator mpi = amp.createIterator();

            boolean first_for_this_partition = true;
            while (mpi.next()) {
              EMap_partition mp = (EMap_partition) amp.getCurrentMemberObject(mpi);
              jc.partition = mp;
              String mp_name = mp.getName(null);
              first_for_this_partition = true;
              // ...
              // only default partition supported - em-planner doesn't need others
              // ...

              if (mp_name.equalsIgnoreCase("_implicit_partition_")) {
                mp_name = "default";
              }

//			pw.println("\tpublic AEntity processPartition_" +mp_name +"(SdaiModel src_model, SdaiModel tar_model, Hashtable target_instances) throws SdaiException {");
//			pw.println("\tpublic AEntity processPartition_" +mp_name +"(SdaiModel src_model, SdaiModel tar_model, Hashtable target_instances, SdaiContext _context) throws SdaiException {");

              // FROM part, generate source binding extent
//			pw.println("\t// FROM part, generate source binding extent");
              ASource_parameter asp = mp.getSource_parameters(null, null);
//System.out.println("source parameters: " + asp);
              jc.asp = asp; // save reference for src parameters to be used in Identified_by node
              SdaiIterator spi = asp.createIterator();
              int ind = 0;
              String add_instances = "";

//			pw.println("\t\tVector binding_inst_extent = new Vector();");
//			pw.println("\t\tVector binding_inst = new Vector();");
//			pw.println("\t\tHashtable src_id_map = new Hashtable();");

              // if it is a subtype, then we need to get source parameters from supertype, etc
              // let's have a separate handling of subtype maps

              while (spi.next()) {
                ind++;
                ESource_parameter sp = (ESource_parameter) asp.getCurrentMemberObject(spi);
                String sp_name = sp.getName(null);

                EEntity_or_view_definition sp_extent = (EEntity_or_view_definition) sp.getExtent(null);
                String sp_extent_name = sp_extent.getName(null);
                String sp_package = getEntityPackage(sp_extent, jc.model);
                String normalized_name = sp_extent_name.substring(0, 1).toUpperCase() + sp_extent_name.substring(1).toLowerCase();
                String esrc_type = sp_package + "E" + normalized_name;
                String asrc_type = sp_package + "A" + normalized_name;

                //			pw.println("\t\t" +asrc_type +" a" +ind +"_inst = (" +asrc_type +")src_model.getInstances(" +esrc_type +".class);");
              }

              spi.beginning();
              ind = 0;
              while (spi.next()) {
                ind++;
                ESource_parameter sp = (ESource_parameter) asp.getCurrentMemberObject(spi);
                String sp_name = sp.getName(null);

                EEntity_or_view_definition sp_extent = (EEntity_or_view_definition) sp.getExtent(null);
                String sp_extent_name = sp_extent.getName(null);
                String sp_package = getEntityPackage(sp_extent, jc.model);
                String normalized_name = sp_extent_name.substring(0, 1).toUpperCase() + sp_extent_name.substring(1).toLowerCase();
                String esrc_type = sp_package + "E" + normalized_name;
                String csrc_type = sp_package + "C" + normalized_name;
                String asrc_type = sp_package + "A" + normalized_name;

                //						tabByIndex(ind, pw); pw.println(asrc_type +" a" +ind +"_inst = (" +asrc_type +")src_model.getInstances(" +esrc_type +".class);");
//				pw.println("");
//				tabByIndex(ind, pw); pw.println("for (int i" +ind +" = 1; i" +ind +" < a" +ind +"_inst.getMemberCount()+1; i" +ind +"++) {");
//				tabByIndex(ind, pw); pw.println("\tValue " +sp_name +" = Value.alloc(" +csrc_type +".definition).set(_context, a" +ind +"_inst.getByIndex(i" +ind +"));");
//				add_instances = tabByIndexToString(asp.getMemberCount(), pw, add_instances); add_instances += "\tbinding_inst.addElement(" +sp_name +");\n";
//				if(asp.getMemberCount() < 2) { tabByIndex(ind, pw); pw.println("\tbinding_inst.addElement(\"\");"); }
//				if(ind == asp.getMemberCount()){ 
//					tabByIndex(ind, pw); pw.println("\tbinding_inst = new Vector();");
//					pw.println(add_instances);
//				}
//				tabByIndex(ind, pw); pw.println("\tsrc_id_map.put(\""+ sp_name +"\", new Integer(" +(ind-1) +"));");
              }

              //
              // WHERE part
              //

              if (children != null) {

                boolean attributes_present = false;

                for (int i = 0; i < children.length; i++) {
                  // possible children:
                  // X_BindingHeader (includes inside optional clauses: From clause, local declarations, WHERE clause, Identified_by clause, Ordered_by clause)
                  // X_MapAttributeDeclaration
                  // etc

                  // so move actions for all this stuff into the children nodes (BindingHeader etc)

// System.out.println("current child: " + children[i] + ", current partition: " + mp.getName(null));

                  if (children[i] instanceof X_BindingHeader) {
// System.out.println("current child - BindingHeader, partition: " + ((X_BindingHeader)children[i]).partition.getName(null) + ", current partition: " + mp.getName(null));
                    jc.identified_by = false;
                    if (((X_BindingHeader) children[i]).partition == mp) {
                      jc.ind = ind;
                      // System.out.println("Oh YES, invoking!");
                      pw.println("// INVOKING -------- YES YES YES - TO BindingHeader!!!!!!!!!!!!!!");
                      children[i].jjtAccept(visitor, data);
                    }

                  }
                  else if (children[i] instanceof X_IncrementControl) {
                    pw.println("\t\t// <EntityInstantiationLoop>: in IncrementControl");

					/*
							have to generate the following code, put into a string and insert later via jc fields and flags in X_MapAttributeDeclaration, probably:
							

			---- start of code to generate: ----------------------
			Value expr_loop_start = Value.alloc().unset();
			expr_loop_start = src2.getAttribute(jsdai.STest_one2many_1b_source.CFirst_friend.attributeWhich_one(null), _context);
			int loop_start = expr_loop_start.getInteger();

			Value expr_loop_end = Value.alloc().unset();
			expr_loop_end = src1.getAttribute(jsdai.STest_one2many_1b_source.CMy_friends.attributeNumber_of_friends(null), _context);
			int loop_end = expr_loop_end.getInteger();


			for (int i = loop_start; i <= loop_end; i++) { 
      ---- end of code to generate ------------------------------------------							
					
					Alternative, perhaps a better one: to generate this code in the X_MapAttributeDeclaration node,
					but loop start and loop end expressions have to be passed over there in a similar way, then.
				 	
       after processing children for  FOR loop with increment control we get:
       
       jc.java_str2: Value _implicit_1_i=src2.getAttribute(jsdai.STest_one2many_1b_source.CFirst_friend.attributeWhich_one(null), _context)
			jc.java_str3: src1.getAttribute(jsdai.STest_one2many_1b_source.CMy_friends.attributeNumber_of_friends(null), _context)

			we also have from this node:
			variable_id: _implicit_1_


------------------- example with a function REPEAT statement pretty much the same:

						Value _end1 = Value.alloc(ExpressTypes.NUMBER_TYPE).set(_nonvar__e_par1.getAttribute("sumber_of_friends", _context));
						Value _step1 = Value.alloc(ExpressTypes.INTEGER_TYPE).set(_context, 1);
						for (Value _implicit_1_i=_nonvar__e_par2.getAttribute(jsdai.STest_one2many_1b_source.CFirst_friend.attributeWhich_one(null), _context);Value.alloc(ExpressTypes.LOGICAL_TYPE).lequal(_context, _implicit_1_i, _end1).getLogical() == 2;_implicit_1_i.inc(_step1)) {						
							_e_a_name.set(_context, _nonvar__e_par1.getAttribute(jsdai.STest_one2many_1b_source.CMy_friends.attributeFriends_names(null), _context).indexing(_implicit_1_i, null));
						} // for - REPEAT


------------------- changing to the case when step is present and not 1:

						Value _end1 = Value.alloc(ExpressTypes.NUMBER_TYPE).set(_nonvar__e_par1.getAttribute("sumber_of_friends", _context));
						Value _step1 = Value.alloc(ExpressTypes.NUMBER_TYPE).set(Value.alloc(ExpressTypes.INTEGER_TYPE).set(_context, 2));
						for (Value _implicit_1_i=_nonvar__e_par2.getAttribute(jsdai.STest_one2many_1b_source.CFirst_friend.attributeWhich_one(null), _context);Value.alloc(ExpressTypes.LOGICAL_TYPE).greater(_context, _step1, Value.alloc(ExpressTypes.INTEGER_TYPE).set(_context, 0)).getLogical() == 2 ? Value.alloc(ExpressTypes.LOGICAL_TYPE).lequal(_context, _implicit_1_i, _end1).getLogical() == 2 : Value.alloc(ExpressTypes.LOGICAL_TYPE).gequal(_context, _implicit_1_i, _end1).getLogical() == 2;_implicit_1_i.inc(_step1)) {						
							_e_a_name.set(_context, _nonvar__e_par1.getAttribute(jsdai.STest_one2many_1b_source.CMy_friends.attributeFriends_names(null), _context).indexing(_implicit_1_i, null));
						} // for - REPEAT



-- in that case (when step is present and not 1), we have:

			jc.java_str2: Value _implicit_2_i=src2.getAttribute(jsdai.STest_one2many_1b_source.CFirst_friend.attributeWhich_one(null), _context)
			jc.java_str3: src1.getAttribute(jsdai.STest_one2many_1b_source.CMy_friends.attributeNumber_of_friends(null), _context)
			jc.java_str4: Value.alloc(ExpressTypes.INTEGER_TYPE).set(_context, 2)


					
			so, we can generate something like this:		
					
			Value _end1 = "Value.alloc(ExpressTypes.NUMBER_TYPE).set(" + jc.java_str3 + ");";		
 		  if (step not present)
 		  Value _step1 = Value.alloc(ExpressTypes.INTEGER_TYPE).set(_context, 1);
			else
			Value _step1 = "Value.alloc(ExpressTypes.NUMBER_TYPE).set(" + jc.java_str4 + ");";
					
			for (" + jc.java_str2 + ";Value.alloc(ExpressTypes.LOGICAL_TYPE).greater(_context, _step1, Value.alloc(ExpressTypes.INTEGER_TYPE).set(_context, 0)).getLogical() == 2 ? Value.alloc(ExpressTypes.LOGICAL_TYPE).lequal(_context, _implicit_1_i, _end1).getLogical() == 2 : Value.alloc(ExpressTypes.LOGICAL_TYPE).gequal(_context, _implicit_1_i, _end1).getLogical() == 2;_implicit_1_i.inc(_step1)) {						
			
			and for indexing use (which will happen by itself): _implicit_1_i		
					
					
					*/
                    children[i].jjtAccept(visitor, data);

// pw.println("\t\t// <EntityInstantiationLoop>: in IncrementControl after children");
// pw.println("\t\t\t// generated_java: " + generated_java);
// pw.println("\t\t\t// jc.generated_java: " + jc.generated_java);
// pw.println("\t\t\t// jc.variable_ids: " + jc.variable_ids);
// pw.println("\t\t\t// jc.saved_str: " + jc.saved_str);
// pw.println("\t\t\t// jc.java_str2: " + jc.java_str2);
// pw.println("\t\t\t// jc.java_str3: " + jc.java_str3);
// pw.println("\t\t\t// jc.java_str4: " + jc.java_str4);
// pw.println("\t\t\t// jc.java_str5: " + jc.java_str5);
// pw.println("\t\t\t// jc.java_str6: " + jc.java_str6);

                    // ok, so trying to construct such a string:

                    String variable_idi = variable_id + "i";
                    String end_str = "_end" + variable_uid;
                    String step_str = "_step" + variable_uid;
                    String end_expr_str = "Value " + end_str + " = Value.alloc(ExpressTypes.NUMBER_TYPE).set(" + jc.java_str3 + ");";
                    String step_expr_str = null;
                    if ((jc.java_str4 == null) || (jc.java_str4.equals(""))) {
                      step_expr_str = "Value " + step_str + " = Value.alloc(ExpressTypes.INTEGER_TYPE).set(_context, 1);";
                    }
                    else {
                      step_expr_str = "Value " + step_str + " = Value.alloc(ExpressTypes.NUMBER_TYPE).set(" + jc.java_str4 + ");";
                    }
                    String for_str = "for (" + jc.java_str2 + "; Value.alloc(ExpressTypes.LOGICAL_TYPE).greater(_context, " + step_str
                        + ", Value.alloc(ExpressTypes.INTEGER_TYPE).set(_context, 0)).getLogical() == 2 ? Value.alloc(ExpressTypes.LOGICAL_TYPE).lequal(_context, "
                        + variable_idi + ", " + end_str + ").getLogical() == 2 : Value.alloc(ExpressTypes.LOGICAL_TYPE).gequal(_context, " + variable_idi + ", "
                        + end_str + ").getLogical() == 2; " + variable_idi + ".inc(" + step_str + ")) {";

//					pw.println("\t\t\t// ----- printing what generated: ------");
//					pw.println("\t\t\t//" + end_expr_str);
//					pw.println("\t\t\t//" + step_expr_str);
//					pw.println("\t\t\t//" + for_str);
//					pw.println("\t\t\t// ----- end of generated: ------");

        /*
        	 the generated code is:
        	 
			Value _end2 = Value.alloc(ExpressTypes.NUMBER_TYPE).set(src1.getAttribute(jsdai.STest_one2many_1b_source.CMy_friends.attributeNumber_of_friends(null), _context));
			Value _step2 = Value.alloc(ExpressTypes.NUMBER_TYPE).set(Value.alloc(ExpressTypes.INTEGER_TYPE).set(_context, 2));
			for (Value _implicit_2_i=src2.getAttribute(jsdai.STest_one2many_1b_source.CFirst_friend.attributeWhich_one(null), _context); Value.alloc(ExpressTypes.LOGICAL_TYPE).greater(_context, _step2, Value.alloc(ExpressTypes.INTEGER_TYPE).set(_context, 0)).getLogical() == 2 ? Value.alloc(ExpressTypes.LOGICAL_TYPE).lequal(_context, _implicit_2_, _end2).getLogical() == 2 : Value.alloc(ExpressTypes.LOGICAL_TYPE).gequal(_context, _implicit_2_, _end2).getLogical() == 2; _implicit_2_.inc(_step2)) {
        	 
					 let's compare again with the one from REPEAT in a function:
					         
			Value _end1 = Value.alloc(ExpressTypes.NUMBER_TYPE).set(_nonvar__e_par1.getAttribute("sumber_of_friends", _context));
			Value _step1 = Value.alloc(ExpressTypes.NUMBER_TYPE).set(Value.alloc(ExpressTypes.INTEGER_TYPE).set(_context, 2));
			for (Value _implicit_1_i=_nonvar__e_par2.getAttribute(jsdai.STest_one2many_1b_source.CFirst_friend.attributeWhich_one(null), _context);Value.alloc(ExpressTypes.LOGICAL_TYPE).greater(_context, _step1, Value.alloc(ExpressTypes.INTEGER_TYPE).set(_context, 0)).getLogical() == 2 ? Value.alloc(ExpressTypes.LOGICAL_TYPE).lequal(_context, _implicit_1_i, _end1).getLogical() == 2 : Value.alloc(ExpressTypes.LOGICAL_TYPE).gequal(_context, _implicit_1_i, _end1).getLogical() == 2;_implicit_1_i.inc(_step1)) {						
				_e_a_name.set(_context, _nonvar__e_par1.getAttribute(jsdai.STest_one2many_1b_source.CMy_friends.attributeFriends_names(null), _context).indexing(_implicit_1_i, null));
			} // for - REPEAT
        
      perhaps ok, too much trouble to check, I will test with the complete version
        
        */

                    // let's put it into jc.java_str5 which is not used:

                    jc.java_str5 = "\n\t\t\t" + end_expr_str + "\n\t\t\t" + step_expr_str + "\n\n\n\t\t\t" + for_str;
                    // perhaps we need also some flag:
                    jc.in_entity_instantiation_loop = true;
                    jc.in_entity_instantiation_loop_first = true;

                  }
                  else if (children[i] instanceof X_InstantiationForeachControl) {
                    pw.println("\t\t// <EntityInstantiationLoop>: in InstantiationForeachControl");

                    children[i].jjtAccept(visitor, data);

                    pw.println("\t\t// <EntityInstantiationLoop>: in  InstantiationForeachControl after children");
                    pw.println("\t\t\t// generated_java: " + generated_java);
                    pw.println("\t\t\t// jc.generated_java: " + jc.generated_java);
                    pw.println("\t\t\t// jc.variable_ids: " + jc.variable_ids);
                    pw.println("\t\t\t// jc.saved_str: " + jc.saved_str);
                    pw.println("\t\t\t// jc.java_str2: " + jc.java_str2);
                    pw.println("\t\t\t// jc.java_str3: " + jc.java_str3);
                    pw.println("\t\t\t// jc.java_str4: " + jc.java_str4);
                    pw.println("\t\t\t// jc.java_str5: " + jc.java_str5);
                    pw.println("\t\t\t// jc.java_str6: " + jc.java_str6);

                    pw.println("\t\t\t// variable_id: " + variable_id);
                    pw.println("\t\t\t// variable_uid: " + variable_uid);

                    String source_str = "_source" + variable_uid;
                    String end_str = "_end" + variable_uid;
                    String step_str = "_step" + variable_uid;
                    // TODO to implement correctly source_expr_str - jc.java_str3 or something
                    // String end_expr_str =	"Value " + end_str + " = Value.alloc(ExpressTypes.NUMBER_TYPE).set(" + jc.java_str3 + ");";
                    // String source_expr_str = "Value " + source_str + " = Value.alloc(ExpressTypes.NUMBER_TYPE).set(src.getAttribute(jsdai.STest_one2many_2_source.CMy_friends.attributeFriends_names(null), _context));";
                    String source_expr_str = "Value " + source_str + " = " + jc.generated_java + ";";
                    String end_expr_str =
                        "Value " + end_str + " = Value.alloc(ExpressTypes.NUMBER_TYPE).set(Value.alloc(ExpressTypes.INTEGER_TYPE).hiIndex(_context, "
                            + source_str + "));";
                    String step_expr_str = "Value " + step_str + " = Value.alloc(ExpressTypes.INTEGER_TYPE).set(_context, 1);";
                    String for_str = "for (\n\tValue " + jc.index_uid
                        + " = Value.alloc(ExpressTypes.INTEGER_TYPE).set(_context, 1);\n\tValue.alloc(ExpressTypes.LOGICAL_TYPE).lequal(_context, "
                        + jc.index_uid + ", " + end_str + ").getLogical() == 2;\n\t" + jc.index_uid + ".inc(" + step_str + ")) {";
                    String element_value_str = "\n\tValue " + jc.iterator_uid + " = " + source_str + ".indexing(_context, " + jc.index_uid + ", null);";

                    jc.java_str5 =
                        "\n\t\t\t" + source_expr_str + "\n\t\t\t" + end_expr_str + "\n\t\t\t" + step_expr_str + "\n\n\n\t\t\t" + for_str + "\n\n\n\t\t\t\t"
                            + element_value_str;
                    jc.in_entity_instantiation_loop = true;
                    jc.in_entity_instantiation_loop_first = true;

                  }
                  else if (children[i] instanceof X_MapAttributeDeclaration) {

                    attributes_present = true;
                    jc.first_pass = true; // define variables in X_MapAttributeDeclaration in first pass
                    jc.first_pass = first_for_this_partition;

                    pw.println("\t\t// <EntityInstantiationLoop>: in MapAttributeDeclaration");

                    // System.out.println("child: " + children[i] + ", partition: " + mp_name + ", is 1st pass: " + jc.first_pass);
//						if (((X_MapAttributeDeclaration)children[i]).partition == mp) { 
                    if (((X_MapAttributeDeclaration) children[i]).partition == mp) {
                      pw.println("\t\t// <EntityInstantiationLoop>: in partition");

                      if (first_for_this_partition) {
                        pw.println("\t\t// <EntityInstantiationLoop>: in first for partition");
                        if (jc.identified_by == false) {
                          pw.println("\t\t// <EntityInstantiationLoop>: no identified_by");
                          pw.println("\t\tfor(int j=0; j < binding_inst_extent.size(); j++){ ");
                        }
                        ((X_MapAttributeDeclaration) children[i]).targets = new HashSet();
                        first_for_this_partition = false;
                        // is it perhaps the same as jc.first_pass ?
                      }
                      pw.println("\t\t// <EntityInstantiationLoop>: going to  children");

                      children[i].jjtAccept(visitor, data);
                      pw.println("\t\t// <EntityInstantiationLoop>: after  children");
                    }
                    else {
                      pw.println("\t\t// <EntityInstantiationLoop>: WRONG partition: " + ((X_MapAttributeDeclaration) children[i]).partition);
                      pw.println("\t\t// <EntityInstantiationLoop>: Expected partition: " + mp);
                      pw.println("\t\t// <EntityInstantiationLoop>: node partition: " + partition);
                    }
//						jc.first_pass = false;

                  }
//				} else // MapAttributeDeclaration
//				if (children[i] instanceof X_EntityInstantiationLoop) {
//					attributes_present = true;
//					children[i].jjtAccept(visitor, data);
//				} // X_EntityInstantiationLoop

                } // for

                jc.in_entity_instantiation_loop = false;

                if (!attributes_present) {
                  // better move from attribute, but temporarily, duplicate these things here

                  // this whole thing is inside the loop through partitions, so it is ok
                  // we way need to handle the following cases:
                  // 1. no source parameters (no FROM clause) - just generate 1 instance
                  // 2. 1 source parameter
                  // 3. multiple source parameters
                  // 4. if source parameters, also WHERE clause present or not
                  // 5 IDENTIFIED_BY clause present or not

                  ATarget_parameter atp2 = map_definition.getTarget_parameters(null, null);
                  jsdai.lang.SdaiIterator tpi2 = atp2.createIterator();
                  while (tpi2.next()) {
                    ETarget_parameter tp2 = (ETarget_parameter) atp2.getCurrentMemberObject(tpi2);

                    if (jc.identified_by == false) {
                      pw.println("\t\tfor(int j=0; j < binding_inst_extent.size(); j++){ ");

                      jsdai.SExtended_dictionary_schema.ETarget_parameter target_parameter = tp2;
                      String tar_par_name = target_parameter.getName(null);
                      String plain_target_name = tar_par_name;
                      Vector src_par_names = new Vector();
                      Vector src_par_orders = new Vector();
                      // target instance should be created only once - when first encountered target_parameter
                      HashSet targets = new HashSet();  // this is stupid, it does not do that, just so that it is compileable

                      SdaiIterator spi2 = jc.asp.createIterator();
                      while (spi2.next()) {
                        ESource_parameter sp2 = (ESource_parameter) jc.asp.getCurrentMemberObject(spi2);
                        String sp_name2 = sp2.getName(null);
                        src_par_names.add(sp_name2);
                      }

                      tar_par_name += "_" + jc.target_par_count;
                      jc.target_par_count++;
//							pw.println("\t\t\tValue expr_" +tar_par_name +" = Value.alloc().unset();");

//							pw.println("\t\t\tValue last_expr_" +tar_par_name +" = Value.alloc().unset();");
                      pw.println("");

                      for (int si = 0; si < src_par_names.size(); si++) {
                        //							pw.println("\t\tint src_par_id_" +(String)src_par_names.get(si) +";");
                        //							pw.println("\t\t\tValue " +(String)src_par_names.get(si) +";");
                        first_for_this_partition = false;

                      }

                      if (!targets.contains(plain_target_name)) {
                        EEntity_definition target_type = target_parameter.getExtent(null);
                        String tar_extent_name = target_type.getName(null);
                        String normalized_name = tar_extent_name.substring(0, 1).toUpperCase() + tar_extent_name.substring(1).toLowerCase();
                        String tar_package = getEntityPackage(target_type);
                        String etar_type2 = tar_package + "E" + normalized_name;
                        String ctar_type2 = tar_package + "C" + normalized_name;

                        pw.println("\t\t\t" + etar_type2 + " " + plain_target_name + "_inst = (" + etar_type2 + ")tar_model.createEntityInstance(" + etar_type2
                            + ".class);");
//								pw.println("\t\t\tValue " +plain_target_name +" = Value.alloc(" +ctar_type2 +".definition).set(_context, " +plain_target_name +"_inst);");
                        targets.add(plain_target_name);
                      }
//String gen_target_attr = "KUKU-HAHA";
//							pw.println("\t\t\t" +gen_target_attr +" expr_" +tar_par_name +");"); //  d.setName();

                    }
                    else { // no identified_by
                      // identified_by present
                      // TODO
                    }

                  } // while - through target parameters

                } // if attributes NOT present - constant partition

                pw.println("\t\t} // one-to-many for loop");

              } // if children NOT null (children include binding header)


/*

			int i=0;  // change into the loop, needed for multiple partitions

			if(children[i] instanceof X_WhereClause){
				pw.println("\t\t\t// WHERE clause");
				tabByIndex(ind, pw); pw.print("\tif(");
				children[i].jjtAccept(visitor, data);
				pw.println("){"); 
				tabByIndex(ind, pw); pw.println("\t\tbinding_inst_extent.addElement(binding_inst);");
				tabByIndex(ind, pw); pw.println("\t}");
				i++; // generate next clause
			}else{
				tabByIndex(ind, pw); pw.println("\tbinding_inst_extent.addElement(binding_inst);");
				//								children[i].jjtAccept(visitor, data);
			}

*/
	
	
/*	
	
			while(ind > 0){
				tabByIndex(ind, pw); pw.println("}");
				ind--;
			}

*/



/*

			//
			// IDENTIFIED_BY expression, classification to eq class
			//
			if(i < children.length){
				if(children[i] instanceof X_IdentifiedByClause){
					pw.println("\t\t// IDENTIFIED_BY clause");
					children[i].jjtAccept(visitor, data);
					i++;
				}
			}
			pw.println("");

*/


/*

			//
			// SELECT part
			//
			// evaluate expression parts for the bindings of the same eq class and set appopriate values
			//
			// TODO: error handling in case of incompatible result of expression with left side of select statement
			// TODO: control by numeric increment, control by iteration over aggregate (
			//
			if(i > 0 && children[i-1] instanceof X_IdentifiedByClause){
				pw.println("\t\t// Evaluating expression parts for the bindings of the same eq class and setting appopriate values");
				pw.println("\t\tIterator iter = alist.iterator();");
				pw.println("\t\tfor(int i = 0; i < alist.size() ; i++) {");
				pw.println("\t\t\tint inst_num = 0;");
				// don't do checking, rely on the size
				pw.println("\t\t\tVector eq_class = (Vector)iter.next();");

				jc.identified_by = true;
			}else{
				pw.println("\t\tfor(int j=0; j < binding_inst_extent.size(); j++){ ");
			}


*/

              // this is handling of MapAttributeDeclarations, a separate loop through the children, as of now



/*


			if (children != null) {
				jc.first_pass = true; // define variables in X_MapAttributeDeclaration in first pass

//				for (int l = i; l < children.length; ++l) {
        // could do also from 1, actually better switch to that, because there are changes about i value, making a loop
				for (int l = 0; l < children.length; ++l) {
	System.out.println("child: " + children[l] + ", partition: " + mp_name + ", is 1st pass: " + jc.first_pass);	
					if (children[l] instanceof X_MapAttributeDeclaration) {
						if (((X_MapAttributeDeclaration)children[l]).partition == mp) { 
							if (first_for_this_partition) {
								((X_MapAttributeDeclaration)children[l]).targets = new HashSet();
								first_for_this_partition = false;
								// is it perhaps the same as jc.first_pass ?
							}
						
							children[l].jjtAccept(visitor, data);
						}
					}
				}
				jc.first_pass = false;
			} // if children not NULL

			pw.println("\t\t}");

*/

// moved into the partition loop

//		pw.println("\t\t}");					
//		pw.println("\t\treturn tar_model.getInstances(" +etar_type +".class);");
//		pw.println("\t}");					

            } // loop through partitions

          } // if not subtype

          //     if (children != null) {

          //       for (int l = i; l < children.length; ++l) {
          // 				if(children[l] instanceof X_WhereClause && (jc.entity == map_definition)){
          // 						children[l].jjtAccept(visitor, data);
          // 						pw.println(jc.generated_java);
          // 				}else{
          // 						children[l].jjtAccept(visitor, data);
          // 				}
          //       }

          //     }

          // FIXME: temporary
          // moving up into the partitino loop
//		pw.println("\t\treturn tar_model.getInstances(" +etar_type +".class);");
//		pw.println("\t}");					

        }
        else { // generate execute in java backend instead of here

          AMap_partition amp = map_definition.getPartitions(null, null);
          SdaiIterator mpi = amp.createIterator();

          boolean first_for_this_partition = true;
          while (mpi.next()) {
            EMap_partition mp = (EMap_partition) amp.getCurrentMemberObject(mpi);
            jc.partition = mp;
            String mp_name = mp.getName(null);
            first_for_this_partition = true;
            // ...
            // only default partition supported - em-planner doesn't need others
            // ...

            if (mp_name.equalsIgnoreCase("_implicit_partition_")) {
              mp_name = "default";
            }

////


/*

//			pw.println("\tpublic AEntity processPartition_" +mp_name +"(SdaiModel src_model, SdaiModel tar_model, Hashtable target_instances) throws SdaiException {");
			pw.println("\tpublic AEntity processPartition_" +mp_name +"(SdaiModel src_model, SdaiModel tar_model, Hashtable target_instances, SdaiContext _context) throws SdaiException {");

			// FROM part, generate source binding extent
			pw.println("\t// FROM part, generate source binding extent");
*/
            ASource_parameter asp = mp.getSource_parameters(null, null);
//System.out.println("source parameters: " + asp);
            jc.asp = asp; // save reference for src parameters to be used in Identified_by node
//			SdaiIterator spi = asp.createIterator();

            int ind = 0;
/*
			String add_instances="";

			pw.println("\t\tVector binding_inst_extent = new Vector();");
			pw.println("\t\tVector binding_inst = new Vector();");
			pw.println("\t\tHashtable src_id_map = new Hashtable();");

*/

///////

//				ASource_parameter asp = mp.getSource_parameters(null, null);

//				 jc.asp = asp; // save reference for src parameters to be used in Identified_by node

            if (children != null) {

              boolean attributes_present = false;

              for (int i = 0; i < children.length; i++) {
                // possible children:
                // X_BindingHeader (includes inside optional clauses: From clause, local declarations, WHERE clause, Identified_by clause, Ordered_by clause)
                // X_MapAttributeDeclaration
                // etc

                // so move actions for all this stuff into the children nodes (BindingHeader etc)

// System.out.println("current child: " + children[i] + ", current partition: " + mp.getName(null));

                if (children[i] instanceof X_BindingHeader) {
// System.out.println("current child - BindingHeader, partition: " + ((X_BindingHeader)children[i]).partition.getName(null));
                  jc.identified_by = false;
                  if (((X_BindingHeader) children[i]).partition == mp) {
                    jc.ind = ind;
// System.out.println("Oh YES, invoking!");
// 	pw.println("// INVOKING -------- YES YES YES - TO BindingHeader!!!!!!!!!!!!!!");

                    children[i].jjtAccept(visitor, data);
                  }
                }
                else if (children[i] instanceof X_MapAttributeDeclaration) {

                  attributes_present = true;
                  jc.first_pass = true; // define variables in X_MapAttributeDeclaration in first pass
                  jc.first_pass = first_for_this_partition;

                  // System.out.println("child: " + children[i] + ", partition: " + mp_name + ", is 1st pass: " + jc.first_pass);
                  if (((X_MapAttributeDeclaration) children[i]).partition == mp) {
                    if (first_for_this_partition) {
                      if (jc.identified_by == false) {
                        pw.println("\t\tfor(int j=0; j < binding_inst_extent.size(); j++){ ");
                      }
                      ((X_MapAttributeDeclaration) children[i]).targets = new HashSet();
                      first_for_this_partition = false;
                      // is it perhaps the same as jc.first_pass ?
                    }

                    children[i].jjtAccept(visitor, data);
                  }
//						jc.first_pass = false;

                } // MapAttributeDeclaration

              } // for
              if (!attributes_present) {
                // better move from attribute, but temporarily, duplicate these things here

                // this whole thing is inside the loop through partitions, so it is ok
                // we way need to handle the following cases:
                // 1. no source parameters (no FROM clause) - just generate 1 instance
                // 2. 1 source parameter
                // 3. multiple source parameters
                // 4. if source parameters, also WHERE clause present or not
                // 5 IDENTIFIED_BY clause present or not

                ATarget_parameter atp2 = map_definition.getTarget_parameters(null, null);
                jsdai.lang.SdaiIterator tpi2 = atp2.createIterator();
                while (tpi2.next()) {
                  ETarget_parameter tp2 = (ETarget_parameter) atp2.getCurrentMemberObject(tpi2);

                  if (jc.identified_by == false) {
                    pw.println("\t\tfor(int j=0; j < binding_inst_extent.size(); j++){ ");

                    jsdai.SExtended_dictionary_schema.ETarget_parameter target_parameter = tp2;
                    String tar_par_name = target_parameter.getName(null);
                    String plain_target_name = tar_par_name;
                    Vector src_par_names = new Vector();
                    Vector src_par_orders = new Vector();
                    // target instance should be created only once - when first encountered target_parameter
                    HashSet targets = new HashSet();  // this is stupid, it does not do that, just so that it is compileable

                    SdaiIterator spi2 = jc.asp.createIterator();
                    while (spi2.next()) {
                      ESource_parameter sp2 = (ESource_parameter) jc.asp.getCurrentMemberObject(spi2);
                      String sp_name2 = sp2.getName(null);
                      src_par_names.add(sp_name2);
                    }

                    tar_par_name += "_" + jc.target_par_count;
                    jc.target_par_count++;
//							pw.println("\t\t\tValue expr_" +tar_par_name +" = Value.alloc().unset();");

//							pw.println("\t\t\tValue last_expr_" +tar_par_name +" = Value.alloc().unset();");
                    pw.println("");

                    for (int si = 0; si < src_par_names.size(); si++) {
                      //							pw.println("\t\tint src_par_id_" +(String)src_par_names.get(si) +";");
                      //							pw.println("\t\t\tValue " +(String)src_par_names.get(si) +";");
                      first_for_this_partition = false;

                    }

                    if (!targets.contains(plain_target_name)) {
                      EEntity_definition target_type = target_parameter.getExtent(null);
                      String tar_extent_name = target_type.getName(null);
                      String normalized_name = tar_extent_name.substring(0, 1).toUpperCase() + tar_extent_name.substring(1).toLowerCase();
                      String tar_package = getEntityPackage(target_type);
                      String etar_type2 = tar_package + "E" + normalized_name;
                      String ctar_type2 = tar_package + "C" + normalized_name;

                      pw.println("\t\t\t" + etar_type2 + " " + plain_target_name + "_inst = (" + etar_type2 + ")tar_model.createEntityInstance(" + etar_type2
                          + ".class);");
//								pw.println("\t\t\tValue " +plain_target_name +" = Value.alloc(" +ctar_type2 +".definition).set(_context, " +plain_target_name +"_inst);");
                      targets.add(plain_target_name);
                    }
//String gen_target_attr = "KUKU-HAHA";
//							pw.println("\t\t\t" +gen_target_attr +" expr_" +tar_par_name +");"); //  d.setName();

                  }
                  else { // no identified_by
                    // identified_by present
                    // TODO
                  }

                } // while - through target parameters

              } // if attributes NOT present - constant partition

            }

          } // through partitions

        }    // generate execute in java backend instead of here

        // ------------------ the main case ends here, non-supertype (and with supertypes main subtype, if not moved to a separate later) ---------------
        break;

    } // switch primary - secondary cases

    return data;
  }

//############################################################################################################################
// temporarily duplicated from MapDecl, could be used from one place

  String getEntityPackage(EEntity_or_view_definition eds, SdaiModel current_model)
      throws jsdai.lang.SdaiException {

    // return an empty string if ed and eds in the same schema, and the package of eds otherwise
    String entity_package = "";
    SdaiModel entity_model = eds.findEntityInstanceSdaiModel();

    if (entity_model != current_model) {
      String entity_schema_name = getSchema_definitionFromModel(entity_model).getName(null);

      if (entity_schema_name.equalsIgnoreCase("Sdai_dictionary_schema")) {
        entity_package = "jsdai.dictionary.";
      }
      else {
        entity_package = "jsdai.S" + entity_schema_name.substring(0, 1).toUpperCase() + entity_schema_name.substring(1).toLowerCase() + ".";
      }
    }

    return entity_package;
  }

  String getEntityPackage(EEntity_definition eds) throws SdaiException {
    // return an empty string if ed and eds in the same schema, and the package of eds otherwise
    String entity_package = "";
    SdaiModel entity_model = eds.findEntityInstanceSdaiModel();

    //    if (entity_model != current_model) {
    String entity_schema_name = getSchema_definitionFromModel(entity_model).getName(null);

    if (entity_schema_name.equalsIgnoreCase("Sdai_dictionary_schema")) {
      entity_package = "jsdai.dictionary.";
    }
    else {
      entity_package = "jsdai.S" + entity_schema_name.substring(0, 1).toUpperCase() +
          entity_schema_name.substring(1).toLowerCase() + ".";
    }

    //    }
    return entity_package;
  }

  EGeneric_schema_definition getSchema_definitionFromModel(SdaiModel sm) throws jsdai.lang.SdaiException {
    jsdai.lang.Aggregate ia = sm.getEntityExtentInstances(EGeneric_schema_definition.class);
    jsdai.lang.SdaiIterator iter_inst = ia.createIterator();

    while (iter_inst.next()) {
      EGeneric_schema_definition inst = (EGeneric_schema_definition) ia.getCurrentMemberObject(iter_inst);
      return inst;
    }

    return null;
  }

  void tabByIndex(int ind, PrintWriter pw) {
    pw.print("\t");
    for (int tt = 0; tt < ind; tt++)
      pw.print("\t");
  }

  String tabByIndexToString(int ind, PrintWriter pw, String st) {
    st += "\t";
    for (int tt = 0; tt < ind; tt++)
      st += "\t";
    return st;
  }

  jsdai.SExtended_dictionary_schema.EMap_definition getRootSupertypeMap(jsdai.SExtended_dictionary_schema.EMap_definition map_definition) throws SdaiException {
    jsdai.SExtended_dictionary_schema.EMap_definition md = null;
    if (map_definition.testSuper_type(null)) {
      md = getRootSupertypeMap(map_definition.getSuper_type(null));
    }
    else {
      md = map_definition;
    }
    return md;
  }

}
