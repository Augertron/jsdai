/*
 * $Id$
 *
 * JSDAI(TM), a way to implement STEP, ISO 10303
 * Copyright (C) 1997-2008, LKSoftWare GmbH, Germany
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License
 * version 3 as published by the Free Software Foundation (AGPL v3).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * JSDAI is a registered trademark of LKSoftWare GmbH, Germany
 * This software is also available under commercial licenses.
 * See also http://www.jsdai.net/
 */

/* Generated By:JJTree&JavaCC: Do not edit this line. Compiler2Constants.java */
package jsdai.expressCompiler;

public interface Compiler2Constants {

  int EOF = 0;
  int REFERENCE2 = 8;
  int SINGLE_LINE_COMMENT = 14;
  int SINGLE_LINE_TAGGED_COMMENT = 17;
  int DOCUMENT_COMMENT = 26;
  int LPAREN = 42;
  int RPAREN = 43;
  int LBRACE = 44;
  int RBRACE = 45;
  int LBRACKET = 46;
  int RBRACKET = 47;
  int SEMICOLON = 48;
  int COMMA = 49;
  int DOT = 50;
  int COLON = 51;
  int EQ = 52;
  int ASSIGN = 53;
  int GT = 54;
  int BPATH = 55;
  int FPATH = 56;
  int LT = 57;
  int HOOK = 58;
  int LE = 59;
  int GE = 60;
  int NE = 61;
  int PLUS = 62;
  int MINUS = 63;
  int STAR = 64;
  int STARS = 65;
  int SLASH = 66;
  int BACKSLASH = 67;
  int BIT_OR = 68;
  int OP_AT = 69;
  int COMPLEX_AND = 70;
  int OP_UNDERSCORE = 71;
  int ABS = 72;
  int ABSTRACT = 73;
  int ACOS = 74;
  int AGGREGATE = 75;
  int ALIAS = 76;
  int AND = 77;
  int ANDOR = 78;
  int ARRAY = 79;
  int AS = 80;
  int ASIN = 81;
  int ATAN = 82;
  int BAG = 83;
  int BASED_ON = 84;
  int BEGIN = 85;
  int BINARY = 86;
  int BLENGTH = 87;
  int BOOLEAN = 88;
  int BY = 89;
  int CASE = 90;
  int CONNOTATIONAL = 91;
  int CONSTANT = 92;
  int CONST_E = 93;
  int CONTEXT = 94;
  int COS = 95;
  int CREATE = 96;
  int DEPENDENT_MAP = 97;
  int DERIVE = 98;
  int DIV = 99;
  int EACH = 100;
  int ELSE = 101;
  int ELSIF = 102;
  int END = 103;
  int END_ALIAS = 104;
  int END_CASE = 105;
  int END_CONSTANT = 106;
  int END_CONTEXT = 107;
  int END_CREATE = 108;
  int END_DEPENDENT_MAP = 109;
  int END_ENTITY = 110;
  int END_FUNCTION = 111;
  int END_IF = 112;
  int END_LOCAL = 113;
  int END_MAP = 114;
  int END_MODEL = 115;
  int END_PROCEDURE = 116;
  int END_REPEAT = 117;
  int END_RULE = 118;
  int END_SCHEMA = 119;
  int END_SCHEMA_MAP = 120;
  int END_SCHEMA_VIEW = 121;
  int END_SUBTYPE_CONSTRAINT = 122;
  int END_TYPE = 123;
  int END_VIEW = 124;
  int ENTITY = 125;
  int ENUMERATION = 126;
  int ESCAPE = 127;
  int EXISTS = 128;
  int EXP = 129;
  int EXTENSIBLE = 130;
  int EXTENT = 131;
  int FALSE = 132;
  int FIXED = 133;
  int FOR = 134;
  int FORMAT = 135;
  int FROM = 136;
  int FUNCTION = 137;
  int GENERIC_ENTITY = 138;
  int GENERIC = 139;
  int HIBOUND = 140;
  int HIINDEX = 141;
  int IDENTIFIED_BY = 142;
  int IF = 143;
  int IN = 144;
  int INDEXING = 145;
  int INSERT = 146;
  int INTEGER = 147;
  int INVERSE = 148;
  int LENGTH = 149;
  int LIKE = 150;
  int LIST = 151;
  int LOBOUND = 152;
  int LOCAL = 153;
  int LOG = 154;
  int LOG10 = 155;
  int LOG2 = 156;
  int LOGICAL = 157;
  int LOINDEX = 158;
  int MAP = 159;
  int MOD = 160;
  int MODEL = 161;
  int NOT = 162;
  int NUMBER = 163;
  int NVL = 164;
  int ODD = 165;
  int OF = 166;
  int ONEOF = 167;
  int OPTIONAL = 168;
  int OR = 169;
  int ORDERED_BY = 170;
  int OTHERWISE = 171;
  int PARTITION = 172;
  int PI = 173;
  int PROCEDURE = 174;
  int QUERY = 175;
  int REAL = 176;
  int REFERENCE = 177;
  int REMOVE = 178;
  int RENAMED = 179;
  int REPEAT = 180;
  int RETURN = 181;
  int ROLESOF = 182;
  int RULE = 183;
  int SCHEMA = 184;
  int SCHEMA_MAP = 185;
  int SCHEMA_VIEW = 186;
  int SELECT = 187;
  int SELF = 188;
  int SET = 189;
  int SIN = 190;
  int SIZEOF = 191;
  int SOURCE = 192;
  int SUBTYPE_CONSTRAINT = 193;
  int KW_SKIP = 194;
  int SQRT = 195;
  int STRING = 196;
  int SUBTYPE = 197;
  int SUPERTYPE = 198;
  int TAN = 199;
  int TARGET = 200;
  int THEN = 201;
  int TO = 202;
  int TOTAL_OVER = 203;
  int TRUE = 204;
  int TYPE = 205;
  int TYPEOF = 206;
  int UNIQUE = 207;
  int UNKNOWN = 208;
  int UNTIL = 209;
  int USE = 210;
  int USEDIN = 211;
  int VALUE = 212;
  int VALUE_IN = 213;
  int VALUE_UNIQUE = 214;
  int VAR = 215;
  int VIEW = 216;
  int WITH = 217;
  int WHERE = 218;
  int WHILE = 219;
  int XOR = 220;
  int BINARY_LITERAL = 221;
  int ENCODED_STRING_LITERAL = 222;
  int INTEGER_LITERAL = 223;
  int REAL_LITERAL = 224;
  int SIMPLE_ID = 225;
  int SIMPLE_STRING_LITERAL = 226;
  int BIT = 227;
  int DIGIT = 228;
  int DIGITS = 229;
  int ENCODED_CHARACTER = 230;
  int HEX_DIGIT = 231;
  int LETTER = 232;
  int NOT_PAREN_STAR_QUOTE_SPECIAL = 233;
  int NOT_QUOTE = 234;
  int OCTET = 235;
  int SIGN = 236;
  int GARBAGE = 237;

  int DEFAULT = 0;
  int IN_SINGLE_LINE_COMMENT = 1;
  int IN_SINGLE_LINE_COMMENT_TAG = 2;
  int IN_SINGLE_LINE_TAGGED_COMMENT = 3;
  int IN_DOCUMENT_COMMENT = 4;
  int IN_DOCUMENT_COMMENT_5 = 5;
  int IN_MULTI_LINE_COMMENT_TAG = 6;
  int IN_MULTI_LINE_TAGGED_COMMENT = 7;
  int IN_MULTI_LINE_COMMENT = 8;

  String[] tokenImage = {
      "<EOF>",
      "\" \"",
      "\"\\t\"",
      "\"\\n\"",
      "\"\\r\"",
      "\"\\f\"",
      "\"\\u0000\"",
      "\"\\u00a0\"",
      "\"(*REFERENCE FROM*) USE\"",
      "\"--\\\"\"",
      "\"--\"",
      "\"(**\"",
      "\"(*\\\"\"",
      "\"(*\"",
      "<SINGLE_LINE_COMMENT>",
      "\"\\\"\"",
      "<token of kind 16>",
      "<SINGLE_LINE_TAGGED_COMMENT>",
      "<token of kind 18>",
      "<token of kind 19>",
      "\"(**\"",
      "\"(*\\\"\"",
      "\"(*\"",
      "\"(**\"",
      "\"(*\\\"\"",
      "\"(*\"",
      "\"*)\"",
      "\"*)\"",
      "\"\\\"\"",
      "<token of kind 29>",
      "\"(**\"",
      "\"(*\\\"\"",
      "\"(*\"",
      "\"*)\"",
      "<token of kind 34>",
      "\"(**\"",
      "\"(*\\\"\"",
      "\"(*\"",
      "\"*)\"",
      "<token of kind 39>",
      "<token of kind 40>",
      "<token of kind 41>",
      "\"(\"",
      "\")\"",
      "\"{\"",
      "\"}\"",
      "\"[\"",
      "\"]\"",
      "\";\"",
      "\",\"",
      "\".\"",
      "\":\"",
      "\"=\"",
      "\":=\"",
      "\">\"",
      "\"<-\"",
      "\"::\"",
      "\"<\"",
      "\"?\"",
      "\"<=\"",
      "\">=\"",
      "\"<>\"",
      "\"+\"",
      "\"-\"",
      "\"*\"",
      "\"**\"",
      "\"/\"",
      "\"\\\\\"",
      "\"|\"",
      "\"@\"",
      "\"&\"",
      "\"_\"",
      "\"abs\"",
      "\"abstract\"",
      "\"acos\"",
      "\"aggregate\"",
      "\"alias\"",
      "\"and\"",
      "\"andor\"",
      "\"array\"",
      "\"as\"",
      "\"asin\"",
      "\"atan\"",
      "\"bag\"",
      "\"based_on\"",
      "\"begin\"",
      "\"binary\"",
      "\"blength\"",
      "\"boolean\"",
      "\"by\"",
      "\"case\"",
      "\"connotational\"",
      "\"constant\"",
      "\"const_e\"",
      "\"context\"",
      "\"cos\"",
      "\"create\"",
      "\"dependent_map\"",
      "\"derive\"",
      "\"div\"",
      "\"each\"",
      "\"else\"",
      "\"elsif\"",
      "\"end\"",
      "\"end_alias\"",
      "\"end_case\"",
      "\"end_constant\"",
      "\"end_context\"",
      "\"end_create\"",
      "\"end_dependent_map\"",
      "\"end_entity\"",
      "\"end_function\"",
      "\"end_if\"",
      "\"end_local\"",
      "\"end_map\"",
      "\"end_model\"",
      "\"end_procedure\"",
      "\"end_repeat\"",
      "\"end_rule\"",
      "\"end_schema\"",
      "\"end_schema_map\"",
      "\"end_schema_view\"",
      "\"end_subtype_constraint\"",
      "\"end_type\"",
      "\"end_view\"",
      "\"entity\"",
      "\"enumeration\"",
      "\"escape\"",
      "\"exists\"",
      "\"exp\"",
      "\"extensible\"",
      "\"extent\"",
      "\"false\"",
      "\"fixed\"",
      "\"for\"",
      "\"format\"",
      "\"from\"",
      "\"function\"",
      "\"generic_entity\"",
      "\"generic\"",
      "\"hibound\"",
      "\"hiindex\"",
      "\"identified_by\"",
      "\"if\"",
      "\"in\"",
      "\"indexing\"",
      "\"insert\"",
      "\"integer\"",
      "\"inverse\"",
      "\"length\"",
      "\"like\"",
      "\"list\"",
      "\"lobound\"",
      "\"local\"",
      "\"log\"",
      "\"log10\"",
      "\"log2\"",
      "\"logical\"",
      "\"loindex\"",
      "\"map\"",
      "\"mod\"",
      "\"model\"",
      "\"not\"",
      "\"number\"",
      "\"nvl\"",
      "\"odd\"",
      "\"of\"",
      "\"oneof\"",
      "\"optional\"",
      "\"or\"",
      "\"ordered_by\"",
      "\"otherwise\"",
      "\"partition\"",
      "\"pi\"",
      "\"procedure\"",
      "\"query\"",
      "\"real\"",
      "\"reference\"",
      "\"remove\"",
      "\"renamed\"",
      "\"repeat\"",
      "\"return\"",
      "\"rolesof\"",
      "\"rule\"",
      "\"schema\"",
      "\"schema_map\"",
      "\"schema_view\"",
      "\"select\"",
      "\"self\"",
      "\"set\"",
      "\"sin\"",
      "\"sizeof\"",
      "\"source\"",
      "\"subtype_constraint\"",
      "\"skip\"",
      "\"sqrt\"",
      "\"string\"",
      "\"subtype\"",
      "\"supertype\"",
      "\"tan\"",
      "\"target\"",
      "\"then\"",
      "\"to\"",
      "\"total_over\"",
      "\"true\"",
      "\"type\"",
      "\"typeof\"",
      "\"unique\"",
      "\"unknown\"",
      "\"until\"",
      "\"use\"",
      "\"usedin\"",
      "\"value\"",
      "\"value_in\"",
      "\"value_unique\"",
      "\"var\"",
      "\"view\"",
      "\"with\"",
      "\"where\"",
      "\"while\"",
      "\"xor\"",
      "<BINARY_LITERAL>",
      "<ENCODED_STRING_LITERAL>",
      "<INTEGER_LITERAL>",
      "<REAL_LITERAL>",
      "<SIMPLE_ID>",
      "<SIMPLE_STRING_LITERAL>",
      "<BIT>",
      "<DIGIT>",
      "<DIGITS>",
      "<ENCODED_CHARACTER>",
      "<HEX_DIGIT>",
      "<LETTER>",
      "<NOT_PAREN_STAR_QUOTE_SPECIAL>",
      "<NOT_QUOTE>",
      "<OCTET>",
      "<SIGN>",
      "<GARBAGE>",
      "\"||\"",
      "\"<*\"",
      "\":<>:\"",
      "\":=:\"",
  };

}
