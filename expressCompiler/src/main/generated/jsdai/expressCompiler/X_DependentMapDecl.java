/*
 * $Id$
 *
 * JSDAI(TM), a way to implement STEP, ISO 10303
 * Copyright (C) 1997-2008, LKSoftWare GmbH, Germany
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License
 * version 3 as published by the Free Software Foundation (AGPL v3).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * JSDAI is a registered trademark of LKSoftWare GmbH, Germany
 * This software is also available under commercial licenses.
 * See also http://www.jsdai.net/
 */

/* Generated By:JJTree: Do not edit this line. X_DependentMapDecl.java */

package jsdai.expressCompiler;

import java.util.*;
import java.io.*;

import jsdai.lang.*;
import jsdai.SExtended_dictionary_schema.*;

public class X_DependentMapDecl extends SimpleNode {

  EDependent_map_definition definition;

  public X_DependentMapDecl(int id) {
    super(id);
  }

  public X_DependentMapDecl(Compiler2 p, int id) {
    super(p, id);
  }

  /**
   * Accept the visitor.
   **/
  public Object jjtAccept(Compiler2Visitor visitor, Object data) throws jsdai.lang.SdaiException {
    return visitor.visit(this, data);
  }

  public Object childrenAccept(Compiler2Visitor visitor, Object data) throws jsdai.lang.SdaiException {
    JavaClass jc = (JavaClass) data;
    PrintWriter pw = jc.pw;

    switch (jc.secondary) {
      case 1: // supertype map, WHERE rule
        break;
      case 2: // supertype map, processing map attributes
        break;
      case 0:
      default:

        String map_name = definition.getName(null);
        String map_class_name = "M" + map_name.substring(0, 1).toUpperCase() + map_name.substring(1).toLowerCase();
        pw.println("public class " + map_class_name + " {");
        pw.println("");

        ATarget_parameter atp = definition.getTarget_parameters(null, null);

        pw.println("// <01> atp: " + atp.getMemberCount());

        jsdai.lang.SdaiIterator tpi = atp.createIterator();

//				String etar_type = "" ;

        tpi.next();
        ETarget_parameter tp = (ETarget_parameter) atp.getCurrentMemberObject(tpi); //here
        pw.println("// <02> tp: " + tp);
        String tp_name = tp.getName(null);
        EEntity_definition tp_extent = tp.getExtent(null);
        String tp_extent_name = tp_extent.getName(null);
//				String atar_type = getEntityPackage(tp_extent, jc.model) + "A" + tp_extent_name.substring(0, 1).toUpperCase() + tp_extent_name.substring(1).toLowerCase();
//				etar_type = getEntityPackage(tp_extent, jc.model) + "E" + tp_extent_name.substring(0, 1).toUpperCase() + tp_extent_name.substring(1).toLowerCase();

/*
				while (tpi.next()) {

					ETarget_parameter tp = (ETarget_parameter)atp.getCurrentMemberObject(tpi); //here
					String tp_name = tp.getName(null);
					EEntity_definition tp_extent = tp.getExtent(null);
					String tp_extent_name = tp_extent.getName(null);

				  for (int i = 0; i < children.length; i++) {
						if (children[i] instanceof X_DepMapPartition) {
							children[i].jjtAccept(visitor, data);
						}
        	} // children
				} // through target parameters
*/
//---------------------------------- start --------------------------------------------------------------------------------------

        if (atp.getMemberCount() < 2) {

          String partition_suffix = "";
//			AMap_partition am_p2 = definition.getPartitions(null, null);
//pw.println("// <01> am_p2 partitions: " + am_p2.getMemberCount());
          //SdaiIterator mp_i2 = am_p2.createIterator();
//			while (mp_i2.next()) {
//				EMap_partition m_p2 = (EMap_partition)am_p2.getCurrentMemberObject(mp_i2);
          //String m_p_name2 = m_p2.getName(null);
// System.out.println("partition: " + m_p_name);				
// pw.println("\t//---partition: " + m_p_name);

          for (int i = 0; i < children.length; i++) {
            if (children[i] instanceof X_DepMapPartition) {

              EDependent_map_partition m_p2 = ((X_DepMapPartition) children[i]).partition;
              String m_p_name2 = m_p2.getName(null);

              if (m_p_name2.equalsIgnoreCase("_implicit_partition_")) {
                m_p_name2 = "default";
              }
              else {
                partition_suffix = "Partition_" + m_p_name2;
              }

              // wee need this only when one target parameter, I think
              pw.println("\tprotected static Value call" + partition_suffix + "(SdaiContext _context, Value input) throws SdaiException {");
//				pw.println("\tprotected static Value call(SdaiContext _context, Value input) {");
              pw.println("\t\tValue result;");

              pw.println("\t\tSdaiModel src_model = _context.src_model;");
              pw.println("\t\tSdaiModel tar_model = _context.tar_model;");
//			pw.println("\t\tVector instances_partition_default;");
//RR			pw.println("\t\tHashtable target_instances;");
              pw.println("\t\tHashtable target_instances = new Hashtable();");
              pw.println("");
//			pw.println("\t\t_context.mapHashTable = new Hashtable();");
              pw.println("");

//				pw.println("\t\tresult = callPartition_" + m_p_name + "(src_model, tar_model, target_instances, _context, input);");
              pw.println("\t\tresult = callPartition_" + m_p_name2 + "(src_model, tar_model, target_instances, _context, input);");
              pw.println("\t\treturn result;");
              pw.println("\t}");

            } // if partition
          } // through partitions
			 


/*
			String partition_suffix = "";
			AMap_partition am_p2 = definition.getPartitions(null, null);
pw.println("// <01> am_p2 partitions: " + am_p2.getMemberCount());
			SdaiIterator mp_i2 = am_p2.createIterator();
			while (mp_i2.next()) {
				EMap_partition m_p2 = (EMap_partition)am_p2.getCurrentMemberObject(mp_i2);
				String m_p_name2 = m_p2.getName(null);
// System.out.println("partition: " + m_p_name);				
// pw.println("\t//---partition: " + m_p_name);
				if(m_p_name2.equalsIgnoreCase("_implicit_partition_")){
					m_p_name2 = "default";
				} else {
					partition_suffix = "Partition_" + m_p_name2;
				}
				

				// wee need this only when one target parameter, I think
				pw.println("\tprotected static Value call" + partition_suffix + "(SdaiContext _context, Value input) throws SdaiException {");
//				pw.println("\tprotected static Value call(SdaiContext _context, Value input) {");
			  pw.println("\t\tValue result;");

			pw.println("\t\tSdaiModel src_model = _context.src_model;");
			pw.println("\t\tSdaiModel tar_model = _context.tar_model;");
//			pw.println("\t\tVector instances_partition_default;");
//RR			pw.println("\t\tHashtable target_instances;");
			pw.println("\t\tHashtable target_instances = new Hashtable();");
			pw.println("");
//			pw.println("\t\t_context.mapHashTable = new Hashtable();");
			pw.println("");


//				pw.println("\t\tresult = callPartition_" + m_p_name + "(src_model, tar_model, target_instances, _context, input);");
				pw.println("\t\tresult = callPartition_" + m_p_name2 + "(src_model, tar_model, target_instances, _context, input);");
				pw.println("\t\treturn result;");
				pw.println("\t}");

			 } // through partitions    	
  
*/
        }

        if (atp.getMemberCount() < 2) {

          String partition_suffix = "";
//			AMap_partition am_p2 = definition.getPartitions(null, null);
//			SdaiIterator mp_i2 = am_p2.createIterator();
          //		while (mp_i2.next()) {

          for (int i = 0; i < children.length; i++) {
            if (children[i] instanceof X_DepMapPartition) {

              EDependent_map_partition m_p2 = ((X_DepMapPartition) children[i]).partition;

//				EMap_partition m_p2 = (EMap_partition)am_p2.getCurrentMemberObject(mp_i2);
              String m_p_name2 = m_p2.getName(null);
// System.out.println("partition: " + m_p_name);				
// pw.println("\t//---partition: " + m_p_name);
              if (m_p_name2.equalsIgnoreCase("_implicit_partition_")) {
                m_p_name2 = "default";
              }
              else {
                partition_suffix = "Partition_" + m_p_name2;
              }

              pw.println("\tprotected static Value callTarget_" + tp_name + partition_suffix + "(SdaiContext _context, Value input) throws SdaiException {");
//			pw.println("\tprotected static Value callTarget_" + tp_name + "(SdaiContext _context, Value input) {");
              pw.println("\t\tValue result;");

              pw.println("\t\tSdaiModel src_model = _context.src_model;");
              pw.println("\t\tSdaiModel tar_model = _context.tar_model;");
//			pw.println("\t\tVector instances_partition_default;");
//RR			pw.println("\t\tHashtable target_instances;");
              pw.println("\t\tHashtable target_instances = new Hashtable();");
              pw.println("");
//			pw.println("\t\t_context.mapHashTable = new Hashtable();");
              pw.println("");

//				pw.println("\t\tresult = callPartition_" + m_p_name + "(src_model, tar_model, target_instances, _context, input);");
              jc.target = null;
              pw.println("\t\tresult = callPartition_" + m_p_name2 + "(src_model, tar_model, target_instances, _context, input);");
              pw.println("\t\treturn result;");
              pw.println("\t}");

/*
			String partition_suffix = "";
			AMap_partition am_p2 = definition.getPartitions(null, null);
			SdaiIterator mp_i2 = am_p2.createIterator();
			while (mp_i2.next()) {
				EMap_partition m_p2 = (EMap_partition)am_p2.getCurrentMemberObject(mp_i2);
				String m_p_name2 = m_p2.getName(null);
// System.out.println("partition: " + m_p_name);				
// pw.println("\t//---partition: " + m_p_name);
				if(m_p_name2.equalsIgnoreCase("_implicit_partition_")){
					m_p_name2 = "default";
				} else {
					partition_suffix = "Partition_" + m_p_name2;
				}
    
			pw.println("\tprotected static Value callTarget_" + tp_name +  partition_suffix + "(SdaiContext _context, Value input) throws SdaiException {");
//			pw.println("\tprotected static Value callTarget_" + tp_name + "(SdaiContext _context, Value input) {");
			  pw.println("\t\tValue result;");

			pw.println("\t\tSdaiModel src_model = _context.src_model;");
			pw.println("\t\tSdaiModel tar_model = _context.tar_model;");
//			pw.println("\t\tVector instances_partition_default;");
//RR			pw.println("\t\tHashtable target_instances;");
			pw.println("\t\tHashtable target_instances = new Hashtable();");
			pw.println("");
//			pw.println("\t\t_context.mapHashTable = new Hashtable();");
			pw.println("");


//				pw.println("\t\tresult = callPartition_" + m_p_name + "(src_model, tar_model, target_instances, _context, input);");
				jc.target = null;
				pw.println("\t\tresult = callPartition_" + m_p_name2 + "(src_model, tar_model, target_instances, _context, input);");
			pw.println("\t\treturn result;");
			pw.println("\t}");

*/
            } // if partition

          } // through partitions

        }
        else {
          // multiple targets

          jsdai.lang.SdaiIterator tpi2 = atp.createIterator();

          while (tpi2.next()) {

            ETarget_parameter tp2 = (ETarget_parameter) atp.getCurrentMemberObject(tpi2); //here
            String tp2_name = tp2.getName(null);

            String partition_suffix = "";
//			AMap_partition am_p2 = definition.getPartitions(null, null);
//			SdaiIterator mp_i2 = am_p2.createIterator();
//			while (mp_i2.next()) {
//				EMap_partition m_p2 = (EMap_partition)am_p2.getCurrentMemberObject(mp_i2);

            for (int i = 0; i < children.length; i++) {
              if (children[i] instanceof X_DepMapPartition) {

                EDependent_map_partition m_p2 = ((X_DepMapPartition) children[i]).partition;

                String m_p_name2 = m_p2.getName(null);
// System.out.println("partition: " + m_p_name);				
// pw.println("\t//---partition: " + m_p_name);
                if (m_p_name2.equalsIgnoreCase("_implicit_partition_")) {
                  m_p_name2 = "default";
                }
                else {
                  partition_suffix = "Partition_" + m_p_name2;
                }

                pw.println("\tprotected static Value callTarget_" + tp2_name + partition_suffix + "(SdaiContext _context, Value input) throws SdaiException {");
//			pw.println("\tprotected static Value callTarget_" + tp_name + "(SdaiContext _context, Value input) {");
                pw.println("\t\tValue result;");

                pw.println("\t\tSdaiModel src_model = _context.src_model;");
                pw.println("\t\tSdaiModel tar_model = _context.tar_model;");
//			pw.println("\t\tVector instances_partition_default;");
//RR			pw.println("\t\tHashtable target_instances;");
                pw.println("\t\tHashtable target_instances = new Hashtable();");
                pw.println("");
//			pw.println("\t\t_context.mapHashTable = new Hashtable();");
                pw.println("");

//				pw.println("\t\tresult = callPartition_" + m_p_name + "(src_model, tar_model, target_instances, _context, input);");
                // jc.target = tp2;
                pw.println("\t\tresult = callTarget_" + tp2_name + "Partition_" + m_p_name2 + "(src_model, tar_model, target_instances, _context, input);");
                // jc.target = null;
                pw.println("\t\treturn result;");
                pw.println("\t}");

              } // if partition
            } // through partitions
          } // through targets
			



/*

			jsdai.lang.SdaiIterator tpi2 = atp.createIterator();

			while (tpi2.next()) {
				
			ETarget_parameter tp2 = (ETarget_parameter)atp.getCurrentMemberObject(tpi2); //here
			String tp2_name = tp2.getName(null);


			String partition_suffix = "";
			AMap_partition am_p2 = definition.getPartitions(null, null);
			SdaiIterator mp_i2 = am_p2.createIterator();
			while (mp_i2.next()) {
				EMap_partition m_p2 = (EMap_partition)am_p2.getCurrentMemberObject(mp_i2);
				String m_p_name2 = m_p2.getName(null);
// System.out.println("partition: " + m_p_name);				
// pw.println("\t//---partition: " + m_p_name);
				if(m_p_name2.equalsIgnoreCase("_implicit_partition_")){
					m_p_name2 = "default";
				} else {
					partition_suffix = "Partition_" + m_p_name2;
				}



			pw.println("\tprotected static Value callTarget_" + tp2_name + partition_suffix + "(SdaiContext _context, Value input) throws SdaiException {");
//			pw.println("\tprotected static Value callTarget_" + tp_name + "(SdaiContext _context, Value input) {");
			  pw.println("\t\tValue result;");

			pw.println("\t\tSdaiModel src_model = _context.src_model;");
			pw.println("\t\tSdaiModel tar_model = _context.tar_model;");
//			pw.println("\t\tVector instances_partition_default;");
//RR			pw.println("\t\tHashtable target_instances;");
			pw.println("\t\tHashtable target_instances = new Hashtable();");
			pw.println("");
//			pw.println("\t\t_context.mapHashTable = new Hashtable();");
			pw.println("");


//				pw.println("\t\tresult = callPartition_" + m_p_name + "(src_model, tar_model, target_instances, _context, input);");
			// jc.target = tp2;
				pw.println("\t\tresult = callTarget_" + tp2_name + "Partition_" + m_p_name2 + "(src_model, tar_model, target_instances, _context, input);");
			// jc.target = null;
			pw.println("\t\treturn result;");
			pw.println("\t}");


	    } // through partitions			
		} // through targets
	
*/

        } // multiple targets

// --------------------------------- end --------------------------------------------------------------------------------------------

        pw.println("");
        pw.println("\t/*---------------------- methods implementing  map calls for each partition --------------------*/");
        pw.println("");

        if (definition.testSuper_type(null)) {
          //TODO
        }
        else { // nut a subtype dependent_map
          // perhaps do it in the partition node: X_DepMapPartition

          for (int i = 0; i < children.length; i++) {
            if (children[i] instanceof X_DepMapPartition) {
              children[i].jjtAccept(visitor, data);
            }
            else {
              pw.println("// DependentMapDecl node: " + children[i]);

            }
          }

        }

        break; // case 0;
    } // switch jc.secondary
    return data;

  } // childrenAccept

/*
  String getEntityPackage(EEntity_definition eds) throws SdaiException {
    // return an empty string if ed and eds in the same schema, and the package of eds otherwise
    String entity_package = "";
    SdaiModel entity_model = eds.findEntityInstanceSdaiModel();

    //    if (entity_model != current_model) {
    String entity_schema_name = getSchema_definitionFromModel(entity_model).getName(null);

    if (entity_schema_name.equalsIgnoreCase("Sdai_dictionary_schema")) {
      entity_package = "jsdai.dictionary.";
    } else {
      entity_package = "jsdai.S" + entity_schema_name.substring(0, 1).toUpperCase() + 
                       entity_schema_name.substring(1).toLowerCase() + ".";
    }

    //    }
    return entity_package;
  }
*/

/*
  EGeneric_schema_definition getSchema_definitionFromModel(SdaiModel sm) throws jsdai.lang.SdaiException {
    jsdai.lang.Aggregate ia = sm.getEntityExtentInstances(EGeneric_schema_definition.class);
    jsdai.lang.SdaiIterator iter_inst = ia.createIterator();

    while (iter_inst.next()) {
      EGeneric_schema_definition inst = ( EGeneric_schema_definition )ia.getCurrentMemberObject(iter_inst);
      return inst;
    }

    return null;
	  }
*/

}
