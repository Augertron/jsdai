(*
 * $Id$
 *
 * JSDAI(TM), a way to implement STEP, ISO 10303
 * Copyright (C) 1997-2008, LKSoftWare GmbH, Germany
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License
 * version 3 as published by the Free Software Foundation (AGPL v3).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * JSDAI is a registered trademark of LKSoftWare GmbH, Germany
 * This software is also available under commercial licenses.
 * See also http://www.jsdai.net/
 *)

(*schema_mapping extended_geometric_tolerance(Extended_geometric_tolerance_arm, Extended_geometric_tolerance_mim);*)


entity_mapping Apex_armx(Apex_armx, apex);

mapping_constraints;

end_mapping_constraints;

end_entity_mapping;

entity_mapping Boundary_size_characteristic(Boundary_size_characteristic, representation);

mapping_constraints;
{representation
(representation.name = 'diametrical boundary size')
(representation.name = 'opposing boundary set size')}

end_mapping_constraints;

attribute_mapping tolerance_value(tolerance_value, $PATH, length_measure_with_unit);
representation
representation.items[i] ->
{representation_item
representation_item.name = 'tolerance value'}
representation_item =>
measure_representation_item <=
measure_with_unit =>
length_measure_with_unit

end_attribute_mapping;

attribute_mapping maximum_tolerance_value(maximum_tolerance_value, $PATH, length_measure_with_unit);
representation
representation.items[i] ->
{representation_item
representation_item.name = 'maximum tolerance value'}
representation_item =>
measure_representation_item <=
measure_with_unit =>
length_measure_with_unit

end_attribute_mapping;

end_entity_mapping;

entity_mapping Centre_axis(Centre_axis, centre_of_symmetry);

mapping_constraints;
{centre_of_symmetry <=
derived_shape_aspect <=
shape_aspect
shape_aspect.description = 'axis'}

end_mapping_constraints;

end_entity_mapping;

entity_mapping Centre_of_symmetry_armx(Centre_of_symmetry_armx, centre_of_symmetry);

mapping_constraints;

end_mapping_constraints;

end_entity_mapping;

entity_mapping Centre_plane(Centre_plane, centre_of_symmetry);

mapping_constraints;
{centre_of_symmetry <=
derived_shape_aspect <=
shape_aspect
shape_aspect.description = 'plane'}

end_mapping_constraints;

end_entity_mapping;

entity_mapping Centre_point(Centre_point, centre_of_symmetry);

mapping_constraints;
{centre_of_symmetry <=
derived_shape_aspect <=
shape_aspect
shape_aspect.description = 'point'}

end_mapping_constraints;

end_entity_mapping;

entity_mapping Composite_linear_profile_refinement_tolerance(Composite_linear_profile_refinement_tolerance, linear_profile_tolerance);

mapping_constraints;
linear_profile_tolerance <=
physical_unit_geometric_tolerance <=
geometric_tolerance
{geometric_tolerance.name = 'linear profile refinement'}

end_mapping_constraints;

attribute_mapping refined_control(refined_control, $PATH, Line_profile_tolerance);
linear_profile_tolerance <=
physical_unit_geometric_tolerance <=
geometric_tolerance <-
geometric_tolerance_relationship.related_geometric_tolerance
geometric_tolerance_relationship
{geometric_tolerance_relationship
geometric_tolerance_relationship.name = 'linear profile refining control'}
geometric_tolerance_relationship.relating_geometric_tolerance ->
{geometric_tolerance
geometric_tolerance.name = 'linear profile locating'}
geometric_tolerance =>
physical_unit_geometric_tolerance =>
linear_profile_tolerance

end_attribute_mapping;

attribute_mapping refined_control(refined_control, $PATH, Composite_linear_profile_refinement_tolerance);
linear_profile_tolerance <=
physical_unit_geometric_tolerance <=
geometric_tolerance <-
geometric_tolerance_relationship.related_geometric_tolerance
geometric_tolerance_relationship
{geometric_tolerance_relationship
geometric_tolerance_relationship.name = 'linear profile refining control'}
geometric_tolerance_relationship.relating_geometric_tolerance ->
{geometric_tolerance
geometric_tolerance.name = 'linear profile refinement'}
geometric_tolerance =>
physical_unit_geometric_tolerance =>
linear_profile_tolerance

end_attribute_mapping;

end_entity_mapping;

entity_mapping Composite_surface_profile_refinement_tolerance(Composite_surface_profile_refinement_tolerance, surface_profile_tolerance);

mapping_constraints;
surface_profile_tolerance <=
geometric_tolerance
{geometric_tolerance.name = 'surface profile refinement'}

end_mapping_constraints;

attribute_mapping refined_control(refined_control, $PATH, Surface_profile_tolerance);
surface_profile_tolerance <=
geometric_tolerance <-
geometric_tolerance_relationship.related_geometric_tolerance
geometric_tolerance_relationship
{geometric_tolerance_relationship
geometric_tolerance_relationship.name = 'surface profile refining control'}
geometric_tolerance_relationship.relating_geometric_tolerance ->
{geometric_tolerance
geometric_tolerance.name = 'surface profile locating'}
geometric_tolerance =>
surface_profile_tolerance

end_attribute_mapping;

attribute_mapping refined_control(refined_control, $PATH, Composite_surface_profile_refinement_tolerance);
surface_profile_tolerance <=
geometric_tolerance <-
geometric_tolerance_relationship.related_geometric_tolerance
geometric_tolerance_relationship
{geometric_tolerance_relationship
geometric_tolerance_relationship.name = 'surface profile refining control'}
geometric_tolerance_relationship.relating_geometric_tolerance ->
{geometric_tolerance
geometric_tolerance.name = 'surface profile refinement'}
geometric_tolerance =>
surface_profile_tolerance

end_attribute_mapping;

end_entity_mapping;

entity_mapping Conical_tolerance_zone_boundary(Conical_tolerance_zone_boundary, tolerance_zone_boundary);

mapping_constraints;
tolerance_zone_boundary <=
shape_aspect
{shape_aspect
shape_aspect.description = 'conical'}

end_mapping_constraints;

end_entity_mapping;

entity_mapping Conical_tolerance_zone_boundary_and_surface_relationship(Conical_tolerance_zone_boundary_and_surface_relationship, shape_aspect_relationship);

mapping_constraints;
{shape_aspect_relationship
shape_aspect_relationship.name = 'conical tolerance zone boundary and surface'}

end_mapping_constraints;

attribute_mapping sized_tolerance_zone_boundary(sized_tolerance_zone_boundary, $PATH, Conical_tolerance_zone_boundary);
shape_aspect_relationship
shape_aspect_relationship.relating_shape_aspect ->
{shape_aspect
shape_aspect.description = 'conical'}
shape_aspect =>
tolerance_zone_boundary

end_attribute_mapping;

attribute_mapping terminating_surface(terminating_surface, $PATH, physical_feature_or_part_template);
shape_aspect_relationship
shape_aspect_relationship.related_shape_aspect ->
shape_aspect

end_attribute_mapping;

attribute_mapping terminating_surface_datum(terminating_surface_datum, $PATH, Shape_element);
shape_aspect_relationship
shape_aspect_relationship.related_shape_aspect ->
shape_aspect
end_attribute_mapping;

attribute_mapping terminating_surface_datum(terminating_surface_datum, $PATH, Datum_defined_by_feature);
shape_aspect_relationship
shape_definition = shape_aspect_relationship
shape_definition
characterized_definition = shape_definition
characterized_definition <-
property_definition.definition
property_definition <-
property_definition_relationship.related_property_definition
property_definition_relationship
{property_definition_relationship
property_definition_relationship.name = 'terminating surface datum'}
property_definition_relationship.relating_property_definition ->
property_definition
property_definition.definition ->
characterized_definition
characterized_definition = shape_definition
shape_definition
shape_definition = shape_aspect
shape_aspect =>
datum
end_attribute_mapping;


end_entity_mapping;

entity_mapping Conical_tolerance_zone_boundary_diametrical_size_characteristic(Conical_tolerance_zone_boundary_diametrical_size_characteristic, property_definition);

mapping_constraints;
{property_definition
property_definition.description = 'conical tolerance zone boundary size'}

end_mapping_constraints;

attribute_mapping sized_boundary_at_surface(sized_boundary_at_surface, $PATH, Conical_tolerance_zone_boundary_and_surface_relationship);
property_definition
property_definition.definition ->
characterized_definition
characterized_definition = shape_definition
shape_definition
shape_definition = shape_aspect_relationship
shape_aspect_relationship
{shape_aspect_relationship
shape_aspect_relationship.name = 'conical tolerance zone boundary and surface'}

end_attribute_mapping;

attribute_mapping tolerance_value(tolerance_value, $PATH, length_measure_with_unit);
property_definition <-
property_definition_representation.definition
property_definition_representation
property_definition_representation.used_representation ->
representation
representation.items[i] ->
{representation_item
representation_item.name = 'conical tolerance zone boundary value'}
representation_item =>
measure_representation_item <=
measure_with_unit =>
length_measure_with_unit

end_attribute_mapping;

end_entity_mapping;

entity_mapping Conical_tolerance_zone_definition(Conical_tolerance_zone_definition, tolerance_zone_definition);

mapping_constraints;
{tolerance_zone_definition
tolerance_zone_definition.zone ->
tolerance_zone <=
shape_aspect
{shape_aspect
shape_aspect.description = 'conical'}}

end_mapping_constraints;

end_entity_mapping;

entity_mapping Datum_axis(Datum_axis, datum);

mapping_constraints;
datum <=
shape_aspect
{shape_aspect
shape_aspect.description = 'axis'}

end_mapping_constraints;

end_entity_mapping;

entity_mapping Datum_axis_and_tolerance_zone_orienting_relationship(Datum_axis_and_tolerance_zone_orienting_relationship, shape_aspect_relationship);

mapping_constraints;
{shape_aspect_relationship
shape_aspect_relationship.name = 'datum axis and tolerance zone'}

end_mapping_constraints;

attribute_mapping oriented_tolerance_zone(oriented_tolerance_zone, $PATH, Tolerance_zone);
shape_aspect_relationship
shape_aspect_relationship.relating_shape_aspect -> 
shape_aspect =>
tolerance_zone

end_attribute_mapping;

attribute_mapping orienting_datum_axis(orienting_datum_axis, $PATH, Datum_axis);
shape_aspect_relationship
shape_aspect_relationship.related_shape_aspect -> 
{shape_aspect
shape_aspect.description = 'axis'}
shape_aspect =>
datum

end_attribute_mapping;

end_entity_mapping;

entity_mapping Datum_axis_related_orientation(Datum_axis_related_orientation, property_definition);

mapping_constraints;
{property_definition
property_definition.description = 'datum axis related orientation'}

end_mapping_constraints;

attribute_mapping orientation_type(orientation_type, property_definition.name);
property_definition
property_definition.name
{(property_definition.name = 'centred on arc')
(property_definition.name = 'centred on radial')}

end_attribute_mapping;

attribute_mapping orienting_relationship(orienting_relationship, $PATH, Datum_axis_and_tolerance_zone_orienting_relationship);
property_definition
property_definition.definition ->
characterized_definition
characterized_definition = shape_definition
shape_definition
shape_definition = shape_aspect_relationship
shape_aspect_relationship
{shape_aspect_relationship
shape_aspect_relationship.name = 'datum axis and tolerance zone'}

end_attribute_mapping;

end_entity_mapping;

entity_mapping Datum_based_direction_vector(Datum_based_direction_vector, property_definition);

mapping_constraints;
property_definition
property_definition.description
{property_definition.description = 'datum direction property'}

end_mapping_constraints;

attribute_mapping positive_direction_vector(positive_direction_vector, property_definition.name);
property_definition
property_definition.name
{(property_definition.name = 'positive direction vector')
(property_definition.name = 'negative direction vector')}

end_attribute_mapping;

attribute_mapping direction_vector_representation(direction_vector_representation, $PATH, axis2_placement);
property_definition <-
property_definition_representation.definition
property_definition_representation
property_definition_representation.used_representation ->
representation
representation.items[i] ->
{representation_item
representation_item.name = 'orientation'}
representation_item =>
geometric_representation_item =>
placement =>
axis2_placement_2d

end_attribute_mapping;

attribute_mapping vector_of(vector_of, $PATH, Datum_plane);
property_definition
property_definition.definition ->
characterized_definition
characterized_definition = shape_definition
shape_definition
shape_definition = shape_aspect
{shape_aspect
shape_aspect.description = 'plane'}
shape_aspect =>
datum

end_attribute_mapping;

end_entity_mapping;

entity_mapping Datum_based_length_measure(Datum_based_length_measure, representation);

mapping_constraints;
{representation
(representation.name = 'maximum positive component height')
(representation.name = 'maximum negative component height')
(representation.name = 'maximum mounting clearance')
(representation.name = 'minimum mounting clearance')}

end_mapping_constraints;

attribute_mapping measure_orientation(measure_orientation, descriptive_representation_item.description);
representation
representation.items[i] ->
{representation_item
representation_item.name = 'descriptive orientation'}
representation_item =>
descriptive_representation_item
descriptive_representation_item.description
{(descriptive_representation_item.description = 'normal')
(descriptive_representation_item.description = 'reversed')}


end_attribute_mapping;

attribute_mapping of_datum(of_datum, $PATH, Datum_plane);
representation <-
property_definition_representation.used_representation
property_definition_representation
property_definition_representation.definition ->
property_definition
property_definition.definition ->
characterized_definition
characterized_definition = shape_definition
shape_definition
shape_definition = shape_aspect
{shape_aspect
shape_aspect.description = 'plane'}
shape_aspect =>
datum

end_attribute_mapping;

attribute_mapping measure(measure, $PATH, length_measure_with_unit);
representation
representation.items[i] ->
{representation_item
representation_item.name = 'measure'}
representation_item =>
measure_representation_item <=
measure_with_unit =>
length_measure_with_unit

end_attribute_mapping;

attribute_mapping measure_orientation(measure_orientation, $PATH, Direction);
representation
representation.items[i] ->
{representation_item
representation_item.name = 'geometric orientation'}
representation_item =>
geometric_representation_item =>
direction

end_attribute_mapping;

end_entity_mapping;

entity_mapping Datum_based_vector_orientation(Datum_based_vector_orientation, property_definition);

mapping_constraints;
{[property_definition
property_definition.description = 'datum based vector orientation']
[property_definition
property_definition.definition ->
characterized_definition
characterized_definition = shape_definition
shape_definition
shape_definition = shape_aspect
shape_aspect
{shape_aspect
shape_aspect.description = 'vector'}]}

end_mapping_constraints;

attribute_mapping direction_components(direction_components, $PATH, Datum_based_direction_element);
property_definition <-
property_definition_relationship.relating_property_definition
property_definition_relationship
{property_definition_relationship
property_definition_relationship.name = 'direction component'}
property_definition_relationship.related_property_definition ->
property_definition
{property_definition
property_definition.description = 'direction element'}

end_attribute_mapping;

end_entity_mapping;

entity_mapping Datum_difference_armx(Datum_difference_armx, datum_difference);

mapping_constraints;
[datum_difference <=
shape_aspect_relationship]
[datum_difference <=
shape_aspect]
{shape_aspect_relationship
[shape_aspect_relationship.related_shape_aspect ->
shape_aspect =>
datum]
[shape_aspect_relationship.relating_shape_aspect ->
shape_aspect =>
datum]}

end_mapping_constraints;

attribute_mapping precedent_datum(precedent_datum, $PATH, Datum);
shape_aspect_relationship
shape_aspect_relationship.relating_shape_aspect ->
shape_aspect => 
datum

end_attribute_mapping;

attribute_mapping subsequent_datum(subsequent_datum, $PATH, Datum);
shape_aspect_relationship
shape_aspect_relationship.related_shape_aspect ->
shape_aspect =>
datum

end_attribute_mapping;

end_entity_mapping;

entity_mapping Datum_difference_based_characteristic_armx(Datum_difference_based_characteristic_armx, datum_difference_based_characteristic);

mapping_constraints;
datum_difference_based_characteristic <=
representation_item

end_mapping_constraints;

attribute_mapping of_datum_difference(of_datum_difference, $PATH, Datum_difference_armx);
datum_difference_based_characteristic <=
representation_item <-
representation.items[i]
representation <-
{representation 
representation.name = 'of datum difference'}
property_definition_representation.used_representation
property_definition_representation
property_definition_representation.definition ->
property_definition
property_definition.definition ->
characterized_definition
characterized_definition = shape_definition
shape_definition
shape_definition = shape_aspect_relationship
shape_aspect_relationship =>
datum_difference

end_attribute_mapping;

end_entity_mapping;

entity_mapping Datum_plane(Datum_plane, datum);

mapping_constraints;
datum <=
shape_aspect
{shape_aspect
shape_aspect.description = 'plane'}

end_mapping_constraints;

end_entity_mapping;

entity_mapping Datum_point(Datum_point, datum);

mapping_constraints;
datum <=
shape_aspect
{shape_aspect
shape_aspect.description = 'point'}

end_mapping_constraints;
(* Removed attributes
attribute_mapping location_in_2d(location_in_2d, $PATH, Cartesian_point);
datum <=
shape_aspect
shape_definition = shape_aspect
characterized_definition = shape_definition
characterized_definition <-
property_definition.definition
property_definition <-
property_definition_representation.definition
property_definition_representation.used_representation ->
representation
representation.items[i] ->
representation_item =>
geometric_representation_item =>
point =>
cartesian_point

end_attribute_mapping;

attribute_mapping location_in_3d(location_in_3d, $PATH, Cartesian_point);
datum <=
shape_aspect
shape_definition = shape_aspect
characterized_definition = shape_definition
characterized_definition <-
property_definition.definition 
property_definition <-
property_definition_representation.definition
property_definition_representation.used_representation ->
representation
representation.items[i] ->
representation_item =>
geometric_representation_item =>
point =>
cartesian_point

end_attribute_mapping;

attribute_mapping associated_3d_shape_intersection(associated_3d_shape_intersection, $PATH, Shape_definition_3d_intersection_armx);
datum <=
shape_aspect
shape_definition = shape_aspect
characterized_definition = shape_definition
characterized_definition <-
property_definition.definition 
property_definition <-
property_definition_representation.definition
property_definition_representation.used_representation ->
representation =>
shape_definition_3d_intersection

end_attribute_mapping;
*)
end_entity_mapping;

entity_mapping Datum_shape_element(Datum_shape_element, [/SUPERTYPE(Datum)/][/SUPERTYPE(Non_feature_shape_element)/]);

end_entity_mapping;

entity_mapping Derived_non_feature_shape_element(Derived_non_feature_shape_element, derived_shape_aspect);

mapping_constraints;

end_mapping_constraints;

end_entity_mapping;

entity_mapping Diametrical_boundary_size_characteristic(Diametrical_boundary_size_characteristic, representation);

mapping_constraints;
{representation
representation.name = 'diametrical boundary size'}

end_mapping_constraints;

attribute_mapping sized_boundary(sized_boundary, $PATH, Tolerance_zone_circular_or_cylindrical_or_spherical_boundary);
representation <-
property_definition_representation.used_representation
property_definition_representation
property_definition_representation.definition ->
property_definition
{property_definition
property_definition.description = 'boundary zone definition with specified size'}
property_definition.definition ->
characterized_definition
characterized_definition = shape_definition
shape_definition
shape_definition = shape_aspect
{shape_aspect
shape_aspect.description = 'circular or cylindrical or spherical'}
shape_aspect =>
tolerance_zone_boundary

end_attribute_mapping;

end_entity_mapping;

entity_mapping Dimension_qualifier(Dimension_qualifier, measure_qualification);

mapping_constraints;
{measure_qualification
(measure_qualification.name = 'predefined dimension qualifier')
(measure_qualification.name = 'user defined dimension qualifier')}

end_mapping_constraints;

attribute_mapping qualified_dimensions(qualified_dimensions, $PATH, Geometric_dimension);
measure_qualification
measure_qualification.qualified_measure ->
measure_with_unit =>
measure_representation_item <=
representation_item <-
representation.items[i]
representation =>
shape_representation =>
shape_dimension_representation <-
dimensional_characteristic_representation.representation
dimensional_characteristic_representation
dimensional_characteristic_representation.dimension ->
dimensional_characteristic
(dimensional_characteristic = dimensional_location)
(dimensional_characteristic = dimensional_size)

end_attribute_mapping;

end_entity_mapping;

entity_mapping Dimension_related_positional_boundary(Dimension_related_positional_boundary, positional_boundary);

mapping_constraints;
positional_boundary <=
shape_aspect
{shape_aspect
shape_aspect.description = 'dimension related positional boundary'}

end_mapping_constraints;

attribute_mapping boundary_members(boundary_members, $PATH, Positional_boundary_member_armx);
positional_boundary <=
shape_aspect <-
shape_aspect_relationship.relating_shape_aspect
shape_aspect_relationship
{shape_aspect_relationship
shape_aspect_relationship.name = 'boundary member'}
shape_aspect_relationship.related_shape_aspect ->
shape_aspect =>
positional_boundary_member

end_attribute_mapping;

attribute_mapping constrained_physical_feature(constrained_physical_feature, $PATH, physical_feature_or_part_template);
positional_boundary <=
shape_aspect <-
shape_aspect_relationship.relating_shape_aspect
shape_aspect_relationship
{shape_aspect_relationship
shape_aspect_relationship.name = 'constrained feature'}
shape_aspect_relationship.related_shape_aspect ->
shape_aspect

end_attribute_mapping;

attribute_mapping constrained_physical_feature(constrained_physical_feature, $PATH, Shape_element);
positional_boundary <=
				shape_aspect <-
				shape_aspect_relationship.relating_shape_aspect
				shape_aspect_relationship
				{shape_aspect_relationship
				shape_aspect_relationship.name = 'constrained feature'}
				shape_aspect_relationship.related_shape_aspect ->
				shape_aspect
end_attribute_mapping;

attribute_mapping constrained_physical_feature_datum(constrained_physical_feature_datum, $PATH, Datum_defined_by_feature);
				positional_boundary <=
				shape_aspect <-
				shape_aspect_relationship.relating_shape_aspect
				shape_aspect_relationship
				{shape_aspect_relationship
				shape_aspect_relationship.name = 'constrained feature datum'}
				shape_aspect_relationship.related_shape_aspect ->
				shape_aspect =>
				datum
end_attribute_mapping;

end_entity_mapping;

entity_mapping Dimension_related_positional_boundary_definition(Dimension_related_positional_boundary_definition, property_definition);

mapping_constraints;
{property_definition
property_definition.description = 'dimension related positional boundary property'}

end_mapping_constraints;

attribute_mapping defined_positional_boundary(defined_positional_boundary, $PATH, Dimension_related_positional_boundary);
property_definition
property_definition.definition ->
characterized_definition
characterized_definition = shape_definition
shape_definition
shape_definition = shape_aspect
{shape_aspect
shape_aspect.description = 'dimension related positional boundary'}
shape_aspect =>
positional_boundary

end_attribute_mapping;

attribute_mapping characterized_boundary_member_definitions(characterized_boundary_member_definitions, $PATH, Positional_boundary_member_definition);
property_definition <-
property_definition_relationship.relating_property_definition
property_definition_relationship
{property_definition_relationship
property_definition_relationship.name = 'defined boundary member property'}
property_definition_relationship.related_property_definition ->
property_definition
{property_definition
property_definition.description = 'positional boundary member property'}

end_attribute_mapping;

end_entity_mapping;

entity_mapping Dimension_set(Dimension_set, property_definition);

mapping_constraints;
{property_definition
property_definition.description = 'dimension set'}

end_mapping_constraints;

attribute_mapping associated_dimensions(associated_dimensions, $PATH, Geometric_dimension);
property_definition <-
property_definition_relationship.relating_property_definition
property_definition_relationship
{property_definition_relationship
property_definition_relationship.name = 'set associated dimension'}
property_definition_relationship.related_property_definition ->
({property_definition
property_definition.description = 'dimensional location property'}
property_definition
property_definition.definition ->
characterized_definition
characterized_definition = shape_definition
shape_definition
shape_definition = shape_aspect_relationship
shape_aspect_relationship =>
dimensional_location)
(property_definition =>
dimensional_size_property <=
dimensional_size)

end_attribute_mapping;

end_entity_mapping;
(*
entity_mapping Dimensional_characteristic_representation(Dimensional_characteristic_representation, (auxiliary_characteristic_dimension_representation) (dimensional_characteristic_representation));

mapping_constraints;
(auxiliary_characteristic_dimension_representation <=
dimensional_characteristic_representation)
(dimensional_characteristic_representation)

end_mapping_constraints;

attribute_mapping auxiliary_dimension_representation(auxiliary_dimension_representation, $PATH);
(auxiliary_characteristic_dimension_representation <= 
dimensional_characteristic_representation .TRUE.)
(dimensional_characteristic_representation .FALSE.)

end_attribute_mapping;

attribute_mapping dimension(dimension, $PATH, Location_dimension);
(auxiliary_characteristic_dimension_representation <=
dimensional_characteristic_representation)
(dimensional_characteristic_representation)
dimensional_characteristic_representation.dimension ->
dimensional_characteristic
dimensional_characteristic = dimensional_location
dimensional_location

end_attribute_mapping;

attribute_mapping dimension(dimension, $PATH, Size_dimension);
(auxiliary_characteristic_dimension_representation <=
dimensional_characteristic_representation)
(dimensional_characteristic_representation)
dimensional_characteristic_representation.dimension ->
dimensional_characteristic
dimensional_characteristic = dimensional_size
dimensional_size

end_attribute_mapping;

attribute_mapping representation(representation, $PATH, Shape_dimension_representation);
(auxiliary_characteristic_dimension_representation <=
dimensional_characteristic_representation)
(dimensional_characteristic_representation)
dimensional_characteristic_representation.representation ->
shape_dimension_representation

end_attribute_mapping;

end_entity_mapping;
*)
entity_mapping Dimensional_size_based_on_opposing_boundaries(Dimensional_size_based_on_opposing_boundaries, opposing_boundary_dimensional_size);

mapping_constraints;
opposing_boundary_dimensional_size <=
dimensional_size

end_mapping_constraints;

attribute_mapping boundary_separation(boundary_separation, $IDENTICAL_MAPPING, Shape_element_locating_relationship);

end_attribute_mapping;

attribute_mapping is_applied_to(is_applied_to, $PATH, Composite_unit_shape_element);
opposing_boundary_dimensional_size <=
dimensional_size
dimensional_size.applies_to ->
shape_aspect =>
composite_shape_aspect =>
composite_unit_shape_aspect

end_attribute_mapping;

end_entity_mapping;

entity_mapping Directed_axis(Directed_axis, derived_shape_aspect);

mapping_constraints;
{derived_shape_aspect <=
shape_aspect
shape_aspect.description = 'directed axis'}

end_mapping_constraints;

attribute_mapping axis_to_be_oriented(axis_to_be_oriented, $PATH, Centre_axis);
derived_shape_aspect <=
shape_aspect <-
shape_aspect_relationship.relating_shape_aspect
shape_aspect_relationship
{[shape_aspect_relationship =>
shape_aspect_deriving_relationship]
[shape_aspect_relationship
shape_aspect_relationship.name = 'derived axis']}
shape_aspect_relationship.related_shape_aspect ->
{shape_aspect
shape_aspect.description = 'axis'}
shape_aspect =>
derived_shape_aspect =>
centre_of_symmetry

end_attribute_mapping;

attribute_mapping end_shape_element(end_shape_element, $PATH, Shape_element);
derived_shape_aspect <=
shape_aspect <-
shape_aspect_relationship.relating_shape_aspect
shape_aspect_relationship
{[shape_aspect_relationship =>
shape_aspect_deriving_relationship]
[shape_aspect_relationship
shape_aspect_relationship.name = 'end shape aspect']}
shape_aspect_relationship.related_shape_aspect ->
shape_aspect

end_attribute_mapping;

attribute_mapping start_shape_element(start_shape_element, $PATH, Shape_element);
derived_shape_aspect <=
shape_aspect <-
shape_aspect_relationship.relating_shape_aspect
shape_aspect_relationship
{[shape_aspect_relationship =>
shape_aspect_deriving_relationship]
[shape_aspect_relationship
shape_aspect_relationship.name = 'start shape aspect']}
shape_aspect_relationship.related_shape_aspect ->
shape_aspect

end_attribute_mapping;

end_entity_mapping;

entity_mapping Datum_based_direction_element(Datum_based_direction_element, property_definition);

mapping_constraints;
{property_definition
property_definition.description = 'direction element'}

end_mapping_constraints;

attribute_mapping angle_value(angle_value, $PATH, plane_angle_measure_with_unit);
property_definition <-
property_definition_representation.definition
property_definition_representation
property_definition_representation.used_representation ->
representation
representation.items[i] ->
{representation_item
representation_item.name = 'angle value'}
representation_item =>
measure_representation_item <=
measure_with_unit =>
plane_angle_measure_with_unit

end_attribute_mapping;

attribute_mapping direction(direction, $PATH, Datum_based_direction_vector);
property_definition <-
property_definition_relationship.relating_property_definition
property_definition_relationship
{property_definition_relationship
property_definition_relationship.name = 'element direction vector'}
property_definition_relationship.related_property_definition ->
property_definition
{property_definition
property_definition.description = 'datum direction property'}

end_attribute_mapping;

attribute_mapping direction_of_half_datum_plane(direction_of_half_datum_plane, $PATH, Datum_based_direction_vector);
property_definition <-
property_definition_relationship.relating_property_definition
property_definition_relationship
{property_definition_relationship
property_definition_relationship.name = 'half datum plane direction vector'}
property_definition_relationship.related_property_definition ->
property_definition
{property_definition
property_definition.description = 'datum direction property'}

end_attribute_mapping;

attribute_mapping base_datum_plane(base_datum_plane, $PATH, Datum_plane);
property_definition
property_definition.definition ->
characterized_definition
characterized_definition = shape_definition
shape_definition
shape_definition = shape_aspect_relationship
shape_aspect_relationship
{[shape_aspect_relationship
shape_aspect_relationship.name = 'datum plane and half plane relationship']
[shape_aspect_relationship
shape_aspect_relationship.relating_shape_aspect ->
shape_aspect
{shape_aspect
[shape_aspect.description = 'half plane']
[shape_aspect.product_definitional = .FALSE.]}]}
shape_aspect_relationship.related_shape_aspect ->
shape_aspect 
{shape_aspect.description = 'plane'}
shape_aspect =>
datum

end_attribute_mapping;

end_entity_mapping;

entity_mapping Edge_segment_vertex_armx(Edge_segment_vertex_armx, edge_segment_vertex);

mapping_constraints;
edge_segment_vertex <=
datum <=
shape_aspect
{shape_aspect
shape_aspect.name = 'single datum'}

end_mapping_constraints;

end_entity_mapping;

entity_mapping External_source_identification(External_source_identification, applied_external_identification_assignment)
extended;

attribute_mapping item(item, , Externally_defined_dimension_representation);

				external_identification_item *> egt_external_identification_item
				egt_external_identification_item = shape_dimension_representation
			
end_attribute_mapping;

end_entity_mapping;

entity_mapping Externally_defined_dimension_representation(Externally_defined_dimension_representation, shape_dimension_representation);

mapping_constraints;
(* GL - added in order to make an inverse attribute as strong *)
				{shape_dimension_representation
				egt_external_identification_item = shape_dimension_representation
				external_identification_item *> egt_external_identification_item
				external_identification_item <-
				applied_external_identification_assignment.items[i]}
end_mapping_constraints;

attribute_mapping dimension_value(dimension_value, $PATH, measure_with_unit);
shape_dimension_representation <=
shape_representation <=
representation
representation.items[i] ->
representation_item =>

measure_representation_item <=
measure_with_unit

end_attribute_mapping;

end_entity_mapping;

entity_mapping Geometric_alignment_armx(Geometric_alignment_armx, geometric_alignment);

mapping_constraints;

end_mapping_constraints;

end_entity_mapping;

entity_mapping Geometric_intersection_armx(Geometric_intersection_armx, geometric_intersection);

mapping_constraints;

end_mapping_constraints;

end_entity_mapping;

entity_mapping Geometric_tolerance_qualifier(Geometric_tolerance_qualifier, measure_qualification);

mapping_constraints;
{measure_qualification
(measure_qualification.name = 'predefined geometric tolerance qualifier')
(measure_qualification.name = 'user defined geometric tolerance qualifier')}

end_mapping_constraints;

attribute_mapping qualified_geometric_tolerances(qualified_geometric_tolerances, $PATH, Geometric_tolerance);
measure_qualification
measure_qualification.qualified_measure ->
measure_with_unit <-
geometric_tolerance.magnitude
geometric_tolerance =>
physical_unit_geometric_tolerance

end_attribute_mapping;

end_entity_mapping;

entity_mapping Geometric_tolerance_with_applied_material_condition_property(Geometric_tolerance_with_applied_material_condition_property, [modified_geometric_tolerance] [physical_unit_geometric_tolerance]);

mapping_constraints;
{[modified_geometric_tolerance <=
geometric_tolerance]
[physical_unit_geometric_tolerance <=
geometric_tolerance]}

end_mapping_constraints;

attribute_mapping applied_material_condition_property_name(applied_material_condition_property_name, modified_geometric_tolerance.modifier);
{(modified_geometric_tolerance.modifier = .MAXIMUM_MATERIAL_CONDITION.)
(modified_geometric_tolerance.modifier = .LEAST_MATERIAL_CONDITION.)}

end_attribute_mapping;

end_entity_mapping;

entity_mapping Limit_dimension_representation(Limit_dimension_representation, shape_dimension_representation);

mapping_constraints;

end_mapping_constraints;

attribute_mapping lower_dimension_value(lower_dimension_value, $PATH, measure_with_unit);
shape_dimension_representation <=
shape_representation <=
representation
representation.items[i] ->
representation_item =>
measure_representation_item <=
measure_with_unit
{measure_with_unit <-
measure_qualification.qualified_measure
measure_qualification
{measure_qualification.name = 'dimension value qualifier'}
measure_qualification.qualifiers[i] ->
value_qualifier
value_qualifier = type_qualifier
type_qualifier
{type_qualifier.name = 'lower value'}}

end_attribute_mapping;

attribute_mapping upper_dimension_value(upper_dimension_value, $PATH, measure_with_unit);
shape_dimension_representation <=
shape_representation <=
representation
representation.items[i] ->
representation_item =>
measure_representation_item <=
measure_with_unit
{measure_with_unit <-
measure_qualification.qualified_measure
measure_qualification
{measure_qualification.name = 'dimension value qualifier'}
measure_qualification.qualifiers[i] ->
value_qualifier
value_qualifier = type_qualifier
type_qualifier
{type_qualifier.name = 'upper value'}}

end_attribute_mapping;

end_entity_mapping;

entity_mapping Linear_extension(Linear_extension, extension);

mapping_constraints;

end_mapping_constraints;

end_entity_mapping;

entity_mapping Maximum_dimension_representation(Maximum_dimension_representation, shape_dimension_representation);

mapping_constraints;
{shape_dimension_representation <=
shape_representation <=
representation
representation.items[i] ->
representation_item =>
measure_representation_item <=
measure_with_unit <-
measure_qualification.qualified_measure
measure_qualification
{measure_qualification.name = 'dimension value qualifier'}
measure_qualification.qualifiers[i] ->
value_qualifier
value_qualifier = type_qualifier
type_qualifier
{type_qualifier.name = 'maximum dimension'}}

end_mapping_constraints;

end_entity_mapping;

entity_mapping Minimum_dimension_representation(Minimum_dimension_representation, shape_dimension_representation);

mapping_constraints;
{shape_dimension_representation <=
shape_representation <=
representation
representation.items[i] ->
representation_item =>
measure_representation_item <=
measure_with_unit <-
measure_qualification.qualified_measure
measure_qualification
{measure_qualification.name = 'dimension value qualifier'}
measure_qualification.qualifiers[i] ->
value_qualifier
value_qualifier = type_qualifier
type_qualifier
{type_qualifier.name = 'minimum dimension'}}

end_mapping_constraints;

end_entity_mapping;

entity_mapping Opposing_boundary_set_size_characteristic(Opposing_boundary_set_size_characteristic, representation);

mapping_constraints;
{representation
representation.name = 'opposing boundary set size'}

end_mapping_constraints;

attribute_mapping sized_boundary_set(sized_boundary_set, $PATH, Tolerance_zone_opposing_boundary_set);
representation <-
property_definition_representation.used_representation
property_definition_representation
property_definition_representation.definition ->

property_definition
{property_definition
property_definition.description = 'boundary zone definition with specified size'}
property_definition.definition ->
characterized_definition
characterized_definition = shape_definition
shape_definition
shape_definition = shape_aspect
shape_aspect
shape_aspect =>
tolerance_zone_boundary 
(tolerance_zone_boundary =>
tolerance_zone_explicit_opposing_boundary_set)
(tolerance_zone_boundary =>
tolerance_zone_implicit_opposing_boundary_set)

end_attribute_mapping;

end_entity_mapping;

entity_mapping Parallel_shape_element_relationship(Parallel_shape_element_relationship, shape_aspect_relationship);

mapping_constraints;
{shape_aspect_relationship
shape_aspect_relationship.name = 'parallel'}

end_mapping_constraints;

end_entity_mapping;

entity_mapping Perpendicular_shape_element_relationship(Perpendicular_shape_element_relationship, shape_aspect_relationship);

mapping_constraints;
{shape_aspect_relationship
shape_aspect_relationship.name = 'perpendicular'}

end_mapping_constraints;

end_entity_mapping;

entity_mapping Positional_boundary_armx(Positional_boundary_armx, positional_boundary);

mapping_constraints;
positional_boundary <=
shape_aspect
{[shape_aspect
(shape_aspect.description = 'dimension related positional boundary')
(shape_aspect.description = 'profile related positional boundary')]
[shape_aspect
shape_aspect.product_definitional = .FALSE.]}

end_mapping_constraints;

end_entity_mapping;

entity_mapping Positional_boundary_and_profile_boundary_member_relationship(Positional_boundary_and_profile_boundary_member_relationship, shape_aspect_relationship);

mapping_constraints;
{shape_aspect_relationship
shape_aspect_relationship.name = 'positional boundary and profile boundary member'}

end_mapping_constraints;

attribute_mapping offset_positional_boundary(offset_positional_boundary, $PATH, Profile_related_positional_boundary);
shape_aspect_relationship
shape_aspect_relationship.relating_shape_aspect ->
{shape_aspect
shape_aspect.description = 'profile related positional boundary'}
shape_aspect =>
positional_boundary

end_attribute_mapping;

attribute_mapping base_profile_tolerance_zone_boundary_member(base_profile_tolerance_zone_boundary_member, $PATH, Tolerance_zone_boundary_member);
shape_aspect_relationship
shape_aspect_relationship.related_shape_aspect ->
shape_aspect
{shape_aspect
[shape_aspect.description = 'tolerance zone boundary member']
[shape_aspect.product_definitional = .FALSE.]}

end_attribute_mapping;

end_entity_mapping;

entity_mapping Positional_boundary_definition(Positional_boundary_definition, property_definition);

mapping_constraints;
{property_definition
(property_definition.description = 'dimension related positional boundary property')
(property_definition.description = 'profile related positional boundary property')}

end_mapping_constraints;

attribute_mapping defined_positional_boundary(defined_positional_boundary, $PATH, Positional_boundary);
(property_definition
{property_definition.description = 'dimension related positional boundary property'}
property_definition.definition ->
characterized_definition
characterized_definition = shape_definition
shape_definition
shape_definition = shape_aspect
{shape_aspect
shape_aspect.description = 'dimension related positional boundary'}
shape_aspect =>
positional_boundary)
(property_definition
{property_definition.description = 'profile related positional boundary property'}
property_definition.definition ->
characterized_definition
characterized_definition = shape_definition
shape_definition
shape_definition = shape_aspect
{shape_aspect
shape_aspect.description = 'profile related positional boundary'}
shape_aspect =>
positional_boundary)

end_attribute_mapping;

end_entity_mapping;

entity_mapping Positional_boundary_member_armx(Positional_boundary_member_armx, positional_boundary_member);

mapping_constraints;
positional_boundary_member <=
shape_aspect
{shape_aspect
shape_aspect.product_definitional = .FALSE.}

end_mapping_constraints;

end_entity_mapping;

entity_mapping Positional_boundary_member_definition(Positional_boundary_member_definition, property_definition);

mapping_constraints;
{property_definition
property_definition.description = 'positional boundary member property'}

end_mapping_constraints;

attribute_mapping defined_positional_boundary_member(defined_positional_boundary_member, $PATH, Positional_boundary_member_armx);
property_definition
property_definition.definition ->
characterized_definition
characterized_definition = shape_definition
shape_definition
shape_definition = shape_aspect
shape_aspect =>
positional_boundary_member

end_attribute_mapping;

attribute_mapping tolerance_value(tolerance_value, $PATH, length_measure_with_unit);
property_definition <-
property_definition_representation.definition
property_definition_representation
property_definition_representation.used_representation ->
representation
representation.items[i] ->
{representation_item
representation_item.name = 'positional boundary member value'}
representation_item =>
measure_representation_item <=
measure_with_unit =>
length_measure_with_unit

end_attribute_mapping;

attribute_mapping associated_dimension(associated_dimension, $PATH, Size_dimension);
property_definition <-
property_definition_relationship.relating_property_definition
property_definition_relationship
{property_definition_relationship
property_definition_relationship.name = 'boundary member associated dimension'}
property_definition_relationship.related_property_definition ->
property_definition =>
dimensional_size_property <=
dimensional_size

end_attribute_mapping;

end_entity_mapping;

entity_mapping Positional_boundary_offset(Positional_boundary_offset, property_definition);

mapping_constraints;
{property_definition
property_definition.description = 'positional boundary offset'}

end_mapping_constraints;

attribute_mapping offset_boundary_relationship(offset_boundary_relationship, $PATH, Positional_boundary_and_profile_boundary_member_relationship);
property_definition
property_definition.definition ->
characterized_definition
characterized_definition = shape_definition
shape_definition
shape_definition = shape_aspect_relationship
shape_aspect_relationship
{shape_aspect_relationship
shape_aspect_relationship.name = 'positional boundary and profile boundary member'}

end_attribute_mapping;

attribute_mapping tolerance_value(tolerance_value, $PATH, length_measure_with_unit);
property_definition <-
property_definition_representation.definition
property_definition_representation
property_definition_representation.used_representation ->
representation
representation.items[i] ->
{representation_item
representation_item.name = 'positional boundary offset value'}
representation_item =>
measure_representation_item <=
measure_with_unit =>
length_measure_with_unit

end_attribute_mapping;

end_entity_mapping;

entity_mapping Pre_defined_dimension_qualifier(Pre_defined_dimension_qualifier, measure_qualification);

mapping_constraints;
{[measure_qualification
measure_qualification.name = 'predefined dimension qualifier']
[measure_qualification
measure_qualification.qualified_measure ->
measure_with_unit =>
measure_representation_item <=
representation_item <-
representation.items[i]
representation =>
shape_representation =>
shape_dimension_representation <-
dimensional_characteristic_representation.representation
dimensional_characteristic_representation
dimensional_characteristic_representation.dimension ->
dimensional_characteristic
(dimensional_characteristic = dimensional_location)
(dimensional_characteristic = dimensional_size)]}

end_mapping_constraints;

attribute_mapping description(description, type_qualifier.name);
measure_qualification
measure_qualification.qualifiers[i] ->
value_qualifier
value_qualifier = type_qualifier
type_qualifier
type_qualifier.name
{(type_qualifier.name = 'average')
(type_qualifier.name = 'free state')}

end_attribute_mapping;

end_entity_mapping;

entity_mapping Pre_defined_geometric_tolerance_qualifier(Pre_defined_geometric_tolerance_qualifier, measure_qualification);

mapping_constraints;
{[measure_qualification
measure_qualification.name = 'predefined geometric tolerance qualifier']
[measure_qualification
measure_qualification.qualified_measure ->
measure_with_unit <-
geometric_tolerance.magnitude
geometric_tolerance =>
physical_unit_geometric_tolerance]}

end_mapping_constraints;

attribute_mapping description(description, type_qualifier.name);
measure_qualification
measure_qualification.qualifiers[i] ->
value_qualifier
value_qualifier = type_qualifier
type_qualifier
type_qualifier.name
{(type_qualifier.name = 'each element')
(type_qualifier.name = 'each radial element')
(type_qualifier.name = 'free state')
(type_qualifier.name = 'major diameter')
(type_qualifier.name = 'minor diameter')
(type_qualifier.name = 'not concave')
(type_qualifier.name = 'not convex')
(type_qualifier.name = 'pitch diameter')}

end_attribute_mapping;

end_entity_mapping;

entity_mapping Profile_related_positional_boundary(Profile_related_positional_boundary, positional_boundary);

mapping_constraints;
positional_boundary <=
shape_aspect
{shape_aspect
shape_aspect.description = 'profile related positional boundary'}

end_mapping_constraints;

end_entity_mapping;

entity_mapping Profile_related_positional_boundary_definition(Profile_related_positional_boundary_definition, property_definition);

mapping_constraints;
{property_definition
property_definition.description = 'profile related positional boundary property'}

end_mapping_constraints;

attribute_mapping defined_positional_boundary(defined_positional_boundary, $PATH, Profile_related_positional_boundary);
property_definition
property_definition.definition ->
characterized_definition
characterized_definition = shape_definition
shape_definition
shape_definition = shape_aspect
{shape_aspect
shape_aspect.description = 'profile related positional boundary'}
shape_aspect =>
positional_boundary

end_attribute_mapping;

attribute_mapping boundary_offset(boundary_offset, $PATH, Positional_boundary_offset);
property_definition <-
property_definition_relationship.relating_property_definition
property_definition_relationship
{property_definition_relationship
property_definition_relationship.name = 'boundary offset'}
property_definition_relationship.related_property_definition ->
property_definition
{property_definition
property_definition.description = 'positional boundary offset'}

end_attribute_mapping;

end_entity_mapping;

entity_mapping Projected_zone_and_base_relationship(Projected_zone_and_base_relationship, projected_zone_definition);

mapping_constraints;

end_mapping_constraints;

attribute_mapping base_physical_feature(base_physical_feature, $PATH, physical_feature_or_part_template);
projected_zone_definition
projected_zone_definition.projection_end ->
shape_aspect

end_attribute_mapping;

attribute_mapping base_physical_feature(base_physical_feature, $PATH, Shape_element);
projected_zone_definition
				projected_zone_definition.projection_end ->
				shape_aspect
				
end_attribute_mapping;

attribute_mapping projected_zone(projected_zone, $PATH, Tolerance_zone);
projected_zone_definition <=
tolerance_zone_definition
tolerance_zone_definition.zone ->
tolerance_zone

end_attribute_mapping;

end_entity_mapping;

entity_mapping Projected_zone_height_characteristic(Projected_zone_height_characteristic, projected_zone_definition);

mapping_constraints;

end_mapping_constraints;

attribute_mapping defined_height_of(defined_height_of, $IDENTICAL_MAPPING, Projected_zone_and_base_relationship);

end_attribute_mapping;

attribute_mapping projected_height_value(projected_height_value, $PATH, length_measure_with_unit);
projected_zone_definition
projected_zone_definition.projected_length ->
measure_with_unit =>
length_measure_with_unit

end_attribute_mapping;

end_entity_mapping;

entity_mapping Requirement_assignment_armx(Requirement_assignment_armx, requirement_assignment)
extended;

attribute_mapping assigned_to(assigned_to, , Restraint_condition);

					requirement_assigned_item *> egt_requirement_assigned_item
					egt_requirement_assigned_item = 
					property_definition
				
end_attribute_mapping;

attribute_mapping assigned_to(assigned_to, , Statistical_dimensional_location_armx);

					requirement_assigned_item *> egt_requirement_assigned_item
					egt_requirement_assigned_item = 
					statistical_dimensional_location
				
end_attribute_mapping;

attribute_mapping assigned_to(assigned_to, , Statistical_dimensional_size_armx);

					requirement_assigned_item *> egt_requirement_assigned_item
					egt_requirement_assigned_item = 
					statistical_dimensional_size
				
end_attribute_mapping;

attribute_mapping assigned_to(assigned_to, , Statistical_geometric_tolerance_armx);

					requirement_assigned_item *> egt_requirement_assigned_item
					egt_requirement_assigned_item = 
					statistical_geometric_tolerance
				
end_attribute_mapping;

end_entity_mapping;

entity_mapping Restraint_condition(Restraint_condition, property_definition);

mapping_constraints;
{property_definition

(property_definition.description = 'restraint')
(property_definition.description = 'tolerance specific restraint')}

end_mapping_constraints;

attribute_mapping applied_to(applied_to, $PATH, physical_feature_or_part_template);
property_definition
property_definition.definition ->
characterized_definition
characterized_definition = shape_definition
shape_definition
shape_definition = shape_aspect
shape_aspect

end_attribute_mapping;

attribute_mapping applied_to(applied_to, $PATH, Single_datum);
property_definition
				property_definition.definition ->
				characterized_definition
				characterized_definition = shape_definition
				shape_definition
				shape_definition = shape_aspect
				shape_aspect => datum
				
end_attribute_mapping;

end_entity_mapping;

entity_mapping Runout_tolerance_zone_definition_with_specified_angle(Runout_tolerance_zone_definition_with_specified_angle, runout_zone_definition);

mapping_constraints;
runout_zone_definition

end_mapping_constraints;

attribute_mapping runout_orientation(runout_orientation, $PATH, Runout_zone_orientation_armx);
runout_zone_definition
runout_zone_definition.orientation ->
runout_zone_orientation =>
runout_zone_orientation_reference_direction

end_attribute_mapping;

end_entity_mapping;

entity_mapping Runout_tolerance_zone_orienting_relationship(Runout_tolerance_zone_orienting_relationship, shape_aspect_relationship);

mapping_constraints;
{shape_aspect_relationship
shape_aspect_relationship.name = 'runout tolerance zone orienting'}

end_mapping_constraints;

attribute_mapping oriented_zone(oriented_zone, $PATH, Tolerance_zone);
shape_aspect_relationship
shape_aspect_relationship.relating_shape_aspect ->
shape_aspect =>
tolerance_zone

end_attribute_mapping;

attribute_mapping orienting_axis(orienting_axis, $PATH, Directed_axis);
shape_aspect_relationship
shape_aspect_relationship.related_shape_aspect ->
{shape_aspect
shape_aspect.description = 'directed axis'}
shape_aspect =>
derived_shape_aspect

end_attribute_mapping;

end_entity_mapping;

entity_mapping Runout_zone_orientation_armx(Runout_zone_orientation_armx, runout_zone_orientation_reference_direction);

mapping_constraints;

end_mapping_constraints;

attribute_mapping oriented_relationship(oriented_relationship, $PATH, Runout_tolerance_zone_orienting_relationship);
runout_zone_orientation_reference_direction
runout_zone_orientation_reference_direction.orientation_defining_relationship ->
shape_aspect_relationship
{shape_aspect_relationship
shape_aspect_relationship.name = 'runout tolerance zone orienting'}

end_attribute_mapping;

attribute_mapping semi_angle_value(semi_angle_value, $PATH, plane_angle_measure_with_unit);
runout_zone_orientation_reference_direction <=
runout_zone_orientation
runout_zone_orientation.angle ->
measure_with_unit =>
plane_angle_measure_with_unit

end_attribute_mapping;

end_entity_mapping;

entity_mapping Separate_geometric_tolerance_requirement(Separate_geometric_tolerance_requirement, geometric_tolerance_group);

mapping_constraints;
geometric_tolerance_group <=
property_definition
{property_definition
property_definition.description = 'separate requirement'}

end_mapping_constraints;

attribute_mapping separated_geometric_tolerances(separated_geometric_tolerances, $PATH, Geometric_tolerance);
geometric_tolerance_group <=
property_definition <-
property_definition_relationship.relating_property_definition
property_definition_relationship
{property_definition_relationship
property_definition_relationship.name = 'group geometric tolerance'}
property_definition_relationship.related_property_definition ->
property_definition =>
physical_unit_geometric_tolerance

end_attribute_mapping;

end_entity_mapping;

entity_mapping Shape_dimension_representation(Shape_dimension_representation, shape_dimension_representation);

mapping_constraints;

end_mapping_constraints;

end_entity_mapping;

entity_mapping Shape_element_deriving_relationship(Shape_element_deriving_relationship, shape_aspect_deriving_relationship);

mapping_constraints;

end_mapping_constraints;

attribute_mapping relating(relating, $PATH, Derived_non_feature_shape_element);
shape_aspect_deriving_relationship <=
shape_aspect_relationship
shape_aspect_relationship.relating_shape_aspect ->
shape_aspect =>
derived_shape_aspect

end_attribute_mapping;

end_entity_mapping;

entity_mapping Simultaneous_geometric_tolerance_requirement(Simultaneous_geometric_tolerance_requirement, geometric_tolerance_group);

mapping_constraints;
geometric_tolerance_group <=
property_definition
{property_definition
property_definition.description = 'simultaneous requirement'}

end_mapping_constraints;

attribute_mapping grouped_geometric_tolerances(grouped_geometric_tolerances, $PATH, Geometric_tolerance);
geometric_tolerance_group <=
property_definition <-
property_definition_relationship.relating_property_definition
property_definition_relationship
{property_definition_relationship
property_definition_relationship.name = 'group geometric tolerance'}
property_definition_relationship.related_property_definition ->
property_definition =>
physical_unit_geometric_tolerance

end_attribute_mapping;

end_entity_mapping;

entity_mapping Singular_dimension_representation(Singular_dimension_representation, shape_dimension_representation);

mapping_constraints;

end_mapping_constraints;

attribute_mapping dimension_value(dimension_value, $PATH, measure_with_unit);
shape_dimension_representation <=
shape_representation <=
representation
representation.items[i] ->
representation_item =>
measure_representation_item <=
measure_with_unit
{measure_with_unit <-
measure_qualification.qualified_measure
measure_qualification
{measure_qualification.name = 'dimension value qualifier'}
measure_qualification.qualifiers[i] ->
value_qualifier
value_qualifier = type_qualifier
type_qualifier
{(type_qualifier.name = 'maximum dimension')
(type_qualifier.name = 'minimum dimension')
(type_qualifier.name = 'theoretically exact')}}

end_attribute_mapping;

end_entity_mapping;

entity_mapping Statistical_dimensional_location_armx(Statistical_dimensional_location_armx, statistical_dimensional_location);

mapping_constraints;
statistical_dimensional_location <=
dimensional_location

end_mapping_constraints;

attribute_mapping alternate_dimension(alternate_dimension, $PATH, Geometric_dimension);
statistical_dimensional_location <=
dimensional_location <=
shape_aspect_relationship
shape_definition = shape_aspect_relationship
shape_definition
characterized_definition = shape_definition
characterized_definition <-
property_definition.definition
{property_definition
property_definition.description = 'dimensional location property'}
property_definition <-
property_definition_relationship.related_property_definition
property_definition_relationship
{property_definition_relationship
property_definition_relationship.name = 'substitutable dimension'}
property_definition_relationship.relating_property_definition ->
{property_definition
property_definition.description = 'dimensional location property'}
property_definition
property_definition.definition ->
characterized_definition
characterized_definition = shape_definition
shape_definition
shape_definition = shape_aspect_relationship
shape_aspect_relationship =>
dimensional_location

end_attribute_mapping;

end_entity_mapping;

entity_mapping Statistical_dimensional_size_armx(Statistical_dimensional_size_armx, statistical_dimensional_size);

mapping_constraints;
statistical_dimensional_size <=
dimensional_size_property <=
[dimensional_size]
[property_definition]

end_mapping_constraints;

attribute_mapping alternate_dimension(alternate_dimension, $PATH, Geometric_dimension);
statistical_dimensional_size <=
dimensional_size_property <=
property_definition <-
property_definition_relationship.related_property_definition
property_definition_relationship
{property_definition_relationship
property_definition_relationship.name = 'substitutable dimension'}
property_definition_relationship.relating_property_definition ->
property_definition =>
dimensional_size_property <=
dimensional_size

end_attribute_mapping;

end_entity_mapping;

entity_mapping Statistical_geometric_tolerance_armx(Statistical_geometric_tolerance_armx, statistical_geometric_tolerance);

mapping_constraints;
statistical_geometric_tolerance <=
physical_unit_geometric_tolerance <=
geometric_tolerance

end_mapping_constraints;

attribute_mapping alternate_tolerance(alternate_tolerance, $PATH, Geometric_tolerance);
statistical_geometric_tolerance <=
physical_unit_geometric_tolerance <=
geometric_tolerance <-
geometric_tolerance_relationship.related_geometric_tolerance
geometric_tolerance_relationship
{geometric_tolerance_relationship
geometric_tolerance_relationship.name = 'substitutable geometric tolerance'}
geometric_tolerance_relationship.relating_geometric_tolerance ->
geometric_tolerance =>
physical_unit_geometric_tolerance

end_attribute_mapping;

end_entity_mapping;

entity_mapping Tangent_plane(Tangent_plane, tangent);

mapping_constraints;
{tangent <=
derived_shape_aspect <=
shape_aspect
shape_aspect.description = 'plane'}

end_mapping_constraints;

end_entity_mapping;

entity_mapping Tangent_shape_element(Tangent_shape_element, tangent);

mapping_constraints;

end_mapping_constraints;

end_entity_mapping;

entity_mapping Theoretically_exact_dimension_representation(Theoretically_exact_dimension_representation, shape_dimension_representation);

mapping_constraints;
{shape_dimension_representation <=
shape_representation <=
representation
representation.items[i] ->
representation_item =>
measure_representation_item <=
measure_with_unit <-
measure_qualification.qualified_measure
measure_qualification
{measure_qualification.name = 'dimension value qualifier'}
measure_qualification.qualifiers[i] ->
value_qualifier
value_qualifier = type_qualifier
type_qualifier
{type_qualifier.name = 'theoretically exact'}}

end_mapping_constraints;

end_entity_mapping;

entity_mapping Tolerance_specific_restraint_condition(Tolerance_specific_restraint_condition, property_definition);

mapping_constraints;
{property_definition
property_definition.description = 'tolerance specific restraint'}

end_mapping_constraints;

attribute_mapping affected_tolerances(affected_tolerances, $PATH, Geometric_dimension);
property_definition <-
property_definition_relationship.relating_property_definition
property_definition_relationship
{property_definition_relationship
property_definition_relationship.name = 'affected tolerance'}
property_definition_relationship.related_property_definition ->
({property_definition
property_definition.description = 'dimensional location property'}
property_definition
property_definition.definition ->
characterized_definition
characterized_definition = shape_definition
shape_definition
shape_definition = shape_aspect_relationship
shape_aspect_relationship =>
dimensional_location)
(property_definition =>
dimensional_size_property <=
dimensional_size)

end_attribute_mapping;

attribute_mapping affected_tolerances(affected_tolerances, $PATH, Geometric_tolerance);
property_definition <-
property_definition_relationship.relating_property_definition
property_definition_relationship
{property_definition_relationship
property_definition_relationship.name = 'affected tolerance'}
property_definition_relationship.related_property_definition ->
property_definition =>
physical_unit_geometric_tolerance

end_attribute_mapping;

end_entity_mapping;

entity_mapping Tolerance_zone_and_viewing_plane_orienting_relationship(Tolerance_zone_and_viewing_plane_orienting_relationship, shape_aspect_relationship);

mapping_constraints;
{shape_aspect_relationship
shape_aspect_relationship.name = 'tolerance zone and viewing plane'}

end_mapping_constraints;

attribute_mapping orienting_viewing_plane(orienting_viewing_plane, $PATH, Viewing_plane_armx);
shape_aspect_relationship
shape_aspect_relationship.related_shape_aspect ->
shape_aspect =>
viewing_plane

end_attribute_mapping;

attribute_mapping oriented_tolerance_zone(oriented_tolerance_zone, $PATH, Tolerance_zone);
shape_aspect_relationship
shape_aspect_relationship.relating_shape_aspect ->
shape_aspect =>
tolerance_zone

end_attribute_mapping;

end_entity_mapping;

entity_mapping Tolerance_zone_boundary_armx(Tolerance_zone_boundary_armx, tolerance_zone_boundary);

mapping_constraints;
tolerance_zone_boundary <=
shape_aspect
{[shape_aspect <-
tolerance_zone_definition.boundaries[i]
tolerance_zone_definition]
[shape_aspect.product_definitional = .FALSE.]}

end_mapping_constraints;

end_entity_mapping;

entity_mapping Tolerance_zone_boundary_member(Tolerance_zone_boundary_member, shape_aspect);

mapping_constraints;
{shape_aspect
[shape_aspect.description = 'tolerance zone boundary member']
[shape_aspect.product_definitional = .FALSE.]}

end_mapping_constraints;

end_entity_mapping;

entity_mapping Tolerance_zone_boundary_member_offset(Tolerance_zone_boundary_member_offset, property_definition);

mapping_constraints;
{property_definition
property_definition.description = 'tolerance zone boundary member offset'}

end_mapping_constraints;

attribute_mapping type_of_offset(type_of_offset, property_definition.name);
property_definition
property_definition.name
{(property_definition.name = 'towards material')
(property_definition.name = 'away from material')}

end_attribute_mapping;

attribute_mapping offset_tolerance_zone_boundary_member(offset_tolerance_zone_boundary_member, $PATH, Tolerance_zone_boundary_member);
property_definition
property_definition.definition ->
characterized_definition
characterized_definition = shape_definition
shape_definition
shape_definition = shape_aspect
shape_aspect
{shape_aspect
[shape_aspect.description = 'tolerance zone boundary member']
[shape_aspect.product_definitional = .FALSE.]}

end_attribute_mapping;

attribute_mapping offset_value(offset_value, $PATH, length_measure_with_unit);
property_definition <-
property_definition_representation.definition
property_definition_representation
property_definition_representation.used_representation ->
representation
representation.items[i] ->
{representation_item
representation_item.name = 'tolerance zone boundary member offset value'}
representation_item =>
measure_representation_item <=
measure_with_unit =>
length_measure_with_unit

end_attribute_mapping;

end_entity_mapping;

entity_mapping Tolerance_zone_circular_or_cylindrical_or_spherical_boundary(Tolerance_zone_circular_or_cylindrical_or_spherical_boundary, tolerance_zone_boundary);

mapping_constraints;
tolerance_zone_boundary <=
shape_aspect
{shape_aspect
shape_aspect.description = 'circular or cylindrical or spherical'}

end_mapping_constraints;

end_entity_mapping;

entity_mapping Tolerance_zone_definition_with_per_unit_size_specification(Tolerance_zone_definition_with_per_unit_size_specification, tolerance_zone_definition);

mapping_constraints;

end_mapping_constraints;

attribute_mapping per_unit_size_specification(per_unit_size_specification, $PATH, Tolerance_zone_per_unit_size_specification);
tolerance_zone_definition
tolerance_zone_definition.zone ->
tolerance_zone <=
shape_aspect
shape_definition = shape_aspect
shape_definition
characterized_definition = shape_definition
characterized_definition <-
property_definition.definition
property_definition
{property_definition
property_definition.description = 'tolerance zone per unit size'}

end_attribute_mapping;

end_entity_mapping;

entity_mapping Tolerance_zone_definition_with_specified_orientation(Tolerance_zone_definition_with_specified_orientation, property_definition);

mapping_constraints;
{property_definition
[property_definition.description = 'tolerance zone orientation']
[property_definition.definition ->
characterized_definition
characterized_definition = shape_definition
shape_definition
shape_definition = shape_aspect
shape_aspect =>
tolerance_zone]}

end_mapping_constraints;

attribute_mapping zone_orientation(zone_orientation, $PATH, Datum_axis_related_orientation);
property_definition <-
property_definition_relationship.relating_property_definition
property_definition_relationship
{property_definition_relationship
property_definition_relationship.name = 'zone orientation'}
property_definition_relationship.related_property_definition ->
property_definition
{property_definition
property_definition.description = 'datum axis related orientation'}

end_attribute_mapping;

attribute_mapping zone_orientation(zone_orientation, $PATH, Viewing_plane_based_orientation);
property_definition <-
property_definition_relationship.relating_property_definition
property_definition_relationship
{property_definition_relationship
property_definition_relationship.name = 'zone orientation'}
property_definition_relationship.related_property_definition ->
property_definition
{property_definition
property_definition.description = 'viewing plane based orientation'}

end_attribute_mapping;

attribute_mapping zone_orientation(zone_orientation, $PATH, Datum_based_vector_orientation);
property_definition <-
property_definition_relationship.relating_property_definition
property_definition_relationship
{property_definition_relationship
property_definition_relationship.name = 'zone orientation'}
property_definition_relationship.related_property_definition ->
property_definition
{property_definition
property_definition.description = 'datum based vector orientation'}

end_attribute_mapping;

end_entity_mapping;

entity_mapping Tolerance_zone_explicit_opposing_boundary_set_armx(Tolerance_zone_explicit_opposing_boundary_set_armx, tolerance_zone_explicit_opposing_boundary_set);

mapping_constraints;
tolerance_zone_explicit_opposing_boundary_set <=
tolerance_zone_boundary <=
shape_aspect

end_mapping_constraints;

attribute_mapping boundary_members(boundary_members, $PATH, Tolerance_zone_boundary_member);
tolerance_zone_explicit_opposing_boundary_set <=
tolerance_zone_boundary <=
shape_aspect <-
shape_aspect_relationship.relating_shape_aspect
shape_aspect_relationship
{shape_aspect_relationship
shape_aspect_relationship.name = 'zone boundary member'}
shape_aspect_relationship.related_shape_aspect ->
shape_aspect
{shape_aspect
[shape_aspect.description = 'tolerance zone boundary member']
[shape_aspect.product_definitional = .FALSE.]}

end_attribute_mapping;

end_entity_mapping;
(* Taken from AIM
entity_mapping Tolerance_zone_form(Tolerance_zone_form, tolerance_zone_form);

mapping_constraints;

end_mapping_constraints;

attribute_mapping name(name, tolerance_zone_form.name);

end_attribute_mapping;

attribute_mapping characterized_tolerance_zone(characterized_tolerance_zone, $PATH, Tolerance_zone);
tolerance_zone_form <-
tolerance_zone.form
tolerance_zone

end_attribute_mapping;

end_entity_mapping;
*)
entity_mapping Tolerance_zone_implicit_opposing_boundary_set_armx(Tolerance_zone_implicit_opposing_boundary_set_armx, tolerance_zone_implicit_opposing_boundary_set);

mapping_constraints;
tolerance_zone_implicit_opposing_boundary_set <=
tolerance_zone_boundary <=
shape_aspect

end_mapping_constraints;

end_entity_mapping;

entity_mapping Tolerance_zone_opposing_boundary_set(Tolerance_zone_opposing_boundary_set, (tolerance_zone_explicit_opposing_boundary_set) (tolerance_zone_implicit_opposing_boundary_set));

mapping_constraints;
(tolerance_zone_explicit_opposing_boundary_set <=
tolerance_zone_boundary <=
shape_aspect)
(tolerance_zone_implicit_opposing_boundary_set <=
tolerance_zone_boundary <=
shape_aspect)

end_mapping_constraints;

end_entity_mapping;

entity_mapping Tolerance_zone_per_unit_size_specification(Tolerance_zone_per_unit_size_specification, property_definition);

mapping_constraints;
{property_definition
property_definition.description = 'tolerance zone per unit size'}

end_mapping_constraints;

attribute_mapping specified_tolerance_zone(specified_tolerance_zone, $PATH, Tolerance_zone);
property_definition
property_definition.definition ->
characterized_definition
characterized_definition = shape_definition
shape_definition
shape_definition = shape_aspect
shape_aspect =>
tolerance_zone

end_attribute_mapping;

attribute_mapping per_unit_size(per_unit_size, $PATH, length_measure_with_unit);
property_definition <-
property_definition_representation.definition
property_definition_representation
property_definition_representation.used_representation ->
representation
representation.items[i] ->
{representation_item
representation_item.name = 'per unit size'}
representation_item =>
measure_representation_item <=
measure_with_unit =>
length_measure_with_unit

end_attribute_mapping;

end_entity_mapping;

entity_mapping True_profile(True_profile, property_definition);

mapping_constraints;
{property_definition
property_definition.description = 'true profile'}

end_mapping_constraints;

attribute_mapping profile_representation(profile_representation, $PATH, Document_definition);

					property_definition <-
					property_definition_representation.definition
					property_definition_representation
					property_definition_representation.used_representation ->
					representation
					document_reference_item = representation
					document_reference_item <-
					applied_document_reference.items[i]
					applied_document_reference
					applied_document_reference <=
					document_reference
					document_reference.assigned_document ->
					document <-
					document_product_association.relating_document
					{document_product_association.name = 'equivalence'}
					document_product_association.related_product ->
					product_or_formation_or_definition = product_definition
					product_definition
					{product_definition.name = 'source code'}
				
end_attribute_mapping;

attribute_mapping profiled_surface(profiled_surface, $PATH, physical_feature_or_part_template);
property_definition
property_definition.definition ->
characterized_definition
characterized_definition = shape_definition
shape_definition
shape_definition = shape_aspect
shape_aspect

end_attribute_mapping;

attribute_mapping profiled_surface(profiled_surface, $PATH, Shape_element);
property_definition
					property_definition.definition ->
					characterized_definition
					characterized_definition = shape_definition
					shape_definition
					shape_definition = shape_aspect
					shape_aspect
				
end_attribute_mapping;

attribute_mapping profiled_surface_datum(profiled_surface_datum, $PATH, Datum_defined_by_feature);
				property_definition <-
				property_definition_relationship.relating_property_definition
				property_definition_relationship
				{property_definition_relationship
				property_definition_relationship.name = 'profiled surface datum'}
				property_definition_relationship.related_property_definition ->
				property_definition
				property_definition.definition ->
				characterized_definition				
				characterized_definition = shape_definition				
				shape_definition
				shape_definition = shape_aspect
				shape_aspect =>
				datum
end_attribute_mapping;

attribute_mapping profile_representation(profile_representation, $PATH, Dimension_set);
property_definition <-
				property_definition_relationship.relating_property_definition
				property_definition_relationship
				{property_definition_relationship
				property_definition_relationship.name = 'true profile specification'}
				property_definition_relationship.related_property_definition ->
				property_definition
				{property_definition
				property_definition.description = 'dimension set'}
				
end_attribute_mapping;

attribute_mapping profile_representation(profile_representation, $PATH, Func_armx);
property_definition <-
				property_definition_representation.definition
				property_definition_representation
				property_definition_representation.used_representation ->
				representation
				representation.items[i] ->
				representation_item =>
				compound_representation_item =>
				func
				
end_attribute_mapping;

end_entity_mapping;

entity_mapping User_defined_dimension_qualifier(User_defined_dimension_qualifier, measure_qualification);

mapping_constraints;
{[measure_qualification
measure_qualification.name = 'user defined dimension qualifier']
[measure_qualification
measure_qualification.qualified_measure ->
measure_with_unit =>
measure_representation_item <=
representation_item <-
representation.items[i]
representation =>
shape_representation =>
shape_dimension_representation <-
dimensional_characteristic_representation.representation
dimensional_characteristic_representation
dimensional_characteristic_representation.dimension ->
dimensional_characteristic
(dimensional_characteristic = dimensional_location)
(dimensional_characteristic = dimensional_size)]}

end_mapping_constraints;

attribute_mapping description(description, type_qualifier.name);
measure_qualification
measure_qualification.qualifiers[i] ->
value_qualifier
value_qualifier = type_qualifier
type_qualifier
type_qualifier.name

end_attribute_mapping;

attribute_mapping name(name, measure_qualification.description);

end_attribute_mapping;

end_entity_mapping;

entity_mapping User_defined_geometric_tolerance_qualifier(User_defined_geometric_tolerance_qualifier, measure_qualification);

mapping_constraints;
{[measure_qualification
measure_qualification.name = 'user defined geometric tolerance qualifier']
[measure_qualification
measure_qualification.qualified_measure ->
measure_with_unit <-
geometric_tolerance.magnitude
geometric_tolerance =>
physical_unit_geometric_tolerance]}

end_mapping_constraints;

attribute_mapping description(description, type_qualifier.name);
measure_qualification
measure_qualification.qualifiers[i] ->
value_qualifier
value_qualifier = type_qualifier
type_qualifier
type_qualifier.name

end_attribute_mapping;

attribute_mapping name(name, measure_qualification.description);

end_attribute_mapping;

end_entity_mapping;

entity_mapping Viewing_plane_armx(Viewing_plane_armx, viewing_plane);

mapping_constraints;
viewing_plane <=
shape_aspect
{shape_aspect
[shape_aspect.description = 'affected plane']
[shape_aspect.product_definitional = .FALSE.]}

end_mapping_constraints;

end_entity_mapping;

entity_mapping Viewing_plane_definition(Viewing_plane_definition, property_definition);

mapping_constraints;
{property_definition
property_definition.description = 'viewing plane property'}

end_mapping_constraints;

attribute_mapping defined_viewing_plane(defined_viewing_plane, $PATH, Viewing_plane_armx);
property_definition
property_definition.definition ->
characterized_definition
characterized_definition = shape_definition
shape_definition
shape_definition = shape_aspect
shape_aspect =>
viewing_plane

end_attribute_mapping;

attribute_mapping viewing_plane_representation(viewing_plane_representation, $PATH, axis2_placement);
property_definition <-
property_definition_representation.definition
property_definition_representation
property_definition_representation.used_representation ->
representation
representation.items[i] ->
{representation_item
representation_item.name = 'orientation'}
representation_item =>
geometric_representation_item =>
placement =>
axis2_placement_2d

end_attribute_mapping;

end_entity_mapping;

entity_mapping Viewing_plane_based_orientation(Viewing_plane_based_orientation, property_definition);

mapping_constraints;
{property_definition
property_definition.description = 'viewing plane based orientation'}

end_mapping_constraints;

attribute_mapping orienting_relationship(orienting_relationship, $PATH, Tolerance_zone_and_viewing_plane_orienting_relationship);
property_definition
property_definition.definition ->
characterized_definition
characterized_definition = shape_definition
shape_definition
shape_definition = shape_aspect_relationship
shape_aspect_relationship
{shape_aspect_relationship
shape_aspect_relationship.name = 'tolerance zone and viewing plane'}

end_attribute_mapping;

attribute_mapping viewing_plane_specification(viewing_plane_specification, $PATH, Viewing_plane_definition);
property_definition <-
property_definition_relationship.relating_property_definition
property_definition_relationship
{property_definition_relationship
property_definition_relationship.name = 'viewing plane specification'}
property_definition_relationship.related_property_definition ->
property_definition
{property_definition
property_definition.description = 'viewing plane property'}

end_attribute_mapping;

end_entity_mapping;
(*end_schema_mapping;*)
