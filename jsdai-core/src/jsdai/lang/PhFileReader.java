/*
 * $Id$
 *
 * JSDAI(TM), a way to implement STEP, ISO 10303
 * Copyright (C) 1997-2008, LKSoftWare GmbH, Germany
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License
 * version 3 as published by the Free Software Foundation (AGPL v3).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * JSDAI is a registered trademark of LKSoftWare GmbH, Germany
 * This software is also available under commercial licenses.
 * See also http://www.jsdai.net/
 */

package jsdai.lang;

import java.io.*;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Set;
import jsdai.dictionary.*;

class PhFileReader {

/**
	An instance of the <code>Scanner</code> class used while reading
	an exchange structure.
*/
	private Scanner scan;

/**
	The field representing a token in an exchange structure.
*/
	private Token token;

	Reader_error_table error_table;

/**
	The largest number encountered in the names of instances of an exchange
	structure being read.
*/
	private long largest_identifier = -1;

/**
	The level of SCOPE structure (see "ISO 10303-21::9.3 Scope structure")
	to which instances that are currently under processing belong.
	If <code>inside_scope = 0</code>, then instances are outside any scope.
	If instances currently being read from the exchange structure are found
	between lines <code>#1 = &SCOPE</code> (here a positive integer different
	than 1 may appear) and <code>ENDSCOPE</code>, then at this moment of the
	reading process <code>inside_scope</code> is equal to 1. Higher levels of
	nesting are defined similarly.
*/
	private int inside_scope = 0;

/**
	Has value 'true' when to represent an instance currently being read the
	external mapping form was used.
*/
	private boolean complex_entity;

/**
	Has value 'true' if an instance currently being read is of user defined
	entity type.
*/
	private boolean user_defined_entity;

/**
	Has value 'true' when data sections are processed (and 'false' when the
	header is processed).
*/
	private boolean data_section_processing;

/**
	Has value 'true' if an instance that references itself is found.
*/
	private boolean autoreference_found;

	CEntity zero_inst = null;

/**
	The name of an entity whose instance is expected to appear next in the exchange
	structure. This field is used when reading the header of the structure.
	An order in which instances appear in the header is defined in "ISO 10303-21".
*/
	private String expect_entity;

/**
	The name of the repository to which the exchange structure shall be imported.
*/
	private String repo_name;

/**
	The repository to which the exchange structure is imported.
	This repository is returned by <code>importClearTextEncoding</code> method
	of <code>SdaiSession</code> class.
*/
	private SdaiRepository file_repo;

	private SdaiSession active_session;

/**
	The name of the exchange structure.
*/
	private String phys_file;

/**
	The empty string.
*/
	static final String nullString = "";

/**
	An array used to read values of string type.
*/
	private char [] chars;

/**
	The field which represents information delivered by 'file_description'
	entity instance in the header of the exchange structure.
*/
	private FILE_DESCRIPTION file_description;

/**
	The field which represents information delivered by a 'file_population'
	entity instance in the header of the exchange structure.
*/
	private FILE_POPULATION file_pop;

	private FILE_POPULATION [] populations;

	private int populations_count;

	private final int POPULATIONS_ARRAY_SIZE = 16;


/**
	The alphabet of ISO 8859-1.
*/
	static char [] iso8859_1 = {
		0x00A0,	//	NO-BREAK SPACE
		0x00A1,	//	INVERTED EXCLAMATION MARK
		0x00A2,	//	CENT SIGN
		0x00A3,	//	POUND SIGN
		0x00A4,	//	CURRENCY SIGN
		0x00A5,	//	YEN SIGN
		0x00A6,	//	BROKEN BAR
		0x00A7,	//	SECTION SIGN
		0x00A8,	//	DIAERESIS
		0x00A9,	//	COPYRIGHT SIGN
		0x00AA,	//	FEMININE ORDINAL INDICATOR
		0x00AB,	//	LEFT-POINTING DOUBLE ANGLE QUOTATION MARK
		0x00AC,	//	NOT SIGN
		0x00AD,	//	SOFT HYPHEN
		0x00AE,	//	REGISTERED SIGN
		0x00AF,	//	MACRON
		0x00B0,	//	DEGREE SIGN
		0x00B1,	//	PLUS-MINUS SIGN
		0x00B2,	//	SUPERSCRIPT TWO
		0x00B3,	//	SUPERSCRIPT THREE
		0x00B4,	//	ACUTE ACCENT
		0x00B5,	//	MICRO SIGN
		0x00B6,	//	PILCROW SIGN
		0x00B7,	//	MIDDLE DOT
		0x00B8,	//	CEDILLA
		0x00B9,	//	SUPERSCRIPT ONE
		0x00BA,	//	MASCULINE ORDINAL INDICATOR
		0x00BB,	//	RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK
		0x00BC,	//	VULGAR FRACTION ONE QUARTER
		0x00BD,	//	VULGAR FRACTION ONE HALF
		0x00BE,	//	VULGAR FRACTION THREE QUARTERS
		0x00BF,	//	INVERTED QUESTION MARK
		0x00C0,	//	LATIN CAPITAL LETTER A WITH GRAVE
		0x00C1,	//	LATIN CAPITAL LETTER A WITH ACUTE
		0x00C2,	//	LATIN CAPITAL LETTER A WITH CIRCUMFLEX
		0x00C3,	//	LATIN CAPITAL LETTER A WITH TILDE
		0x00C4,	//	LATIN CAPITAL LETTER A WITH DIAERESIS
		0x00C5,	//	LATIN CAPITAL LETTER A WITH RING ABOVE
		0x00C6,	//	LATIN CAPITAL LETTER AE
		0x00C7,	//	LATIN CAPITAL LETTER C WITH CEDILLA
		0x00C8,	//	LATIN CAPITAL LETTER E WITH GRAVE
		0x00C9,	//	LATIN CAPITAL LETTER E WITH ACUTE
		0x00CA,	//	LATIN CAPITAL LETTER E WITH CIRCUMFLEX
		0x00CB,	//	LATIN CAPITAL LETTER E WITH DIAERESIS
		0x00CC,	//	LATIN CAPITAL LETTER I WITH GRAVE
		0x00CD,	//	LATIN CAPITAL LETTER I WITH ACUTE
		0x00CE,	//	LATIN CAPITAL LETTER I WITH CIRCUMFLEX
		0x00CF,	//	LATIN CAPITAL LETTER I WITH DIAERESIS
		0x00D0,	//	LATIN CAPITAL LETTER ETH (Icelandic)
		0x00D1,	//	LATIN CAPITAL LETTER N WITH TILDE
		0x00D2,	//	LATIN CAPITAL LETTER O WITH GRAVE
		0x00D3,	//	LATIN CAPITAL LETTER O WITH ACUTE
		0x00D4,	//	LATIN CAPITAL LETTER O WITH CIRCUMFLEX
		0x00D5,	//	LATIN CAPITAL LETTER O WITH TILDE
		0x00D6,	//	LATIN CAPITAL LETTER O WITH DIAERESIS
		0x00D7,	//	MULTIPLICATION SIGN
		0x00D8,	//	LATIN CAPITAL LETTER O WITH STROKE
		0x00D9,	//	LATIN CAPITAL LETTER U WITH GRAVE
		0x00DA,	//	LATIN CAPITAL LETTER U WITH ACUTE
		0x00DB,	//	LATIN CAPITAL LETTER U WITH CIRCUMFLEX
		0x00DC,	//	LATIN CAPITAL LETTER U WITH DIAERESIS
		0x00DD,	//	LATIN CAPITAL LETTER Y WITH ACUTE
		0x00DE,	//	LATIN CAPITAL LETTER THORN (Icelandic)
		0x00DF,	//	LATIN SMALL LETTER SHARP S (German)
		0x00E0,	//	LATIN SMALL LETTER A WITH GRAVE
		0x00E1,	//	LATIN SMALL LETTER A WITH ACUTE
		0x00E2,	//	LATIN SMALL LETTER A WITH CIRCUMFLEX
		0x00E3,	//	LATIN SMALL LETTER A WITH TILDE
		0x00E4,	//	LATIN SMALL LETTER A WITH DIAERESIS
		0x00E5,	//	LATIN SMALL LETTER A WITH RING ABOVE
		0x00E6,	//	LATIN SMALL LETTER AE
		0x00E7,	//	LATIN SMALL LETTER C WITH CEDILLA
		0x00E8,	//	LATIN SMALL LETTER E WITH GRAVE
		0x00E9,	//	LATIN SMALL LETTER E WITH ACUTE
		0x00EA,	//	LATIN SMALL LETTER E WITH CIRCUMFLEX
		0x00EB,	//	LATIN SMALL LETTER E WITH DIAERESIS
		0x00EC,	//	LATIN SMALL LETTER I WITH GRAVE
		0x00ED,	//	LATIN SMALL LETTER I WITH ACUTE
		0x00EE,	//	LATIN SMALL LETTER I WITH CIRCUMFLEX
		0x00EF,	//	LATIN SMALL LETTER I WITH DIAERESIS
		0x00F0,	//	LATIN SMALL LETTER ETH (Icelandic)
		0x00F1,	//	LATIN SMALL LETTER N WITH TILDE
		0x00F2,	//	LATIN SMALL LETTER O WITH GRAVE
		0x00F3,	//	LATIN SMALL LETTER O WITH ACUTE
		0x00F4,	//	LATIN SMALL LETTER O WITH CIRCUMFLEX
		0x00F5,	//	LATIN SMALL LETTER O WITH TILDE
		0x00F6,	//	LATIN SMALL LETTER O WITH DIAERESIS
		0x00F7,	//	DIVISION SIGN
		0x00F8,	//	LATIN SMALL LETTER O WITH STROKE
		0x00F9,	//	LATIN SMALL LETTER U WITH GRAVE
		0x00FA,	//	LATIN SMALL LETTER U WITH ACUTE
		0x00FB,	//	LATIN SMALL LETTER U WITH CIRCUMFLEX
		0x00FC,	//	LATIN SMALL LETTER U WITH DIAERESIS
		0x00FD,	//	LATIN SMALL LETTER Y WITH ACUTE
		0x00FE,	//	LATIN SMALL LETTER THORN (Icelandic)
		0x00FF	//	LATIN SMALL LETTER Y WITH DIAERESIS
	};

/**
	The alphabet of ISO 8859-2.
*/
	static char [] iso8859_2 = {
		0x00A0,	//	NO-BREAK SPACE
		0x0104,	//	LATIN CAPITAL LETTER A WITH OGONEK
		0x02D8,	//	BREVE
		0x0141,	//	LATIN CAPITAL LETTER L WITH STROKE
		0x00A4,	//	CURRENCY SIGN
		0x013D,	//	LATIN CAPITAL LETTER L WITH CARON
		0x015A,	//	LATIN CAPITAL LETTER S WITH ACUTE
		0x00A7,	//	SECTION SIGN
		0x00A8,	//	DIAERESIS
		0x0160,	//	LATIN CAPITAL LETTER S WITH CARON
		0x015E,	//	LATIN CAPITAL LETTER S WITH CEDILLA
		0x0164,	//	LATIN CAPITAL LETTER T WITH CARON
		0x0179,	//	LATIN CAPITAL LETTER Z WITH ACUTE
		0x00AD,	//	SOFT HYPHEN
		0x017D,	//	LATIN CAPITAL LETTER Z WITH CARON
		0x017B,	//	LATIN CAPITAL LETTER Z WITH DOT ABOVE
		0x00B0,	//	DEGREE SIGN
		0x0105,	//	LATIN SMALL LETTER A WITH OGONEK
		0x02DB,	//	OGONEK
		0x0142,	//	LATIN SMALL LETTER L WITH STROKE
		0x00B4,	//	ACUTE ACCENT
		0x013E,	//	LATIN SMALL LETTER L WITH CARON
		0x015B,	//	LATIN SMALL LETTER S WITH ACUTE
		0x02C7,	//	CARON
		0x00B8,	//	CEDILLA
		0x0161,	//	LATIN SMALL LETTER S WITH CARON
		0x015F,	//	LATIN SMALL LETTER S WITH CEDILLA
		0x0165,	//	LATIN SMALL LETTER T WITH CARON
		0x017A,	//	LATIN SMALL LETTER Z WITH ACUTE
		0x02DD,	//	DOUBLE ACUTE ACCENT
		0x017E,	//	LATIN SMALL LETTER Z WITH CARON
		0x017C,	//	LATIN SMALL LETTER Z WITH DOT ABOVE
		0x0154,	//	LATIN CAPITAL LETTER R WITH ACUTE
		0x00C1,	//	LATIN CAPITAL LETTER A WITH ACUTE
		0x00C2,	//	LATIN CAPITAL LETTER A WITH CIRCUMFLEX
		0x0102,	//	LATIN CAPITAL LETTER A WITH BREVE
		0x00C4,	//	LATIN CAPITAL LETTER A WITH DIAERESIS
		0x0139,	//	LATIN CAPITAL LETTER L WITH ACUTE
		0x0106,	//	LATIN CAPITAL LETTER C WITH ACUTE
		0x00C7,	//	LATIN CAPITAL LETTER C WITH CEDILLA
		0x010C,	//	LATIN CAPITAL LETTER C WITH CARON
		0x00C9,	//	LATIN CAPITAL LETTER E WITH ACUTE
		0x0118,	//	LATIN CAPITAL LETTER E WITH OGONEK
		0x00CB,	//	LATIN CAPITAL LETTER E WITH DIAERESIS
		0x011A,	//	LATIN CAPITAL LETTER E WITH CARON
		0x00CD,	//	LATIN CAPITAL LETTER I WITH ACUTE
		0x00CE,	//	LATIN CAPITAL LETTER I WITH CIRCUMFLEX
		0x010E,	//	LATIN CAPITAL LETTER D WITH CARON
		0x0110,	//	LATIN CAPITAL LETTER D WITH STROKE
		0x0143,	//	LATIN CAPITAL LETTER N WITH ACUTE
		0x0147,	//	LATIN CAPITAL LETTER N WITH CARON
		0x00D3,	//	LATIN CAPITAL LETTER O WITH ACUTE
		0x00D4,	//	LATIN CAPITAL LETTER O WITH CIRCUMFLEX
		0x0150,	//	LATIN CAPITAL LETTER O WITH DOUBLE ACUTE
		0x00D6,	//	LATIN CAPITAL LETTER O WITH DIAERESIS
		0x00D7,	//	MULTIPLICATION SIGN
		0x0158,	//	LATIN CAPITAL LETTER R WITH CARON
		0x016E,	//	LATIN CAPITAL LETTER U WITH RING ABOVE
		0x00DA,	//	LATIN CAPITAL LETTER U WITH ACUTE
		0x0170,	//	LATIN CAPITAL LETTER U WITH DOUBLE ACUTE
		0x00DC,	//	LATIN CAPITAL LETTER U WITH DIAERESIS
		0x00DD,	//	LATIN CAPITAL LETTER Y WITH ACUTE
		0x0162,	//	LATIN CAPITAL LETTER T WITH CEDILLA
		0x00DF,	//	LATIN SMALL LETTER SHARP S
		0x0155,	//	LATIN SMALL LETTER R WITH ACUTE
		0x00E1,	//	LATIN SMALL LETTER A WITH ACUTE
		0x00E2,	//	LATIN SMALL LETTER A WITH CIRCUMFLEX
		0x0103,	//	LATIN SMALL LETTER A WITH BREVE
		0x00E4,	//	LATIN SMALL LETTER A WITH DIAERESIS
		0x013A,	//	LATIN SMALL LETTER L WITH ACUTE
		0x0107,	//	LATIN SMALL LETTER C WITH ACUTE
		0x00E7,	//	LATIN SMALL LETTER C WITH CEDILLA
		0x010D,	//	LATIN SMALL LETTER C WITH CARON
		0x00E9,	//	LATIN SMALL LETTER E WITH ACUTE
		0x0119,	//	LATIN SMALL LETTER E WITH OGONEK
		0x00EB,	//	LATIN SMALL LETTER E WITH DIAERESIS
		0x011B,	//	LATIN SMALL LETTER E WITH CARON
		0x00ED,	//	LATIN SMALL LETTER I WITH ACUTE
		0x00EE,	//	LATIN SMALL LETTER I WITH CIRCUMFLEX
		0x010F,	//	LATIN SMALL LETTER D WITH CARON
		0x0111,	//	LATIN SMALL LETTER D WITH STROKE
		0x0144,	//	LATIN SMALL LETTER N WITH ACUTE
		0x0148,	//	LATIN SMALL LETTER N WITH CARON
		0x00F3,	//	LATIN SMALL LETTER O WITH ACUTE
		0x00F4,	//	LATIN SMALL LETTER O WITH CIRCUMFLEX
		0x0151,	//	LATIN SMALL LETTER O WITH DOUBLE ACUTE
		0x00F6,	//	LATIN SMALL LETTER O WITH DIAERESIS
		0x00F7,	//	DIVISION SIGN
		0x0159,	//	LATIN SMALL LETTER R WITH CARON
		0x016F,	//	LATIN SMALL LETTER U WITH RING ABOVE
		0x00FA,	//	LATIN SMALL LETTER U WITH ACUTE
		0x0171,	//	LATIN SMALL LETTER U WITH DOUBLE ACUTE
		0x00FC,	//	LATIN SMALL LETTER U WITH DIAERESIS
		0x00FD,	//	LATIN SMALL LETTER Y WITH ACUTE
		0x0163,	//	LATIN SMALL LETTER T WITH CEDILLA
		0x02D9	//	DOT ABOVE
	};

/**
	The alphabet of ISO 8859-3.
*/
	static char [] iso8859_3 = {
		0x00A0,	//	NO-BREAK SPACE
		0x0126,	//	LATIN CAPITAL LETTER H WITH STROKE
		0x02D8,	//	BREVE
		0x00A3,	//	POUND SIGN
		0x00A4,	//	CURRENCY SIGN
		0x0000,	//	DOES NOT EXIST
		0x0124,	//	LATIN CAPITAL LETTER H WITH CIRCUMFLEX
		0x00A7,	//	SECTION SIGN
		0x00A8,	//	DIAERESIS
		0x0130,	//	LATIN CAPITAL LETTER I WITH DOT ABOVE
		0x015E,	//	LATIN CAPITAL LETTER S WITH CEDILLA
		0x011E,	//	LATIN CAPITAL LETTER G WITH BREVE
		0x0134,	//	LATIN CAPITAL LETTER J WITH CIRCUMFLEX
		0x00AD,	//	SOFT HYPHEN
		0x0000,	//	DOES NOT EXIST
		0x017B,	//	LATIN CAPITAL LETTER Z WITH DOT ABOVE
		0x00B0,	//	DEGREE SIGN
		0x0127,	//	LATIN SMALL LETTER H WITH STROKE
		0x00B2,	//	SUPERSCRIPT TWO
		0x00B3,	//	SUPERSCRIPT THREE
		0x00B4,	//	ACUTE ACCENT
		0x00B5,	//	MICRO SIGN
		0x0125,	//	LATIN SMALL LETTER H WITH CIRCUMFLEX
		0x00B7,	//	MIDDLE DOT
		0x00B8,	//	CEDILLA
		0x0131,	//	LATIN SMALL LETTER DOTLESS I
		0x015F,	//	LATIN SMALL LETTER S WITH CEDILLA
		0x011F,	//	LATIN SMALL LETTER G WITH BREVE
		0x0135,	//	LATIN SMALL LETTER J WITH CIRCUMFLEX
		0x00BD,	//	VULGAR FRACTION ONE HALF
		0x0000,	//	DOES NOT EXIST
		0x017C,	//	LATIN SMALL LETTER Z WITH DOT ABOVE
		0x00C0,	//	LATIN CAPITAL LETTER A WITH GRAVE
		0x00C1,	//	LATIN CAPITAL LETTER A WITH ACUTE
		0x00C2,	//	LATIN CAPITAL LETTER A WITH CIRCUMFLEX
		0x0000,	//	DOES NOT EXIST
		0x00C4,	//	LATIN CAPITAL LETTER A WITH DIAERESIS
		0x010A,	//	LATIN CAPITAL LETTER C WITH DOT ABOVE
		0x0108,	//	LATIN CAPITAL LETTER C WITH CIRCUMFLEX
		0x00C7,	//	LATIN CAPITAL LETTER C WITH CEDILLA
		0x00C8,	//	LATIN CAPITAL LETTER E WITH GRAVE
		0x00C9,	//	LATIN CAPITAL LETTER E WITH ACUTE
		0x00CA,	//	LATIN CAPITAL LETTER E WITH CIRCUMFLEX
		0x00CB,	//	LATIN CAPITAL LETTER E WITH DIAERESIS
		0x00CC,	//	LATIN CAPITAL LETTER I WITH GRAVE
		0x00CD,	//	LATIN CAPITAL LETTER I WITH ACUTE
		0x00CE,	//	LATIN CAPITAL LETTER I WITH CIRCUMFLEX
		0x00CF,	//	LATIN CAPITAL LETTER I WITH DIAERESIS
		0x0000,	//	DOES NOT EXIST
		0x00D1,	//	LATIN CAPITAL LETTER N WITH TILDE
		0x00D2,	//	LATIN CAPITAL LETTER O WITH GRAVE
		0x00D3,	//	LATIN CAPITAL LETTER O WITH ACUTE
		0x00D4,	//	LATIN CAPITAL LETTER O WITH CIRCUMFLEX
		0x0120,	//	LATIN CAPITAL LETTER G WITH DOT ABOVE
		0x00D6,	//	LATIN CAPITAL LETTER O WITH DIAERESIS
		0x00D7,	//	MULTIPLICATION SIGN
		0x011C,	//	LATIN CAPITAL LETTER G WITH CIRCUMFLEX
		0x00D9,	//	LATIN CAPITAL LETTER U WITH GRAVE
		0x00DA,	//	LATIN CAPITAL LETTER U WITH ACUTE
		0x00DB,	//	LATIN CAPITAL LETTER U WITH CIRCUMFLEX
		0x00DC,	//	LATIN CAPITAL LETTER U WITH DIAERESIS
		0x016C,	//	LATIN CAPITAL LETTER U WITH BREVE
		0x015C,	//	LATIN CAPITAL LETTER S WITH CIRCUMFLEX
		0x00DF,	//	LATIN SMALL LETTER SHARP S
		0x00E0,	//	LATIN SMALL LETTER A WITH GRAVE
		0x00E1,	//	LATIN SMALL LETTER A WITH ACUTE
		0x00E2,	//	LATIN SMALL LETTER A WITH CIRCUMFLEX
		0x0000,	//	DOES NOT EXIST
		0x00E4,	//	LATIN SMALL LETTER A WITH DIAERESIS
		0x010B,	//	LATIN SMALL LETTER C WITH DOT ABOVE
		0x0109,	//	LATIN SMALL LETTER C WITH CIRCUMFLEX
		0x00E7,	//	LATIN SMALL LETTER C WITH CEDILLA
		0x00E8,	//	LATIN SMALL LETTER E WITH GRAVE
		0x00E9,	//	LATIN SMALL LETTER E WITH ACUTE
		0x00EA,	//	LATIN SMALL LETTER E WITH CIRCUMFLEX
		0x00EB,	//	LATIN SMALL LETTER E WITH DIAERESIS
		0x00EC,	//	LATIN SMALL LETTER I WITH GRAVE
		0x00ED,	//	LATIN SMALL LETTER I WITH ACUTE
		0x00EE,	//	LATIN SMALL LETTER I WITH CIRCUMFLEX
		0x00EF,	//	LATIN SMALL LETTER I WITH DIAERESIS
		0x0000,	//	DOES NOT EXIST
		0x00F1,	//	LATIN SMALL LETTER N WITH TILDE
		0x00F2,	//	LATIN SMALL LETTER O WITH GRAVE
		0x00F3,	//	LATIN SMALL LETTER O WITH ACUTE
		0x00F4,	//	LATIN SMALL LETTER O WITH CIRCUMFLEX
		0x0121,	//	LATIN SMALL LETTER G WITH DOT ABOVE
		0x00F6,	//	LATIN SMALL LETTER O WITH DIAERESIS
		0x00F7,	//	DIVISION SIGN
		0x011D,	//	LATIN SMALL LETTER G WITH CIRCUMFLEX
		0x00F9,	//	LATIN SMALL LETTER U WITH GRAVE
		0x00FA,	//	LATIN SMALL LETTER U WITH ACUTE
		0x00FB,	//	LATIN SMALL LETTER U WITH CIRCUMFLEX
		0x00FC,	//	LATIN SMALL LETTER U WITH DIAERESIS
		0x016D,	//	LATIN SMALL LETTER U WITH BREVE
		0x015D,	//	LATIN SMALL LETTER S WITH CIRCUMFLEX
		0x02D9	//	DOT ABOVE
	};

/**
	The alphabet of ISO 8859-4.
*/
	static char [] iso8859_4 = {
		0x00A0,	//	NO-BREAK SPACE
		0x0104,	//	LATIN CAPITAL LETTER A WITH OGONEK
		0x0138,	//	LATIN SMALL LETTER KRA
		0x0156,	//	LATIN CAPITAL LETTER R WITH CEDILLA
		0x00A4,	//	CURRENCY SIGN
		0x0128,	//	LATIN CAPITAL LETTER I WITH TILDE
		0x013B,	//	LATIN CAPITAL LETTER L WITH CEDILLA
		0x00A7,	//	SECTION SIGN
		0x00A8,	//	DIAERESIS
		0x0160,	//	LATIN CAPITAL LETTER S WITH CARON
		0x0112,	//	LATIN CAPITAL LETTER E WITH MACRON
		0x0122,	//	LATIN CAPITAL LETTER G WITH CEDILLA
		0x0166,	//	LATIN CAPITAL LETTER T WITH STROKE
		0x00AD,	//	SOFT HYPHEN
		0x017D,	//	LATIN CAPITAL LETTER Z WITH CARON
		0x00AF,	//	MACRON
		0x00B0,	//	DEGREE SIGN
		0x0105,	//	LATIN SMALL LETTER A WITH OGONEK
		0x02DB,	//	OGONEK
		0x0157,	//	LATIN SMALL LETTER R WITH CEDILLA
		0x00B4,	//	ACUTE ACCENT
		0x0129,	//	LATIN SMALL LETTER I WITH TILDE
		0x013C,	//	LATIN SMALL LETTER L WITH CEDILLA
		0x02C7,	//	CARON
		0x00B8,	//	CEDILLA
		0x0161,	//	LATIN SMALL LETTER S WITH CARON
		0x0113,	//	LATIN SMALL LETTER E WITH MACRON
		0x0123,	//	LATIN SMALL LETTER G WITH CEDILLA
		0x0167,	//	LATIN SMALL LETTER T WITH STROKE
		0x014A,	//	LATIN CAPITAL LETTER ENG
		0x017E,	//	LATIN SMALL LETTER Z WITH CARON
		0x014B,	//	LATIN SMALL LETTER ENG
		0x0100,	//	LATIN CAPITAL LETTER A WITH MACRON
		0x00C1,	//	LATIN CAPITAL LETTER A WITH ACUTE
		0x00C2,	//	LATIN CAPITAL LETTER A WITH CIRCUMFLEX
		0x00C3,	//	LATIN CAPITAL LETTER A WITH TILDE
		0x00C4,	//	LATIN CAPITAL LETTER A WITH DIAERESIS
		0x00C5,	//	LATIN CAPITAL LETTER A WITH RING ABOVE
		0x00C6,	//	LATIN CAPITAL LETTER AE
		0x012E,	//	LATIN CAPITAL LETTER I WITH OGONEK
		0x010C,	//	LATIN CAPITAL LETTER C WITH CARON
		0x00C9,	//	LATIN CAPITAL LETTER E WITH ACUTE
		0x0118,	//	LATIN CAPITAL LETTER E WITH OGONEK
		0x00CB,	//	LATIN CAPITAL LETTER E WITH DIAERESIS
		0x0116,	//	LATIN CAPITAL LETTER E WITH DOT ABOVE
		0x00CD,	//	LATIN CAPITAL LETTER I WITH ACUTE
		0x00CE,	//	LATIN CAPITAL LETTER I WITH CIRCUMFLEX
		0x012A,	//	LATIN CAPITAL LETTER I WITH MACRON
		0x0110,	//	LATIN CAPITAL LETTER D WITH STROKE
		0x0145,	//	LATIN CAPITAL LETTER N WITH CEDILLA
		0x014C,	//	LATIN CAPITAL LETTER O WITH MACRON
		0x0136,	//	LATIN CAPITAL LETTER K WITH CEDILLA
		0x00D4,	//	LATIN CAPITAL LETTER O WITH CIRCUMFLEX
		0x00D5,	//	LATIN CAPITAL LETTER O WITH TILDE
		0x00D6,	//	LATIN CAPITAL LETTER O WITH DIAERESIS
		0x00D7,	//	MULTIPLICATION SIGN
		0x00D8,	//	LATIN CAPITAL LETTER O WITH STROKE
		0x0172,	//	LATIN CAPITAL LETTER U WITH OGONEK
		0x00DA,	//	LATIN CAPITAL LETTER U WITH ACUTE
		0x00DB,	//	LATIN CAPITAL LETTER U WITH CIRCUMFLEX
		0x00DC,	//	LATIN CAPITAL LETTER U WITH DIAERESIS
		0x0168,	//	LATIN CAPITAL LETTER U WITH TILDE
		0x016A,	//	LATIN CAPITAL LETTER U WITH MACRON
		0x00DF,	//	LATIN SMALL LETTER SHARP S
		0x0101,	//	LATIN SMALL LETTER A WITH MACRON
		0x00E1,	//	LATIN SMALL LETTER A WITH ACUTE
		0x00E2,	//	LATIN SMALL LETTER A WITH CIRCUMFLEX
		0x00E3,	//	LATIN SMALL LETTER A WITH TILDE
		0x00E4,	//	LATIN SMALL LETTER A WITH DIAERESIS
		0x00E5,	//	LATIN SMALL LETTER A WITH RING ABOVE
		0x00E6,	//	LATIN SMALL LETTER AE
		0x012F,	//	LATIN SMALL LETTER I WITH OGONEK
		0x010D,	//	LATIN SMALL LETTER C WITH CARON
		0x00E9,	//	LATIN SMALL LETTER E WITH ACUTE
		0x0119,	//	LATIN SMALL LETTER E WITH OGONEK
		0x00EB,	//	LATIN SMALL LETTER E WITH DIAERESIS
		0x0117,	//	LATIN SMALL LETTER E WITH DOT ABOVE
		0x00ED,	//	LATIN SMALL LETTER I WITH ACUTE
		0x00EE,	//	LATIN SMALL LETTER I WITH CIRCUMFLEX
		0x012B,	//	LATIN SMALL LETTER I WITH MACRON
		0x0111,	//	LATIN SMALL LETTER D WITH STROKE
		0x0146,	//	LATIN SMALL LETTER N WITH CEDILLA
		0x014D,	//	LATIN SMALL LETTER O WITH MACRON
		0x0137,	//	LATIN SMALL LETTER K WITH CEDILLA
		0x00F4,	//	LATIN SMALL LETTER O WITH CIRCUMFLEX
		0x00F5,	//	LATIN SMALL LETTER O WITH TILDE
		0x00F6,	//	LATIN SMALL LETTER O WITH DIAERESIS
		0x00F7,	//	DIVISION SIGN
		0x00F8,	//	LATIN SMALL LETTER O WITH STROKE
		0x0173,	//	LATIN SMALL LETTER U WITH OGONEK
		0x00FA,	//	LATIN SMALL LETTER U WITH ACUTE
		0x00FB,	//	LATIN SMALL LETTER U WITH CIRCUMFLEX
		0x00FC,	//	LATIN SMALL LETTER U WITH DIAERESIS
		0x0169,	//	LATIN SMALL LETTER U WITH TILDE
		0x016B,	//	LATIN SMALL LETTER U WITH MACRON
		0x02D9,	//	DOT ABOVE
	};

/**
	The alphabet of ISO 8859-5.
*/
	static char [] iso8859_5 = {
		0x00A0,	//	NO-BREAK SPACE
		0x0401,	//	CYRILLIC CAPITAL LETTER IO
		0x0402,	//	CYRILLIC CAPITAL LETTER DJE
		0x0403,	//	CYRILLIC CAPITAL LETTER GJE
		0x0404,	//	CYRILLIC CAPITAL LETTER UKRAINIAN IE
		0x0405,	//	CYRILLIC CAPITAL LETTER DZE
		0x0406,	//	CYRILLIC CAPITAL LETTER BYELORUSSIAN-UKRAINIAN I
		0x0407,	//	CYRILLIC CAPITAL LETTER YI
		0x0408,	//	CYRILLIC CAPITAL LETTER JE
		0x0409,	//	CYRILLIC CAPITAL LETTER LJE
		0x040A,	//	CYRILLIC CAPITAL LETTER NJE
		0x040B,	//	CYRILLIC CAPITAL LETTER TSHE
		0x040C,	//	CYRILLIC CAPITAL LETTER KJE
		0x00AD,	//	SOFT HYPHEN
		0x040E,	//	CYRILLIC CAPITAL LETTER SHORT U
		0x040F,	//	CYRILLIC CAPITAL LETTER DZHE
		0x0410,	//	CYRILLIC CAPITAL LETTER A
		0x0411,	//	CYRILLIC CAPITAL LETTER BE
		0x0412,	//	CYRILLIC CAPITAL LETTER VE
		0x0413,	//	CYRILLIC CAPITAL LETTER GHE
		0x0414,	//	CYRILLIC CAPITAL LETTER DE
		0x0415,	//	CYRILLIC CAPITAL LETTER IE
		0x0416,	//	CYRILLIC CAPITAL LETTER ZHE
		0x0417,	//	CYRILLIC CAPITAL LETTER ZE
		0x0418,	//	CYRILLIC CAPITAL LETTER I
		0x0419,	//	CYRILLIC CAPITAL LETTER SHORT I
		0x041A,	//	CYRILLIC CAPITAL LETTER KA
		0x041B,	//	CYRILLIC CAPITAL LETTER EL
		0x041C,	//	CYRILLIC CAPITAL LETTER EM
		0x041D,	//	CYRILLIC CAPITAL LETTER EN
		0x041E,	//	CYRILLIC CAPITAL LETTER O
		0x041F,	//	CYRILLIC CAPITAL LETTER PE
		0x0420,	//	CYRILLIC CAPITAL LETTER ER
		0x0421,	//	CYRILLIC CAPITAL LETTER ES
		0x0422,	//	CYRILLIC CAPITAL LETTER TE
		0x0423,	//	CYRILLIC CAPITAL LETTER U
		0x0424,	//	CYRILLIC CAPITAL LETTER EF
		0x0425,	//	CYRILLIC CAPITAL LETTER HA
		0x0426,	//	CYRILLIC CAPITAL LETTER TSE
		0x0427,	//	CYRILLIC CAPITAL LETTER CHE
		0x0428,	//	CYRILLIC CAPITAL LETTER SHA
		0x0429,	//	CYRILLIC CAPITAL LETTER SHCHA
		0x042A,	//	CYRILLIC CAPITAL LETTER HARD SIGN
		0x042B,	//	CYRILLIC CAPITAL LETTER YERU
		0x042C,	//	CYRILLIC CAPITAL LETTER SOFT SIGN
		0x042D,	//	CYRILLIC CAPITAL LETTER E
		0x042E,	//	CYRILLIC CAPITAL LETTER YU
		0x042F,	//	CYRILLIC CAPITAL LETTER YA
		0x0430,	//	CYRILLIC SMALL LETTER A
		0x0431,	//	CYRILLIC SMALL LETTER BE
		0x0432,	//	CYRILLIC SMALL LETTER VE
		0x0433,	//	CYRILLIC SMALL LETTER GHE
		0x0434,	//	CYRILLIC SMALL LETTER DE
		0x0435,	//	CYRILLIC SMALL LETTER IE
		0x0436,	//	CYRILLIC SMALL LETTER ZHE
		0x0437,	//	CYRILLIC SMALL LETTER ZE
		0x0438,	//	CYRILLIC SMALL LETTER I
		0x0439,	//	CYRILLIC SMALL LETTER SHORT I
		0x043A,	//	CYRILLIC SMALL LETTER KA
		0x043B,	//	CYRILLIC SMALL LETTER EL
		0x043C,	//	CYRILLIC SMALL LETTER EM
		0x043D,	//	CYRILLIC SMALL LETTER EN
		0x043E,	//	CYRILLIC SMALL LETTER O
		0x043F,	//	CYRILLIC SMALL LETTER PE
		0x0440,	//	CYRILLIC SMALL LETTER ER
		0x0441,	//	CYRILLIC SMALL LETTER ES
		0x0442,	//	CYRILLIC SMALL LETTER TE
		0x0443,	//	CYRILLIC SMALL LETTER U
		0x0444,	//	CYRILLIC SMALL LETTER EF
		0x0445,	//	CYRILLIC SMALL LETTER HA
		0x0446,	//	CYRILLIC SMALL LETTER TSE
		0x0447,	//	CYRILLIC SMALL LETTER CHE
		0x0448,	//	CYRILLIC SMALL LETTER SHA
		0x0449,	//	CYRILLIC SMALL LETTER SHCHA
		0x044A,	//	CYRILLIC SMALL LETTER HARD SIGN
		0x044B,	//	CYRILLIC SMALL LETTER YERU
		0x044C,	//	CYRILLIC SMALL LETTER SOFT SIGN
		0x044D,	//	CYRILLIC SMALL LETTER E
		0x044E,	//	CYRILLIC SMALL LETTER YU
		0x044F,	//	CYRILLIC SMALL LETTER YA
		0x2116,	//	NUMERO SIGN
		0x0451,	//	CYRILLIC SMALL LETTER IO
		0x0452,	//	CYRILLIC SMALL LETTER DJE
		0x0453,	//	CYRILLIC SMALL LETTER GJE
		0x0454,	//	CYRILLIC SMALL LETTER UKRAINIAN IE
		0x0455,	//	CYRILLIC SMALL LETTER DZE
		0x0456,	//	CYRILLIC SMALL LETTER BYELORUSSIAN-UKRAINIAN I
		0x0457,	//	CYRILLIC SMALL LETTER YI
		0x0458,	//	CYRILLIC SMALL LETTER JE
		0x0459,	//	CYRILLIC SMALL LETTER LJE
		0x045A,	//	CYRILLIC SMALL LETTER NJE
		0x045B,	//	CYRILLIC SMALL LETTER TSHE
		0x045C,	//	CYRILLIC SMALL LETTER KJE
		0x00A7,	//	SECTION SIGN
		0x045E,	//	CYRILLIC SMALL LETTER SHORT U
		0x045F	//	CYRILLIC SMALL LETTER DZHE
	};

/**
	The alphabet of ISO 8859-6.
*/
	static char [] iso8859_6 = {
		0x00A0,	//	NO-BREAK SPACE
		0x0000,	//	DOES NOT EXIST
		0x0000,	//	DOES NOT EXIST
		0x0000,	//	DOES NOT EXIST
		0x00A4,	//	CURRENCY SIGN
		0x0000,	//	DOES NOT EXIST
		0x0000,	//	DOES NOT EXIST
		0x0000,	//	DOES NOT EXIST
		0x0000,	//	DOES NOT EXIST
		0x0000,	//	DOES NOT EXIST
		0x0000,	//	DOES NOT EXIST
		0x0000,	//	DOES NOT EXIST
		0x060C,	//	ARABIC COMMA
		0x00AD,	//	SOFT HYPHEN
		0x0000,	//	DOES NOT EXIST
		0x0000,	//	DOES NOT EXIST
		0x0000,	//	DOES NOT EXIST
		0x0000,	//	DOES NOT EXIST
		0x0000,	//	DOES NOT EXIST
		0x0000,	//	DOES NOT EXIST
		0x0000,	//	DOES NOT EXIST
		0x0000,	//	DOES NOT EXIST
		0x0000,	//	DOES NOT EXIST
		0x0000,	//	DOES NOT EXIST
		0x0000,	//	DOES NOT EXIST
		0x0000,	//	DOES NOT EXIST
		0x0000,	//	DOES NOT EXIST
		0x061B,	//	ARABIC SEMICOLON
		0x0000,	//	DOES NOT EXIST
		0x0000,	//	DOES NOT EXIST
		0x0000,	//	DOES NOT EXIST
		0x061F,	//	ARABIC QUESTION MARK
		0x0000,	//	DOES NOT EXIST
		0x0621,	//	ARABIC LETTER HAMZA
		0x0622,	//	ARABIC LETTER ALEF WITH MADDA ABOVE
		0x0623,	//	ARABIC LETTER ALEF WITH HAMZA ABOVE
		0x0624,	//	ARABIC LETTER WAW WITH HAMZA ABOVE
		0x0625,	//	ARABIC LETTER ALEF WITH HAMZA BELOW
		0x0626,	//	ARABIC LETTER YEH WITH HAMZA ABOVE
		0x0627,	//	ARABIC LETTER ALEF
		0x0628,	//	ARABIC LETTER BEH
		0x0629,	//	ARABIC LETTER TEH MARBUTA
		0x062A,	//	ARABIC LETTER TEH
		0x062B,	//	ARABIC LETTER THEH
		0x062C,	//	ARABIC LETTER JEEM
		0x062D,	//	ARABIC LETTER HAH
		0x062E,	//	ARABIC LETTER KHAH
		0x062F,	//	ARABIC LETTER DAL
		0x0630,	//	ARABIC LETTER THAL
		0x0631,	//	ARABIC LETTER REH
		0x0632,	//	ARABIC LETTER ZAIN
		0x0633,	//	ARABIC LETTER SEEN
		0x0634,	//	ARABIC LETTER SHEEN
		0x0635,	//	ARABIC LETTER SAD
		0x0636,	//	ARABIC LETTER DAD
		0x0637,	//	ARABIC LETTER TAH
		0x0638,	//	ARABIC LETTER ZAH
		0x0639,	//	ARABIC LETTER AIN
		0x063A,	//	ARABIC LETTER GHAIN
		0x0000,	//	DOES NOT EXIST
		0x0000,	//	DOES NOT EXIST
		0x0000,	//	DOES NOT EXIST
		0x0000,	//	DOES NOT EXIST
		0x0000,	//	DOES NOT EXIST
		0x0640,	//	ARABIC TATWEEL
		0x0641,	//	ARABIC LETTER FEH
		0x0642,	//	ARABIC LETTER QAF
		0x0643,	//	ARABIC LETTER KAF
		0x0644,	//	ARABIC LETTER LAM
		0x0645,	//	ARABIC LETTER MEEM
		0x0646,	//	ARABIC LETTER NOON
		0x0647,	//	ARABIC LETTER HEH
		0x0648,	//	ARABIC LETTER WAW
		0x0649,	//	ARABIC LETTER ALEF MAKSURA
		0x064A,	//	ARABIC LETTER YEH
		0x064B,	//	ARABIC FATHATAN
		0x064C,	//	ARABIC DAMMATAN
		0x064D,	//	ARABIC KASRATAN
		0x064E,	//	ARABIC FATHA
		0x064F,	//	ARABIC DAMMA
		0x0650,	//	ARABIC KASRA
		0x0651,	//	ARABIC SHADDA
		0x0652,	//	ARABIC SUKUN
		0x0000,	//	DOES NOT EXIST
		0x0000,	//	DOES NOT EXIST
		0x0000,	//	DOES NOT EXIST
		0x0000,	//	DOES NOT EXIST
		0x0000,	//	DOES NOT EXIST
		0x0000,	//	DOES NOT EXIST
		0x0000,	//	DOES NOT EXIST
		0x0000,	//	DOES NOT EXIST
		0x0000,	//	DOES NOT EXIST
		0x0000,	//	DOES NOT EXIST
		0x0000,	//	DOES NOT EXIST
		0x0000,	//	DOES NOT EXIST
		0x0000	//	DOES NOT EXIST
	};

/**
	The alphabet of ISO 8859-7.
*/
	static char [] iso8859_7 = {
		0x00A0,	//	NO-BREAK SPACE
		0x2018,	//	LEFT SINGLE QUOTATION MARK
		0x2019,	//	RIGHT SINGLE QUOTATION MARK
		0x00A3,	//	POUND SIGN
		0x0000,	//	DOES NOT EXIST
		0x0000,	//	DOES NOT EXIST
		0x00A6,	//	BROKEN BAR
		0x00A7,	//	SECTION SIGN
		0x00A8,	//	DIAERESIS
		0x00A9,	//	COPYRIGHT SIGN
		0x0000,	//	DOES NOT EXIST
		0x00AB,	//	LEFT-POINTING DOUBLE ANGLE QUOTATION MARK
		0x00AC,	//	NOT SIGN
		0x00AD,	//	SOFT HYPHEN
		0x0000,	//	DOES NOT EXIST
		0x2015,	//	HORIZONTAL BAR
		0x00B0,	//	DEGREE SIGN
		0x00B1,	//	PLUS-MINUS SIGN
		0x00B2,	//	SUPERSCRIPT TWO
		0x00B3,	//	SUPERSCRIPT THREE
		0x0384,	//	GREEK TONOS
		0x0385,	//	GREEK DIALYTIKA TONOS
		0x0386,	//	GREEK CAPITAL LETTER ALPHA WITH TONOS
		0x00B7,	//	MIDDLE DOT
		0x0388,	//	GREEK CAPITAL LETTER EPSILON WITH TONOS
		0x0389,	//	GREEK CAPITAL LETTER ETA WITH TONOS
		0x038A,	//	GREEK CAPITAL LETTER IOTA WITH TONOS
		0x00BB,	//	RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK
		0x038C,	//	GREEK CAPITAL LETTER OMICRON WITH TONOS
		0x00BD,	//	VULGAR FRACTION ONE HALF
		0x038E,	//	GREEK CAPITAL LETTER UPSILON WITH TONOS
		0x038F,	//	GREEK CAPITAL LETTER OMEGA WITH TONOS
		0x0390,	//	GREEK SMALL LETTER IOTA WITH DIALYTIKA AND TONOS
		0x0391,	//	GREEK CAPITAL LETTER ALPHA
		0x0392,	//	GREEK CAPITAL LETTER BETA
		0x0393,	//	GREEK CAPITAL LETTER GAMMA
		0x0394,	//	GREEK CAPITAL LETTER DELTA
		0x0395,	//	GREEK CAPITAL LETTER EPSILON
		0x0396,	//	GREEK CAPITAL LETTER ZETA
		0x0397,	//	GREEK CAPITAL LETTER ETA
		0x0398,	//	GREEK CAPITAL LETTER THETA
		0x0399,	//	GREEK CAPITAL LETTER IOTA
		0x039A,	//	GREEK CAPITAL LETTER KAPPA
		0x039B,	//	GREEK CAPITAL LETTER LAMDA
		0x039C,	//	GREEK CAPITAL LETTER MU
		0x039D,	//	GREEK CAPITAL LETTER NU
		0x039E,	//	GREEK CAPITAL LETTER XI
		0x039F,	//	GREEK CAPITAL LETTER OMICRON
		0x03A0,	//	GREEK CAPITAL LETTER PI
		0x03A1,	//	GREEK CAPITAL LETTER RHO
		0x0000,	//	DOES NOT EXIST
		0x03A3,	//	GREEK CAPITAL LETTER SIGMA
		0x03A4,	//	GREEK CAPITAL LETTER TAU
		0x03A5,	//	GREEK CAPITAL LETTER UPSILON
		0x03A6,	//	GREEK CAPITAL LETTER PHI
		0x03A7,	//	GREEK CAPITAL LETTER CHI
		0x03A8,	//	GREEK CAPITAL LETTER PSI
		0x03A9,	//	GREEK CAPITAL LETTER OMEGA
		0x03AA,	//	GREEK CAPITAL LETTER IOTA WITH DIALYTIKA
		0x03AB,	//	GREEK CAPITAL LETTER UPSILON WITH DIALYTIKA
		0x03AC,	//	GREEK SMALL LETTER ALPHA WITH TONOS
		0x03AD,	//	GREEK SMALL LETTER EPSILON WITH TONOS
		0x03AE,	//	GREEK SMALL LETTER ETA WITH TONOS
		0x03AF,	//	GREEK SMALL LETTER IOTA WITH TONOS
		0x03B0,	//	GREEK SMALL LETTER UPSILON WITH DIALYTIKA AND TONOS
		0x03B1,	//	GREEK SMALL LETTER ALPHA
		0x03B2,	//	GREEK SMALL LETTER BETA
		0x03B3,	//	GREEK SMALL LETTER GAMMA
		0x03B4,	//	GREEK SMALL LETTER DELTA
		0x03B5,	//	GREEK SMALL LETTER EPSILON
		0x03B6,	//	GREEK SMALL LETTER ZETA
		0x03B7,	//	GREEK SMALL LETTER ETA
		0x03B8,	//	GREEK SMALL LETTER THETA
		0x03B9,	//	GREEK SMALL LETTER IOTA
		0x03BA,	//	GREEK SMALL LETTER KAPPA
		0x03BB,	//	GREEK SMALL LETTER LAMDA
		0x03BC,	//	GREEK SMALL LETTER MU
		0x03BD,	//	GREEK SMALL LETTER NU
		0x03BE,	//	GREEK SMALL LETTER XI
		0x03BF,	//	GREEK SMALL LETTER OMICRON
		0x03C0,	//	GREEK SMALL LETTER PI
		0x03C1,	//	GREEK SMALL LETTER RHO
		0x03C2,	//	GREEK SMALL LETTER FINAL SIGMA
		0x03C3,	//	GREEK SMALL LETTER SIGMA
		0x03C4,	//	GREEK SMALL LETTER TAU
		0x03C5,	//	GREEK SMALL LETTER UPSILON
		0x03C6,	//	GREEK SMALL LETTER PHI
		0x03C7,	//	GREEK SMALL LETTER CHI
		0x03C8,	//	GREEK SMALL LETTER PSI
		0x03C9,	//	GREEK SMALL LETTER OMEGA
		0x03CA,	//	GREEK SMALL LETTER IOTA WITH DIALYTIKA
		0x03CB,	//	GREEK SMALL LETTER UPSILON WITH DIALYTIKA
		0x03CC,	//	GREEK SMALL LETTER OMICRON WITH TONOS
		0x03CD,	//	GREEK SMALL LETTER UPSILON WITH TONOS
		0x03CE,	//	GREEK SMALL LETTER OMEGA WITH TONOS
		0x0000	//	DOES NOT EXIST
	};

/**
	The alphabet of ISO 8859-8.
*/
	static char [] iso8859_8 = {
		0x00A0,	//	NO-BREAK SPACE
		0x0000,	//	DOES NOT EXIST
		0x00A2,	//	CENT SIGN
		0x00A3,	//	POUND SIGN
		0x00A4,	//	CURRENCY SIGN
		0x00A5,	//	YEN SIGN
		0x00A6,	//	BROKEN BAR
		0x00A7,	//	SECTION SIGN
		0x00A8,	//	DIAERESIS
		0x00A9,	//	COPYRIGHT SIGN
		0x00D7,	//	MULTIPLICATION SIGN
		0x00AB,	//	LEFT-POINTING DOUBLE ANGLE QUOTATION MARK
		0x00AC,	//	NOT SIGN
		0x00AD,	//	SOFT HYPHEN
		0x00AE,	//	REGISTERED SIGN
		0x203E,	//	OVERLINE
		0x00B0,	//	DEGREE SIGN
		0x00B1,	//	PLUS-MINUS SIGN
		0x00B2,	//	SUPERSCRIPT TWO
		0x00B3,	//	SUPERSCRIPT THREE
		0x00B4,	//	ACUTE ACCENT
		0x00B5,	//	MICRO SIGN
		0x00B6,	//	PILCROW SIGN
		0x00B7,	//	MIDDLE DOT
		0x00B8,	//	CEDILLA
		0x00B9,	//	SUPERSCRIPT ONE
		0x00F7,	//	DIVISION SIGN
		0x00BB,	//	RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK
		0x00BC,	//	VULGAR FRACTION ONE QUARTER
		0x00BD,	//	VULGAR FRACTION ONE HALF
		0x00BE,	//	VULGAR FRACTION THREE QUARTERS
		0x0000,	//	DOES NOT EXIST
		0x0000,	//	DOES NOT EXIST
		0x0000,	//	DOES NOT EXIST
		0x0000,	//	DOES NOT EXIST
		0x0000,	//	DOES NOT EXIST
		0x0000,	//	DOES NOT EXIST
		0x0000,	//	DOES NOT EXIST
		0x0000,	//	DOES NOT EXIST
		0x0000,	//	DOES NOT EXIST
		0x0000,	//	DOES NOT EXIST
		0x0000,	//	DOES NOT EXIST
		0x0000,	//	DOES NOT EXIST
		0x0000,	//	DOES NOT EXIST
		0x0000,	//	DOES NOT EXIST
		0x0000,	//	DOES NOT EXIST
		0x0000,	//	DOES NOT EXIST
		0x0000,	//	DOES NOT EXIST
		0x0000,	//	DOES NOT EXIST
		0x0000,	//	DOES NOT EXIST
		0x0000,	//	DOES NOT EXIST
		0x0000,	//	DOES NOT EXIST
		0x0000,	//	DOES NOT EXIST
		0x0000,	//	DOES NOT EXIST
		0x0000,	//	DOES NOT EXIST
		0x0000,	//	DOES NOT EXIST
		0x0000,	//	DOES NOT EXIST
		0x0000,	//	DOES NOT EXIST
		0x0000,	//	DOES NOT EXIST
		0x0000,	//	DOES NOT EXIST
		0x0000,	//	DOES NOT EXIST
		0x0000,	//	DOES NOT EXIST
		0x0000,	//	DOES NOT EXIST
		0x2017,	//	DOUBLE LOW LINE
		0x05D0,	//	HEBREW LETTER ALEF
		0x05D1,	//	HEBREW LETTER BET
		0x05D2,	//	HEBREW LETTER GIMEL
		0x05D3,	//	HEBREW LETTER DALET
		0x05D4,	//	HEBREW LETTER HE
		0x05D5,	//	HEBREW LETTER VAV
		0x05D6,	//	HEBREW LETTER ZAYIN
		0x05D7,	//	HEBREW LETTER HET
		0x05D8,	//	HEBREW LETTER TET
		0x05D9,	//	HEBREW LETTER YOD
		0x05DA,	//	HEBREW LETTER FINAL KAF
		0x05DB,	//	HEBREW LETTER KAF
		0x05DC,	//	HEBREW LETTER LAMED
		0x05DD,	//	HEBREW LETTER FINAL MEM
		0x05DE,	//	HEBREW LETTER MEM
		0x05DF,	//	HEBREW LETTER FINAL NUN
		0x05E0,	//	HEBREW LETTER NUN
		0x05E1,	//	HEBREW LETTER SAMEKH
		0x05E2,	//	HEBREW LETTER AYIN
		0x05E3,	//	HEBREW LETTER FINAL PE
		0x05E4,	//	HEBREW LETTER PE
		0x05E5,	//	HEBREW LETTER FINAL TSADI
		0x05E6,	//	HEBREW LETTER TSADI
		0x05E7,	//	HEBREW LETTER QOF
		0x05E8,	//	HEBREW LETTER RESH
		0x05E9,	//	HEBREW LETTER SHIN
		0x05EA,	//	HEBREW LETTER TAV
		0x0000,	//	DOES NOT EXIST
		0x0000,	//	DOES NOT EXIST
		0x0000,	//	DOES NOT EXIST
		0x0000,	//	DOES NOT EXIST
		0x0000	//	DOES NOT EXIST
	};

/**
	The alphabet of ISO 8859-9.
*/
	static char [] iso8859_9 = {
		0x00A0,	//	NO-BREAK SPACE
		0x00A1,	//	INVERTED EXCLAMATION MARK
		0x00A2,	//	CENT SIGN
		0x00A3,	//	POUND SIGN
		0x00A4,	//	CURRENCY SIGN
		0x00A5,	//	YEN SIGN
		0x00A6,	//	BROKEN BAR
		0x00A7,	//	SECTION SIGN
		0x00A8,	//	DIAERESIS
		0x00A9,	//	COPYRIGHT SIGN
		0x00AA,	//	FEMININE ORDINAL INDICATOR
		0x00AB,	//	LEFT-POINTING DOUBLE ANGLE QUOTATION MARK
		0x00AC,	//	NOT SIGN
		0x00AD,	//	SOFT HYPHEN
		0x00AE,	//	REGISTERED SIGN
		0x00AF,	//	MACRON
		0x00B0,	//	DEGREE SIGN
		0x00B1,	//	PLUS-MINUS SIGN
		0x00B2,	//	SUPERSCRIPT TWO
		0x00B3,	//	SUPERSCRIPT THREE
		0x00B4,	//	ACUTE ACCENT
		0x00B5,	//	MICRO SIGN
		0x00B6,	//	PILCROW SIGN
		0x00B7,	//	MIDDLE DOT
		0x00B8,	//	CEDILLA
		0x00B9,	//	SUPERSCRIPT ONE
		0x00BA,	//	MASCULINE ORDINAL INDICATOR
		0x00BB,	//	RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK
		0x00BC,	//	VULGAR FRACTION ONE QUARTER
		0x00BD,	//	VULGAR FRACTION ONE HALF
		0x00BE,	//	VULGAR FRACTION THREE QUARTERS
		0x00BF,	//	INVERTED QUESTION MARK
		0x00C0,	//	LATIN CAPITAL LETTER A WITH GRAVE
		0x00C1,	//	LATIN CAPITAL LETTER A WITH ACUTE
		0x00C2,	//	LATIN CAPITAL LETTER A WITH CIRCUMFLEX
		0x00C3,	//	LATIN CAPITAL LETTER A WITH TILDE
		0x00C4,	//	LATIN CAPITAL LETTER A WITH DIAERESIS
		0x00C5,	//	LATIN CAPITAL LETTER A WITH RING ABOVE
		0x00C6,	//	LATIN CAPITAL LETTER AE
		0x00C7,	//	LATIN CAPITAL LETTER C WITH CEDILLA
		0x00C8,	//	LATIN CAPITAL LETTER E WITH GRAVE
		0x00C9,	//	LATIN CAPITAL LETTER E WITH ACUTE
		0x00CA,	//	LATIN CAPITAL LETTER E WITH CIRCUMFLEX
		0x00CB,	//	LATIN CAPITAL LETTER E WITH DIAERESIS
		0x00CC,	//	LATIN CAPITAL LETTER I WITH GRAVE
		0x00CD,	//	LATIN CAPITAL LETTER I WITH ACUTE
		0x00CE,	//	LATIN CAPITAL LETTER I WITH CIRCUMFLEX
		0x00CF,	//	LATIN CAPITAL LETTER I WITH DIAERESIS
		0x011E,	//	LATIN CAPITAL LETTER G WITH BREVE
		0x00D1,	//	LATIN CAPITAL LETTER N WITH TILDE
		0x00D2,	//	LATIN CAPITAL LETTER O WITH GRAVE
		0x00D3,	//	LATIN CAPITAL LETTER O WITH ACUTE
		0x00D4,	//	LATIN CAPITAL LETTER O WITH CIRCUMFLEX
		0x00D5,	//	LATIN CAPITAL LETTER O WITH TILDE
		0x00D6,	//	LATIN CAPITAL LETTER O WITH DIAERESIS
		0x00D7,	//	MULTIPLICATION SIGN
		0x00D8,	//	LATIN CAPITAL LETTER O WITH STROKE
		0x00D9,	//	LATIN CAPITAL LETTER U WITH GRAVE
		0x00DA,	//	LATIN CAPITAL LETTER U WITH ACUTE
		0x00DB,	//	LATIN CAPITAL LETTER U WITH CIRCUMFLEX
		0x00DC,	//	LATIN CAPITAL LETTER U WITH DIAERESIS
		0x0130,	//	LATIN CAPITAL LETTER I WITH DOT ABOVE
		0x015E,	//	LATIN CAPITAL LETTER S WITH CEDILLA
		0x00DF,	//	LATIN SMALL LETTER SHARP S
		0x00E0,	//	LATIN SMALL LETTER A WITH GRAVE
		0x00E1,	//	LATIN SMALL LETTER A WITH ACUTE
		0x00E2,	//	LATIN SMALL LETTER A WITH CIRCUMFLEX
		0x00E3,	//	LATIN SMALL LETTER A WITH TILDE
		0x00E4,	//	LATIN SMALL LETTER A WITH DIAERESIS
		0x00E5,	//	LATIN SMALL LETTER A WITH RING ABOVE
		0x00E6,	//	LATIN SMALL LETTER AE
		0x00E7,	//	LATIN SMALL LETTER C WITH CEDILLA
		0x00E8,	//	LATIN SMALL LETTER E WITH GRAVE
		0x00E9,	//	LATIN SMALL LETTER E WITH ACUTE
		0x00EA,	//	LATIN SMALL LETTER E WITH CIRCUMFLEX
		0x00EB,	//	LATIN SMALL LETTER E WITH DIAERESIS
		0x00EC,	//	LATIN SMALL LETTER I WITH GRAVE
		0x00ED,	//	LATIN SMALL LETTER I WITH ACUTE
		0x00EE,	//	LATIN SMALL LETTER I WITH CIRCUMFLEX
		0x00EF,	//	LATIN SMALL LETTER I WITH DIAERESIS
		0x011F,	//	LATIN SMALL LETTER G WITH BREVE
		0x00F1,	//	LATIN SMALL LETTER N WITH TILDE
		0x00F2,	//	LATIN SMALL LETTER O WITH GRAVE
		0x00F3,	//	LATIN SMALL LETTER O WITH ACUTE
		0x00F4,	//	LATIN SMALL LETTER O WITH CIRCUMFLEX
		0x00F5,	//	LATIN SMALL LETTER O WITH TILDE
		0x00F6,	//	LATIN SMALL LETTER O WITH DIAERESIS
		0x00F7,	//	DIVISION SIGN
		0x00F8,	//	LATIN SMALL LETTER O WITH STROKE
		0x00F9,	//	LATIN SMALL LETTER U WITH GRAVE
		0x00FA,	//	LATIN SMALL LETTER U WITH ACUTE
		0x00FB,	//	LATIN SMALL LETTER U WITH CIRCUMFLEX
		0x00FC,	//	LATIN SMALL LETTER U WITH DIAERESIS
		0x0131,	//	LATIN SMALL LETTER DOTLESS I
		0x015F,	//	LATIN SMALL LETTER S WITH CEDILLA
		0x00FF	//	LATIN SMALL LETTER Y WITH DIAERESIS
	};

/**
	The alphabet of ISO 8859.
*/
	private static char[] [] iso8859 = {
		iso8859_1,
		iso8859_2,
		iso8859_3,
		iso8859_4,
		iso8859_5,
		iso8859_6,
		iso8859_7,
		iso8859_8,
		iso8859_9
	};


/**
	The constants indicating the type of tokens.
*/
	static final int EOF = -1; // previously it was 0
	static final int ERROR = 1;
	static final int LPAREN = 2;
	static final int RPAREN = 3;
	static final int SLASH = 4;
	static final int SEMICOLON = 5;
	static final int COMMA = 6;
	static final int EQUALS = 7;
	static final int LOGICAL = 8;
	static final int MISSING = 11;
	static final int REDEFINE = 12;
	static final int SCOPE = 13;
	static final int ENDSEC = 14;
	static final int ISO_BEGIN = 15;
	static final int ISO_END = 16;
	static final int DATA = 17;
	static final int HEADER = 18;
	static final int ENDSCOPE = 19;
	static final int BINARY = 20;
	static final int INSTANCE_NAME = 21;
	static final int INTEGER = 22;
	static final int REAL = 23;
	static final int STRING = 24;
	static final int ENUM = 25;
	static final int USER_DEFINED_KEYWORD = 26;
	static final int ENTITY_NAME = 27;
	static final int COMMENT = 28;

/**
	The strings describing types of tokens.
	The specific string for a token is taken at the index that is equal
	to the constant indicating the type of that token. An exception is
	'LOGICAL' type which is represented by 3 strings (one for each possible
	logical value).
*/
	private static final String[] token_image = {
		"<EOF>",
		" ",
		"\"(\"",
		"\")\"",
		"\"/\"",
		"\";\"",
		"\",\"",
		"\"=\"",
		"\".T.\"",
		"\".U.\"",
		"\".F.\"",
		"\"$\"",
		"\"*\"",
		"\"SCOPE\"",
		"\"ENDSEC\"",
		"\"ISO-10303-21\"",
		"\"END-ISO-10303-21\"",
		"\"DATA\"",
		"\"HEADER\"",
		"\"ENDSCOPE\"",
		"<BINARY>",
		"<INSTANCE_NAME>",
		"<INTEGER>",
		"<REAL>",
		"<STRING>",
		"<ENUM>",
		"<USER_DEFINED_KEYWORD>",
		"<ENTITY_NAME>",
		"<COMMENT>"
	};

/**
	The constant strings used in the comments within instances of the entity
	'file_population' in the header of the exchange structure.
*/
	static final String[] SCH_INST_HIDDEN_FIELDS = {
		"schema_instance.name",
		"schema_instance.change_date",
		"schema_instance.validation_date",
		"schema_instance.validation_result",
		"schema_instance.validation_level",
		"schema_instance.description",
		"schema_instance.author",
		"schema_instance.organization",
		"schema_instance.preprocessor_version",
		"schema_instance.originating_system",
		"schema_instance.authorization",
		"schema_instance.language",
		"schema_instance.context_identifiers",
		"schema_instance.included_schema_instances"
	};

/**
	The constants representing special symbols as java byte fields.
	These constants are used extensively during reading/writing exchange
	structures.
*/
	static final byte DOT = (byte)'.';
	static final byte APOSTROPHE = (byte)'\'';
	static final byte QUOTATION_MARK = (byte)'\"';
	static final byte LEFT_PARENTHESIS = (byte)'(';
	static final byte RIGHT_PARENTHESIS = (byte)')';
	static final byte DOLLAR_SIGN = (byte)'$';
	static final byte ASTERISK = (byte)'*';
	static final byte SPECIAL = (byte)'#';
	static final byte COMMA_b = (byte)',';
	static final byte EQUAL = (byte)'=';
	static final byte SEMICOLON_b = (byte)';';
	static final byte COLON = (byte)':';
	static final byte MINUS = (byte)'-';
	static final byte PLUS = (byte)'+';
	static final byte UNDERSCORE = (byte)'_';
	static final byte EXCLAMATION_MARK = (byte)'!';
	static final byte CONJUNCTION = (byte)'&';
	static final byte SLASH_b = (byte)'/';
	static final byte BACKSLASH = (byte)'\\';
	static final byte SPACE = (byte)' ';
	static final byte QUESTION_MARK = (byte)'?';
	static final byte CAPITAL_S = (byte)'S';
	static final byte CAPITAL_P = (byte)'P';
	static final byte CAPITAL_X = (byte)'X';
	static final byte ZERO      = (byte)'0';
	static final byte TWO       = (byte)'2';
	static final byte FOUR      = (byte)'4';


/**
	The byte representation of special string tokens encountered in the exchange
	structures.
*/
	static final byte keywords[][] = {
		{(byte)'D',(byte)'A',(byte)'T',(byte)'A'},
		{(byte)'E',(byte)'N',(byte)'D',(byte)'S',(byte)'C',(byte)'O',(byte)'P',(byte)'E'},
		{(byte)'E',(byte)'N',(byte)'D',(byte)'S',(byte)'E',(byte)'C'},
		{(byte)'H',(byte)'E',(byte)'A',(byte)'D',(byte)'E',(byte)'R'},
		{(byte)'S',(byte)'C',(byte)'O',(byte)'P',(byte)'E'},
		{(byte)'I',(byte)'S',(byte)'O',(byte)'-',(byte)'1',(byte)'0',(byte)'3',(byte)'0',(byte)'3',(byte)'-',(byte)'2',(byte)'1'},
		{(byte)'E',(byte)'N',(byte)'D',(byte)'-',(byte)'I',(byte)'S',(byte)'O',(byte)'-',(byte)'1',(byte)'0',(byte)'3',(byte)'0',(byte)'3',(byte)'-',(byte)'2',(byte)'1'}
	};

/**
	The constant indicating the type of value: the case of defined type.
*/
	static final int TYPED_PARAMETER 							= 51;

/**
	The constant indicating the type of value: reference to an entity instance.
*/
	static final int ENTITY_REFERENCE 							= 52;

/**
	The constant indicating the type of value: reference to an entity instance
	which will be found later while reading an exchange structure (forward reference).
*/
	static final int ENTITY_REFERENCE_SPECIAL 				= 53;

/**
	The constant indicating the type of value: the case of aggregate.
*/
	static final int EMBEDDED_LIST 								= 54;

/**
	The constant indicating the type of value: the case of boolean.
*/
	static final int BOOLEAN 										=  9;

/**
	The constants indicating the type of an error.
*/
	static final int ONLY_SIGN_IS_SPECIFIED					= 11;
	static final int INTEGER_NUMBER_IS_TOO_LARGE				= 12;
	static final int BAD_REAL_LITERAL							= 13;
	static final int UNTERMINATED_STRING						= 14;
	static final int UNTERMINATED_BINARY						= 15;
	static final int UNTERMINATED_ENUMERATION					= 16;
	static final int INCORRECT_ENUMERATION						= 17;
	static final int INVALID_USER_DEFINED_ENTITY_NAME		= 18;
	static final int ZERO_INSTANCE_IDENTIFIER					= 19;
	static final int INCORRECT_INSTANCE_IDENTIFIER			= 20;
	static final int UNMATCHED_CLOSE_COMMENT					= 21;
	static final int UNTERMINATED_COMMENT						= 22;
	static final int ILLEGAL_LOWERCASE							= 23;
	static final int UNEXPECTED_CHARACTER						= 24; // %@^~
	static final int UNMATCHED_INPUT								= 25;
	static final int INTERNAL_ERROR								= 29;
	static final int BAD_INPUT_STREAM							= 30;
	static final int UNEXPECTED_ENTITY 							= 41;
	static final int INCORRECT_VALUE 							= 42;
	static final int TOO_LESS_VALUES 							= 43;
	static final int IMPROPER_LIST_ITEM 						= 44;
	static final int LIST_CANNOT_BE_EMPTY 						= 45;
	static final int SCHEMA_NOT_PROVIDED 						= 47;
	static final int WRONG_TOKEN 									= 48;
	static final int ENTITY_EXPECTED 							= 49;
	static final int WRONG_VALUE_IN_HEADER 					= 50;
	static final int TYPED_PARAMETER_IN_HEADER 				= 51;
	static final int INVALID_STRING_IN_DSECTION				= 52;
	static final int TOO_MANY_VALUES_IN_DSECTION				= 53;
	static final int DICTIONARY_MODEL_NOT_FOUND 				= 81;
	static final int DUPLICATE_INSTANCE 						= 82;
	static final int ILLEGAL_ACCESS 								= 86;
	static final int CLASS_NOT_FOUND 							= 87;
	static final int INVALID_SECTION_NAME						= 89;

/**
	The constant that controls the amount of the information printed.
*/
	private final byte PRINT_IN_PARSER 							=  0;

/**
	The initial length of the internal array 'instance_name'.
*/
	private final int COMPLEX_ENTITY_NAME_LENGTH 			= 512;

/**
	The initial length of the internal array 'chars'.
*/
	private final int NUMBER_OF_CHARACTERS_IN_STRING      = 128;

/**
	The initial length of the internal arrays 'partial_values' and
	'used_ent_values' in this class and arrays 'complex_name' and
	'ref2partial_values' in Create_instance.
*/
	static final int NAMES_ARRAY_SIZE                     = 16;

	private final int BOUND_ON_WARNINGS_COUNT             = 10;


/**
	An internal array to which forward references (type indicator is
	ENTITY_REFERENCE_SPECIAL) from the entity instance under consideration
	are temporary stored. Afterwards, when the latter instance is created,
	a pointer to this instance is added to the inverse list of each element
	in this array.
*/
	private CLateBindingEntity array_of_inverse[] =
		new CLateBindingEntity[SdaiSession.NUMBER_OF_VALUES];

/**
	The length of the internal array 'array_of_inverse'.
*/
	private int length_of_array_of_inverse;

/**
	An object of the class representing the values of an entity instance.
	The values are read from an exchange structure and stored to this object.
*/
	private ComplexEntityValue entity_values = new ComplexEntityValue();

/**
	An internal array used to store objects of the class <code>EntityValue</code>
	representing the subsets of values of an instance corresponding to
	simple entity types from which entity data type of the instance is composed.
	Usually, these objects are taken from the array <code>entityValues</code>
	of <code>ComplexEntityValue</code>.
*/
	private EntityValue [] partial_values;

	private EntityValue [] begin_ent_values;

/**
	An internal array used to mark (by 1) those objects of the class
	<code>EntityValue</code> within the array <code>entityValues</code> of
	<code>ComplexEntityValue</code> which have values in the complex entity
	instance. Values of some simple entity types may be missing due to some
	reason (for example, a bug in coding) in the external mapping of an instance
	in the exchange structure. This array also helps to reoder values of
	simple entity types when these values appear in the external mapping
	in a wrong order (are ordered by mistake not alphabetically).
*/
	private int [] used_ent_values;

/**
	An internal array used to store the names of simple entity types within
	an entity data type for which an encoding of an instance in the external
	mapping mode in the exchange structure was found.
*/
	private PartialEntityName complex_name[] =
		new PartialEntityName[SdaiSession.NUMBER_OF_ITEMS_IN_COMPLEX_ENTITY];

	private PartialEntityName [] saved_ent_name;

	private static final int PARTIAL_ENTITIES_COUNT = 16;

/**
	The name of an entity instance in the form of the byte array. If the instance
	is complex, then to concatenate the names of simple entity types the
	symbol '$" is used.
*/
	private byte instance_name[] = new byte[COMPLEX_ENTITY_NAME_LENGTH];

/**
	The length of the internal array 'instance_name'.
*/
	private int instance_name_length;
	int enl_instance_name_length;

	byte req_instance_name [];
	int req_instance_name_length;
	boolean inst_is_required;

/**
	An object of the class <code>Create_instance</code> used to create
	entity instances whose coding is read from the exchange structure.
*/
//	private Create_instance create = new Create_instance(this);
	private Create_instance create;

/**
	An object of the class <code>Binary_tree</code> used to process references
	between entity instances whose coding is read from the exchange structure.
	It helps to compile all the data contained in the exchange structure in one pass.
*/
	private Binary_tree tree;


/**
	A data dictionary model for Express schema which is underlying for a model
	to which all instances read from a data section of the exchange structure are
	stored.
*/
	private SdaiModel model_dic;

/**
	A model to which all instances read from a data section of the exchange
	structure are stored.
*/
	private SdaiModel model_app;

	// The set of SdaiModels read from physical file. The set contains SdaiModel objects
	Set modelSet;

	private boolean aggr_violation;
	private boolean inst_values_violation;


/**
	The constructor of this class. Used in <code>SdaiSession</code>.
*/
	PhFileReader() throws SdaiException, java.io.IOException {
		create = new Create_instance(this);
		token = new Token();
		for (int m = 0; m < SdaiSession.NUMBER_OF_ITEMS_IN_COMPLEX_ENTITY; m++) {
			complex_name[m] = new PartialEntityName();
		}
		error_table = new Reader_error_table();
		autoreference_found = false;
		if (chars == null) {
			chars = new char[NUMBER_OF_CHARACTERS_IN_STRING];
		}
		StaticFields staticFields = StaticFields.get();
		staticFields.importing = false;
	}



/**
	Reads an exchange structure. The file is submitted through the parameter
	<code>source_location</code>, and the data from it are stored into a repository
	whose name is given by the second parameter. The last parameter represents
	the schema instance for data dictionary (this is a field of the class
	<code>SdaiSession</code>). This method does the main job of the
	<code>SdaiSession</code> method <code>importClearTextEncoding</code>.
*/
	final SdaiRepository exchange_file(SdaiSession session, String name, Object source_location,
			Object destination_location, SchemaInstance schema_instance)
			throws SdaiException, java.io.IOException {
//long time1, time2, time3 = 0, time4 = 0;
//long time5, time6, time7 , time8, time9, time10;
//time1 = System.currentTimeMillis();
//time5 = System.currentTimeMillis();
		int i;
		long time_before_reading = 0, time_after_reading;
		long time_in_sec;

		active_session = session;
		StaticFields staticFields = StaticFields.get();
		staticFields.importing = true;
		try {
		repo_name = name;
		phys_file = source_location.toString();
		largest_identifier = -1;
		if (PRINT_IN_PARSER >= 0 && source_location instanceof String) {
			if (session.logWriterSession != null) {
				session.printlnSession("--- Exchange structure: " + phys_file);
			} else {
				SdaiSession.println("--- Exchange structure: " + phys_file);
			}
		}
		InputStream input;
		String locationString;
		if(source_location instanceof String) {
			locationString = (String)source_location;
			input = new FileInputStream(locationString);
		} else if(source_location instanceof InputStream) {
			locationString = null;
			input = (InputStream)source_location;
		} else {
			throw new SdaiException(SdaiException.VT_NVLD);
		}
		if (PRINT_IN_PARSER >= 0) {
			time_before_reading = System.currentTimeMillis();
		}
		if (scan == null) {
			scan = new Scanner(input, session);
		} else {
			scan.attach_stream(input, session);
		}
		tree = new Binary_tree();
		modelSet = new HashSet();

		try {
			consume_token(ISO_BEGIN);
			scan.begin_or_end_expected = false;
			consume_token(SEMICOLON);
			data_section_processing = false;
			header_section(session, locationString, destination_location);
			data_section_processing = true;
			scan.begin_or_end_expected = true;
			scan.get_token(token);
			scan.begin_or_end_expected = false;
			if (token.type == ERROR) {
				scanning_exception(token, -1, null);
			}
			int section_count = 0;
			while (token.type == DATA) {
				section_count++;
				if (section_count > 1 && SdaiCommon.feature_level == 0) {
					String base = SdaiSession.line_separator + AdditionalMessages.FL_OMZE;
					throw new SdaiException(SdaiException.SY_ERR, base);
				}
				file_repo.importing = true;
				data_section(schema_instance, file_repo);
				file_repo.importing = false;
				model_app.sort_inside_extents();
				scan.begin_or_end_expected = true;
				scan.get_token(token);
				scan.begin_or_end_expected = false;
				if (token.type == ERROR) {
					scanning_exception(token, -1, null);
				}
			}
			if (zero_inst != null) {
				replace_zero_id(session);
			}
            //<--VV--030310--
			//file_repo.largest_identifier = largest_identifier;
            file_repo.setNextPersistentLabel(largest_identifier+1);
            //--VV--030310-->
			if (token.type != ISO_END) {
				parsing_exception(token, WRONG_TOKEN, AdditionalMessages.RD_TOKE, token_image[ISO_END]);
			}
			consume_token(SEMICOLON);
			tree.check_unresolved();
			for(Iterator mi = modelSet.iterator(); mi.hasNext(); ) {
				SdaiModel model = (SdaiModel)mi.next();
				model.renumberPersistentLabels();
			}
		} finally {
			if(locationString != null) input.close();
			modelSet = null;
		}
		if (PRINT_IN_PARSER >= 0) {
			time_after_reading = System.currentTimeMillis();
			time_in_sec = (time_after_reading-time_before_reading) / 1000;
			if (session.logWriterSession != null) {
				session.printlnSession("--- Imported to the repository: " + file_repo.name);
				session.printlnSession("--- Reading time=" + time_in_sec + "sec");
			} else {
				SdaiSession.println("--- Imported to the repository: " + file_repo.name);
				SdaiSession.println("--- Reading time=" + time_in_sec + "sec");
			}
		}
		int j, k;
		boolean found;
		SdaiModel mod;
		for (j = 0; j < file_repo.languages_count; j++) {
			found = false;
			SECTION_LANGUAGE language = file_repo.languages[j];
			if (language.section == null) {
				file_repo.language = language.default_language;
				continue;
			}
			file_repo.internal_usage = true;
			mod = file_repo.findSdaiModel(language.section);
			file_repo.internal_usage = false;
			if (mod != null) {
				mod.language = language.default_language;
				found = true;
			}
			if (!found) {
				action_exception(INVALID_SECTION_NAME, null, null);
			}
		}
		for (j = 0; j < file_repo.contexts_count; j++) {
			found = false;
			SECTION_CONTEXT context = file_repo.contexts[j];
			if (context.section == null) {
				file_repo.context_identifiers = context.context_identifiers;
				continue;
			}
			file_repo.internal_usage = true;
			mod = file_repo.findSdaiModel(context.section);
			file_repo.internal_usage = false;
			if (mod != null) {
				mod.context_identifiers = context.context_identifiers;
				found = true;
			}
			if (!found) {
				action_exception(INVALID_SECTION_NAME, null, null);
			}
		}
		for (j = 0; j < file_repo.schemas.myLength; j++) {
			SchemaInstance sch_inst = (SchemaInstance)file_repo.schemas.myData[j];
			if (sch_inst.moved_data_status == 1) {
				sch_inst.moveDataAfterImportClearTextEncoding();
			}
		}
		file_repo.modified = false;
		create_schema_instances();
		include_schema_instances(session);
		} finally {
			tree = null;
			staticFields.importing = false;
			staticFields.current_instance_identifier = -1;
		}
		entity_values.unset_ComplexEntityValue();
		return file_repo;
/*System.out.println("    !!!!!PhFileReader    forw_count = " + forw_count);
System.out.println("    !!!!!PhFileReader    inv_added_count = " + inv_added_count);
System.out.println("    !!!!!PhFileReader    tree_insert_count = " + tree_insert_count);
System.out.println("    !!!!!PhFileReader    tree_replace_count = " + tree_replace_count);
System.out.println("    ^^^^^PhFileReader    time_insert_first = " + time_insert_first);
System.out.println("    ^^^^^PhFileReader    time_insert_second = " + time_insert_second);
System.out.println("    ^^^^^PhFileReader    time_replace = " + time_replace);
System.out.println("    ^^^^^PhFileReader    time_data_entity = " + time_data_entity);
long diff = time2 - time1;
System.out.println("    ^^^^^PhFileReader    exchange_file = " + diff);
diff = time6 - time5;
System.out.println("    ^^^^^PhFileReader    first_part = " + diff);
diff = time7 - time6;
System.out.println("    ^^^^^PhFileReader    second_part = " + diff);
diff = time8 - time7;
System.out.println("    ^^^^^PhFileReader    sorting = " + diff);
diff = time9 - time8;
System.out.println("    ^^^^^PhFileReader    third_part = " + diff);*/
	}


	final private void replace_zero_id(SdaiSession session) throws SdaiException {
		largest_identifier++;
		zero_inst.instance_identifier = largest_identifier;
		if (session != null && session.logWriterSession != null) {
			session.printlnSession(AdditionalMessages.RD_ZEID + largest_identifier);
		} else {
			SdaiSession.println(AdditionalMessages.RD_ZEID + largest_identifier);
		}
		SdaiModel mod = zero_inst.owning_model;
		SchemaData sch_data = mod.underlying_schema.modelDictionary.schemaData;
		int index_to_entity = sch_data.findEntityExtentIndex((CEntity_definition)zero_inst.getInstanceType());
		if (index_to_entity < 0) {
			throw new SdaiException(SdaiException.SY_ERR);
		}
		int ln = mod.lengths[index_to_entity];
		System.arraycopy(mod.instances_sim[index_to_entity], 1, mod.instances_sim[index_to_entity], 0, ln-1);
		mod.instances_sim[index_to_entity][ln-1] = zero_inst;
		zero_inst = null;
	}


/**
	Creates a schema instance for each instance of the entity 'file_population'
	encountered in the exchange structure.
*/
	final private void create_schema_instances() throws SdaiException {
		int j;
		for (int i = 0; i < populations_count; i++) {
			FILE_POPULATION file_pop = populations[i];
			SdaiModel dict_model = SdaiSession.systemRepository.get_schema_model(file_pop);
			if (dict_model.getMode() == SdaiModel.NO_ACCESS) {
				dict_model.startReadOnlyAccess();
			}
			String sch_inst_name;
			if (file_pop.name != null) {
				sch_inst_name = file_pop.name;
			} else {
				int sch_count = file_repo.schema_count + 1;
				sch_inst_name = "schema" + sch_count;
			}
			file_pop.final_name = sch_inst_name;
//System.out.println("  PhFileReader   file_repo: " + file_repo.name +
//"  sch_inst_name: " + sch_inst_name +
//"   dict_model: " + dict_model.name);
			SchemaInstance sch_inst = file_repo.createSchemaInstance(sch_inst_name,
				dict_model.described_schema);
			sch_inst.created = true;
			if (file_pop.governed_sections == null) {
				for (j = 0; j < file_repo.models.myLength; j++) {
					SdaiModel mod = (SdaiModel)file_repo.models.myData[j];
					sch_inst.addSdaiModel(mod);
					if (mod.modified_outside_contents) {
						mod.modified_outside_contents_by_import = true;
						mod.modified_outside_contents = false;
					}
				}
			} else {

				Object [] myDataA = null;
				if (file_pop.governed_sections.myLength > 1) {
					myDataA = (Object [])file_pop.governed_sections.myData;
				}
				for (j = 0; j < file_pop.governed_sections.myLength; j++) {
					String section_name;
					if (file_pop.governed_sections.myLength == 1) {
						section_name = (String)file_pop.governed_sections.myData;
					} else {
						section_name = (String)myDataA[j];
					}
					file_repo.internal_usage = true;
					SdaiModel mod = file_repo.findSdaiModel(section_name);
					file_repo.internal_usage = false;
					if (mod != null) {
						sch_inst.addSdaiModel(mod);
						if (mod.modified_outside_contents) {
							mod.modified_outside_contents_by_import = true;
							mod.modified_outside_contents = false;
						}
					} else {
						printWarningToLogo(active_session, AdditionalMessages.RD_WSPO, section_name);
					}
				}
			}
			if (file_pop.change_date != null) {
				sch_inst.change_date = file_repo.session.cal.timeStampToLong(file_pop.change_date);
			} else {
				sch_inst.change_date = -1;
			}
			if (file_pop.validation_date != null) {
				sch_inst.validation_date = file_repo.session.cal.timeStampToLong(file_pop.validation_date);
			} else {
				sch_inst.validation_date = -1;
			}
			if (file_pop.validation_result >= 0) {
				sch_inst.validation_result = file_pop.validation_result;
			}
			sch_inst.validation_level = file_pop.validation_level;
			sch_inst.description = file_pop.description;
			sch_inst.author = file_pop.author;
			sch_inst.organization = file_pop.organization;
			sch_inst.preprocessor_version = file_pop.preprocessor_version;
			sch_inst.originating_system = file_pop.originating_system;
			sch_inst.authorization = file_pop.authorization;
			sch_inst.language = file_pop.language;
			sch_inst.context_identifiers = file_pop.context_identifiers;
			sch_inst.modified_by_import = sch_inst.modified;
			sch_inst.modified = false;
		}
	}


	final private void include_schema_instances(SdaiSession session) throws SdaiException {
		SchemaInstance own_sch_inst;
		for (int i = 0; i < populations_count; i++) {
			FILE_POPULATION file_pop = populations[i];
			if (file_pop.included_schema_instances == null) {
				continue;
			}
			String sch_inst_name;
			own_sch_inst = null;
			A_string aggr = file_pop.included_schema_instances;
			for (int j = 1; j <= aggr.myLength; j++) {
				sch_inst_name = aggr.getByIndex(j);
				SchemaInstance sch_inst = file_repo.findSchemaInstance(sch_inst_name);
				if (sch_inst == null) {
					printWarningToLogoSchiInst(session, AdditionalMessages.RD_UNSI, file_pop.final_name, sch_inst_name);
					continue;
				}
				if (own_sch_inst == null) {
					own_sch_inst = file_repo.findSchemaInstance(file_pop.final_name);
					own_sch_inst.included_schemas = new ASchemaInstance(SdaiSession.setType0toN, own_sch_inst);
				}
				own_sch_inst.included_schemas.addUnorderedRO(sch_inst);
			}
		}
	}


/**
	Reads the header of the exchange structure. According to ISO 10303-21,
	first of all, instances of the entities <code>file_description</code>,
	<code>file_name</code> and <code>file_schema</code> are processed.
	Then, instances of the entities <code>section_language</code>,
	<code>section_context</code> and <code>file_population</code> in any order
	are read. Finally, user defined header instances (if any) are considered.
*/
	final private void header_section(SdaiSession session, String source_location,
			Object destination_location) throws SdaiException, java.io.IOException {
		String entity_in_header;
		boolean [] defaults = {false, false};
		consume_token(HEADER);
		consume_token(SEMICOLON);
		expect_entity = "FILE_DESCRIPTION";
		header_entity(null, defaults, session, source_location, destination_location);
		expect_entity = "FILE_NAME";
		header_entity(null, defaults, session, source_location, destination_location);
		scan.get_token(token);
		if (token.type == ERROR) {
			scanning_exception(token, -1, null);
		}
		boolean found_FILE_SCHEMA = false;
		if (token.type != ENDSEC) {
			entity_in_header = new String(token.string, 0, token.length);
			if (entity_in_header.equals("FILE_SCHEMA")) {
				found_FILE_SCHEMA = true;
				expect_entity = "FILE_SCHEMA";
				header_entity(entity_in_header, defaults, session, source_location, destination_location);
			}
		}
		if (found_FILE_SCHEMA) {
			scan.get_token(token);
			if (token.type == ERROR) {
				scanning_exception(token, -1, null);
			}
		} else {
			file_repo.file_schema = new FILE_SCHEMA(file_repo);
			printWarningToLogo(session, phys_file);
		}
		populations_count = 0;
		if (token.type != ENDSEC) {
			entity_in_header = new String(token.string, 0, token.length);
			while (entity_in_header.equals("SECTION_LANGUAGE") ||
						entity_in_header.equals("SECTION_CONTEXT") ||
						entity_in_header.equals("FILE_POPULATION")) {
				expect_entity = entity_in_header;
				header_entity(entity_in_header, defaults, session, source_location, destination_location);
				scan.get_token(token);
				if (token.type == ERROR) {
					scanning_exception(token, -1, null);
				}
				entity_in_header = new String(token.string, 0, token.length);
			}
			expect_entity = " ";
			file_repo.user_defined_instances_count = 0;
			while (token.type == USER_DEFINED_KEYWORD) {
				opt_header_entity(file_repo);
				scan.get_token(token);
				if (token.type == ERROR) {
					scanning_exception(token, -1, null);
				}
			}
		}
		if (token.type != ENDSEC) {
			parsing_exception(token, WRONG_TOKEN, AdditionalMessages.RD_TOKE, token_image[ENDSEC]);
		}
		consume_token(SEMICOLON);
	}


/**
	Reads an encoding of a user defined header instance from the exchange
	structure. The instance created is put into the array
	<code>user_defined_instances</code> of the repository to which the
	exchange structure is imported.
*/
	final private void opt_header_entity(SdaiRepository repo)
			throws SdaiException, java.io.IOException {
		expect_entity = "user_defined";
		$HEADER_USER_DEFINED_ENTITY user_entity_in_header = new $HEADER_USER_DEFINED_ENTITY();
		user_entity_in_header.name = new String(token.string, 0, token.length);
		consume_token(LPAREN);
		if (entity_values.entityValues[0] == null) {
			entity_values.entityValues[0] = new EntityValue(active_session);
		}
		parameters(entity_values.entityValues[0]);
		if (token.type != RPAREN) {
			parsing_exception(token, WRONG_TOKEN, AdditionalMessages.RD_TOKE, token_image[RPAREN]);
		}
		consume_token(SEMICOLON);

		int res = user_entity_in_header.write(entity_values.entityValues[0]);
		if (res > 0) {
			parsing_exception(token, res, null, null);
		}
		if (repo.user_defined_instances == null) {
			repo.user_defined_instances =
				new $HEADER_USER_DEFINED_ENTITY[repo.USER_DEFINED_INSTANCES_ARRAY_SIZE];
		} else if (repo.user_defined_instances_count >= repo.user_defined_instances.length) {
			int new_length = repo.user_defined_instances.length * 2;
			$HEADER_USER_DEFINED_ENTITY [] new_array = new $HEADER_USER_DEFINED_ENTITY[new_length];
			System.arraycopy(repo.user_defined_instances, 0, new_array, 0, repo.user_defined_instances.length);
			repo.user_defined_instances = new_array;
		}
		repo.user_defined_instances[repo.user_defined_instances_count++] = user_entity_in_header;
	}


/**
	Reads an encoding of a header instance different than user defined from
	the exchange structure. The extracted data are written into the
	repository to which the exchange structure is imported.
*/
	final private void header_entity(String ent, boolean [] defaults, SdaiSession session,
			String source_location, Object destination_location)
			throws SdaiException, java.io.IOException {
		String entity_in_header;
		String str;
		int i;
		int new_length;

//		populations_count = 0;
		if (entity_values.entityValues[0] == null) {
			entity_values.entityValues[0] = new EntityValue(session);
		}
		if (ent != null) {
			entity_in_header = ent;
		} else {
			consume_token(ENTITY_NAME);
			entity_in_header = new String(token.string, 0, token.length);
		}
		consume_token(LPAREN);
		if (expect_entity.equals("FILE_POPULATION")) {
			file_pop = new FILE_POPULATION(file_repo);
			scan.file_population_comments = true;
		}
		parameters(entity_values.entityValues[0]);
		if (expect_entity.equals("FILE_POPULATION")) {
			scan.file_population_comments = false;
		}
		if (token.type != RPAREN) {
			parsing_exception(token, WRONG_TOKEN, AdditionalMessages.RD_TOKE, token_image[RPAREN]);
		}
		consume_token(SEMICOLON);

		if (ent == null && expect_entity != " " &&	!expect_entity.equals(entity_in_header) ) {
			parsing_exception(token, UNEXPECTED_ENTITY, AdditionalMessages.RD_ENTE, expect_entity);
		}

		int integ;
		if ( expect_entity.equals("FILE_DESCRIPTION") ) {
			file_description = new FILE_DESCRIPTION(null);
			integ = file_description.write(entity_values.entityValues[0]);
			if (integ > 0) {
				parsing_exception(token, integ, null, null);
			}
			if (PRINT_IN_PARSER > 0) {
				file_description.print();
			}
		} else if ( expect_entity.equals("FILE_NAME") ) {
			FILE_NAME file_name = new FILE_NAME(null);
			integ = file_name.write(entity_values.entityValues[0]);
			if (integ > 0) {
				parsing_exception(token, integ, null, null);
			}
			if (PRINT_IN_PARSER > 0) {
				file_name.print();
			}
			if (repo_name == null) {
				repo_name = file_name.repository_name;
			}
			String newRepositoryFormat = session.props.getProperty("new.repository.format", "DIR");
			String loc = "SdaiRepository/";
			if (destination_location instanceof String) {
				loc = (String)destination_location;
			}

			int current = -1;
			if ((loc == null && newRepositoryFormat.equalsIgnoreCase("SDAI")) || (loc != null && (!loc.endsWith(SdaiSession.DIRECTORY_SUFFIX) && !loc.endsWith(File.separator)))) {
				// Deriving repository name from location
				if (repo_name == null || repo_name.length() == 0) {
					if (loc != null) {
						int lastIndex = loc.lastIndexOf(File.separatorChar);
						if (lastIndex > -1) {
							repo_name = loc.substring(lastIndex + 1);
						}
						else {
							repo_name = loc;
						}

						lastIndex = repo_name.lastIndexOf('.');
						if (lastIndex > 0) {
							repo_name = repo_name.substring(0, lastIndex);
						}
					}
				}
				if (loc == null) {
					loc = repo_name+SdaiSession.SDAI_FILE_EXTENSION;
				}
				// Adding repos_path to the start of location if file name without path is specified
				if (loc.lastIndexOf(File.separator) < 0) {
					loc = session.repos_path + File.separator + loc;
				}
				// Adding sequence numbers for repeating repository names
				boolean bFreeNameFound = false;
				boolean bNameExists;
				String current_name;
				while (!bFreeNameFound) {
					current++;

					if (current > 0) {
						current_name = repo_name + "_" +String.valueOf(current);
					}
					else {
						current_name = repo_name;
					}
					bNameExists = false;
					for (i = 0; i < session.known_servers.myLength; i++) {
						SdaiRepository existingRepository = (SdaiRepository)session.known_servers.myData[i];
						String existingLocation = (String)existingRepository.location;
						if (current == 0 && loc.equals(existingLocation)) {
							throw new SdaiException(SdaiException.RP_DUP, existingRepository, AdditionalMessages.AX_NAME + repo_name + " location: " + loc);
						}
						if (existingRepository.name.equals(current_name)) {
							bNameExists = true;
							break;
						}
					}
					if (!bNameExists) {
						bFreeNameFound = true;
						repo_name = current_name;
					}
				}
				destination_location = loc;
			}
			file_repo = get_repository(session, repo_name, source_location, destination_location);
			file_name.author.owner = file_repo;
			file_name.organization.owner = file_repo;
			file_repo.file_name = file_name;
			file_description.description.owner = file_repo;
			file_repo.description = file_description.description;
			file_repo.implementation_level = file_description.implementation_level;
			file_repo.languages_count = 0;
			file_repo.contexts_count = 0;
			if ((loc == null && newRepositoryFormat.equalsIgnoreCase("SDAI")) || (loc != null && (!loc.endsWith(SdaiSession.DIRECTORY_SUFFIX) && !loc.endsWith(File.separator)))) {
				if (current > 0) {
					((SdaiRepositoryZipImpl)file_repo).nameWithRecurrenceNumber = true;
				}
			}
		} else if ( expect_entity.equals("FILE_SCHEMA") ) {
			FILE_SCHEMA file_schema = new FILE_SCHEMA(file_repo);
			integ = file_schema.write(entity_values.entityValues[0]);
			if (integ > 0) {
				parsing_exception(token, integ, null, null);
			}
			if (PRINT_IN_PARSER > 0) {
				file_schema.print();
			}
			file_repo.file_schema = file_schema;
		} else if ( expect_entity.equals("SECTION_LANGUAGE") ) {
			if (defaults[0] == false || entity_values.entityValues[0].values[0].tag != MISSING) {
				if (entity_values.entityValues[0].values[0].tag == MISSING) {
					defaults[0] = true;
				}
				SECTION_LANGUAGE sect_language = new SECTION_LANGUAGE();
				integ = sect_language.write(entity_values.entityValues[0]);
				if (integ > 0) {
					parsing_exception(token, integ, null, null);
				}
				if (PRINT_IN_PARSER > 0) {
					sect_language.print();
				}
				if (file_repo.languages == null) {
					file_repo.languages = new SECTION_LANGUAGE[file_repo.LANGUAGES_ARRAY_SIZE];
				} else if (file_repo.languages_count >= file_repo.languages.length) {
					file_repo.enlarge_languages();
				}
				file_repo.languages[file_repo.languages_count++] = sect_language;
			}
		} else if ( expect_entity.equals("SECTION_CONTEXT") ) {
			if (defaults[1] == false || entity_values.entityValues[0].values[1].tag != MISSING) {
				if (entity_values.entityValues[0].values[1].tag == MISSING) {
					defaults[1] = true;
				}
				SECTION_CONTEXT sect_context = new SECTION_CONTEXT(file_repo);
				integ = sect_context.write(entity_values.entityValues[0]);
				if (integ > 0) {
					parsing_exception(token, integ, null, null);
				}
				if (PRINT_IN_PARSER > 0) {
					sect_context.print();
				}
				if (file_repo.contexts == null) {
					file_repo.contexts = new SECTION_CONTEXT[file_repo.CONTEXTS_ARRAY_SIZE];
				} else if (file_repo.contexts_count >= file_repo.contexts.length) {
					file_repo.enlarge_contexts();
				}
				file_repo.contexts[file_repo.contexts_count++] = sect_context;
			}
		} else if ( expect_entity.equals("FILE_POPULATION") ) {
			integ = file_pop.write(entity_values.entityValues[0]);
			if (integ > 0) {
				parsing_exception(token, integ, null, null);
			}
			if (PRINT_IN_PARSER > 0) {
				file_pop.print();
			}
			if (populations == null) {
				populations = new FILE_POPULATION[POPULATIONS_ARRAY_SIZE];
			} else if (populations_count >= populations.length) {
				new_length = populations.length * 2;
				FILE_POPULATION [] new_array = new FILE_POPULATION[new_length];
				System.arraycopy(populations, 0, new_array, 0, populations.length);
				populations = new_array;
			}
			populations[populations_count++] = file_pop;
		}

	}


/**
	Returns a repository for a given name to which the exchange structure will
	be imported. The repository is that already existing (of course, in the virtual
	mode) or a new one created within this method.
*/
	final private SdaiRepository get_repository(SdaiSession session, String name,
			String source_location, Object destination_location) throws SdaiException {
		if(destination_location instanceof SdaiRepository) {
			return (SdaiRepository)destination_location;
		}
		SdaiRepository repository = null;
		for (int i = 0; i < session.known_servers.myLength; i++) {
			SdaiRepository rep = (SdaiRepository)session.known_servers.myData[i];
			if (rep.name.equals(name)) {
				repository = rep;
				break;
			}
		}
		if (repository != null) {
			if (repository.virtual) {
				repository.promoteVirtualToOrdinary(destination_location, true);
			} else {
				throw new SdaiException(SdaiException.RP_DUP, repository,
					AdditionalMessages.AX_NAME + name);
			}
		} else {
			String loc = destination_location instanceof String ? (String)destination_location : null;
			if ((loc != null && (!loc.endsWith(SdaiSession.DIRECTORY_SUFFIX) && !loc.endsWith(File.separator)))) {
				repository = new SdaiRepositoryZipImpl(session, name, loc, false);
			}
			else {
				repository = session.createSdaiRepositoryImpl(name, loc, false);
			}
		}
		repository.active = true;
		repository.created_or_imported = true;
		repository.physical_file_name = source_location != null ? source_location : name;
		return repository;
	}


/**
	Reads parameters of the encoding of an instance of one of the following types:
	 - header entity instance (within <code>header_entity</code> method);
	 - header user-defined entity instance (within <code>opt_header_entity</code> method);
	 - user-defined entity instance (within <code>entity_instance_RHS</code> method);
	 - entity instance in external mapping mode (within <code>entity_instance_RHS</code> method).
	This method is also used to read data section parameters (such parameters exist
	if the exchange structure contains more than one data section).
*/
	private final void parameters(EntityValue pval)
			throws SdaiException, java.io.IOException {
		int index = -1;
		StaticFields staticFields;
		scan.get_token(token);
		if (token.type == ERROR) {
			staticFields = StaticFields.get();
			scanning_exception(token, staticFields.current_instance_identifier, null);
		} else if (token.type == COMMENT) {
			go_through_comments(token);
		}
		if (token.type == LPAREN || token.type == ENTITY_NAME ||
			 (8 <= token.type && token.type <= 12) || (20 <= token.type && token.type <= 25) ) {
			index++;
			if (pval.values == null) {
				pval.values = new Value[SdaiSession.NUMBER_OF_VALUES];
			} else if (index >= pval.values.length) {
				pval.enlarge(index + 1);
			}
			if (pval.values[index] == null) {
				pval.values[index] = new Value();
			}
			if (data_section_processing) {
				aggr_violation = false;
				pval.values[index].types_count = 0;
				parameter(pval.values[index]);
				if (aggr_violation) {
					pval.values[index].types_count = 1;
					inst_values_violation = true;
				}
			} else {
				parameter_in_header(pval.values[index]);
			}
			scan.get_token(token);
			if (token.type == ERROR) {
				staticFields = StaticFields.get();
				scanning_exception(token, staticFields.current_instance_identifier, null);
			} else if (token.type == COMMENT) {
				go_through_comments(token);
			}

			int warn_count = 0;
			while (token.type != RPAREN) {
				while (token.type == COMMA) {
					scan.get_token(token);
					if (token.type == ERROR) {
						staticFields = StaticFields.get();
						scanning_exception(token, staticFields.current_instance_identifier, null);
					} else if (token.type == COMMENT) {
						go_through_comments(token);
					}
					index++;
					if (index >= pval.values.length) {
						pval.enlarge(index + 1);
					}
					if (pval.values[index] == null) {
						pval.values[index] = new Value();
					}
					if (data_section_processing) {
						aggr_violation = false;
						pval.values[index].types_count = 0;
						parameter(pval.values[index]);
						if (aggr_violation) {
							pval.values[index].types_count = 1;
							inst_values_violation = true;
						}
					} else {
						parameter_in_header(pval.values[index]);
					}
					scan.get_token(token);
					if (token.type == ERROR) {
						staticFields = StaticFields.get();
						scanning_exception(token, staticFields.current_instance_identifier, new String(token.string));
					} else if (token.type == COMMENT) {
						go_through_comments(token);
					}
				}
				if (token.type == RPAREN || warn_count >= BOUND_ON_WARNINGS_COUNT) {
					break;
				}
				parsing_warning(active_session, token, WRONG_TOKEN, AdditionalMessages.RD_TOKE, token_image[RPAREN]);
				warn_count++;
				while (token.type != COMMA && token.type != RPAREN) {
					scan.get_token(token);
					if (token.type == ERROR) {
						staticFields = StaticFields.get();
						parsing_exception(token, AdditionalMessages.RD_CORP, AdditionalMessages.RD_INST,
							Long.toString(staticFields.current_instance_identifier));
					} else if (token.type == COMMENT) {
						go_through_comments(token);
					}
					if (token.type != COMMA && token.type != RPAREN) {
						if (warn_count >= BOUND_ON_WARNINGS_COUNT) {
							break;
						}
						parsing_warning(active_session, token, WRONG_TOKEN, AdditionalMessages.RD_TOKE, token_image[RPAREN]);
						warn_count++;
					}
				}
				if (token.type != COMMA && warn_count >= BOUND_ON_WARNINGS_COUNT) {
					break;
				}
			}

		}
		pval.count = index+1;
	}


/**
	Reads the comments within an encoding of <code>file_population</code>
	instances. In this specific case these comments bear some useful information.
*/
	private final void go_through_comments(Token token)
			throws SdaiException, java.io.IOException {
		while (token.type == COMMENT) {
			process_comment_file_population(token);
			scan.get_token(token);
			if (token.type == ERROR) {
				StaticFields staticFields = StaticFields.get();
				scanning_exception(token, staticFields.current_instance_identifier, null);
			}
		}
	}


/**
	Processes a comment encountered within an encoding of a <code>file_population</code>
	instance.
*/
	private final void process_comment_file_population(Token token) throws SdaiException {
		int i;
		int first_ind = -1, last_ind = -1;
		String com = new String(token.string, 0, token.length);
		int last_comma = com.lastIndexOf(COMMA_b);
		if (last_comma < 0) {
			return;
		}
		for (i = last_comma + 1; i < token.length; i++) {
			if (token.string[i] != SPACE) {
				first_ind = i;
				break;
			}
		}
		if (first_ind < 0) {
			printCommentError(AdditionalMessages.RD_WCPO, com);
			return;
		}
		for (i = token.length - 1; i > last_comma; i--) {
			if (token.string[i] != SPACE) {
				last_ind = i;
				break;
			}
		}
		if (last_ind < 0 || last_ind < first_ind) {
			printCommentError(AdditionalMessages.RD_WCPO, com);
			return;
		}
		String key = com.substring(first_ind, last_ind + 1);
		if (key.equals(SCH_INST_HIDDEN_FIELDS[0])) {					//		"name"
			file_pop.name = process_string(token, com, 0, last_comma);
		} else if (key.equals(SCH_INST_HIDDEN_FIELDS[1])) {		//		"change_date"
			file_pop.change_date = process_string(token, com, 0, last_comma);
		} else if (key.equals(SCH_INST_HIDDEN_FIELDS[2])) {		//		"validation_date"
			file_pop.validation_date = process_string(token, com, 0, last_comma);
		} else if (key.equals(SCH_INST_HIDDEN_FIELDS[3])) {		//		"validation_result"
			file_pop.validation_result = process_logical(token, com, last_comma);
		} else if (key.equals(SCH_INST_HIDDEN_FIELDS[4])) {		//		"validation_level"
			file_pop.validation_level = process_digit(token, com, last_comma);
		} else if (key.equals(SCH_INST_HIDDEN_FIELDS[5])) {		//		"description"
			file_pop.description = new A_string(SdaiSession.listTypeSpecial, file_repo);
			process_aggregate(token, com, last_comma, file_pop.description);
		} else if (key.equals(SCH_INST_HIDDEN_FIELDS[6])) {		//		"author"
			file_pop.author = new A_string(SdaiSession.listTypeSpecial, file_repo);
			process_aggregate(token, com, last_comma, file_pop.author);
		} else if (key.equals(SCH_INST_HIDDEN_FIELDS[7])) {		//		"organization"
			file_pop.organization = new A_string(SdaiSession.listTypeSpecial, file_repo);
			process_aggregate(token, com, last_comma, file_pop.organization);
		} else if (key.equals(SCH_INST_HIDDEN_FIELDS[8])) {		//		"preprocessor_version"
			file_pop.preprocessor_version = process_string(token, com, 0, last_comma);
		} else if (key.equals(SCH_INST_HIDDEN_FIELDS[9])) {		//		"originating_system"
			file_pop.originating_system = process_string(token, com, 0, last_comma);
		} else if (key.equals(SCH_INST_HIDDEN_FIELDS[10])) {		//		"authorization"
			file_pop.authorization = process_string(token, com, 0, last_comma);
		} else if (key.equals(SCH_INST_HIDDEN_FIELDS[11])) {		//		"language"
			file_pop.language = process_string(token, com, 0, last_comma);
		} else if (key.equals(SCH_INST_HIDDEN_FIELDS[12])) {		//		"context_identifiers"
			file_pop.context_identifiers = new A_string(SdaiSession.listTypeSpecial, file_repo);
			process_aggregate(token, com, last_comma, file_pop.context_identifiers);
		} else if (key.equals(SCH_INST_HIDDEN_FIELDS[13])) {		//		"included_schema_instances"
			file_pop.included_schema_instances = new A_string(SdaiSession.listTypeSpecial, file_repo);
			process_aggregate(token, com, last_comma, file_pop.included_schema_instances);
		}
	}


/**
	Prints a warning message related to processing of comments within
	<code>file_population</code> instances to log file.
*/
	private final void printCommentError(String message, String com) throws SdaiException {
		String str;
		if (file_pop.name != null) {
			str = file_pop.name;
		} else {
			str = "";
		}
		printWarningToLogo(active_session, message, str, com);
	}


/**
	Extracts the string from the comment encountered within an encoding of a
	<code>file_population</code> instance.
*/
	private final String process_string(Token token, String com, int st_ind, int c_ind) throws SdaiException {
		int i;
		int first_ind = -1, last_ind = -1;
		for (i = st_ind; i < c_ind; i++) {
			if (token.string[i] == APOSTROPHE) {
				first_ind = i + 1;
				break;
			}
		}
		if (first_ind < 0) {
			printCommentError(AdditionalMessages.RD_WCPO, com);
			return null;
		}
		for (i = c_ind - 1; i > st_ind; i--) {
			if (token.string[i] == APOSTROPHE) {
				last_ind = i;
				break;
			}
		}
		if (last_ind < 0 || last_ind < first_ind) {
			printCommentError(AdditionalMessages.RD_WCPO, com);
			return null;
		} else if (last_ind == first_ind) {
			return "";
		}
		return com.substring(first_ind, last_ind);
	}


/**
	Extracts the logical value from the comment encountered within an encoding of a
	<code>file_population</code> instance.
*/
	private final int process_logical(Token token, String com, int c_ind) throws SdaiException {
		int ind = -1;
		for (int i = 0; i < c_ind; i++) {
			if (token.string[i] == DOT) {
				ind = i + 1;
				break;
			}
		}
		if (ind < 0) {
			printCommentError(AdditionalMessages.RD_WLFP, com);
			return 0;
		}
		if (token.string[ind] == 'F') {
			return 1;
		} else if (token.string[ind] == 'T') {
			return 2;
		} else if (token.string[ind] == 'U') {
			return 3;
		} else {
			printCommentError(AdditionalMessages.RD_WLFP, com);
			return 0;
		}
	}


/**
	Extracts the digit from the comment encountered within an encoding of a
	<code>file_population</code> instance.
*/
	private final int process_digit(Token token, String com, int c_ind) throws SdaiException {
		int ind = -1;
		for (int i = 0; i < c_ind; i++) {
			if (token.string[i] != SPACE) {
				ind = i;
				break;
			}
		}
		if (ind < 0) {
			printCommentError(AdditionalMessages.RD_WDFP, com);
			return 0;
		}
		if (token.string[ind + 1] != SPACE || token.string[ind + 1] != COMMA_b) {
// print warning
		}
		int dig = (int)token.string[ind] - (int)'0';
		if (dig < 0 || dig > 4) {
			printCommentError(AdditionalMessages.RD_WDFP, com);
			return 0;
		}
		return dig;
	}


/**
	Processes the aggregate in the comment encountered within an encoding of a
	<code>file_population</code> instance.
*/
	private final void process_aggregate(Token token, String com, int c_ind, A_string aggr)
			throws SdaiException {
		int ind;
		int start_ind = -1;
		int end_ind;
		int count = 0;
		String str;
		for (int i = 0; i < c_ind; i++) {
			if (token.string[i] == LEFT_PARENTHESIS) {
				start_ind = i;
				break;
			}
		}
		if (start_ind < 0) {
			printCommentError(AdditionalMessages.RD_WAFP, com);
			return;
		}
		start_ind++;
		ind = start_ind;
		while (token.string[ind] != RIGHT_PARENTHESIS) {
			int ap_count = 0;
			while ((token.string[ind] != COMMA_b || ap_count < 2) && token.string[ind] != RIGHT_PARENTHESIS) {
				if (token.string[ind] == APOSTROPHE) ap_count++;
				ind++;
				if (ind >= c_ind) {
					printCommentError(AdditionalMessages.RD_WAFP, com);
					break;
				}
			}
			if (ind >= c_ind) {
				printCommentError(AdditionalMessages.RD_WAFP, com);
				break;
			}
			end_ind = ind;
			if (start_ind + 3 <= end_ind) {
				str = process_string(token, com, start_ind, end_ind);
				if (str == null) {
					printCommentError(AdditionalMessages.RD_WAFP, com);
				} else {
					aggr.addByIndexPrivate(count + 1, str);
					count++;
				}
			} else {
//				printCommentError(AdditionalMessages.RD_WAFP, com);
			}
			start_ind = end_ind + 1;
			if (token.string[ind] == COMMA_b) {
				ind++;
			}
		}
//System.out.println(" 00000 PhFileReader   aggr.myLength: " + aggr.myLength);
	}


/**
	Reads parameters of the encoding of an instance in internal mapping mode
	(within <code>entity_instance_RHS</code> method).
*/
	private final void parameters(CEntity_definition def, long instance_identifier)
			throws SdaiException, java.io.IOException {
		int count_of_values;
		int count_of_attributes, count_of_partial_values = -1;
		int index_to_partial_types;
		int index, count;
		CEntity_definition partial_def;
		EntityValue partial_entity_values = null;

		StaticFields staticFields;
		scan.get_token(token);
		if (token.type == ERROR) {
			staticFields = StaticFields.get();
			scanning_exception(token, staticFields.current_instance_identifier, null);
		}
		if (token.type == LPAREN || token.type == ENTITY_NAME ||
			 (8 <= token.type && token.type <= 12) || (20 <= token.type && token.type <= 25) ) {
			boolean too_many = false;
			index_to_partial_types = 0;
			index = def.externalMappingIndexing[0];
			partial_def = def.partialEntityTypes[index];
if (SdaiSession.debug2) System.out.println(" index1 = " + index + "   name = " + partial_def.getCorrectName());
			count_of_values = 1;
			count = partial_def.noOfPartialAttributes;
if (SdaiSession.debug2) System.out.println("def: " + def.getCorrectName() + "   ext_map_length: " + def.externalMappingIndexing.length);
if (SdaiSession.debug2) System.out.println("partial_def: " + partial_def.getCorrectName()
+ "   ident: #" + partial_def.instance_identifier);
			entity_values.entityValues[index].count = count;
if (SdaiSession.debug2) System.out.println("partial values index = " + index + "    count_of_attributes = " + count);
			count_of_attributes = count;
if (SdaiSession.debug2) System.out.println("count_of_attributes = " + count_of_attributes);
if (SdaiSession.debug2) System.out.println("count_of_values = " + count_of_values);
if (SdaiSession.debug2) System.out.println("def.externalMappingIndexing.length = " + def.externalMappingIndexing.length);
			while (count_of_values > count_of_attributes) {
				index_to_partial_types++;
				if (index_to_partial_types >= def.externalMappingIndexing.length) {
					too_many = true;
					EntityValue.printWarningToLogo(active_session, AdditionalMessages.RD_DFEX, instance_identifier);
					break;
				}
				index = def.externalMappingIndexing[index_to_partial_types];
				partial_def = def.partialEntityTypes[index];
if (SdaiSession.debug2) System.out.println("partial_def 2 : " + partial_def.getCorrectName());
if (SdaiSession.debug2) System.out.println(" index2 = " + index + "   name = " + partial_def.getCorrectName());
				count = partial_def.noOfPartialAttributes;
				entity_values.entityValues[index].count = count;
if (SdaiSession.debug2) System.out.println("partial values index 2 = " + index + "    count_of_attributes = " + count);
				count_of_attributes += count;
			}
			if (!too_many) {
				partial_entity_values = entity_values.entityValues[index];
				if (partial_entity_values.values == null) {
					if (SdaiSession.NUMBER_OF_VALUES >=count) {
						partial_entity_values.values = new Value[SdaiSession.NUMBER_OF_VALUES];
					} else {
						partial_entity_values.values = new Value[count];
					}
				} else if (partial_entity_values.values.length < count) {
					partial_entity_values.enlarge(count);
				}
				partial_entity_values.def = partial_def;
				count_of_partial_values = 0;
				if (partial_entity_values.values[0] == null) {
					partial_entity_values.values[0] = new Value();
				}
				aggr_violation = false;
				parameter(partial_entity_values.values[0]);
				if (aggr_violation) {
					partial_entity_values.values[0].check_aggregate(
						((CEntityDefinition)def).attributes[0], instance_identifier, 
						take_entity_name_for_exception(), active_session);
				}
			} else if (token.type == ENTITY_NAME || token.type == LPAREN) {
				parameter(null);
			}
			scan.get_token(token);
			if (token.type == ERROR) {
				staticFields = StaticFields.get();
				scanning_exception(token, staticFields.current_instance_identifier, null);
			}

			int warn_count = 0;
			while (token.type != RPAREN) {
				while (token.type == COMMA) {
					scan.get_token(token);
					if (token.type == ERROR) {
						staticFields = StaticFields.get();
						scanning_exception(token, staticFields.current_instance_identifier, null);
					}
					count_of_values++;
					if (count_of_values > count_of_attributes && !too_many) {
						while (count_of_values > count_of_attributes) {
							index_to_partial_types++;
							if (index_to_partial_types >= def.externalMappingIndexing.length) {
								too_many = true;
								break;
							}
							index = def.externalMappingIndexing[index_to_partial_types];
							partial_def = def.partialEntityTypes[index];
							count = partial_def.noOfPartialAttributes;
if (SdaiSession.debug2) System.out.println(" count_of_values = " + count_of_values);
if (SdaiSession.debug2) System.out.println(" count_of_attributes = " + count_of_attributes);
if (SdaiSession.debug2) System.out.println(" index3 = " + index + "   name = " + partial_def.getCorrectName() + "    count = " + count);
if (SdaiSession.debug2) System.out.println("  entity_values.entityValues[1].count = " + entity_values.entityValues[1].count);
							entity_values.entityValues[index].count = count;
							count_of_attributes += count;
						}
						if (!too_many) {
							partial_entity_values = entity_values.entityValues[index];
							if (partial_entity_values.values == null) {
								if (SdaiSession.NUMBER_OF_VALUES >=count) {
									partial_entity_values.values = new Value[SdaiSession.NUMBER_OF_VALUES];
								} else {
									partial_entity_values.values = new Value[count];
								}
							} else if (partial_entity_values.values.length < count) {
								partial_entity_values.enlarge(count);
							}
							count_of_partial_values = -1;
							partial_entity_values.def = partial_def;
						}
					}
					if (!too_many) {
						count_of_partial_values++;
						if (partial_entity_values.values[count_of_partial_values] == null) {
							partial_entity_values.values[count_of_partial_values] = new Value();
						}
						aggr_violation = false;
						parameter(partial_entity_values.values[count_of_partial_values]);
						if (aggr_violation) {
							partial_entity_values.values[count_of_partial_values].check_aggregate(
								((CEntityDefinition)def).attributes[count_of_values - 1], instance_identifier, 
								take_entity_name_for_exception(), active_session);
						}
					} else if (token.type == ENTITY_NAME || token.type == LPAREN) {
						parameter(null);
					}
					scan.get_token(token);
					if (token.type == ERROR) {
						staticFields = StaticFields.get();
						scanning_exception(token, staticFields.current_instance_identifier, new String(token.string));
					}
				}
				if (token.type == RPAREN || warn_count >= BOUND_ON_WARNINGS_COUNT) {
					break;
				}
				parsing_warning(active_session, token, WRONG_TOKEN, AdditionalMessages.RD_TOKE, token_image[RPAREN]);
				warn_count++;
				while (token.type != COMMA && token.type != RPAREN) {
					scan.get_token(token);
					if (token.type == ERROR) {
						staticFields = StaticFields.get();
						parsing_exception(token, AdditionalMessages.RD_CORP, AdditionalMessages.RD_INST,
							Long.toString(staticFields.current_instance_identifier));
					}
					if (token.type != COMMA && token.type != RPAREN) {
						if (warn_count >= BOUND_ON_WARNINGS_COUNT) {
							break;
						}
						parsing_warning(active_session, token, WRONG_TOKEN, AdditionalMessages.RD_TOKE, token_image[RPAREN]);
						warn_count++;
					}
				}
				if (token.type != COMMA && warn_count >= BOUND_ON_WARNINGS_COUNT) {
					break;
				}
			}
			boolean too_less = false;
			if (count_of_partial_values < partial_entity_values.count - 1) {
				for (int j = count_of_partial_values + 1; j < partial_entity_values.count; j++) {
					if (partial_entity_values.values[j] == null) {
						partial_entity_values.values[j] = new Value();
					}
					partial_entity_values.values[j].tag = MISSING;
					too_less = true;
				}
			}
			if (index_to_partial_types < def.externalMappingIndexing.length - 1) {
				for (int i = index_to_partial_types + 1; i < def.externalMappingIndexing.length; i++) {
					index = def.externalMappingIndexing[i];
					partial_def = def.partialEntityTypes[index];
if (SdaiSession.debug2) System.out.println(" index4 = " + index + "   name = " + partial_def.getCorrectName());
					count = partial_def.noOfPartialAttributes;
					partial_entity_values = entity_values.entityValues[index];
					if (partial_entity_values.values == null) {
						if (SdaiSession.NUMBER_OF_VALUES >=count) {
							partial_entity_values.values = new Value[SdaiSession.NUMBER_OF_VALUES];
						} else {
							partial_entity_values.values = new Value[count];
						}
					} else if (partial_entity_values.values.length < count) {
						partial_entity_values.enlarge(count);
					}
					partial_entity_values.count = count;
					partial_entity_values.def = partial_def;
					for (int j = 0; j < count; j++) {
						if (partial_entity_values.values[j] == null) {
							partial_entity_values.values[j] = new Value();
						}
						partial_entity_values.values[j].tag = MISSING;
						too_less = true;
					}
				}
			}
			if (too_less) {
				EntityValue.printWarningToLogo(active_session, AdditionalMessages.RD_VLEA, instance_identifier);
			}
			if (too_many) {
				EntityValue.printWarningToLogo(active_session, AdditionalMessages.RD_VEXA, instance_identifier);
			}
		}
	}


/**
	Reads parameters of the encoding of an instance in internal mapping mode
	(within <code>entity_instance_RHS</code> method) in the case when by some
	reasons JSDAI failed to create an instance for the entity name found in
	the encoding (instances are created by <code>object</code> method in
	<code>Create_instance</code> class).
*/
	private final void parameters() throws SdaiException, java.io.IOException {
		StaticFields staticFields;
		int count_of_values = 0;
		if (entity_values.entityValues[0] == null) {
			entity_values.entityValues[0] = new EntityValue(active_session);
		}
		EntityValue partial_entity_values = entity_values.entityValues[0];
		scan.get_token(token);
		if (token.type == ERROR) {
			staticFields = StaticFields.get();
			scanning_exception(token, staticFields.current_instance_identifier, null);
		}
		if (token.type == LPAREN || token.type == ENTITY_NAME ||
			 (8 <= token.type && token.type <= 12) || (20 <= token.type && token.type <= 25) ) {
			if (partial_entity_values.values == null) {
				partial_entity_values.values = new Value[SdaiSession.NUMBER_OF_VALUES];
			}
			if (partial_entity_values.values[0] == null) {
				partial_entity_values.values[0] = new Value();
			}
			parameter(partial_entity_values.values[0]);
			count_of_values++;
			scan.get_token(token);
			if (token.type == ERROR) {
				staticFields = StaticFields.get();
				scanning_exception(token, staticFields.current_instance_identifier, null);
			}
			while (token.type == COMMA) {
				scan.get_token(token);
				if (token.type == ERROR) {
					staticFields = StaticFields.get();
					scanning_exception(token, staticFields.current_instance_identifier, null);
				}
				count_of_values++;
				if (partial_entity_values.values.length < count_of_values) {
					partial_entity_values.enlarge(count_of_values);
				}
				if (partial_entity_values.values[count_of_values - 1] == null) {
					partial_entity_values.values[count_of_values - 1] = new Value();
				}
				parameter(partial_entity_values.values[count_of_values - 1]);
				scan.get_token(token);
				if (token.type == ERROR) {
					staticFields = StaticFields.get();
					scanning_exception(token, staticFields.current_instance_identifier, new String(token.string));
				}
			}
		}
	}


/**
	Reads parameters representing elements of an aggregate in the encoding
	of an instance. Speaking differently, processes the text of the exchange
	structure enclosed between left parenthesis and right parenthesis on the
	right-hand side of the instance description. In the case of nested
	aggregates the method can be invoked recursively.
*/
	private final void embedded_list(Value value) throws SdaiException, java.io.IOException {
		StaticFields staticFields;
		int index_in_list = -1;
		scan.get_token(token);
		if (token.type == ERROR) {
			staticFields = StaticFields.get();
			scanning_exception(token, staticFields.current_instance_identifier, null);
		}
		if (value != null && value.nested_values == null) {
			value.nested_values = new Value[SdaiSession.NUMBER_OF_VALUES];
		}
		if (token.type == LPAREN || token.type == ENTITY_NAME ||
				(8 <= token.type && token.type <= 12) || (20 <= token.type && token.type <= 25) ) {
			if (token.type != REDEFINE) {
				if (value != null) {
					index_in_list++;
//					if (index_in_list >= value.nested_values.length) {
//						value.enlarge();
//					}
					if (value.nested_values[index_in_list] == null) {
						value.nested_values[index_in_list] = new Value();
					}
				}
				if (data_section_processing) {
					if (value != null) {
						parameter(value.nested_values[index_in_list]);
					} else if (token.type == ENTITY_NAME || token.type == LPAREN) {
						parameter(null);
					}
				} else {
					parameter_in_header(value.nested_values[index_in_list]);
				}
			}
			scan.get_token(token);
			if (token.type == ERROR) {
				staticFields = StaticFields.get();
				scanning_exception(token, staticFields.current_instance_identifier, null);
			}

			int warn_count = 0;
			while (token.type != RPAREN) {
				while (token.type == COMMA) {
					scan.get_token(token);
					if (token.type == ERROR) {
						staticFields = StaticFields.get();
						scanning_exception(token, staticFields.current_instance_identifier, null);
					}
					if (token.type != REDEFINE) {
						if (value != null) {
							index_in_list++;
							if (index_in_list >= value.nested_values.length) {
								value.enlarge();
							}
							if (value.nested_values[index_in_list] == null) {
								value.nested_values[index_in_list] = new Value();
							}
						}
						if (data_section_processing) {
							if (value != null) {
								parameter(value.nested_values[index_in_list]);
								if (index_in_list > 0) {
									boolean res = is_non_conforming(value.nested_values[index_in_list - 1], 
										value.nested_values[index_in_list]);
									if (res) {
										aggr_violation = true;
									}
								}
							} else if (token.type == ENTITY_NAME || token.type == LPAREN) {
								parameter(null);
							}
						} else {
							parameter_in_header(value.nested_values[index_in_list]);
						}
					}
					scan.get_token(token);
					if (token.type == ERROR) {
						staticFields = StaticFields.get();
						parsing_exception(token, AdditionalMessages.RD_CORP, AdditionalMessages.RD_INST,
							Long.toString(staticFields.current_instance_identifier));
					}
				}
				if (token.type == RPAREN || warn_count >= BOUND_ON_WARNINGS_COUNT) {
					break;
				}
				parsing_warning(active_session, token, WRONG_TOKEN, AdditionalMessages.RD_TOKE, token_image[RPAREN]);
				warn_count++;
				while (token.type != COMMA && token.type != RPAREN) {
					scan.get_token(token);
					if (token.type == ERROR) {
						staticFields = StaticFields.get();
						parsing_exception(token, AdditionalMessages.RD_CORP, AdditionalMessages.RD_INST,
							Long.toString(staticFields.current_instance_identifier));
					}
					if (token.type != COMMA && token.type != RPAREN) {
						if (warn_count >= BOUND_ON_WARNINGS_COUNT) {
							break;
						}
						parsing_warning(active_session, token, WRONG_TOKEN, AdditionalMessages.RD_TOKE, token_image[RPAREN]);
						warn_count++;
					}
				}
				if (token.type != COMMA && warn_count >= BOUND_ON_WARNINGS_COUNT) {
					break;
				}
			}

		}
		if (value != null) {
			value.integer = index_in_list+1;
			value.length = index_in_list+1;
		}
	}


	private final boolean is_non_conforming(Value value_prev, Value value_next) throws SdaiException, java.io.IOException {
		switch (value_prev.tag) {
			case INTEGER:
			case REAL:
				if (value_next.tag == INTEGER || value_next.tag == REAL) {
					return false;
				}
				return true;
			case LOGICAL:
			case ENUM:
			case STRING:
			case BINARY:
				if (value_next.tag != value_prev.tag) {
					return true;
				}
				return false;
			case ENTITY_REFERENCE:
			case ENTITY_REFERENCE_SPECIAL:
				if (value_next.tag == ENTITY_REFERENCE || value_next.tag == ENTITY_REFERENCE_SPECIAL) {
					return false;
				}
				return true;
		}
		return false;
  }


/**
	Writes the parameter taken from the encoding of an instance (as variable
	<code>token</code>) to the object of class <code>Value</code> submitted
	as an argument to this method. The method is applied to reading instances
	in data sections (but not in the header).
*/
	private final void parameter(Value value) throws SdaiException, java.io.IOException {
//long time1, time2;
		StaticFields staticFields;
		switch (token.type) {
			case MISSING:
				value.tag = MISSING;
				break;
			case REDEFINE:
				value.tag = REDEFINE;
				break;
			case INTEGER:
				value.tag = INTEGER;
				value.integer = token.integer;
				break;
			case REAL:
				value.tag = REAL;
				value.real = token.real;
				break;
			case LOGICAL:
				value.tag = LOGICAL;
				value.integer = token.integer;
				break;
			case ENUM:
				value.tag = ENUM;
				value.string = getStringBasicLatin();
				break;
			case STRING:
				value.tag = STRING;
				value.string = getString();
				break;
			case BINARY:
				value.tag = BINARY;
				value.reference = new Binary(token.string, token.length);
				break;
			case ENTITY_NAME:
				if (value != null) {
					value.tag = TYPED_PARAMETER;
					value.string = getStringBasicLatin();
					value.integer = 1;
				}
				consume_token(LPAREN);
				if (value != null) {
					if (value.nested_values == null) {
						value.nested_values = new Value[SdaiSession.NUMBER_OF_VALUES];
					}
					if (value.nested_values[0] == null) {
						value.nested_values[0] = new Value();
					}
				}
				scan.get_token(token);
				if (token.type == ERROR) {
					staticFields = StaticFields.get();
					scanning_exception(token, staticFields.current_instance_identifier, null);
				}
				if (value != null) {
					parameter(value.nested_values[0]);
				} else if (token.type == ENTITY_NAME || token.type == LPAREN) {
					parameter(null);
				}
				consume_token(RPAREN);
				break;
			case INSTANCE_NAME:
//						if (inside_scope > 0) break;
				value.tag = ENTITY_REFERENCE;
				staticFields = StaticFields.get();
				if (token.integer == staticFields.current_instance_identifier) {
					value.integer = -1;
					autoreference_found = true;
					break;
				}
				value.integer = token.integer;
				boolean found = tree.insert(null, value.integer);
//time2 = System.currentTimeMillis();time_insert_first += (time2 - time1);
				value.reference = tree.reference_node.content;
				if (value.reference instanceof CLateBindingEntity) {
					CLateBindingEntity forward = (CLateBindingEntity)tree.reference_node.content;
					if (length_of_array_of_inverse >= array_of_inverse.length) {
						enlarge_array_of_inverse();
					}
					array_of_inverse[length_of_array_of_inverse] = forward;
					length_of_array_of_inverse++;
					value.tag = ENTITY_REFERENCE_SPECIAL;
				}
				break;
			case LPAREN:
				if (value != null) {
					value.tag = EMBEDDED_LIST;
				}
				embedded_list(value);
				if (token.type != RPAREN) {
					parsing_exception(token, WRONG_TOKEN, AdditionalMessages.RD_TOKE, token_image[RPAREN]);
				}
				break;
		}
  }


/**
	Writes the parameter taken from the encoding of an instance (as variable
	<code>token</code>) to the object of class <code>Value</code> submitted
	as an argument to this method. The method is applied to reading instances
	in header only (not in data sections).
*/
	private final void parameter_in_header(Value value) throws SdaiException, java.io.IOException {
		switch (token.type) {
			case MISSING:
				value.tag = MISSING;
				break;
			case REDEFINE:
				parsing_exception(token, WRONG_VALUE_IN_HEADER, null, null);
			case INTEGER:
				value.tag = INTEGER;
				value.integer = token.integer;
				break;
			case REAL:
				value.tag = REAL;
				value.real = token.real;
				break;
			case LOGICAL:
				value.tag = LOGICAL;
				value.integer = token.integer;
				break;
			case ENUM:
				value.tag = ENUM;
				value.string = getStringBasicLatin();
				break;
			case STRING:
				value.tag = STRING;
				value.string = getString();
				break;
			case BINARY:
				value.tag = BINARY;
				value.reference = new Binary(token.string, token.length);
				break;
			case ENTITY_NAME:
				value.tag = TYPED_PARAMETER;
				value.string = getStringBasicLatin();
				value.integer = 1;
				consume_token(LPAREN);
				if (value.nested_values == null) {
					value.nested_values = new Value[SdaiSession.NUMBER_OF_VALUES];
				}
				if (value.nested_values[0] == null) {
					value.nested_values[0] = new Value();
				}
				parameter(value.nested_values[0]);
				consume_token(RPAREN);
				break;
			case INSTANCE_NAME:
				parsing_exception(token, WRONG_VALUE_IN_HEADER, null, null);
			case LPAREN:
				value.tag = EMBEDDED_LIST;
				embedded_list(value);
				if (token.type != RPAREN) {
					parsing_exception(token, WRONG_TOKEN, AdditionalMessages.RD_TOKE, token_image[RPAREN]);
				}
				break;
		}
  }


/**
	Reads parameters of the data section (that is, those given in parenthesis
	after keyword <code>DATA</code>, see ammendment to "ISO 10303-21"). This
	method is activated only for an exchange structure containing more than one
	data section.
*/
	private final String [] data_section_parameters(SdaiRepository repository)
			throws SdaiException, java.io.IOException {
		int error = 0;
		if (entity_values.entityValues[0] == null) {
			entity_values.entityValues[0] = new EntityValue(active_session);
		}
		parameters(entity_values.entityValues[0]);
		if (token.type != RPAREN) {
			parsing_exception(token, WRONG_TOKEN, AdditionalMessages.RD_TOKE, token_image[RPAREN]);
		}
		consume_token(SEMICOLON);
		String [] strs = new String[3];
		if (entity_values.entityValues[0].count < 2) {
			error = TOO_LESS_VALUES;
		} else if (entity_values.entityValues[0].values[0].tag != STRING) {
			error = INCORRECT_VALUE;
		} else {
			strs[0] = entity_values.entityValues[0].values[0].string;
		}
		strs[2] = null;
		if (error > 0) {
			parsing_exception(token, error, null, null);
		}
		Value value = entity_values.entityValues[0].values[1];
		if (value.tag != EMBEDDED_LIST) {
			parsing_exception(token, INCORRECT_VALUE, null, null);
		}
		Value value_in_list = value.nested_values[0];
		if (value_in_list.tag == STRING) {
			String str = value_in_list.string;
			strs[2] = str;
//			A_string ident = repository.file_schema.schema_identifiers;
			A_string ident = repository.file_schema.schema_identifiers_short;
			boolean found = false;
			String id;
			for (int i = 1; i <= ident.myLength; i++) {
				id = ident.getByIndex(i);
				if (id.equals(str)) {
					found = true;
					break;
				} else if (repository.verify_schema_name(id, str) != null) {
					found = true;
					break;
				}
			}
			if (found) {
				strs[1] = str;
			} else {
				error = INVALID_STRING_IN_DSECTION;
			}
		} else {
			error = IMPROPER_LIST_ITEM;
		}
		if (value.integer > 1) {
			error = TOO_MANY_VALUES_IN_DSECTION;
		}
		if (error > 0) {
			parsing_exception(token, error, null, null);
		}
		return strs;
	}


/**
	Reads a data section. More specifically:
	 - takes parameters of the data section in the case when the exchange
		structure contains more than one data section;
	 - extracts the data dictionary model representing Express schema that is
		underlying for the data section being considered;
	 - prepares a model for application data (either promotes an existing
		virtual one to the state of an ordinary model or creates a new one);
		the read-write access of the model is started;
	 - finds or creates a schema instance with which the application data
		model is associated;
	 - reads encoding of instances from the data section in the exchange
		structure and creates entity instances which are put into application
		data model.
*/
	private final void data_section(SchemaInstance schema_instance,
			SdaiRepository repository) throws SdaiException, java.io.IOException {
		long time_dictionary_creation = 0;
		long time_before_invocation, time_after_invocation;
		String [] strs = null;
		String name_searched = null, model_name = null, or_name = null;
		int count = repository.model_count + 1;
		scan.get_token(token);
		if (token.type == ERROR) {
			scanning_exception(token, -1, null);
		}
		A_string s_ids_orig;
		boolean found = false;
		if (token.type == LPAREN) {
			strs = data_section_parameters(repository);
			if (strs[1] != null) {
				model_dic = SdaiSession.systemRepository.get_schema_model(strs[1]);
			}
			if (model_dic == null) {
				name_searched = strs[1] + SdaiSession.DICTIONARY_NAME_SUFIX;
			} else {
				name_searched = model_dic.name;
				found = true;
			}
			model_name = strs[0];
			or_name = strs[2];
			if (or_name == null) {
				s_ids_orig = repository.file_schema.schema_identifiers;
				if (s_ids_orig.myLength == 1) {
					or_name = (String)s_ids_orig.myData;
				}
			}
		} else if (token.type != SEMICOLON) {
			parsing_exception(token, WRONG_TOKEN, AdditionalMessages.RD_TOKE, token_image[SEMICOLON]);
		} else {
			s_ids_orig = repository.file_schema.schema_identifiers;
			if (s_ids_orig.myLength == 1) {
				or_name = (String)s_ids_orig.myData;
			} else if(s_ids_orig.myLength > 1) {
				// Workaround for bug #2526
				// The right way would be to have method
				// String[] getOriginalSchemaNames()
//				or_name = (String)((Object[])s_ids_orig.myData)[0];
				or_name = (String)s_ids_orig.getByIndex(1);
			}
			model_dic = repository.get_schema_model();
			if (model_dic != null) {
				name_searched = model_dic.name;
				found = true;
			} else {
				A_string s_ids = repository.file_schema.schema_identifiers_short;
				Object [] myDataA;
				String express;
				if (s_ids.myLength == 1) {
					express = (String)s_ids.myData;
				} else if (s_ids.myLength == 2) {
					myDataA = (Object [])s_ids.myData;
					express = (String)myDataA[0];
				} else {
					ListElement element;
					if (s_ids.myLength <= CAggregate.SHORT_AGGR) {
						element = (ListElement)s_ids.myData;
					} else {
						myDataA = (Object [])s_ids.myData;
						element = (ListElement)myDataA[0];
					}
					express = (String)element.object;
				}
				name_searched = express + SdaiSession.DICTIONARY_NAME_SUFIX;
			}
			model_name = "default";
		}
		ASdaiModel set = SdaiSession.systemRepository.models;
		SdaiModel m;
		int i;
		if (!found) {
			for (i = 0; i < set.myLength; i++) {
				m = (SdaiModel)set.myData[i];
				if (m.name.equals(name_searched)) {
					model_dic = m;
					found = true;
					break;
				}
			}
		}
		if (!found || model_dic.described_schema == null) {
			time_before_invocation = System.currentTimeMillis();
			SdaiModel new_dict = SdaiSession.systemRepository.findDictionarySdaiModel(name_searched);
			time_after_invocation = System.currentTimeMillis();
			time_dictionary_creation += (time_after_invocation - time_before_invocation);
			if (!found) {
				model_dic = new_dict;
				found = true;
			}
		}
		if (found) {
			if (model_dic.getMode() == SdaiModel.NO_ACCESS) {
				time_before_invocation = System.currentTimeMillis();
				model_dic.startReadOnlyAccess();
				time_after_invocation = System.currentTimeMillis();
				time_dictionary_creation += (time_after_invocation - time_before_invocation);
			}
			repository.internal_usage = true;
			model_app = repository.findSdaiModel(model_name);
			repository.internal_usage = false;
			if (model_app != null) {
				if (model_app.underlying_schema == null && model_app.dictionary == null) {
					model_app.promoteVirtualToOrdinary(model_dic);
				} else {
					throw new SdaiException(SdaiException.MO_DUP, model_app,
						AdditionalMessages.AX_NAME + model_name);
				}
			} else {
if (SdaiSession.debug2) System.out.println("   repository name = " + repository.name);
if (SdaiSession.debug2) System.out.println("  schema name in Reader = " + model_dic.described_schema.getName(null));
				model_app = repository.createSdaiModel(model_name, model_dic.described_schema);
//System.out.println("PhFileReader  model_app: " + model_app.name + "    its repo name: " + model_app.repository.name +
//"    its repo: " + model_app.repository + "  session: " + model_app.repository.getSession());
				model_app.created = true;
			}
			modelSet.add(model_app);
			model_app.modified_by_import = true;
			if (strs != null) {
				model_app.schema_name = strs[1];
			}
			model_app.startReadWriteAccess();
			model_app.inst_deleted_permanently = true;
			model_app.original_name = or_name;

			int impl_level = 0;
			boolean impl_lev_found = true;
			boolean numeric = true;
			int k;
			int dig;
			int semicolon_pos = file_repo.implementation_level.indexOf((int)';');
			if (semicolon_pos <= 0) {
				for (k = 0; k < file_repo.implementation_level.length(); k++) {
					dig = (int)file_repo.implementation_level.charAt(k) - (int)'0';
					if (dig < 0 || dig > 9) {
						numeric = false;
					}
				}
				if (numeric) {
					if (file_repo.implementation_level.length() == 1) {
						impl_level = (int)file_repo.implementation_level.charAt(0) - (int)'0';
					} else {
						impl_level = Integer.parseInt(file_repo.implementation_level);
					}
				} else {
					impl_lev_found = false;
				}
			} else {
				for (k = 0; k < semicolon_pos; k++) {
					dig = (int)file_repo.implementation_level.charAt(k) - (int)'0';
					if (dig < 0 || dig > 9) {
						numeric = false;
					}
				}
				if (numeric) {
					for (k = semicolon_pos + 1; k < file_repo.implementation_level.length(); k++) {
						dig = (int)file_repo.implementation_level.charAt(k) - (int)'0';
						if (dig < 0 || dig > 9) {
							numeric = false;
						}
					}
				}
				if (numeric) {
					if (semicolon_pos == 1) {
						impl_level = (int)file_repo.implementation_level.charAt(0) - (int)'0';
					} else {
						String str = file_repo.implementation_level.substring(0, semicolon_pos);
						impl_level = Integer.parseInt(str);
					}
				} else {
					impl_lev_found = false;
				}
			}
			if (!impl_lev_found) {
				AdditionalMessages.printWarningToLogo(repository.session, AdditionalMessages.RD_WRIL);
				impl_level = 2;
			}

			if (impl_level <= 2 && populations_count <= 0) {
				SchemaInstance sch_inst;
				SchemaInstance appl_schema_instance = null;
				for (int j = 0; j < repository.schemas.myLength; j++) {
					sch_inst = (SchemaInstance)repository.schemas.myData[j];
					if (sch_inst.native_schema == model_dic.described_schema || sch_inst.dictionary == model_dic) {
						appl_schema_instance = sch_inst;
						break;
					}
				}
				if (appl_schema_instance == null) {
					int sch_count = repository.schema_count + 1;
					appl_schema_instance =
						(SchemaInstance)repository.createSchemaInstance("schema" + sch_count,
							model_dic.described_schema);
					appl_schema_instance.created = true;
					appl_schema_instance.modified_by_import = appl_schema_instance.modified;
					appl_schema_instance.modified = false;
				}
				boolean saved_value = appl_schema_instance.modified;
				appl_schema_instance.modified = false;
				appl_schema_instance.addSdaiModel(model_app);
				if (appl_schema_instance.modified) {
					appl_schema_instance.modified_by_import = true;
				}
				appl_schema_instance.modified = saved_value;
				model_app.modified_outside_contents_by_import = model_app.modified_outside_contents;
				model_app.modified_outside_contents = false;
				if (appl_schema_instance.moved_data_status <= 0) {
					appl_schema_instance.moved_data_status = 1;
				}
			}
		} else {
			action_exception(DICTIONARY_MODEL_NOT_FOUND, AdditionalMessages.RD_MODL, name_searched);
		}

		scan.get_token(token);
		if (token.type == ERROR) {
			scanning_exception(token, -1, null);
		}
		if (token.type == ENDSEC) {
			consume_token(SEMICOLON);
			return;
		} else if (token.type != INSTANCE_NAME) {
			parsing_exception(token, WRONG_TOKEN, AdditionalMessages.RD_TOKE, token_image[INSTANCE_NAME]);
		}
//CEntity_definition edef = (CEntity_definition)model_dic.repository.getSessionIdentifier("#2118");
//System.out.println("  READER entity: " + edef.getName(null) + "   ident: #" + edef.instance_identifier);
//System.out.println("  READER partial_attrs = " + edef.noOfPartialAttributes);
		data_entity();
		scan.get_token(token);
		if (token.type == ERROR) {
			scanning_exception(token, -1, null);
		}
		while (token.type == INSTANCE_NAME) {
			data_entity();
			scan.get_token(token);
			if (token.type == ERROR) {
				scanning_exception(token, -1, null);
			}
		}
		if (token.type != ENDSEC) {
			parsing_exception(token, WRONG_TOKEN, AdditionalMessages.RD_TOKE, token_image[ENDSEC]);
		}
		consume_token(SEMICOLON);
//		SdaiSession.println("--- Dictionary creation time=" + time_dictionary_creation/1000 + "sec");
	}


/**
	Creates an instance from its encoding in the exchange structure. More
	specifically:
	 - creates an instance of the needed entity data type;
	 - collects values into the object of class <code>ComplexEntityValue</code>
		(field <code>entity_values</code> in the current class);
	 - inserts the created instance into a binary tree which is a data structure
		used for storing the objects of the following two types:
		 1) entity instances;
		 2) references to not existing at the current moment entity instances
			(so-called forward references); the type of these objects is
			<code>CLateBindingEntity</code>. In the case when the entity instance
			is just created and for it an object of <code>CLateBindingEntity</code>
			in the binary tree already exists, the latter is replaced by the former.
			This mechanism allows to read an exchange structure in one pass;
	 - assigns the values (taken from <code>entity_values</code>) to the attributes
		of the created entity instance.
*/
	private final void data_entity() throws SdaiException, java.io.IOException {
		int i;
		long instance_identifier,saved_instance_identifier;
//long time1, time2;
//long time3, time4;

		instance_identifier = token.integer;
//if (instance_identifier == 16) Value.prnt = true; else Value.prnt = false;
		StaticFields staticFields = StaticFields.get();
		staticFields.current_instance_identifier = instance_identifier;
		consume_token(EQUALS);
		scan.get_token(token);
		if (token.type == ERROR) {
			scanning_exception(token, instance_identifier, null);
		}
		if (token.type == SCOPE) {
			saved_instance_identifier = instance_identifier;
			inside_scope++;
			scan.get_token(token);
			if (token.type == ERROR) {
				scanning_exception(token, saved_instance_identifier, null);
			}
			if (token.type != INSTANCE_NAME) {
				parsing_exception(token, WRONG_TOKEN, AdditionalMessages.RD_TOKE, token_image[INSTANCE_NAME]);
			}
			data_entity();
			scan.get_token(token);
			if (token.type == ERROR) {
				scanning_exception(token, saved_instance_identifier, null);
			}
			while (token.type == INSTANCE_NAME) {
				data_entity();
				scan.get_token(token);
				if (token.type == ERROR) {
					scanning_exception(token, saved_instance_identifier, null);
				}
			}
			if (token.type != ENDSCOPE) {
				parsing_exception(token, WRONG_TOKEN, AdditionalMessages.RD_TOKE, token_image[ENDSCOPE]);
			}
			scan.get_token(token);
			if (token.type == ERROR) {
				scanning_exception(token, saved_instance_identifier, null);
			}
			if (token.type == SLASH) {
				entity_export();
				scan.get_token(token);
				if (token.type == ERROR) {
					scanning_exception(token, saved_instance_identifier, null);
				}
			}
			inside_scope--;
			instance_identifier = saved_instance_identifier;
		}

		length_of_array_of_inverse = 0;
		instance_name_length = 0;
		CEntity created_instance = entity_instance_RHS(staticFields, instance_identifier);
		if (created_instance == null) {
			return;
		}
		if (instance_identifier == 0 && zero_inst == null) {
			zero_inst = created_instance;
		}
		if (user_defined_entity) {
			EntityValue.printWarningToLogo(active_session, AdditionalMessages.RD_UDEN, instance_identifier);
			return;
		}
//		if (inside_scope == 0) {
		if (largest_identifier < instance_identifier) {
			largest_identifier = instance_identifier;
		}
		CLateBindingEntity forward;
//		for (i = 0; i < length_of_array_of_inverse; i++) {
//			forward = array_of_inverse[i];
//			forward.inverseAdd((CEntity)created_instance);
//		}
		created_instance.instance_identifier = instance_identifier;
		boolean found = tree.insert(created_instance, instance_identifier);
//time2 = System.currentTimeMillis();time_insert_second += (time2 - time1);
		if (found) {
			forward = tree.replace(created_instance);
//time2 = System.currentTimeMillis();time_replace += (time2 - time1);
			if (forward == null) {
				String entity_name_for_exception = take_entity_name_for_exception();
				action_exception(token, DUPLICATE_INSTANCE, instance_identifier,
					entity_name_for_exception);
			}
		}
if (SdaiSession.debug2) print_entity_values(instance_identifier);
		if (autoreference_found) {
			resolve_autoreference(created_instance);
		}
//if (instance_identifier == 891) print_entity_values(instance_identifier);
		created_instance.setAll(entity_values);
//if (instance_identifier==211)
//System.out.println("PhFileReader &&&&& created_instance: " + created_instance);
        created_instance.instance_position = CEntity.INS_MASK | created_instance.instance_position; //--VV-- Instance state tracking --
//		}
//time4 = System.currentTimeMillis();time_data_entity += (time4 - time3);
	}


/**
	Processes the right-hand side (entity name and parameters) in the encoding
	of a (data section) entity instance. More specifically, creates an instance
	of the required entity data type and puts the parameters into
	<code>entity_values</code>.
*/
	private final CEntity entity_instance_RHS(StaticFields staticFields, long instance_identifier)
    		throws SdaiException, java.io.IOException {
		int number_of_items_in_complex_instance;
		CEntity created_instance = null;
		CEntity_definition def;
		if (token.type == USER_DEFINED_KEYWORD || token.type == ENTITY_NAME) {
			complex_entity = false;
			if (token.type == ENTITY_NAME) {
				try {
					created_instance = create.object(token.string, token.length, model_dic,
						model_app, instance_identifier, 1, 1);
					staticFields.c_instance = created_instance;
				} catch (java.lang.IllegalAccessException ex) {
					String entity_name_for_exception = take_entity_name_for_exception();
					action_exception(token, ILLEGAL_ACCESS, instance_identifier, entity_name_for_exception);
				} catch (java.lang.InstantiationException ex) {
					String entity_name_for_exception = take_entity_name_for_exception();
					action_exception(token, CLASS_NOT_FOUND, instance_identifier, entity_name_for_exception);
				}
				if (created_instance == null) {
					def = null;
				} else {
					def = (CEntity_definition)((CEntity)created_instance).getInstanceType();
					entity_values.def = def;
					if (def.noOfPartialEntityTypes > entity_values.entityValues.length) {
						entity_values.enlarge(def.noOfPartialEntityTypes);
					} else {
						for (int i = 0; i < def.noOfPartialEntityTypes; i++) {
							if (entity_values.entityValues[i] == null) {
								entity_values.entityValues[i] = new EntityValue(active_session);
							}
						}
					}
				}
				consume_token(LPAREN);
				if (created_instance == null) {
					parameters();
				} else {
					parameters(def, instance_identifier);
				}
				if (token.type != RPAREN) {
					parsing_exception(token, WRONG_TOKEN, AdditionalMessages.RD_TOKE, token_image[RPAREN]);
				}
//				print_entity_values(instance_identifier);
				user_defined_entity = false;
			} else {
				if (complex_name[0].entity_name.length < token.length) {
					complex_name[0].enlarge_entity_name(token.length, token.string);
				}
				consume_token(LPAREN);
				created_instance = new $USER_DEFINED_ENTITY();
				(($USER_DEFINED_ENTITY)created_instance).name = new String(token.string, 0, token.length);
				if (entity_values.entityValues[0] == null) {
					entity_values.entityValues[0] = new EntityValue(active_session);
				}
				parameters(entity_values.entityValues[0]);
				if (token.type != RPAREN) {
					parsing_exception(token, WRONG_TOKEN, AdditionalMessages.RD_TOKE, token_image[RPAREN]);
				}
				user_defined_entity = true;
			}
		} else if (token.type == LPAREN) {
			complex_entity = true;
			instance_name_length = 0;
			consume_token(ENTITY_NAME);
			instance_name_length += (token.length + 1);
			if (complex_name[0].entity_name.length < token.length) {
				complex_name[0].enlarge_entity_name(token.length, token.string);
			} else {
				System.arraycopy(token.string, 0, complex_name[0].entity_name, 0, token.length);
				complex_name[0].length_of_entity_name = token.length;
			}
			consume_token(LPAREN);
			if (entity_values.entityValues[0] == null) {
				entity_values.entityValues[0] = new EntityValue(active_session);
			}
			parameters(entity_values.entityValues[0]);
			number_of_items_in_complex_instance = 1;
			if (token.type != RPAREN) {
				parsing_exception(token, WRONG_TOKEN, AdditionalMessages.RD_TOKE, token_image[RPAREN]);
			}
			scan.get_token(token);
			while (token.type == ENTITY_NAME) {
				instance_name_length += (token.length + 1);
				if (number_of_items_in_complex_instance >= complex_name.length) {
					enlarge_complex_name();
				}
				if (complex_name[number_of_items_in_complex_instance].entity_name.length
							< token.length) {
					complex_name[number_of_items_in_complex_instance].enlarge_entity_name(token.length, token.string);
				} else {
					System.arraycopy(token.string, 0,
						complex_name[number_of_items_in_complex_instance].entity_name, 0, token.length);
					complex_name[number_of_items_in_complex_instance].length_of_entity_name =
						token.length;
				}
				consume_token(LPAREN);
				if (number_of_items_in_complex_instance >= entity_values.entityValues.length) {
					entity_values.enlarge(number_of_items_in_complex_instance + 1);
				} else {
					if (entity_values.entityValues[number_of_items_in_complex_instance] == null) {
						entity_values.entityValues[number_of_items_in_complex_instance] = new EntityValue(active_session);
					}
				}
				parameters(entity_values.entityValues[number_of_items_in_complex_instance]);
				number_of_items_in_complex_instance++;
				if (token.type != RPAREN) {
					parsing_exception(token, WRONG_TOKEN, AdditionalMessages.RD_TOKE, token_image[RPAREN]);
				}
				scan.get_token(token);
			}
			instance_name_length--;
			take_name(number_of_items_in_complex_instance);
			try {
				created_instance = create.object(instance_name, instance_name_length,
					model_dic, model_app, instance_identifier,
					number_of_items_in_complex_instance, number_of_items_in_complex_instance);
				staticFields.c_instance = created_instance;
			} catch (java.lang.IllegalAccessException ex) {
				String entity_name_for_exception = take_entity_name_for_exception();
				action_exception(token, ILLEGAL_ACCESS, instance_identifier, entity_name_for_exception);
			} catch (java.lang.InstantiationException ex) {
				String entity_name_for_exception = take_entity_name_for_exception();
				action_exception(token, CLASS_NOT_FOUND, instance_identifier, entity_name_for_exception);
			}
			if (created_instance != null) {
				def = (CEntity_definition)((CEntity)created_instance).getInstanceType();
				entity_values.def = def;
//if (def==null)
//System.out.println("PhFileReader def is NULL  entity class name: " + created_instance.getClass().getName());
				int tot_attr_count = 0;
				for (int i = 0; i < def.noOfPartialEntityTypes; i++) {
					entity_values.entityValues[i].def = def.partialEntityTypes[i];
					if (entity_values.entityValues[i].count != def.partialEntityTypes[i].noOfPartialAttributes) {
						EntityValue.printWarningToLogo(active_session, AdditionalMessages.RD_VADI, instance_identifier);
					}
// Below is a new code
					if (!inst_values_violation) {
						continue;
					}
					for (int j = 0; j < entity_values.entityValues[i].count; j++) {
						Value val = entity_values.entityValues[i].values[j];
						if (val.types_count == 0) {
							continue;
						}
						val.check_aggregate(((CEntityDefinition)def).attributes[tot_attr_count + j], instance_identifier, 
							take_entity_name_for_exception(), active_session);
						val.types_count = 0;
					}
					tot_attr_count += def.partialEntityTypes[i].noOfPartialAttributes;
				}
				inst_values_violation = false;
			}
			if (token.type != RPAREN) {
				parsing_exception(token, WRONG_TOKEN, AdditionalMessages.RD_TOKE, token_image[RPAREN]);
			}
		} else {
			parsing_exception(token, ENTITY_EXPECTED, null, null);
		}
		consume_token(SEMICOLON);
		return created_instance;
	}


/**
	Reads the data contained in the export list attached to a scope structure
	(see "ISO 10303-21::9.3 Scope structure").
*/
	private final void entity_export() throws SdaiException, java.io.IOException {
		consume_token(INSTANCE_NAME);
		scan.get_token(token);
		while (token.type == COMMA) {
			consume_token(INSTANCE_NAME);
			scan.get_token(token);
		}
		if (token.type != SLASH) {
			parsing_exception(token, WRONG_TOKEN, AdditionalMessages.RD_TOKE, token_image[SLASH]);
		}
	}


/**
	Checks if the current token read from the exchange structure is of the
	specified type. If not, then <code>SdaiException</code> is thrown.
*/
	final private void consume_token(int type) throws SdaiException, java.io.IOException {
		scan.get_token(token);
		if (token.type == ERROR) {
			scanning_exception(token, -1, null);
		}
		if (token.type != type) {
			if (type == ISO_BEGIN) {
 				parsing_warning(active_session, token, WRONG_TOKEN, AdditionalMessages.RD_TOKE, token_image[type]);
			} else {
 				parsing_exception(token, WRONG_TOKEN, AdditionalMessages.RD_TOKE, token_image[type]);
			}
		}
	}


/**
	Constructs the so-called java name of the complex entity.
	Having this name, a complex entity instance is created.
*/
	final private void take_name(int number_of_items_in_complex_instance) throws SdaiException {
		int i, j, k;

		if (instance_name_length > instance_name.length) {
			int new_length = instance_name.length * 2;
			if (new_length < instance_name_length) {
				new_length = instance_name_length;
			}
			instance_name = new byte[new_length];
		}
		for (i = 0, k = -1; i < number_of_items_in_complex_instance; i++) {
			for (j = 0; j < complex_name[i].length_of_entity_name; j++) {
				k++;
				instance_name[k] = complex_name[i].entity_name[j];
			}
			if (i < number_of_items_in_complex_instance - 1) {
				k++;
				instance_name[k] = (byte)'$';
			}
		}
	}


/**
	Puts simple entity data types in the alphabetical order within the complex entity
	being considered. Violations of the order may (by mistake) happen
	when external mapping mode for an instance is used. In addition, objects
	of <code>EntityValue</code> within <code>entity_values</code> are reordered
	accordingly, and the so-called java name of the complex entity is constructed.
	This method is invoked in <code>Create_instance</code> class.
*/
	byte [] remedy_complex_name(int number_of_items_in_complex_instance) throws SdaiException {
		int i, j, k;
		boolean order_changed = false;
		for (i = 0; i < number_of_items_in_complex_instance; i++) {
			for (j = i; j > 0 && compare_names(j-1, j) > 0; j--) {
				PartialEntityName name = complex_name[j-1];
				complex_name[j-1] = complex_name[j];
				complex_name[j] = name;
				EntityValue evalue = entity_values.entityValues[j-1];
				entity_values.entityValues[j-1] = entity_values.entityValues[j];
				entity_values.entityValues[j] = evalue;
				order_changed = true;
			}
		}
		if (enl_instance_name_length > instance_name.length) {
			int new_length = instance_name.length * 2;
			if (new_length < enl_instance_name_length) {
				new_length = enl_instance_name_length;
			}
			instance_name = new byte[new_length];
		}
		for (i = 0, k = -1; i < number_of_items_in_complex_instance; i++) {
			for (j = 0; j < complex_name[i].length_of_entity_name; j++) {
				k++;
				instance_name[k] = complex_name[i].entity_name[j];
			}
			if (i < number_of_items_in_complex_instance - 1) {
				k++;
				instance_name[k] = (byte)'$';
			}
		}
		if (order_changed) {
			return instance_name;
		} else {
			return null;
		}
	}


	byte [] extendComplexName(SdaiModel mod, int items_count, CEntityDefinition [] sep_defs, int [] sep_def_inds,
         int sep_count, long instance_identifier) throws SdaiException {
		save_entity_values(items_count);
		if (saved_ent_name == null) {
			if (PARTIAL_ENTITIES_COUNT >= items_count) {
				saved_ent_name = new PartialEntityName[PARTIAL_ENTITIES_COUNT];
			} else {
				saved_ent_name = new PartialEntityName[items_count];
			}
		} else if (saved_ent_name.length < items_count) {
			saved_ent_name = new PartialEntityName[items_count];
		}
		System.arraycopy(complex_name, 0, saved_ent_name, 0, items_count);
		int ext_count = separateDefValues(items_count, sep_defs, sep_def_inds, sep_count, instance_identifier);
		if (ext_count < 0) {
			return null;
		}
		int count = items_count;
		enl_instance_name_length = instance_name_length;
		SchemaData sch_data = mod.underlying_schema.modelDictionary.schemaData;
		for (int i = items_count; i < ext_count; i++) {
			CEntityDefinition def = entity_values.entityValues[i].def;
			if (count >= complex_name.length) {
				enlarge_complex_name();
			}
			int index_to_entity = sch_data.findEntityExtentIndex(def);
			if (index_to_entity < 0) {
				System.arraycopy(saved_ent_name, 0, complex_name, 0, items_count);
				return null;
			}
			byte [] b_name = sch_data.bNames[index_to_entity];
//String str = new String(b_name, 0, b_name.length);
//System.out.println("PhFileReader *****  b_name: " + str);
			if (complex_name[count].entity_name.length < b_name.length) {
				complex_name[count].enlarge_entity_name(b_name.length, b_name);
			} else {
				System.arraycopy(b_name, 0, complex_name[count].entity_name, 0, b_name.length);
				complex_name[count].length_of_entity_name = b_name.length;
			}
			enl_instance_name_length += (b_name.length + 1);
			count++;
		}
		remedy_complex_name(count);
		return instance_name;
	}


	void restoreComplexName(int items_count) throws SdaiException {
		int i, j;
		int m = items_count;
		for (i = 0; i < items_count; i++) {
			boolean missing = true;
			for (j = 0; j < items_count; j++) {
				if (complex_name[i] == saved_ent_name[j]) {
					missing = false;
					break;
				}
			}
			if (missing) {
				complex_name[m] = complex_name[i];
				m++;
			}
		}
		System.arraycopy(saved_ent_name, 0, complex_name, 0, items_count);
		req_instance_name_length = enl_instance_name_length;
		if (req_instance_name == null) {
			if (COMPLEX_ENTITY_NAME_LENGTH >= req_instance_name_length) {
				req_instance_name = new byte[COMPLEX_ENTITY_NAME_LENGTH];
			} else {
				req_instance_name = new byte[req_instance_name_length];
			}
		} else if (req_instance_name_length > req_instance_name.length) {
			int new_length = req_instance_name.length * 2;
			if (new_length < req_instance_name_length) {
				new_length = req_instance_name_length;
			}
			req_instance_name = new byte[new_length];
		}
		inst_is_required = true;
		for (i = 0; i < req_instance_name_length; i++) {
			req_instance_name[i] = instance_name[i];
		}
		int k = -1;
		for (i = 0; i < items_count; i++) {
			for (j = 0; j < complex_name[i].length_of_entity_name; j++) {
				k++;
				instance_name[k] = complex_name[i].entity_name[j];
			}
			if (i < items_count - 1) {
				k++;
				instance_name[k] = (byte)'$';
			}
		}
	}


	void setNameLength() throws SdaiException {
		instance_name_length = enl_instance_name_length;
	}


	void save_entity_values(int items_count) throws SdaiException {
		if (partial_values == null) {
			if (items_count <= NAMES_ARRAY_SIZE) {
				partial_values = new EntityValue[NAMES_ARRAY_SIZE];
			} else {
				partial_values = new EntityValue[items_count];
			}
		} else if (items_count > partial_values.length) {
			enlarge_partial_values(items_count);
		}
		for (int i = 0; i < items_count; i++) {
			partial_values[i] = entity_values.entityValues[i];
		}
	}


	void restore_entity_values(int items_count) throws SdaiException {
		int i, j, k;
		if (begin_ent_values == null) {
			if (items_count <= NAMES_ARRAY_SIZE) {
				begin_ent_values= new EntityValue[NAMES_ARRAY_SIZE];
			} else {
				begin_ent_values = new EntityValue[items_count];
			}
		} else if (items_count > begin_ent_values.length) {
			enlarge_begin_ent_values(items_count);
		}
		if (used_ent_values == null) {
			if (items_count <= NAMES_ARRAY_SIZE) {
				used_ent_values = new int[NAMES_ARRAY_SIZE];
			} else {
				used_ent_values = new int[items_count];
			}
		} else if (items_count > used_ent_values.length) {
			enlarge_used_ent_values(items_count);
		}
		for (i = 0; i < items_count; i++) {
			begin_ent_values[i] = entity_values.entityValues[i];
			used_ent_values[i] = 0;
		}
		for (i = 0; i < items_count; i++) {
			entity_values.entityValues[i] = partial_values[i];
		}
		for (i = 0; i < items_count; i++) {
			for (j = 0; j < items_count; j++) {
				if (partial_values[i] == begin_ent_values[j]) {
					used_ent_values[j] = -1;
					partial_values[i] = null;
					break;
				}
			}
		}
		for (i = 0, k = -1; i < items_count; i++) {
			if (used_ent_values[i] < 0) {
				continue;
			}
			for (j = k + 1; j < items_count; j++) {
				if (partial_values[j] != null) {
					k = j;
					break;
				}
			}
			used_ent_values[i] = k;
		}
		for (i = 0; i < items_count; i++) {
			if (used_ent_values[i] < 0) {
				continue;
			}
			EntityValue target = partial_values[used_ent_values[i]];
			for (j = items_count; j < entity_values.entityValues.length; j++) {
				if (entity_values.entityValues[j] == target) {
					entity_values.entityValues[j] = begin_ent_values[i];
				}
			}
		}
	}


	int separateDefValues(CEntityDefinition def, int items_count, int ln, int def_index, long instance_identifier)
			throws SdaiException {
		int i,j;
		int val_count = entity_values.entityValues[def_index].count;
		int enl_ln = ln + def.noOfPartialEntityTypes;
		if (enl_ln > entity_values.entityValues.length) {
			entity_values.enlarge(enl_ln);
		} else {
			for (i = ln; i < enl_ln; i++) {
				if (entity_values.entityValues[i] == null) {
					entity_values.entityValues[i] = new EntityValue(active_session);
				}
			}
		}
		boolean too_less = false;
		int accum_count = 0;
		int index;
		if (used_ent_values == null) {
			if (def.noOfPartialEntityTypes <= NAMES_ARRAY_SIZE) {
				used_ent_values = new int[NAMES_ARRAY_SIZE];
			} else {
				used_ent_values = new int[def.noOfPartialEntityTypes];
			}
		} else if (def.noOfPartialEntityTypes > used_ent_values.length) {
			enlarge_used_ent_values(def.noOfPartialEntityTypes);
		}
		CEntity_definition partial_def;
		for (i = 0; i < def.noOfPartialEntityTypes; i++) {
			index = def.externalMappingIndexing[i];
			partial_def = def.partialEntityTypes[index];
			if (findPartialEntity(items_count, partial_def, def)) {
				used_ent_values[index] = -1;
			} else {
				used_ent_values[index] = 0;
			}
		}
		for (i = 0, j = 0; i < def.noOfPartialEntityTypes; i++) {
			if (used_ent_values[i] == -1) {
				j++;
				enl_ln--;
			} else {
				used_ent_values[i] = j;
			}
		}
		for (i = 0; i < def.noOfPartialEntityTypes; i++) {
			index = def.externalMappingIndexing[i];
			if (used_ent_values[index] < 0) {
				continue;
			}
			partial_def = def.partialEntityTypes[index];
			int count = partial_def.noOfPartialAttributes;
			int index_mod = index - used_ent_values[index];
			EntityValue partial_entity_values = entity_values.entityValues[ln + index_mod];
			partial_entity_values.count = count;
			partial_entity_values.def = partial_def;
			if (partial_entity_values.values == null) {
				if (SdaiSession.NUMBER_OF_VALUES >=count) {
					partial_entity_values.values = new Value[SdaiSession.NUMBER_OF_VALUES];
				} else {
					partial_entity_values.values = new Value[count];
				}
			} else if (partial_entity_values.values.length < count) {
				partial_entity_values.enlarge(count);
			}
			for (j = 0; j < count; j++) {
				if (accum_count >= val_count) {
					too_less = true;
					if (partial_entity_values.values[j] == null) {
						partial_entity_values.values[j] = new Value();
					}
					partial_entity_values.values[j].tag = MISSING;
				} else {
					if (partial_entity_values.values[j] == null) {
						partial_entity_values.values[j] = new Value();
					}
//					partial_entity_values.values[j] = entity_values.entityValues[def_index].values[accum_count++];
					partial_entity_values.values[j].copyValueStepFile(entity_values.entityValues[def_index].values[accum_count]);
					accum_count++;
				}
			}
		}
		if (too_less) {
			EntityValue.printWarningToLogo(active_session, AdditionalMessages.RD_VLEA, instance_identifier);
		}
		if (accum_count < val_count) {
			EntityValue.printWarningToLogo(active_session, AdditionalMessages.RD_VEXA, instance_identifier);
		}
		index = -1;
		CEntity_definition parent_def = (CEntity_definition)complex_name[def_index].def;
		EntityValue ev_saved = entity_values.entityValues[def_index];
		for (i = ln; i < enl_ln; i++) {
			EntityValue ev = entity_values.entityValues[i];
			if (parent_def == ev.def) {
				entity_values.entityValues[def_index] = ev;
				index = i;
				break;
			}
		}
		if (index < 0) {
			return -1;
		}
		for (i = index; i < enl_ln - 1; i++) {
			entity_values.entityValues[i] = entity_values.entityValues[i + 1];
		}
		entity_values.entityValues[enl_ln - 1] = ev_saved;
		return enl_ln - 1;
	}


	boolean findPartialEntity(int items_count, CEntityDefinition partial_def, CEntityDefinition except)
			throws SdaiException {
		for (int i = 0; i < items_count; i++) {
			if (complex_name[i].def == except) {
				continue;
			}
			if (partial_def == complex_name[i].def) {
				return true;
			}
		}
		return false;
	}


	int separateDefValues(int items_count, CEntityDefinition [] sep_defs, int [] sep_def_inds,
			int sep_count, long instance_identifier) throws SdaiException {
		int ev_count = items_count;
		for (int i = 0; i < sep_count; i++) {
			ev_count = separateDefValues(sep_defs[i], items_count, ev_count, sep_def_inds[i], instance_identifier);
			if (ev_count < 0) {
				break;
			}
		}
		return ev_count;
	}


/**
	Updates <code>entity_values</code> to represent the values of the entity
	whose definition is given by the first parameter. This method is invoked
	in the cases when JSDAI library does not contain entity whose instance
	is found in the exchange structure. If this happens, JSDAI tries to select
	another entity which is most similar to the missing one. The latter is
	replaced by the selected entity. The current method transfers the values
	of the attributes of the missing entity to the attributes of the
	substitute. The new attributes of the substitute (that does not appear in
	the missing entity) remain unset, whereas the values of those in the
	missing entity but not in its substitute are ignored. All these operations
	result in a new <code>entity_values</code>.
	This method is invoked in <code>Create_instance</code> class.
*/
	void update_complex_entity_values(CEntityDefinition def, int [] ref2partial_values)
			throws SdaiException {
		int i, j;
//print_entity_values(240);
		int part_types_count = def.noOfPartialEntityTypes;
		if (partial_values == null) {
			if (part_types_count <= NAMES_ARRAY_SIZE) {
				partial_values = new EntityValue[NAMES_ARRAY_SIZE];
			} else {
				partial_values = new EntityValue[part_types_count];
			}
		} else if (part_types_count > partial_values.length) {
			enlarge_partial_values(part_types_count);
		}
		if (part_types_count > entity_values.entityValues.length) {
			entity_values.enlarge(part_types_count);
		}
		int ent_values_count = entity_values.entityValues.length;
		for (i = 0; i < ent_values_count; i++) {
			if (entity_values.entityValues[i] == null) {
				entity_values.entityValues[i] = new EntityValue(active_session);
			}
		}
		if (used_ent_values == null) {
			if (ent_values_count <= NAMES_ARRAY_SIZE) {
				used_ent_values = new int[NAMES_ARRAY_SIZE];
			} else {
				used_ent_values = new int[ent_values_count];
			}
		} else if (ent_values_count > used_ent_values.length) {
			enlarge_used_ent_values(ent_values_count);
		}
		for (i = 0; i < ent_values_count; i++) {
			used_ent_values[i] = 0;
		}
		for (i = 0; i < part_types_count; i++) {
			if (ref2partial_values[i] >= 0) {
				partial_values[i] = entity_values.entityValues[ref2partial_values[i]];
				used_ent_values[ref2partial_values[i]] = 1;
			}
		}
		for (i = 0; i < part_types_count; i++) {
			if (ref2partial_values[i] >= 0) {
				continue;
			}
			for (j = 0; j < ent_values_count; j++) {
				if (used_ent_values[j] == 0) {
					partial_values[i] = entity_values.entityValues[j];
					used_ent_values[j] = 1;
					break;
				}
			}
		}
		int k = ent_values_count - 1;
		for (i = ent_values_count - 1; i >= 0 ; i--) {
			if (used_ent_values[i] == 0) {
				entity_values.entityValues[k] = entity_values.entityValues[i];
				k--;
			}
		}
		for (i = 0; i < part_types_count; i++) {
			entity_values.entityValues[i] = partial_values[i];
			if (ref2partial_values[i] >= 0) {
				continue;
			}
			CEntityDefinition partial_def = def.partialEntityTypes[i];
			EntityValue entity_val = entity_values.entityValues[i];
			if (entity_val.values == null) {
				if (SdaiSession.NUMBER_OF_VALUES >= partial_def.noOfPartialAttributes) {
					entity_val.values = new Value[SdaiSession.NUMBER_OF_VALUES];
				} else {
					entity_val.values = new Value[partial_def.noOfPartialAttributes];
				}
			} else if (entity_val.values.length < partial_def.noOfPartialAttributes) {
				entity_val.enlarge(partial_def.noOfPartialAttributes);
			}
			entity_val.count = partial_def.noOfPartialAttributes;
			for (j = 0; j < partial_def.noOfPartialAttributes; j++) {
				if (entity_val.values[j] == null) {
					entity_val.values[j] = new Value();
				}
				entity_val.values[j].tag = MISSING;
			}
		}
//print_entity_values(241);
	}


/**
	Establishes references of an entity instance to itself. This method is
	invoked in the cases when the variable <code>autoreference_found</code>
	is set to <code>true</code>.
*/
	final private void resolve_autoreference(CEntity instance) {
		for (int i = 0; i < entity_values.def.noOfPartialEntityTypes; i++) {
			EntityValue partval = entity_values.entityValues[i];
			for (int j = 0; j < partval.count; j++) {
				check_value(partval.values[j], instance);
			}
		}
		autoreference_found = false;
	}


/**
	Checks if the entity instance should reference itself. If so, then this
	reference is settled.
*/
	final private void check_value(Value val, CEntity instance) {
		Value value_next;
		switch (val.tag) {
			case TYPED_PARAMETER:
				value_next = val.nested_values[0];
				check_value(value_next, instance);
				break;
			case ENTITY_REFERENCE:
				if (val.integer < 0) {
					StaticFields staticFields = StaticFields.get();
					val.integer = (int)staticFields.current_instance_identifier;
					val.reference = instance;
				}
				break;
			case EMBEDDED_LIST:
				for (int i = 0; i < val.length; i++) {
					value_next = val.nested_values[i];
					check_value(value_next, instance);
				}
				break;
			default:
				break;
		}
	}


/**
	Returns an internal array used to store the names of simple entity types
	within a complex entity data type.
	This method is invoked in <code>Create_instance</code> class.
*/
	PartialEntityName [] get_complex_name() {
		return complex_name;
	}


/**
	Compares two simple entity names within a complex entity type. Returns
	value 1 if the first name is alphabetically larger, -1 if the first is
	smaller, and 0 if the names coincide.
*/
	final private int compare_names(int first, int second) {
		int ln;
		int used_if_included;
		if (complex_name[first].length_of_entity_name < complex_name[second].length_of_entity_name) {
			used_if_included = -1;
			ln = complex_name[first].length_of_entity_name;
		} else if (complex_name[first].length_of_entity_name == complex_name[second].length_of_entity_name) {
			used_if_included = 0;
			ln = complex_name[first].length_of_entity_name;
		} else {
			used_if_included = 1;
			ln = complex_name[second].length_of_entity_name;
		}
		for (int i = 0; i < ln; i++) {
			if (complex_name[first].entity_name[i] < complex_name[second].entity_name[i]) {
				return -1;
			} else if (complex_name[first].entity_name[i] > complex_name[second].entity_name[i]) {
				return 1;
			}
		}
		return used_if_included;
	}


/**
	Returns the string described by the current token assuming
	that all symbols are from the basic Latin alphabet.
*/
	final private String getStringBasicLatin() {
		if (token.length == 0) {
			return nullString;
		} else {
			return (new String(token.string, 0, token.length)).intern();
		}
	}


/**
	Returns the string described by the current token assuming that
	to encode it the character sets of ISO 8859 and/or ISO 10646 might be used.
*/
	final private String getString() throws SdaiException  {
		if (token.length == 0) {
			return nullString;
		} else {
			return analyse_string().intern();
		}
	}

/**
	Returns the string described by the current token assuming that
	to encode it the character sets of ISO 8859 and/or ISO 10646 might be used.
*/
	final private String analyse_string() throws SdaiException  {
		int i;
		int k = 0;
		int count = 0;
		int to_string = -1;
		int code;
		int mult;
		int numb = 0;
		byte bt;
		boolean iso10646 = false;
		String base, current_str;
		StaticFields staticFields;
		if (token.length > chars.length) {
			int new_length = chars.length * 2;
			if (new_length < token.length) {
				new_length = token.length;
			}
			chars = new char[new_length];
		}
//current_str = new String(token.string, 0, token.length);
//System.out.println("PhFileReader   ******   current_str: " + current_str);
		if (token.integer == 0) {
			if (token.length > 0) {
				return new String(token.string, 0, token.length);
			} else {
				return nullString;
			}
		}
		while (k < token.length) {
			if (token.string[k] == BACKSLASH) {
				k++;
				if (token.string[k] == BACKSLASH) {
					chars[count] = (char)token.string[k];
					count++;
					k++;
					continue;
				}
				switch (token.string[k]) {
					case CAPITAL_S:
						k++;
						if (token.string[k] != BACKSLASH) {
//							string_exception(AdditionalMessages.RD_WRST, new String(token.string, 0, k));
							string_warning(active_session, AdditionalMessages.RD_WRIS, new String(token.string, 0, k + 1), token, k + 1);
						} else {
							k++;
						}
						code = (int)token.string[k];
						if (to_string >= 0) {
							code = iso8859[to_string][code - 32];
							if (code <= 0) {
//								string_exception(AdditionalMessages.RD_INCH, new String(token.string, 0, k));
								string_warning(active_session, AdditionalMessages.RD_INCS, new String(token.string, 0, k + 1), token, k + 1);
								code = iso8859[to_string][0];
							}
						} else {
							code += 128;
						}
						chars[count] = (char)code;
						count++;
						k++;
						break;
					case CAPITAL_P:
						k++;
						if (token.string[k] < 'A' || token.string[k] > 'I') {
//							string_exception(AdditionalMessages.RD_WRST, new String(token.string, 0, k));
							string_warning(active_session, AdditionalMessages.RD_WRIS, new String(token.string, 0, k + 1), token, k + 1);
							to_string = 0;
						} else {
							to_string = (int)token.string[k] - (int)'A';
						}
						k++;
						if (token.string[k] != BACKSLASH) {
//							string_exception(AdditionalMessages.RD_WRST, new String(token.string, 0, k));
							string_warning(active_session, AdditionalMessages.RD_WRIS, new String(token.string, 0, k + 1), token, k + 1);
						} else {
							k++;
						}
						break;
					case CAPITAL_X:
						k++;
						switch (token.string[k]) {
							case BACKSLASH:
								code = 0;
								mult = 1;
								for (i = 0; i < 2; i++) {
									bt = token.string[k + 2 - i];
									if (bt >= '0' && bt <= '9') {
										numb = (int)bt - (int)'0';
									} else if (bt >= 'A' && bt <= 'F') {
										numb = (int)bt - (int)'A' + 10;
									} else {
//										string_exception(AdditionalMessages.RD_WRST, new String(token.string, 0, k + 2 - i));
										string_warning(active_session, AdditionalMessages.RD_WRIS,
											new String(token.string, 0, k + 3 - i), token, k + 3 - i);
										numb = 0;
									}
									code += (mult * numb);
									mult *= 16;
								}
								chars[count] = (char)code;
								count++;
								k += 3;
								break;
							case ZERO:
								k++;
								if (token.string[k] != BACKSLASH) {
//									string_exception(AdditionalMessages.RD_WRST, new String(token.string, 0, k));
									string_warning(active_session, AdditionalMessages.RD_WRIS,
										new String(token.string, 0, k + 1), token, k + 1);
								} else {
									k++;
								}
								if (iso10646) {
									iso10646 = false;
								} else {
//									string_exception(AdditionalMessages.RD_WRST, new String(token.string, 0, k));
									string_warning(active_session, AdditionalMessages.RD_WRIS,
										new String(token.string, 0, k), token, k);
								}
								break;
							case TWO:
								k++;
								if (token.string[k] != BACKSLASH) {
//									string_exception(AdditionalMessages.RD_WRST, new String(token.string, 0, k));
									string_warning(active_session, AdditionalMessages.RD_WRIS,
										new String(token.string, 0, k + 1), token, k + 1);
								} else {
									k++;
								}
								iso10646 = true;
								while (true) {
									if (k >= token.length) {
										break;
									}
									mult = 1;
									bt = token.string[k];
									if (!((bt >= '0' && bt <= '9') || (bt >= 'A' && bt <= 'F'))) {
										break;
									}
									code = 0;
									for (i = 0; i < 4; i++) {
										bt = token.string[k + 3 - i];
										if (bt >= '0' && bt <= '9') {
											numb = (int)bt - (int)'0';
										} else if (bt >= 'A' && bt <= 'F') {
											numb = (int)bt - (int)'A' + 10;
										} else {
//											string_exception(AdditionalMessages.RD_WRST, new String(token.string, 0, k + 3 - i));
											string_warning(active_session, AdditionalMessages.RD_WRIS,
												new String(token.string, 0, k + 4 - i), token, k + 4 - i);
											numb = 0;
										}
										code += (mult * numb);
										mult *= 16;
									}
									chars[count] = (char)code;
									count++;
									k += 4;
								}
								if (k >= token.length || token.string[k] != BACKSLASH) {
									iso10646 = false;
									staticFields = StaticFields.get();
									EntityValue.printWarningToLogo(active_session, AdditionalMessages.RD_CDEM, staticFields.current_instance_identifier);
								}
								break;
							case FOUR:
								k++;
								if (token.string[k] != BACKSLASH) {
//									string_exception(AdditionalMessages.RD_WRST, new String(token.string, 0, k));
									string_warning(active_session, AdditionalMessages.RD_WRIS,
										new String(token.string, 0, k + 1), token, k + 1);
								} else {
									k++;
								}
								iso10646 = true;
								while (true) {
									if (k >= token.length) {
										break;
									}
									mult = 1;
									bt = token.string[k];
									if (!((bt >= '0' && bt <= '9') || (bt >= 'A' && bt <= 'F'))) {
										break;
									}
									code = 0;
									for (i = 0; i < 8; i++) {
										bt = token.string[k + 7 - i];
										if (bt >= '0' && bt <= '9') {
											numb = (int)bt - (int)'0';
										} else if (bt >= 'A' && bt <= 'F') {
											numb = (int)bt - (int)'A' + 10;
										} else {
//											string_exception(AdditionalMessages.RD_WRST, new String(token.string, 0, k + 7 - i));
											string_warning(active_session, AdditionalMessages.RD_WRIS,
												new String(token.string, 0, k + 8 - i), token, k + 8 - i);
											numb = 0;
										}
										code += (mult * numb);
										mult *= 16;
									}
									chars[count] = (char)code;
									count++;
									k += 8;
								}
								if (k >= token.length || token.string[k] != BACKSLASH) {
									iso10646 = false;
									staticFields = StaticFields.get();
									EntityValue.printWarningToLogo(active_session, AdditionalMessages.RD_CDEM, staticFields.current_instance_identifier);
								}
								break;
							default:
//								string_exception(AdditionalMessages.RD_WRST, new String(token.string, 0, k));
								string_warning(active_session, AdditionalMessages.RD_WRIS,
									new String(token.string, 0, k + 1), token, k + 1);
								code = 0;
								mult = 1;
								for (i = 0; i < 2; i++) {
									bt = token.string[k + 1 - i];
									if (bt >= '0' && bt <= '9') {
										numb = (int)bt - (int)'0';
									} else if (bt >= 'A' && bt <= 'F') {
										numb = (int)bt - (int)'A' + 10;
									} else {
										string_warning(active_session, AdditionalMessages.RD_WRIS,
											new String(token.string, 0, k + 2 - i), token, k + 2 - i);
										numb = 0;
									}
									code += (mult * numb);
									mult *= 16;
								}
								chars[count] = (char)code;
								count++;
								k += 2;
						}
						break;
					default:
						string_warning(active_session, AdditionalMessages.RD_WRIS, new String(token.string, 0, k + 1), token, k + 1);
//						string_exception(AdditionalMessages.RD_WRST, new String(token.string, 0, k + 1), token);
						chars[count] = (char)BACKSLASH;
						count++;
						continue;
				}
			} else {
				chars[count] = (char)token.string[k];
				count++;
				k++;
			}
		}
		if (count > 0) {
			return new String(chars, 0, count);
		} else {
			return nullString;
		}
	}


/**
	Increases the size of the auxiliary array 'complex_name' twice.
*/
	final void enlarge_complex_name() {
		int new_length = complex_name.length*2;
		PartialEntityName [] new_complex_name = new PartialEntityName[new_length];
		System.arraycopy(complex_name, 0, new_complex_name,
			0, complex_name.length);
		for (int i = complex_name.length; i < new_length; i++) {
			new_complex_name[i] = new PartialEntityName();
		}
		complex_name = new_complex_name;
	}


/**
	Increases the size of the auxiliary array 'array_of_inverse' twice.
*/
	final private void enlarge_array_of_inverse() {
		int new_length = array_of_inverse.length*2;
		CLateBindingEntity new_array_of_inverse[] = new CLateBindingEntity[new_length];
		System.arraycopy(array_of_inverse, 0, new_array_of_inverse,
			0, array_of_inverse.length);
		array_of_inverse = new_array_of_inverse;
	}


/**
	Increases the size of the auxiliary array 'partial_values' either twice
	or to satisfy the required demand, whichever of these two values is larger.
*/
	final private void enlarge_partial_values(int demand) {
		int new_length = partial_values.length * 2;
		if (new_length < demand) {
			new_length = demand;
		}
		partial_values = new EntityValue[new_length];
	}


	final private void enlarge_begin_ent_values(int demand) {
		int new_length = begin_ent_values.length * 2;
		if (new_length < demand) {
			new_length = demand;
		}
		begin_ent_values = new EntityValue[new_length];
	}


/**
	Increases the size of the auxiliary array 'used_ent_values' either twice
	or to satisfy the required demand, whichever of these two values is larger.
*/
	final private void enlarge_used_ent_values(int demand) {
		int new_length = used_ent_values.length * 2;
		if (new_length < demand) {
			new_length = demand;
		}
		used_ent_values = new int[new_length];
	}


/**
	Returns the name of the instance currently being read from the exchange
	structure.
*/
	final private String take_entity_name_for_exception() throws SdaiException {
		if (complex_entity) {
			return new String(instance_name, 0, instance_name_length);
		} else if (!user_defined_entity) {
			return entity_values.def.name;
		} else {
			return new String(complex_name[0].entity_name, 0, complex_name[0].length_of_entity_name);
		}
	}


/**
	Throws an <code>SdaiException</code> in the case when an error while scanning
	of the exchange structure was encountered.
*/
	final private void scanning_exception(Token token, long inst_ident, String str) throws SdaiException {
		int line = token.line + 1;
		String base = SdaiSession.line_separator + AdditionalMessages.RD_SCAN +
			(String)error_table.messages.get(new Integer(token.integer)) /*+
			SdaiSession.line_separator + AdditionalMessages.RD_PHFI + phys_file*/;
		if (inst_ident > 0) {
			base = base + SdaiSession.line_separator + AdditionalMessages.RD_INST + inst_ident;
		}
		base = base + SdaiSession.line_separator + "   Line: " + line +
			SdaiSession.line_separator + "   Column: " + token.column;
		if (str != null) {
			base = base + SdaiSession.line_separator + AdditionalMessages.RD_WTOK + str;
		}
		throw new SdaiException(SdaiException.SY_ERR, base);
	}


/**
	Throws an <code>SdaiException</code> in the case when an error while parsing
	of the exchange structure was encountered.
*/
	final private void parsing_exception(Token token, int error_index,
			String str1, String str2) throws SdaiException {
		int line = token.line + 1;
		String base = SdaiSession.line_separator + AdditionalMessages.RD_PARS +
			(String)error_table.messages.get(new Integer(error_index)) +
//			SdaiSession.line_separator + AdditionalMessages.RD_PHFI + phys_file +
			SdaiSession.line_separator + "   Line: " + line +
			SdaiSession.line_separator + "   Column: " + token.column;
			StaticFields staticFields = StaticFields.get();
			long id = staticFields.current_instance_identifier;
			if (id > 0) {
				String str = SdaiSession.line_separator + "   Instance: #" + id;
				base = base + str;
			}
		if (str2 != null) {
			base = base + SdaiSession.line_separator + str1 + str2;
		}
		throw new SdaiException(SdaiException.SY_ERR, base);
	}


	final private void parsing_warning(Token token, int error_index,
			String str1, String str2, SdaiSession session) throws SdaiException {
		int line = token.line + 1;
		String base = AdditionalMessages.RD_PARS +
			(String)error_table.messages.get(new Integer(error_index)) +
			SdaiSession.line_separator + "   Line: " + line +
			SdaiSession.line_separator + "   Column: " + token.column;
		if (str2 != null) {
			base = base + SdaiSession.line_separator + str1 + str2;
		}
		if (session != null && session.logWriterSession != null) {
			session.printlnSession(base);
		} else {
			SdaiSession.println(base);
		}
	}


/**
	Throws an <code>SdaiException</code> in the case when an error while parsing
	of the exchange structure was encountered.
*/
	final private void parsing_exception(Token token, String error_text,
			String str1, String str2) throws SdaiException {
		int line = token.line + 1;
		String base = SdaiSession.line_separator + AdditionalMessages.RD_PARS + error_text +
//			SdaiSession.line_separator + AdditionalMessages.RD_PHFI + phys_file +
			SdaiSession.line_separator + "   Line: " + line +
			SdaiSession.line_separator + "   Column: " + token.column;
		if (str2 != null) {
			base = base + SdaiSession.line_separator + str1 + str2;
		}
		throw new SdaiException(SdaiException.SY_ERR, base);
	}


/**
	Throws an <code>SdaiException</code> in the case when an error while processing
	some information read from the exchange structure was encountered.
	The information processed is not related with the instances in a data section
	of the exchange structure.
*/
	final private void action_exception(int error_index, String str1, String str2) throws SdaiException {
		String base = SdaiSession.line_separator + AdditionalMessages.RD_ERR +
			(String)error_table.messages.get(new Integer(error_index)) /*+
			SdaiSession.line_separator + AdditionalMessages.RD_PHFI + phys_file*/;
		if (str2 != null) {
			base = base + SdaiSession.line_separator + str1 + str2;
		}
		throw new SdaiException(SdaiException.SY_ERR, base);
	}


/**
	Throws an <code>SdaiException</code> in the case when an error while processing
	some information read from the exchange structure was encountered.
	The information processed is related with instances in a data section of the
	exchange structure.
*/
	final private void action_exception(Token token, int error_index,
			long instance, String entity_name) throws SdaiException {
		int line = token.line + 1;
		String base = SdaiSession.line_separator + AdditionalMessages.RD_ERR +
			(String)error_table.messages.get(new Integer(error_index)) +
//			SdaiSession.line_separator + AdditionalMessages.RD_PHFI + phys_file +
			SdaiSession.line_separator + "   Line: " + line +
			SdaiSession.line_separator + "   Column: " + token.column +
			SdaiSession.line_separator + AdditionalMessages.RD_INST + instance +
			SdaiSession.line_separator + AdditionalMessages.RD_ENT + entity_name;
		throw new SdaiException(SdaiException.SY_ERR, base);
	}


/**
	Throws an <code>SdaiException</code> in the case when an error while
	analysing the string was encountered.
*/
	final private void string_exception(String error_message, String str) throws SdaiException {
		String base = SdaiSession.line_separator + error_message +
			SdaiSession.line_separator + AdditionalMessages.RD_WSTR + str;
		throw new SdaiException(SdaiException.SY_ERR, base);
	}


	final private void string_exception(String error_message, String str, Token token) throws SdaiException {
		int line = token.line + 1;
		String base = SdaiSession.line_separator + error_message +
			SdaiSession.line_separator + AdditionalMessages.RD_WSTR + str +
			SdaiSession.line_separator + "   Line: " + line +
			SdaiSession.line_separator + "   Column: " + token.column;
		throw new SdaiException(SdaiException.SY_ERR, base);
	}


	final private void string_warning(SdaiSession session, String warning_message, String str, Token token, int shift)
			throws SdaiException {
		int line = token.line + 1;
		int column = token.column + shift;
		String text = warning_message +
			SdaiSession.line_separator + AdditionalMessages.RD_WSTR + str +
			SdaiSession.line_separator + "   Line: " + line +
			SdaiSession.line_separator + "   Column: " + column;
		if (session != null && session.logWriterSession != null) {
			session.printlnSession(text);
		} else {
			SdaiSession.println(text);
		}
	}


	final private void parsing_warning(SdaiSession session, Token token, int error_index,
			String str1, String str2) throws SdaiException {
		int line = token.line + 1;
		String str = null;
		switch (token.type) {
			case INTEGER:
				str = Integer.toString(token.integer);
				break;
			case REAL:
				str = Double.toString(token.real);
				break;
			case LOGICAL:
				str = Integer.toString(token.integer);
				break;
			case ENUM:
				str = getStringBasicLatin();
				break;
			case STRING:
				str = getString();
				break;
			case ENTITY_NAME:
				str = getStringBasicLatin();
				break;
			case INSTANCE_NAME:
				str = "#" + token.integer;
				break;
			case LPAREN:
				str = "(";
				break;
		}
		String text = AdditionalMessages.RD_PARS +
			(String)error_table.messages.get(new Integer(error_index)) +
			SdaiSession.line_separator + "   Line: " + line +
			SdaiSession.line_separator + "   Column: " + token.column;
		if (str != null) {
			text = text + SdaiSession.line_separator + AdditionalMessages.RD_WTOK + str;
		}
		if (str2 != null) {
			text = text + SdaiSession.line_separator + str1 + str2;
		}
		if (session != null && session.logWriterSession != null) {
			session.printlnSession(text);
		} else {
			SdaiSession.println(text);
		}
	}


/**
	Prints a warning message to logo file.
*/
	private static void printWarningToLogo(SdaiSession session, String text, String section_name) throws SdaiException {
		if (session != null && session.logWriterSession != null) {
			session.printlnSession(text + SdaiSession.line_separator +
//				AdditionalMessages.RD_PHFI + phys_file + SdaiSession.line_separator +
				AdditionalMessages.RD_SENA + section_name);
		} else {
			SdaiSession.println(text + SdaiSession.line_separator +
//				AdditionalMessages.RD_PHFI + phys_file + SdaiSession.line_separator +
				AdditionalMessages.RD_SENA + section_name);
		}
	}


/**
	Prints a warning message to logo file.
*/
	private static void printWarningToLogo(SdaiSession session, String text, String file_pop, String wrong_token)
			throws SdaiException {
		if (session != null && session.logWriterSession != null) {
			session.printlnSession(text + SdaiSession.line_separator +
//				AdditionalMessages.RD_PHFI + phys_file + SdaiSession.line_separator +
				AdditionalMessages.RD_FPOP + file_pop + SdaiSession.line_separator +
				AdditionalMessages.RD_WTOK + wrong_token);
		} else {
			SdaiSession.println(text + SdaiSession.line_separator +
//				AdditionalMessages.RD_PHFI + phys_file + SdaiSession.line_separator +
				AdditionalMessages.RD_FPOP + file_pop + SdaiSession.line_separator +
				AdditionalMessages.RD_WTOK + wrong_token);
		}
	}


	static void printWarningToLogoSchiInst(SdaiSession session, String text, 
			String schema, String included_schema) throws SdaiException {
		if (session != null && session.logWriterSession != null) {
			session.printlnSession(text + SdaiSession.line_separator +
				AdditionalMessages.BF_SCH + schema + SdaiSession.line_separator +
				AdditionalMessages.BF_ISCH + included_schema);
		} else {
			SdaiSession.println(text + SdaiSession.line_separator +
				AdditionalMessages.BF_SCH + schema + SdaiSession.line_separator +
				AdditionalMessages.BF_ISCH + included_schema);
		}
	}


/**
	Prints a warning message to logo file.
*/
	private static void printWarningToLogo(SdaiSession session, String file_name) throws SdaiException {
		String base = AdditionalMessages.RD_OSC1 + file_name + AdditionalMessages.RD_OSC2;
		if (session != null && session.logWriterSession != null) {
			session.printlnSession(base);
		} else {
			SdaiSession.println(base);
		}
	}


/**
	A method for debugging purposes. Used to print the contents of
	ComplexEntityValue.
*/
	private void print_entity_values(long instance_identifier) throws SdaiException {
		int count = entity_values.def.noOfPartialEntityTypes;
		System.out.println("INSTANCE: #" + instance_identifier);
		for (int i = 0; i < count; i++) {
			EntityValue partval = entity_values.entityValues[i];
			String def_name = entity_values.def.partialEntityTypes[i].name;
			System.out.println("****** partial entity no. " + i + "   entity: " + def_name);
			for (int j = 0; j < partval.count; j++) {
				print_value(partval.values[j]);
				System.out.println("");
			}
		}
	}


/**
	A method for debugging purposes.
*/
	private void print_value(Value val) {
		Value value_next;
		String str;
		switch (val.tag) {
			case MISSING:
				System.out.print("$  ");
				break;
			case REDEFINE:
				System.out.print("*  ");
				break;
			case INTEGER:
				System.out.print(val.integer + "  ");
				break;
			case REAL:
				System.out.print(val.real + "  ");
				break;
			case LOGICAL:
				if (val.integer == 0) {
					System.out.print(".F.  ");
				} else if (val.integer == 1) {
					System.out.print(".T.  ");
				} else {
					System.out.print(".U.  ");
				}
				break;
			case ENUM:
				System.out.print("." + val.string + ".  ");
				break;
			case STRING:
				System.out.print("'" + val.string + "'  ");
				break;
			case BINARY:
				System.out.print("\"" + BINARY + "\"  ");
				break;
			case TYPED_PARAMETER:
				System.out.print(val.string + "(");
				value_next = val.nested_values[0];
				print_value(value_next);
				System.out.print(")  ");
				break;
			case ENTITY_REFERENCE:
				Object ref = val.reference;
				String ref_class = ref.getClass().getName();
				System.out.print(ref_class + "  ");
//				System.out.print("REF  ");
				break;
			case ENTITY_REFERENCE_SPECIAL:
				System.out.print("REF FORWARD  ");
				break;
			case EMBEDDED_LIST:
				System.out.print("(");
				for (int i = 0; i < val.length; i++) {
					value_next = val.nested_values[i];
					print_value(value_next);
				}
				System.out.print(")  ");
				break;
			}
	}



}
