/*
 * $Id$
 *
 * JSDAI(TM), a way to implement STEP, ISO 10303
 * Copyright (C) 1997-2008, LKSoftWare GmbH, Germany
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License
 * version 3 as published by the Free Software Foundation (AGPL v3).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * JSDAI is a registered trademark of LKSoftWare GmbH, Germany
 * This software is also available under commercial licenses.
 * See also http://www.jsdai.net/
 */

/* Generated By:JJTree: Do not edit this line. X_DependentMapDecl.java */

package jsdai.expressCompiler;

import java.util.*;
import java.io.*;
import jsdai.lang.*;
import jsdai.SExtended_dictionary_schema.*;


public class X_DependentMapDecl extends SimpleNode {


EDependent_map_definition definition;

  public X_DependentMapDecl(int id) {
    super(id);
  }

  public X_DependentMapDecl(Compiler2 p, int id) {
    super(p, id);
  }


  /** Accept the visitor. **/
  public Object jjtAccept(Compiler2Visitor visitor, Object data) throws jsdai.lang.SdaiException {
    return visitor.visit(this, data);
  }


  public Object childrenAccept(Compiler2Visitor visitor, Object data) throws jsdai.lang.SdaiException {
    JavaClass jc = ( JavaClass )data;
		PrintWriter pw = jc.pw;

		switch (jc.secondary) {
			case 1: // supertype map, WHERE rule
				break;
			case 2: // supertype map, processing map attributes
				break;
			case 0:
			default:

				String map_name = definition.getName(null);
				String map_class_name = "M" + map_name.substring(0, 1).toUpperCase() + map_name.substring(1).toLowerCase();
				pw.println("public class " + map_class_name + " {");
				pw.println("");

				ATarget_parameter atp = definition.getTarget_parameters(null, null);

pw.println("// <01> atp: " + atp.getMemberCount());
	
				jsdai.lang.SdaiIterator tpi = atp.createIterator();

//				String etar_type = "" ;


	 			tpi.next();
				ETarget_parameter tp = (ETarget_parameter)atp.getCurrentMemberObject(tpi); //here
pw.println("// <02> tp: " + tp);
				String tp_name = tp.getName(null);
				EEntity_definition tp_extent = tp.getExtent(null);
				String tp_extent_name = tp_extent.getName(null);
//				String atar_type = getEntityPackage(tp_extent, jc.model) + "A" + tp_extent_name.substring(0, 1).toUpperCase() + tp_extent_name.substring(1).toLowerCase();
//				etar_type = getEntityPackage(tp_extent, jc.model) + "E" + tp_extent_name.substring(0, 1).toUpperCase() + tp_extent_name.substring(1).toLowerCase();

/*
				while (tpi.next()) {

					ETarget_parameter tp = (ETarget_parameter)atp.getCurrentMemberObject(tpi); //here
					String tp_name = tp.getName(null);
					EEntity_definition tp_extent = tp.getExtent(null);
					String tp_extent_name = tp_extent.getName(null);

				  for (int i = 0; i < children.length; i++) {
						if (children[i] instanceof X_DepMapPartition) {
							children[i].jjtAccept(visitor, data);
						}
        	} // children
				} // through target parameters
*/
//---------------------------------- start --------------------------------------------------------------------------------------

			if (atp.getMemberCount() < 2) {

			String partition_suffix = "";
//			AMap_partition am_p2 = definition.getPartitions(null, null);
//pw.println("// <01> am_p2 partitions: " + am_p2.getMemberCount());
			//SdaiIterator mp_i2 = am_p2.createIterator();
//			while (mp_i2.next()) {
//				EMap_partition m_p2 = (EMap_partition)am_p2.getCurrentMemberObject(mp_i2);
				//String m_p_name2 = m_p2.getName(null);
// System.out.println("partition: " + m_p_name);				
// pw.println("\t//---partition: " + m_p_name);

			for (int i = 0; i < children.length; i++) {
				if (children[i] instanceof X_DepMapPartition) {
				
				EDependent_map_partition m_p2 = ((X_DepMapPartition)children[i]).partition;
				String m_p_name2 = m_p2.getName(null);

				if(m_p_name2.equalsIgnoreCase("_implicit_partition_")){
					m_p_name2 = "default";
				} else {
					partition_suffix = "Partition_" + m_p_name2;
				}
				

				// wee need this only when one target parameter, I think
				pw.println("\tprotected static Value call" + partition_suffix + "(SdaiContext _context, Value input) throws SdaiException {");
//				pw.println("\tprotected static Value call(SdaiContext _context, Value input) {");
			  pw.println("\t\tValue result;");

			pw.println("\t\tSdaiModel src_model = _context.src_model;");
			pw.println("\t\tSdaiModel tar_model = _context.tar_model;");
//			pw.println("\t\tVector instances_partition_default;");
//RR			pw.println("\t\tHashtable target_instances;");
			pw.println("\t\tHashtable target_instances = new Hashtable();");
			pw.println("");
//			pw.println("\t\t_context.mapHashTable = new Hashtable();");
			pw.println("");


//				pw.println("\t\tresult = callPartition_" + m_p_name + "(src_model, tar_model, target_instances, _context, input);");
				pw.println("\t\tresult = callPartition_" + m_p_name2 + "(src_model, tar_model, target_instances, _context, input);");
				pw.println("\t\treturn result;");
				pw.println("\t}");
         
        } // if partition
			 } // through partitions    	
			 


/*
			String partition_suffix = "";
			AMap_partition am_p2 = definition.getPartitions(null, null);
pw.println("// <01> am_p2 partitions: " + am_p2.getMemberCount());
			SdaiIterator mp_i2 = am_p2.createIterator();
			while (mp_i2.next()) {
				EMap_partition m_p2 = (EMap_partition)am_p2.getCurrentMemberObject(mp_i2);
				String m_p_name2 = m_p2.getName(null);
// System.out.println("partition: " + m_p_name);				
// pw.println("\t//---partition: " + m_p_name);
				if(m_p_name2.equalsIgnoreCase("_implicit_partition_")){
					m_p_name2 = "default";
				} else {
					partition_suffix = "Partition_" + m_p_name2;
				}
				

				// wee need this only when one target parameter, I think
				pw.println("\tprotected static Value call" + partition_suffix + "(SdaiContext _context, Value input) throws SdaiException {");
//				pw.println("\tprotected static Value call(SdaiContext _context, Value input) {");
			  pw.println("\t\tValue result;");

			pw.println("\t\tSdaiModel src_model = _context.src_model;");
			pw.println("\t\tSdaiModel tar_model = _context.tar_model;");
//			pw.println("\t\tVector instances_partition_default;");
//RR			pw.println("\t\tHashtable target_instances;");
			pw.println("\t\tHashtable target_instances = new Hashtable();");
			pw.println("");
//			pw.println("\t\t_context.mapHashTable = new Hashtable();");
			pw.println("");


//				pw.println("\t\tresult = callPartition_" + m_p_name + "(src_model, tar_model, target_instances, _context, input);");
				pw.println("\t\tresult = callPartition_" + m_p_name2 + "(src_model, tar_model, target_instances, _context, input);");
				pw.println("\t\treturn result;");
				pw.println("\t}");

			 } // through partitions    	
  
*/  
    	}


			if (atp.getMemberCount() < 2) {

			String partition_suffix = "";
//			AMap_partition am_p2 = definition.getPartitions(null, null);
//			SdaiIterator mp_i2 = am_p2.createIterator();
	//		while (mp_i2.next()) {



			for (int i = 0; i < children.length; i++) {
				if (children[i] instanceof X_DepMapPartition) {
				
				EDependent_map_partition m_p2 = ((X_DepMapPartition)children[i]).partition;

//				EMap_partition m_p2 = (EMap_partition)am_p2.getCurrentMemberObject(mp_i2);
				String m_p_name2 = m_p2.getName(null);
// System.out.println("partition: " + m_p_name);				
// pw.println("\t//---partition: " + m_p_name);
				if(m_p_name2.equalsIgnoreCase("_implicit_partition_")){
					m_p_name2 = "default";
				} else {
					partition_suffix = "Partition_" + m_p_name2;
				}
    
			pw.println("\tprotected static Value callTarget_" + tp_name +  partition_suffix + "(SdaiContext _context, Value input) throws SdaiException {");
//			pw.println("\tprotected static Value callTarget_" + tp_name + "(SdaiContext _context, Value input) {");
			  pw.println("\t\tValue result;");

			pw.println("\t\tSdaiModel src_model = _context.src_model;");
			pw.println("\t\tSdaiModel tar_model = _context.tar_model;");
//			pw.println("\t\tVector instances_partition_default;");
//RR			pw.println("\t\tHashtable target_instances;");
			pw.println("\t\tHashtable target_instances = new Hashtable();");
			pw.println("");
//			pw.println("\t\t_context.mapHashTable = new Hashtable();");
			pw.println("");


//				pw.println("\t\tresult = callPartition_" + m_p_name + "(src_model, tar_model, target_instances, _context, input);");
				jc.target = null;
				pw.println("\t\tresult = callPartition_" + m_p_name2 + "(src_model, tar_model, target_instances, _context, input);");
			pw.println("\t\treturn result;");
			pw.println("\t}");

/*
			String partition_suffix = "";
			AMap_partition am_p2 = definition.getPartitions(null, null);
			SdaiIterator mp_i2 = am_p2.createIterator();
			while (mp_i2.next()) {
				EMap_partition m_p2 = (EMap_partition)am_p2.getCurrentMemberObject(mp_i2);
				String m_p_name2 = m_p2.getName(null);
// System.out.println("partition: " + m_p_name);				
// pw.println("\t//---partition: " + m_p_name);
				if(m_p_name2.equalsIgnoreCase("_implicit_partition_")){
					m_p_name2 = "default";
				} else {
					partition_suffix = "Partition_" + m_p_name2;
				}
    
			pw.println("\tprotected static Value callTarget_" + tp_name +  partition_suffix + "(SdaiContext _context, Value input) throws SdaiException {");
//			pw.println("\tprotected static Value callTarget_" + tp_name + "(SdaiContext _context, Value input) {");
			  pw.println("\t\tValue result;");

			pw.println("\t\tSdaiModel src_model = _context.src_model;");
			pw.println("\t\tSdaiModel tar_model = _context.tar_model;");
//			pw.println("\t\tVector instances_partition_default;");
//RR			pw.println("\t\tHashtable target_instances;");
			pw.println("\t\tHashtable target_instances = new Hashtable();");
			pw.println("");
//			pw.println("\t\t_context.mapHashTable = new Hashtable();");
			pw.println("");


//				pw.println("\t\tresult = callPartition_" + m_p_name + "(src_model, tar_model, target_instances, _context, input);");
				jc.target = null;
				pw.println("\t\tresult = callPartition_" + m_p_name2 + "(src_model, tar_model, target_instances, _context, input);");
			pw.println("\t\treturn result;");
			pw.println("\t}");

*/
			 } // if partition

    	} // through partitions

			} else {
				// multiple targets			


			jsdai.lang.SdaiIterator tpi2 = atp.createIterator();

			while (tpi2.next()) {
				
			ETarget_parameter tp2 = (ETarget_parameter)atp.getCurrentMemberObject(tpi2); //here
			String tp2_name = tp2.getName(null);


			String partition_suffix = "";
//			AMap_partition am_p2 = definition.getPartitions(null, null);
//			SdaiIterator mp_i2 = am_p2.createIterator();
//			while (mp_i2.next()) {
//				EMap_partition m_p2 = (EMap_partition)am_p2.getCurrentMemberObject(mp_i2);


			for (int i = 0; i < children.length; i++) {
				if (children[i] instanceof X_DepMapPartition) {
				
				EDependent_map_partition m_p2 = ((X_DepMapPartition)children[i]).partition;

				String m_p_name2 = m_p2.getName(null);
// System.out.println("partition: " + m_p_name);				
// pw.println("\t//---partition: " + m_p_name);
				if(m_p_name2.equalsIgnoreCase("_implicit_partition_")){
					m_p_name2 = "default";
				} else {
					partition_suffix = "Partition_" + m_p_name2;
				}



			pw.println("\tprotected static Value callTarget_" + tp2_name + partition_suffix + "(SdaiContext _context, Value input) throws SdaiException {");
//			pw.println("\tprotected static Value callTarget_" + tp_name + "(SdaiContext _context, Value input) {");
			  pw.println("\t\tValue result;");

			pw.println("\t\tSdaiModel src_model = _context.src_model;");
			pw.println("\t\tSdaiModel tar_model = _context.tar_model;");
//			pw.println("\t\tVector instances_partition_default;");
//RR			pw.println("\t\tHashtable target_instances;");
			pw.println("\t\tHashtable target_instances = new Hashtable();");
			pw.println("");
//			pw.println("\t\t_context.mapHashTable = new Hashtable();");
			pw.println("");


//				pw.println("\t\tresult = callPartition_" + m_p_name + "(src_model, tar_model, target_instances, _context, input);");
			// jc.target = tp2;
				pw.println("\t\tresult = callTarget_" + tp2_name + "Partition_" + m_p_name2 + "(src_model, tar_model, target_instances, _context, input);");
			// jc.target = null;
			pw.println("\t\treturn result;");
			pw.println("\t}");

			 } // if partition
	    } // through partitions			
		} // through targets
			



/*

			jsdai.lang.SdaiIterator tpi2 = atp.createIterator();

			while (tpi2.next()) {
				
			ETarget_parameter tp2 = (ETarget_parameter)atp.getCurrentMemberObject(tpi2); //here
			String tp2_name = tp2.getName(null);


			String partition_suffix = "";
			AMap_partition am_p2 = definition.getPartitions(null, null);
			SdaiIterator mp_i2 = am_p2.createIterator();
			while (mp_i2.next()) {
				EMap_partition m_p2 = (EMap_partition)am_p2.getCurrentMemberObject(mp_i2);
				String m_p_name2 = m_p2.getName(null);
// System.out.println("partition: " + m_p_name);				
// pw.println("\t//---partition: " + m_p_name);
				if(m_p_name2.equalsIgnoreCase("_implicit_partition_")){
					m_p_name2 = "default";
				} else {
					partition_suffix = "Partition_" + m_p_name2;
				}



			pw.println("\tprotected static Value callTarget_" + tp2_name + partition_suffix + "(SdaiContext _context, Value input) throws SdaiException {");
//			pw.println("\tprotected static Value callTarget_" + tp_name + "(SdaiContext _context, Value input) {");
			  pw.println("\t\tValue result;");

			pw.println("\t\tSdaiModel src_model = _context.src_model;");
			pw.println("\t\tSdaiModel tar_model = _context.tar_model;");
//			pw.println("\t\tVector instances_partition_default;");
//RR			pw.println("\t\tHashtable target_instances;");
			pw.println("\t\tHashtable target_instances = new Hashtable();");
			pw.println("");
//			pw.println("\t\t_context.mapHashTable = new Hashtable();");
			pw.println("");


//				pw.println("\t\tresult = callPartition_" + m_p_name + "(src_model, tar_model, target_instances, _context, input);");
			// jc.target = tp2;
				pw.println("\t\tresult = callTarget_" + tp2_name + "Partition_" + m_p_name2 + "(src_model, tar_model, target_instances, _context, input);");
			// jc.target = null;
			pw.println("\t\treturn result;");
			pw.println("\t}");


	    } // through partitions			
		} // through targets
	
*/	
			
			} // multiple targets



// --------------------------------- end --------------------------------------------------------------------------------------------

		pw.println("");
		pw.println("\t/*---------------------- methods implementing  map calls for each partition --------------------*/");
		pw.println("");

		if (definition.testSuper_type(null)) {
			//TODO
		} else { // nut a subtype dependent_map
			 // perhaps do it in the partition node: X_DepMapPartition

			for (int i = 0; i < children.length; i++) {
				if (children[i] instanceof X_DepMapPartition) {
					children[i].jjtAccept(visitor, data);
				} else {
					pw.println("// DependentMapDecl node: "  + children[i]);
					
				}
			}
		
		}


				break; // case 0;				
	 	} // switch jc.secondary
		return data;
	
	} // childrenAccept

/*
  String getEntityPackage(EEntity_definition eds) throws SdaiException {
    // return an empty string if ed and eds in the same schema, and the package of eds otherwise
    String entity_package = "";
    SdaiModel entity_model = eds.findEntityInstanceSdaiModel();

    //    if (entity_model != current_model) {
    String entity_schema_name = getSchema_definitionFromModel(entity_model).getName(null);

    if (entity_schema_name.equalsIgnoreCase("Sdai_dictionary_schema")) {
      entity_package = "jsdai.dictionary.";
    } else {
      entity_package = "jsdai.S" + entity_schema_name.substring(0, 1).toUpperCase() + 
                       entity_schema_name.substring(1).toLowerCase() + ".";
    }

    //    }
    return entity_package;
  }
*/

/*
  EGeneric_schema_definition getSchema_definitionFromModel(SdaiModel sm) throws jsdai.lang.SdaiException {
    jsdai.lang.Aggregate ia = sm.getEntityExtentInstances(EGeneric_schema_definition.class);
    jsdai.lang.SdaiIterator iter_inst = ia.createIterator();

    while (iter_inst.next()) {
      EGeneric_schema_definition inst = ( EGeneric_schema_definition )ia.getCurrentMemberObject(iter_inst);
      return inst;
    }

    return null;
	  }
*/

}
