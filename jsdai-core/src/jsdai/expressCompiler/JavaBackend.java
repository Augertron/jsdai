/*
 * $Id$
 *
 * JSDAI(TM), a way to implement STEP, ISO 10303
 * Copyright (C) 1997-2008, LKSoftWare GmbH, Germany
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License
 * version 3 as published by the Free Software Foundation (AGPL v3).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * JSDAI is a registered trademark of LKSoftWare GmbH, Germany
 * This software is also available under commercial licenses.
 * See also http://www.jsdai.net/
 */

/*

Vaidas:

mano siulymas pridet tiesiog dar viena rakta
-special_class_suffix_match <regex>
ir tai visus klausimus isspredzia ir be to lanksciai


sita darai viena karta:
Matcher specialClassSuffixMatcher = Pattern.compile(args[i], Pattern.CASE_INSENSITIVE).matcher("");

o sita darai su schemos vardu:
specialClassSuffixMatcher..reset(schemaName);
if(specialClassSuffixMatcher.matches()) {
 pridetiSpecialClassSuffix;
}




*/

/*
Java inheritance for entity classes is disabled.
To enable, uncomment //2.1
in generateEntityClass() - for has_supertypes flag,
in collectAttributes() - 6 changes from _SUPERTYPE_ to _JAVA_
 */
package jsdai.expressCompiler;

import java.io.*;
import java.util.regex.*;
import java.util.*;

import jsdai.SExtended_dictionary_schema.*;
import jsdai.lang.*;


public class JavaBackend {
	Compiler2 parser;
  static String select_two_dollars = null;
  static final int SELECT_ENTITIES_ONLY = 0;
  static final int SELECT_MIXED = 1;
  static final int SELECT_DEFINED_TYPES_ONLY = 2;
  static final int AA_JAVA_EXPLICIT = 1;
  static final int AA_JAVA_EXPLICIT_REDECLARING = 2;
  static final int AA_SUPERTYPE_EXPLICIT = 3;
  static final int AA_SUPERTYPE_EXPLICIT_REDECLARING = 4;
  static final int AA_CURRENT_EXPLICIT = 5;
  static final int AA_CURRENT_EXPLICIT_REDECLARING = 6;
  static final int AA_JAVA_DERIVED = 7;
  static final int AA_JAVA_DERIVED_REDECLARING = 8;
  static final int AA_SUPERTYPE_DERIVED = 9;
  static final int AA_SUPERTYPE_DERIVED_REDECLARING = 10;
  static final int AA_CURRENT_DERIVED = 11;
  static final int AA_CURRENT_DERIVED_REDECLARING = 12;
  static final int AA_JAVA_INVERSE = 13;
  static final int AA_JAVA_INVERSE_REDECLARING = 14;
  static final int AA_SUPERTYPE_INVERSE = 15;
  static final int AA_SUPERTYPE_INVERSE_REDECLARING = 16;
  static final int AA_CURRENT_INVERSE = 17;
  static final int AA_CURRENT_INVERSE_REDECLARING = 18;
  static final int AA_JAVA_EXPLICIT_TO_DERIVED = 19;
  static final int AA_SUPERTYPE_EXPLICIT_TO_DERIVED = 20;
  static final int AA_CURRENT_EXPLICIT_TO_DERIVED = 21; // I think this case is hardly possible.
	static final int AA_SUPERTYPE_EXPLICIT_TO_DERIVED_RENAMED = 22;
  static JavaBackend java_backend_inst = null;
  static X_AllSchemas tree;
  static SdaiModel static_model;
	static SdaiRepository repo;

	static boolean debug_java = true;
	static boolean replace_object_by_entity = true; // this condition could be removed later if everything is ok after transition

	static boolean flag_generate_map_methods_in_node = true;


  static boolean flag_process_all_domain_rules = false;
  static boolean flag_print_failed_domain_rule = false;

  static boolean flag_value = true;
  static boolean flag_verbose = false;
  static boolean flag_deep_debug = false;
	static boolean flag_split_debug = false;
//  static boolean flag_split_debug = true;
  static boolean flag_debug = false;
  static boolean flag_express_x = true;
//	static boolean flag_no_print_active_nodes = false;
	static boolean flag_no_print_active_nodes = true;
  static boolean flag_expressions = false;
	static boolean flag_serialize = false;
	static boolean flag_incremental_enabled = false;
	String lksoft_header = "";
	String compiler_version = "";
	//FIXME: suspended;  static Vector pdb = new Vector();
  boolean debug_mode;
  boolean verbose_mode;
  boolean java_inheritance_enabled;
  String time_stamp;
  String output_directory;
  SdaiModel model;
  SdaiModel java_model;

	static	Vector global_all_attributes ;
  static		Vector global_all_flags;
	static	ArrayList global_all_attributes_all;
	static	ArrayList global_all_flags_all;
	static	Vector global_all_attributes_ext;
	static	Vector global_all_flags_ext;


  HashSet select_loops;


  //  ESchema_definition sd;
  EGeneric_schema_definition sd;
  EEntity_definition _ed;

  static void printVerbose(String msg) {
    if (flag_verbose) {
      System.out.println("Express Compiler> " + msg);
    }
  }

  static void printDebug(String msg) {
    if (flag_debug) {
      System.out.println("EC DEBUG> " + msg);
    }
  }

  static void printDDebug(String msg) {
    if (flag_deep_debug) {
      System.out.println("EC DEEP DEBUG> " + msg);
    }
  }

  void runMe(SdaiRepository repository, boolean f_inherit, boolean f_verbose, boolean f_debug, 
             boolean f_value, boolean f_expressions, X_AllSchemas x_data, boolean f_serialize,
             String xc_version, String xc_build, String xc_date, Compiler2 the_parser, String output_dir)
      throws SdaiException, IOException {

		debug_java = true;	

    java_backend_inst = this;

//    testing the parser invoked from here on a string

//		String the_string_schema = "SCHEMA test_string;ENTITY entity_a;attr1 : INTEGER;END_ENTITY;END_SCHEMA;";	
//		System.out.println("XXXXXXXX testing parser - start");
//    X_AllSchemas xall = Compiler2.runParser(the_string_schema);
//    xall.dump("STRING NODE: ");
//		System.out.println("XXXXXXXX testing parser - end: " + xall);

// 		Calendar calendar = new GregorianCalendar();
// 		String comp_date = calendar.get(Calendar.YEAR) + " " +
// 			calendar.get(Calendar.MONTH) + " " +
// 			calendar.get(Calendar.DAY_OF_MONTH) +" ";

		String comp_date = "2003-04-23";
//		compiler_version = "3.5" + ", " + comp_date;
		compiler_version = xc_version + "." + xc_build + ", " + xc_date;

//		lksoft_header = "/* Generated by JSDAI Express Compiler, Version " + compiler_version + " */";

		lksoft_header = "/* Generated by JSDAI Express Compiler, version " + xc_version + ", build " + xc_build + ", " + xc_date + " */";


    output_directory = output_dir;
		parser = the_parser;
    String jsdai_name = "jsdai";
    File jsdai_dir = null;
		if (output_directory != null) {
			jsdai_name = output_directory + File.separator + jsdai_name;
	    jsdai_dir = new File(jsdai_name);
  	  jsdai_dir.mkdirs();
		} else {
      jsdai_dir = new File(jsdai_name);
    	jsdai_dir.mkdir();
		}

    tree = x_data;
    repo = repository;
    java_inheritance_enabled = f_inherit;
    flag_value = f_value;
    flag_serialize = f_serialize;
    flag_incremental_enabled = f_serialize;
    flag_verbose = f_verbose;
    flag_debug = f_debug;
    flag_expressions = f_expressions;
    System.out.println("Java backend is running");
    time_stamp = get_time();

    ASdaiModel models = repository.getModels();
    printDebug("Number of models: " + models.getMemberCount());

    SdaiIterator iter_model = models.createIterator();

    while (iter_model.next()) {
      model = models.getCurrentMember(iter_model);

      String model_name = model.getName();

			if (skipModel(model_name)) {
				continue;
			}

/*			
      String part_model_name = model_name.substring(0, 13);

      if (part_model_name.equalsIgnoreCase("_EXPRESSIONS_")) {
        continue;
      }

      part_model_name = model_name.substring(0, 9);

      if (part_model_name.equalsIgnoreCase("_EXPRESS_")) {
        continue;
      }

      part_model_name = model_name.substring(0, 6);

      if (part_model_name.equalsIgnoreCase("_JAVA_")) {
        continue;
      }
*/

      if (model.getMode() == SdaiModel.NO_ACCESS) {
        model.startReadOnlyAccess();
      }

      if (model.getMode() != SdaiModel.READ_WRITE) {
        continue;
      }

      clearAggregateDepths();
    }

    iter_model = models.createIterator();

    while (iter_model.next()) {
      model = models.getCurrentMember(iter_model);

      String model_name = model.getName();

			if (skipModel(model_name)) {
				continue;
			}

/*
      String part_model_name = model_name.substring(0, 13);

      if (part_model_name.equalsIgnoreCase("_EXPRESSIONS_")) {
        continue;
      }

      part_model_name = model_name.substring(0, 9);

      if (part_model_name.equalsIgnoreCase("_EXPRESS_")) {
        continue;
      }

      part_model_name = model_name.substring(0, 6);

      if (part_model_name.equalsIgnoreCase("_JAVA_")) {
        continue;
      }

*/

      if (model.getMode() == SdaiModel.NO_ACCESS) {
        model.startReadOnlyAccess();
      }

      if (model.getMode() != SdaiModel.READ_WRITE) {
        continue;
      }

      sd = getSchema_definitionFromModel(model);

      if (sd == null) {
        String sdai_model_name = model.getName();
        String partial_name = sdai_model_name.substring(0, 14);

        //         System.out.println(partial_name);
        if (!partial_name.equalsIgnoreCase("_DOCUMENTATION")) {
          System.out.println("Express Compiler> Schema definition not found for model: " + 
                             model.getName());
        }

        continue;
      }

      java_model = findJavaModel(models, model_name);

      String schema_name = sd.getName(null);
      printVerbose("schema: " + schema_name);

      String schema_package = "jsdai" + File.separator + "S" + 
                              schema_name.substring(0, 1).toUpperCase() + 
                              schema_name.substring(1).toLowerCase();
      String schema_package_name = "jsdai.S" + schema_name.substring(0, 1).toUpperCase() + 
                                   schema_name.substring(1).toLowerCase();

      if (schema_name.equalsIgnoreCase("sdai_mapping_schema")) {
        schema_name = "mapping";
        schema_package = "jsdai" + File.separator + "mapping";
        schema_package_name = "jsdai.mapping";
      } else if (schema_name.equalsIgnoreCase("sdai_dictionary_schema")) {
        schema_name = "dictionary";
        schema_package = "jsdai" + File.separator + "dictionary";
        schema_package_name = "jsdai.dictionary";
      }

//      File schema_directory = new File(schema_package);
//      schema_directory.mkdir();
			String schema_package_dir = schema_package;
			File schema_directory = null;
			if (output_directory != null) {
				schema_package_dir = output_directory + File.separator + schema_package;
	      schema_directory = new File(schema_package_dir);
  	    schema_directory.mkdirs();
			} else {
	      schema_directory = new File(schema_package);
  	    schema_directory.mkdir();
			}


      //    generateSchemaClass();
      //    generateTypes();
      clearSelects(repository);
      generateTypeInterfaces(schema_package, schema_package_name);
      generateEntities(schema_package, schema_package_name);
      generateMaps(schema_package, schema_package_name);


      //         generateAggregateClasses(schema_package, schema_package_name);
      generateSpecialClass(schema_package, schema_package_name, schema_name);
    }


    // new extension
    iter_model = models.createIterator();

    while (iter_model.next()) {
      model = models.getCurrentMember(iter_model);

      String model_name = model.getName();

			if (skipModel(model_name)) {
				continue;
			}

/*
      String part_model_name = model_name.substring(0, 13);

      if (part_model_name.equalsIgnoreCase("_EXPRESSIONS_")) {
        continue;
      }

	      part_model_name = model_name.substring(0, 9);

      if (part_model_name.equalsIgnoreCase("_EXPRESS_")) {
        continue;
      }

      part_model_name = model_name.substring(0, 6);

      if (part_model_name.equalsIgnoreCase("_JAVA_")) {
        continue;
      }

 */
  
      if (model.getMode() == SdaiModel.NO_ACCESS) {
        model.startReadOnlyAccess();
      }

      if (model.getMode() != SdaiModel.READ_WRITE) {
        continue;
      }

      sd = getSchema_definitionFromModel(model);

      if (sd == null) {
        String sdai_model_name = model.getName();
        String partial_name = sdai_model_name.substring(0, 14);

        //         System.out.println(partial_name);
        if (!partial_name.equalsIgnoreCase("_DOCUMENTATION")) {
          System.out.println("Express Compiler> Schema definition not found for model: " + 
                             model.getName());
        }

        continue;
      }

      String schema_name = sd.getName(null);
      printVerbose("schema: " + schema_name);

      String schema_package = "jsdai" + File.separator + "S" + 
                              schema_name.substring(0, 1).toUpperCase() + 
                              schema_name.substring(1).toLowerCase();
      String schema_package_name = "jsdai.S" + schema_name.substring(0, 1).toUpperCase() + 
                                   schema_name.substring(1).toLowerCase();

      if (schema_name.equalsIgnoreCase("sdai_mapping_schema")) {
        schema_name = "mapping";
        schema_package = "jsdai" + File.separator + "mapping";
        schema_package_name = "jsdai.mapping";
      } else if (schema_name.equalsIgnoreCase("sdai_dictionary_schema")) {
        schema_name = "dictionary";
        schema_package = "jsdai" + File.separator + "dictionary";
        schema_package_name = "jsdai.dictionary";
      }

//      File schema_directory = new File(schema_package);
//      schema_directory.mkdir();
			String schema_package_dir = schema_package;
			File schema_directory = null;
			if (output_directory != null) {
				schema_package_dir = output_directory + File.separator + schema_package;
	      schema_directory = new File(schema_package_dir);
  	    schema_directory.mkdirs();
			} else {
	      schema_directory = new File(schema_package);
  	    schema_directory.mkdir();
			}
      generateAggregateClasses(schema_package, schema_package_name);
    }

    System.out.println("Java backend ended");
  }

  void clearSelects(SdaiRepository repository1) throws SdaiException {
    ASdaiModel models1 = repository1.getModels();
    SdaiIterator iter_model = models1.createIterator();

    while (iter_model.next()) {
      SdaiModel model1 = models1.getCurrentMember(iter_model);
      String model_name = model1.getName();

 			if (skipModel(model_name)) {
				continue;
			}

/*
     String part_model_name = model_name.substring(0, 13);

      if (part_model_name.equalsIgnoreCase("_EXPRESSIONS_")) {
        continue;
      }

      part_model_name = model_name.substring(0, 9);

      if (part_model_name.equalsIgnoreCase("_EXPRESS_")) {
        continue;
      }

      part_model_name = model_name.substring(0, 6);

      if (part_model_name.equalsIgnoreCase("_JAVA_")) {
        continue;
      }

*/
  
      if (model1.getMode() == SdaiModel.NO_ACCESS) {
        model1.startReadOnlyAccess();
      }

      if (model1.getMode() != SdaiModel.READ_WRITE) {
        continue;
      }

      Aggregate ia = model1.getEntityExtentInstances(ESelect_type.class);
      SdaiIterator iter_inst = ia.createIterator();

      while (iter_inst.next()) {
        ESelect_type inst = (ESelect_type) ia.getCurrentMemberObject(iter_inst);
        inst.setTemp(null);
      }
    }
  }

  void generateTypeInterfaces(String schema_package, String schema_package_name)
                       throws SdaiException, IOException {
    Aggregate adt = model.getEntityExtentInstances(EDefined_type.class);
    SdaiIterator idt = adt.createIterator();

    while (idt.next()) {
      EDefined_type dt = (EDefined_type) adt.getCurrentMemberObject(idt);
      EEntity ut = dt.getDomain(null);

      if (ut instanceof EEnumeration_type) {
//        A_string enelements = ((EEnumeration_type) ut).getElements(null);
//        A_string enelements = ((EEnumeration_type) ut).getLocal_elements(null);
//        A_string enelements = getElements((EEnumeration_type) ut);
        Vector enelements = getElementsV((EEnumeration_type) ut);

        // generate enumeration class
        String the_enum_name = dt.getName(null);
        String class_name = "E" + the_enum_name.substring(0, 1).toUpperCase() + 
                            the_enum_name.substring(1).toLowerCase();
        String class_file = schema_package + File.separator + class_name + ".java";
        PrintWriter pw = getPrintWriter(class_file);

        pw.println(lksoft_header);
        pw.println("");
        pw.println("// Java class implementing enumeration " + the_enum_name);
        pw.println("");
        pw.println("package " + schema_package_name + ";");
        pw.println("import jsdai.lang.*;");
        pw.println("");
        pw.println("public class " + class_name + " {");

        int index = 1;
        pw.println("");
        pw.println("\tprivate static final int unset = 0;");

//        SdaiIterator iter = enelements.createIterator();

//        while (iter.next()) {
//          String element = (String) enelements.getCurrentMemberObject(iter);
//          pw.println("\tpublic static final int " + element.toUpperCase() + " = " + index++ + ";\t// " + element);
//        }

				Iterator iter = enelements.iterator();
				
				while (iter.hasNext()) {
          String element = (String) iter.next();
          pw.println("\tpublic static final int " + element.toUpperCase() + " = " + index++ + ";\t// " + element);
				}
				

        pw.println("");
        pw.println("\tprivate static final int dim = " + (--index) + ";");
        pw.println("");
        pw.print("\tpublic static final String values[] = {");

        boolean first_time = true;
//        iter = enelements.createIterator();
				iter = enelements.iterator();
//        while (iter.next()) {
//          String element = (String) enelements.getCurrentMemberObject(iter);
				while (iter.hasNext()) {
						String element = (String)iter.next();
          if (first_time == true) {
            first_time = false;
          } else {
            pw.print(", ");
          }

          pw.print("\"" + element.toUpperCase() + "\"");
        }

        pw.println("};");


        //          the_name = "C" + name.substring(0,1).toUpperCase() + name.substring(1).toLowerCase();
        pw.println("");
        pw.println("//-------- methods ---------");
        pw.println("");
        pw.println(
              "\tprivate static boolean isSet(int value) { return ((value >= 1) && (value <= dim)); }");
        pw.println("");
        pw.println("\tpublic static int toInt(String str) {");
        pw.println("\t\tfor (int i = 0; i < dim; i++) {");
        pw.println("\t\t\tif (values[i].equalsIgnoreCase(str)) return i+1;");
        pw.println("\t\t}");
        pw.println("\t\treturn unset;");
        pw.println("\t}");
        pw.println("");
        pw.println("\tpublic static String toString(int value) {");
        pw.println("\t\tif (!isSet(value)) return \"unset\";");
        pw.println("\t\treturn values[value-1];");
        pw.println("\t}");
        pw.println("}");
        pw.flush();
        pw.close();
      } else if (ut instanceof ESelect_type) {
        // do not generated for select - no need.
      } else {
        // for all other defined types generate empty interfaces
        String the_type_name = dt.getName(null);
        String interface_name = "E" + the_type_name.substring(0, 1).toUpperCase() + 
                                the_type_name.substring(1).toLowerCase();
        String interface_file = schema_package + File.separator + interface_name + ".java";
        PrintWriter pw = getPrintWriter(interface_file);
        pw.println(lksoft_header);
        pw.println("");
        pw.println("// Java interface implementing type " + the_type_name);
        pw.println("");
        pw.println("package " + schema_package_name + ";");
        pw.println("import jsdai.lang.*;");
        pw.println("");
        pw.println("public interface " + interface_name + " {");
        pw.println("}");
        pw.flush();
        pw.close();
      }
    }
  }

  void generateStaticFieldsForConstantsX(PrintWriter pw, String schema_package, 
                                        String schema_package_name)
                                 throws SdaiException {
		if (!flag_expressions) return;
    Aggregate acd = model.getEntityExtentInstances(EConstant_declaration.class);
    SdaiIterator cdi = acd.createIterator();

    while (cdi.next()) {
      EConstant_declaration cd = (EConstant_declaration) acd.getCurrentMemberObject(cdi);
			if (cd instanceof EInner_declaration) continue;
			if (!(cd instanceof ELocal_declaration)) continue;
			
			EConstant_definition cdef = (EConstant_definition)cd.getDefinition(null);
      // String f_name = fd.getName(null);
      // String class_name = "F" + f_name.substring(0, 1).toUpperCase() + f_name.substring(1).toLowerCase();
      // String class_file = schema_package + File.separator + class_name + ".java";
      // PrintWriter pwf = getPrintWriter(class_file);
      // pwf.println(lksoft_header);
      //pwf.println("");
      //pwf.println("// Java class implementing EXPRESS function " + f_name);
      //pwf.println("");
      //pwf.println("package " + schema_package_name + ";");
      //pwf.println("");
      //pwf.println("public class " + class_name + " {");
      printDDebug("XXXOOOXXX constant name: " + cdef.getName(null));
      generateJavaExpression(pw, cdef, sd, null, model);

      // pwf.println("");
      // pwf.println("}");
      // pwf.flush();
      // pwf.close();
    }
  }

  void generateStaticFieldsForConstants(PrintWriter pw, String schema_package, 
                                        String schema_package_name)
                                 throws SdaiException {
		if (!flag_expressions) return;
    Aggregate acd = model.getEntityExtentInstances(EConstant_definition.class);
    SdaiIterator cdi = acd.createIterator();

    while (cdi.next()) {
      EConstant_definition cd = (EConstant_definition) acd.getCurrentMemberObject(cdi);


      // String f_name = fd.getName(null);
      // String class_name = "F" + f_name.substring(0, 1).toUpperCase() + f_name.substring(1).toLowerCase();
      // String class_file = schema_package + File.separator + class_name + ".java";
      // PrintWriter pwf = getPrintWriter(class_file);
      // pwf.println(lksoft_header);
      //pwf.println("");
      //pwf.println("// Java class implementing EXPRESS function " + f_name);
      //pwf.println("");
      //pwf.println("package " + schema_package_name + ";");
      //pwf.println("");
      //pwf.println("public class " + class_name + " {");
      printDDebug("XXXOOOXXX constant name: " + cd.getName(null));
      generateJavaExpression(pw, cd, sd, null, model);

      // pwf.println("");
      // pwf.println("}");
      // pwf.flush();
      // pwf.close();
    }
  }

  void generateDomainRuleMethodsForDefinedTypes(PrintWriter pw, String schema_package,
                                           String schema_package_name)
                                    throws SdaiException {
		if (!flag_expressions) return;

    Aggregate adt = model.getEntityExtentInstances(EDefined_type.class);
    SdaiIterator idt = adt.createIterator();
    while (idt.next()) {
      EDefined_type dt = (EDefined_type) adt.getCurrentMemberObject(idt);
		  AWhere_rule awr = dt.getWhere_rules(null, null);
			// perhaps it is enough to generate only methods for this defined type, 
			// but run() method should include also methods for all its chained underlying types

    	int where_rule_count = awr.getMemberCount();

    	if (where_rule_count > 0) {
      	pw.println("");
      	pw.println(
        "\t/*--- methods to validate WHERE rules in defined type " + dt.getName(null) + " ---*/");
      	pw.println("");

      	SdaiIterator wri = awr.createIterator();
		
				/*
						in generated expressions, implementation of SELF in defined types is self with the Value type 
						- static type string of the underlying type.
						We also need the corresponding additional parameter in rWR1() and run() methods.
						Perhaps we should use exactly the same type as is generated for attributes of that type in entities?
						It is a safe and logical approach.
						Alternative - interface of the underlying type if it is also a defined type?
						
					
				*/		
      	while (wri.next()) {
        	EWhere_rule wr = (EWhere_rule) awr.getCurrentMemberObject(wri);
        	generateJavaExpression(pw, wr, sd, null, model);
      	} // loop via where rules in the current type
    	}
      // here we need to generate run() methods, not only for the above rule methods, but also for rule methods in underlying types
			// collect all where_rules into an aggregate, then, if it is not empty, generate run() method	
      Vector all_where_rules = findAllDTWhere_rules(dt);
      where_rule_count = all_where_rules.size();
// System.out.println("EEEXXX count: " + where_rule_count);					
    	if (where_rule_count > 0) {
  			if (!flag_print_failed_domain_rule) {
	  			flag_process_all_domain_rules = false;
  			}

				// generate run() method
				boolean more_than_one = false;
				if (where_rule_count > 1) {
					more_than_one = true;
				}

//	      String self_type = constructSelfType(dt);
	      String self_type = "Value";
	      String dt_original_name = dt.getName(null);
	      String dt_name = dt_original_name.substring(0,1).toUpperCase() + dt_original_name.substring(1).toLowerCase();
	      pw.println("\tpublic static int run" + dt_name + "(SdaiContext _context, " + self_type + " self, A_string violations) throws SdaiException {");
				pw.println("\t\tint result;");
  			if (more_than_one) {
					pw.println("\t\tint r;");
  			}
				// fill in the run() method
				boolean first_time = true;
//				Iterator it = all_where_rules.iterator();
//				int i = 0;
				for (int i = 0; i < all_where_rules.size(); i++) {
//				if (it.hasNext()) {
//					EWhere_rule wr = (EWhere_rule)it.next();
					EWhere_rule wr = (EWhere_rule)all_where_rules.elementAt(i);
//					String label = "_WR" + i++; // see what is the name of the method(s) if optional label is missing!!
					String label = "WR1"; // if optional label is not present, assume that there is only one domain rule, and name it WR1.
					if (wr.testLabel(null)) {
						label = wr.getLabel(null);
					}
					String current_dt_original_name = "_SOMETHING_WRONG_WITH_THE_NAME_";
					EEntity current_parent = wr.getParent_item(null);
					EDefined_type current_dt = null;
					if (current_parent instanceof EDefined_type) {
						current_dt = (EDefined_type)current_parent;
						current_dt_original_name = current_dt.getName(null);
					}
// System.out.println("EEEXXX label: " + label + ", type: " + current_dt_original_name);					
					String current_dt_name = current_dt_original_name.substring(0,1).toUpperCase() + current_dt_original_name.substring(1).toLowerCase();
					String normalized_where_rule_name = getTypePackage(current_dt) + "r" + current_dt_name + label.substring(0,1).toUpperCase() + label.substring(1).toLowerCase();

					String wr_stuff = "\"" + current_dt_original_name + "." + label + "\"";


/////--start


					if (more_than_one) {
						if (first_time) {
							first_time = false;
							pw.println("\t\tresult = " + normalized_where_rule_name + "(_context, self);");
							if ((!flag_process_all_domain_rules) || flag_print_failed_domain_rule) {
								pw.println("\t\tif (result == 1) {");
								if (flag_print_failed_domain_rule) {
//									pw.println("\t\t\tSystem.out.println(\"Violation of domain rule " + label + " in defined type " + current_dt_original_name + "\");");
									pw.println("\t\t\tviolations.addUnordered(" + wr_stuff + ");");
								}	
								if (!flag_process_all_domain_rules) {
									pw.println("\t\t\treturn 1;");
								}
								pw.println("\t\t}");
							} 
						} else {
							pw.println("\t\tr = " + normalized_where_rule_name + "(_context, self);");
							if ((!flag_process_all_domain_rules) || flag_print_failed_domain_rule) {
								pw.println("\t\tif (r == 1) {");
									if (flag_print_failed_domain_rule) {
//										pw.println("\t\t\tSystem.out.println(\"Violation of domain rule " + label + " in defined type " + current_dt_original_name + "\");");
										pw.println("\t\t\tviolations.addUnordered(" + wr_stuff + ");");
									}	
									if (!flag_process_all_domain_rules) {
										pw.println("\t\t\treturn 1;");
									} else {
										pw.println("\t\t\tresult = 1;");
									}
								pw.println("\t\t} else");
//								pwr.println("\t\tif ((r == 3) || (r == 0) || (result == 3) || (result == 0)) result = 3;");             	
// 	          		pwr.println("\t\telse result = 2;");
								pw.println("\t\tif ((result == 2) && (r == 2)) ;");             	
 	          	  if (flag_process_all_domain_rules) {
									pw.println("\t\telse if (result != 1) result = 3;");
 	          	  } else { 
 	          			pw.println("\t\telse result = 3;");
								}
							} else {
								//  check if (r == 1) is not needed, other ways are possible, including the check as well, if it seems to be optimal solution
	              pw.println("\t\tif ((r == 1) || (result == 1)) result = 1;");
//  	            pwr.println("\t\telse if ((r == 3) || (r == 0) || (result == 3) || (result == 0)) result = 3;");
//    	          pwr.println("\t\telse result = 2;"); 
								pw.println("\t\telse if ((result == 2) && (r == 2)) ;");             	
 	          		pw.println("\t\telse result = 3;");
							} 
						}
					} else {
//						pw.println("\t\treturn " + normalized_where_rule_name + "(_context, self);");
							pw.println("\t\tresult = " + normalized_where_rule_name + "(_context, self);");
							pw.println("\t\tif (result == 1) {");
								if (flag_print_failed_domain_rule) {
//									pw.println("\t\t\tSystem.out.println(\"Violation of domain rule " + label + " in defined type " + current_dt_original_name + "\");");
									pw.println("\t\t\tviolations.addUnordered(" + wr_stuff + ");");
								}	
							pw.println("\t\t}");
			
					}

			



////-----end



				}
//				if (more_than_one) {
				pw.println("\t\treturn result;");
//				}

	      pw.println("\t}");
			}		
		} // loop via defined types

	}


  String getTypePackage(EDefined_type dt)
                   throws SdaiException {
    String type_package = "";
    SdaiModel type_model = dt.findEntityInstanceSdaiModel();

    if (type_model != model) {
      String type_schema_name = getSchema_definitionFromModel(type_model).getName(null);

      if (type_schema_name.equalsIgnoreCase("Sdai_dictionary_schema")) {
        type_package = "jsdai.dictionary.SDictionary.";
      } else {
        type_package = "jsdai.S" + type_schema_name.substring(0, 1).toUpperCase() + 
                         type_schema_name.substring(1).toLowerCase() + ".S"  + 
                         type_schema_name.substring(0, 1).toUpperCase() +
      									 type_schema_name.substring(1).toLowerCase() + ".";
      }
    }

    return type_package;
  }

	String constructSelfType(EDefined_type dt2) throws SdaiException {

			EEntity bt = dt2.getDomain(null);
			String return_object = "_SOMETHING_WRONG_";
			
      if (bt instanceof ESimple_type) {
        ESimple_type st = (ESimple_type) bt;
        return_object = getDTSimpleTypeString(st);
      } else if (bt instanceof EAggregation_type) {
        EAggregation_type at = (EAggregation_type) bt;
        return_object = getDTAggregateString(at);
      } else if (bt instanceof EDefined_type) {
        EDefined_type dt = (EDefined_type) bt;
        return_object = getDTDefinedTypeString(dt);
      } else if (bt instanceof EEntity_definition) {
        EEntity_definition ed1 = (EEntity_definition) bt;
        String entity_name = ed1.getName(null);
        return_object = "Object";
      } else 
      if (bt instanceof EParameter) {	 // generalized attribute type - ammendment
        return_object = "Object";
      } else 
      if (bt instanceof ESelect_type) {
        return_object = "Object";
      } else 
      if (bt instanceof EEnumeration_type) {
        return_object = "int";
      } else {
      }
		
		return return_object;
	}

  String getDTSimpleTypeString(ESimple_type st) throws SdaiException {
    String return_object = "_WRONG_SIMPLE_";

    if (st instanceof EInteger_type) {
      return_object = "int";
    } else if (st instanceof ENumber_type) {
      return_object = "double";
    } else if (st instanceof EReal_type) {
      return_object = "double";
    } else if (st instanceof EBoolean_type) {
      return_object = "int";
    } else if (st instanceof ELogical_type) {
      return_object = "int";
    } else if (st instanceof EBinary_type) {
      return_object = "Binary";
    } else if (st instanceof EString_type) {
      return_object = "String";
    }

    return return_object;
  }

  String getDTAggregateString(EAggregation_type at) throws SdaiException {
    String return_object = "_WRONG_AGGREGATION_";

    int aggregate_depth = 1;
    EEntity an_ss;
    EEntity ass = at;
    String aggr_prefices = "";
    an_ss = at.getElement_type(null);

    for (;;) {
      boolean done_something = false;

      if (an_ss instanceof EDefined_type) {
        ass = an_ss;
        an_ss = ((EDefined_type) an_ss).getDomain(null);
        done_something = true;
      } else if (an_ss instanceof EAggregation_type) {
        aggr_prefices += "a";
        aggregate_depth++;
        ass = an_ss;


        an_ss = ((EAggregation_type) an_ss).getElement_type(null);
        done_something = true;
      }

      if (!done_something) {
        break;
      }
    }

    String aggr_prefix = "A" + aggr_prefices;

    if (an_ss instanceof ESelect_type) {
      return_object = "" + getAggregatePackage(aggr_prefix, ass);
    } else if (an_ss instanceof EEntity_definition) {
      return_object = "" + getAggregatePackage(aggr_prefix, an_ss);
    } else if (an_ss instanceof EEnumeration_type) {
      return_object = "" + aggr_prefix + "_enumeration";
    } else if (an_ss instanceof EInteger_type) {
      return_object = "" + aggr_prefix + "_integer";
    } else if (an_ss instanceof ENumber_type) {
      return_object = "" + aggr_prefix + "_double";
    } else if (an_ss instanceof EReal_type) {
      return_object = "" + aggr_prefix + "_double";
    } else if (an_ss instanceof EString_type) {
      return_object = "" + aggr_prefix + "_string";
    } else if (an_ss instanceof ELogical_type) {
      return_object = "" + aggr_prefix + "_enumeration";
    } else if (an_ss instanceof EBoolean_type) {
      return_object = "" + aggr_prefix + "_boolean";
    } else if (an_ss instanceof EBinary_type) {
      return_object = "" + aggr_prefix + "_binary";
    } else if (an_ss instanceof EData_type) {
      if (((EData_type)an_ss).getName(null).equalsIgnoreCase("_GENERIC")) { 
	      	return_object = "CAggregate";
    	} else
      if (((EData_type)an_ss).getName(null).equalsIgnoreCase("_ENTITY")) { 
      	return_object = "AEntity";
			}
    }

    return return_object;
  }

  String getDTDefinedTypeString(EDefined_type dt) throws SdaiException {
    String return_object = "";
    EEntity ut = dt.getDomain(null);

    if (ut instanceof ESimple_type) {
      return_object = getDTSimpleTypeString((ESimple_type) ut);
    } else if (ut instanceof EAggregation_type) {
      return_object = getDTAggregateString((EAggregation_type) ut);
    } else if (ut instanceof EDefined_type) {
      return_object = getDTDefinedTypeString((EDefined_type) ut);
    } else if (ut instanceof EEnumeration_type) {
      return_object = "int";
    } else if (ut instanceof ESelect_type) {
      return_object = "Object";
		}

    return return_object;
  }



	Vector  findAllDTWhere_rules(EDefined_type dt) throws SdaiException {
		Vector result = new Vector();

	  // for short forms, we will need correct domain ASdaiModel, not null
	  ASdaiModel domain = null;
	 	
	 	recurseDTWhereRules(dt, result, domain);
		
		return result;
	}


	void recurseDTWhereRules(EDefined_type dt, Vector result, ASdaiModel domain) throws SdaiException {

	  AWhere_rule awr = dt.getWhere_rules(null, domain);
   	SdaiIterator wri = awr.createIterator();
   	while (wri.next()) {
	   	EWhere_rule wr = (EWhere_rule) awr.getCurrentMemberObject(wri);
			result.addElement(wr);
		}	
		EEntity ut = dt.getDomain(null);
		if (ut instanceof EDefined_type) {
			recurseDTWhereRules((EDefined_type)ut, result, domain);
		}
		return;
	}



  void generateStaticFieldsForDefinedTypes(PrintWriter pw, String schema_package, 
                                           String schema_package_name)
                                    throws SdaiException {
		if (!flag_expressions) return;

    Aggregate adt = model.getEntityExtentInstances(EDefined_type.class);
    SdaiIterator idt = adt.createIterator();

		// = SSuper.initSuper(new " + 
		//               schema_definition_name + "());");
	
    while (idt.next()) {
      EDefined_type dt = (EDefined_type) adt.getCurrentMemberObject(idt);
      String type_name = dt.getName(null);

			pw.println("\tpublic static jsdai.dictionary.EDefined_type _st_" + type_name + ";");
		}
		pw.println("");

		pw.println("\tstatic void initDefinedDataTypes(){");
	
		idt.beginning();
    while (idt.next()) {
      EDefined_type dt = (EDefined_type) adt.getCurrentMemberObject(idt);
      String type_name = dt.getName(null);

      // String schema_name = model.getUnderlyingSchema().getName(null);
      String model_name = model.getName();
      String schema_name;

      if (model_name.length() > 16) {
        String part_model_name = model_name.substring(model_name.length() - 16);

        if (part_model_name.equalsIgnoreCase("_DICTIONARY_DATA")) {
          schema_name = model_name.substring(0, model_name.length() - 16);
        } else {
          schema_name = model_name;
        }
      } else {
        schema_name = model_name;
      }

      String type_schema_class = "jsdai.S" + schema_name.substring(0, 1).toUpperCase() + 
                                 schema_name.substring(1).toLowerCase() + ".S" + 
                                 schema_name.substring(0, 1).toUpperCase() + 
                                 schema_name.substring(1).toLowerCase() + ".class";
      pw.println("\t\t_st_" + type_name + 
                 " = (jsdai.dictionary.EDefined_type)SdaiSession.findDataType(\"" + type_name + 
                 "\"," + type_schema_class + ");");
    }
		pw.println("\t}");
		
  }

  void generateStaticFieldsForNonDefinedTypes(PrintWriter pw, String schema_package, 
                                              String schema_package_name)
                                       throws SdaiException {
		if (!flag_expressions) return;
    String static_type_name = null;
    String static_type_express = null;
    HashSet static_names = new HashSet();
		HashSet static_names_inits = new HashSet();

    // this thing is generated on-demand, for the types that are used as attribute, local variable and parameter types.
    // loop through attributes - check the type
    // if defined type - nothing needed
    // if not defined type - if simple type, see if has additional specialization, width, fixed, percision, where applicable
    // if has such an additional specialization - treat as unnamed type, generate static field.
    // if not defined and not simple - generate the static field. Generic types may be considered to be simple types.
    // the same thing repeat for parameters and variables, therefore - a method.

    Aggregate acd = model.getEntityExtentInstances(EConstant_definition.class);
    SdaiIterator ica = acd.createIterator();

		pw.println("");

    while (ica.next()) {
      EConstant_definition cd = (EConstant_definition) acd.getCurrentMemberObject(ica);
      EEntity domain = null;

      if (cd.testDomain(null)) {
        domain = cd.getDomain(null);
      }

      printDDebug("#XX# 001 - constant");
      processDomain(pw, domain, false, static_names, static_names_inits);
    }

    Aggregate aea = model.getEntityExtentInstances(EExplicit_attribute.class);
    SdaiIterator iea = aea.createIterator();

    while (iea.next()) {
      EExplicit_attribute ea = (EExplicit_attribute) aea.getCurrentMemberObject(iea);
      EEntity domain = null;

      if (ea.testDomain(null)) {
        domain = ea.getDomain(null);
      }


      //			printDDebug("XOXOX explicit: " + ea);
      printDDebug("#XX# 002 - explicit");
      processDomain(pw, domain, false, static_names, static_names_inits);
    }

    Aggregate ada = model.getEntityExtentInstances(EDerived_attribute.class);
    SdaiIterator ida = ada.createIterator();

    while (ida.next()) {
      EDerived_attribute da = (EDerived_attribute) ada.getCurrentMemberObject(ida);
      EEntity domain = null;

      if (da.testDomain(null)) {
        domain = da.getDomain(null);
      }

      printDDebug("#XX# 003 - derived");
      processDomain(pw, domain, false, static_names, static_names_inits);
    }

    // loop through parameter types
    Aggregate ap = model.getEntityExtentInstances(EParameter.class);
    SdaiIterator ip = ap.createIterator();

    while (ip.next()) {
      EParameter p = (EParameter) ap.getCurrentMemberObject(ip);

      // domain could be EData_type
      EEntity domain = null;

      if (p.testParameter_type(null)) {
        domain = p.getParameter_type(null);
      }


      // printDDebug("########_____######## : " + domain);
      printDDebug("#XX# 004 - parameter: " + p + ", domain: " + domain);

      if (!p.getName(null).equals("_implicit_variable_")) {
        processDomain(pw, domain, true, static_names, static_names_inits);
      }
    }

    // loop through local variables
    // current implementation creates EParameter instances for local variables.
    // They can be removed after the XC backends are finished.
    // So nothing is needed, the loop through parameters takes care of local variables too.
    // support for population:
    Aggregate adt = model.getEntityExtentInstances(ESet_type.class);
    SdaiIterator idt = adt.createIterator();

    while (idt.next()) {
      ESet_type dt = (ESet_type) adt.getCurrentMemberObject(idt);
      String name = dt.getName(null);

      if (name.length() > 12) {
        String name_part = name.substring(0, 12);

        if (name_part.equalsIgnoreCase("_POPULATION_")) {
          printDDebug("dt.getName(): " + name);
					pw.println("\tpublic static jsdai.dictionary.EData_type _st" + name.toLowerCase() +";");
          static_names_inits.add("\t\t _st" + 
                     name.toLowerCase() + " = SdaiSession.findDataType(\"" + name + "\", " + 
                     constructTypeSchemaClass(null) + ");");
        }
      }
    }

		pw.println("");
		pw.println("\tstatic void initNonDefinedDataTypes(){");

    Iterator iter = static_names_inits.iterator();
		while(iter.hasNext()){
			String str = (String)iter.next();
			pw.println(str);
		}

		pw.println("\t}");
  }

  void processDomain(PrintWriter pw, EEntity domain, boolean is_generic, HashSet static_names, HashSet static_names_inits)
              throws SdaiException {
    if (domain == null) {
      // obviously, nothing to do.
      return;
    } else if (domain instanceof ENamed_type) {
      // again, it is either entity or defined_type for which the static field is already generated.
      return;
    } else if (domain instanceof ESimple_type) {
      // check the types that may have WIDTH FIXED PRECISION - string binary real
      if (domain instanceof EString_type) {
        if (!((EString_type) domain).testWidth(null)) {
          return;
        }

        String static_type_express = constructTypeExpress(domain, is_generic);
        String static_type_name = "_st" + static_type_express.toLowerCase();
        String static_type_schema_class = constructTypeSchemaClass(domain);
        boolean no_duplication = static_names.add(static_type_name);

        if (no_duplication) {
					pw.println("\tpublic static jsdai.dictionary.EData_type " + static_type_name +";");
          static_names_inits.add("\t\t" +static_type_name + 
                     " = SdaiSession.findDataType(\"" + static_type_express + "\", " + 
                     static_type_schema_class + ");");
        }
      } else if (domain instanceof EBinary_type) {
        if (!((EBinary_type) domain).testWidth(null)) {
          return;
        }

        String static_type_express = constructTypeExpress(domain, is_generic);
        String static_type_name = "_st" + static_type_express.toLowerCase();
        String static_type_schema_class = constructTypeSchemaClass(domain);
        boolean no_duplication = static_names.add(static_type_name);

        if (no_duplication) {
					pw.println("\tpublic static jsdai.dictionary.EData_type " + static_type_name +";");
          static_names_inits.add("\t\t" + static_type_name + 
                     " = SdaiSession.findDataType(\"" + static_type_express + "\", " + 
                     static_type_schema_class + ");");
        }
      } else if (domain instanceof EReal_type) {
        if (!((EReal_type) domain).testPrecision(null)) {
          return;
        }

        String static_type_express = constructTypeExpress(domain, is_generic);
        String static_type_name = "_st" + static_type_express.toLowerCase();
        String static_type_schema_class = constructTypeSchemaClass(domain);
        boolean no_duplication = static_names.add(static_type_name);

        if (no_duplication) {
					pw.println("\tpublic static jsdai.dictionary.EData_type " + static_type_name +";");
          static_names_inits.add("\t\t" + static_type_name + 
                     " = SdaiSession.findDataType(\"" + static_type_express + "\", " + 
     		                static_type_schema_class + ");");
        }
      }
    } else {
      // whatever is here certainly needs static defined type. Or maybe not - generic or aggregate do not.
      // I need to eliminate EData_type and EAggregation_type, these two could be separately. but how?
      // No, better leave aggregates, because their element types  may be different.
      // stupid thing to check if EData_type, all are.
      if (domain instanceof EData_type) {
        // possible GENERIC if not any subtype
        // possible subtypes: named_type, enumeration_type, select_type, simple_type, aggregation_type
        if ((!(domain instanceof ENamed_type)) && (!(domain instanceof EEnumeration_type)) && 
                (!(domain instanceof ESelect_type)) && (!(domain instanceof ESimple_type)) && 
                (!(domain instanceof EAggregation_type))) {
          // if suppresses GENERIC which is good.
          return; // generic type. This if statement is stupid, as the only possible things there are data_type and aggregation_type
        }

        // named and simple types are already eliminated, select and enumeration types cannot happen outside named types.
        // so here we have only aggregation_type left. But lets check anyway:
        //            if (domain instanceof EAggregation_type) {
        // generic aggregate and generalized array, bag, list, set are also possible here
        //            } else {
        // internal error.
        //            }
        //printDDebug("XOXOX-3 in process: " + domain);
        String static_type_express = constructTypeExpress(domain, is_generic);

        // no need to construct again, use the same.
        // String static_type_name = constructTypeName(domain);
        String static_type_name = "_st" + static_type_express.toLowerCase();

        // all no-name types are in the current model, it may no longer be true, if they are moved to the models of element types.
        String static_type_schema_class = constructTypeSchemaClass(domain);

        // do we use a generic data type for these static fields here or more specific?
        boolean no_duplication = static_names.add(static_type_name);

        // do we need separate types in dictionary for set of string and generalset of string?
        if (no_duplication) {
          // standard express types
          if ((!static_type_express.equals("_GENERALLIST_0_GENERIC")) && 
                  (!static_type_express.equals("_GENERALSET_0_GENERIC")) && 
                  (!static_type_express.equals("_GENERALSET_0_STRING")) && 
                  (!static_type_express.equals("_AGGREGATE_GENERIC")) && 
                  (!static_type_express.equals("_GENERALBAG_0_GENERIC"))) {
						pw.println("\tpublic static jsdai.dictionary.EData_type " + static_type_name +";");
            static_names_inits.add("\t\t" + static_type_name + 
                       " = SdaiSession.findDataType(\"" + static_type_express + "\", " + 
                       static_type_schema_class + ");");
          }
        }
      }
    }
  }

  //------------ constructTypeName() -------------------
  String constructTypeSchemaClass(EEntity domain) throws SdaiException {
    // String schema_name = model.getUnderlyingSchema().getName(null);
    String model_name = model.getName();
    String schema_name;

    if (domain instanceof EAggregation_type) {
    	// at least for this case we need not the current model, but the model where the aggregation type is defined,
    	// it may be the current model or a different model, the model of an interfaced schema
    	// the static variable for the aggregate is defined in the S... class of the package of that schema
    	// The same approach may be needed also for non-aggregates, so far everyhing seems to be ok, 
    	// so not changing for other cases so far, for non-aggregates non-java inheritance duplicates a number of things,
    	// so that the current model may be needed instead
    	// even for aggregates there may be unexpected issues, so thorough testing will be needed
// System.out.println("<> rt model: " + rt.findEntityInstanceSdaiModel());    	

			// especially in this class, needs testing!!!

    	model_name = domain.findEntityInstanceSdaiModel().getName();
    }

    if (model_name.length() > 16) {
      String part_model_name = model_name.substring(model_name.length() - 16);

      if (part_model_name.equalsIgnoreCase("_DICTIONARY_DATA")) {
        schema_name = model_name.substring(0, model_name.length() - 16);
      } else {
        schema_name = model_name;
      }
    } else {
      schema_name = model_name;
    }

    //     String type_schema_class = "jsdai.S" + schema_name.substring(0,1).toUpperCase() + schema_name.substring(1).toLowerCase() + ".class";
    String type_schema_class = "jsdai.S" + schema_name.substring(0, 1).toUpperCase() + 
                               schema_name.substring(1).toLowerCase() + ".S" + 
                               schema_name.substring(0, 1).toUpperCase() + 
                               schema_name.substring(1).toLowerCase() + ".class";

    return type_schema_class;
  }

  String constructTypeExpress(EEntity domain, boolean is_generic)
                       throws SdaiException {
    String type_name = null;
    EEntity rt;


    // EParameter pt;
    // rt = parameter_type.getParameter_type(null);
    // // rt = pt.getParameter_type(null);
    rt = domain;

    if (rt instanceof EEntity_definition) {
      String base_entity_name = ((EEntity_definition) rt).getName(null);
      String base_name = getEntityPackage((EEntity_definition) rt) + "E" + 
                         base_entity_name.substring(0, 1).toUpperCase() + 
                         base_entity_name.substring(1).toLowerCase();


      // pw.println("\t// attribute:" + attr_name + ", base type: entity " + base_entity_name);
      // pw.println("\tpublic boolean test" + method_suffix + "(" + entity_name + " type) throws " + "SdaiException;");
      // pw.println("\tpublic " + base_name + " get" + method_suffix + "(" + entity_name + " type) throws " + "SdaiException;");
      // pw.println("\tpublic void set" + method_suffix + "(" + entity_name + " type, " + base_name + " value) throws " + "SdaiException;");
      // pw.println("\tpublic void unset" + method_suffix + "(" + entity_name + " type) throws " + "SdaiException;");
      type_name = base_name;
    } else if (rt instanceof EInteger_type) {
      type_name = "_INTEGER";

      // nothing more
    } else if (rt instanceof EReal_type) {
      type_name = "_REAL";

      // process precision specification:
      EReal_type real_type = (EReal_type) rt;
      boolean precision_present = real_type.testPrecision(null);

      if (precision_present) {
        EBound b_precision = real_type.getPrecision(null);

        if (b_precision instanceof EInteger_bound) {
          EInteger_bound i_precision = (EInteger_bound) b_precision;
          boolean integer_bound_set = i_precision.testBound_value(null);

          if (integer_bound_set) {
            int precision_value = i_precision.getBound_value(null);
            type_name += ("_" + precision_value);
          }
        }
      }
    } else if (rt instanceof ENumber_type) {
      type_name = "_NUMBER";

      // nothing more
    } else if (rt instanceof EBoolean_type) {
      type_name = "_BOOLEAN";

      // nothing more
    } else if (rt instanceof EBinary_type) {
      type_name = "_BINARY";

      // processing width spec - width, fixed
      EBinary_type binary_type = (EBinary_type) rt;
      boolean width_present = binary_type.testWidth(null);

      if (width_present) {
        EBound b_width = binary_type.getWidth(null);

        if (b_width instanceof EInteger_bound) {
          EInteger_bound i_width = (EInteger_bound) b_width;
          boolean integer_bound_set = i_width.testBound_value(null);

          if (integer_bound_set) {
            int width_value = i_width.getBound_value(null);
            type_name += ("_" + width_value);
          }
        }

        boolean fixed_present = binary_type.testFixed_width(null);

        if (fixed_present) {
          boolean fixed_value = binary_type.getFixed_width(null);

          if (fixed_value) {
            type_name += "_FIXED";
          }
        }
      }
    } else if (rt instanceof ELogical_type) {
      type_name = "_LOGICAL";

      // nothing more
    } else if (rt instanceof EString_type) {
      type_name = "_STRING";

      // processing width spec - width, fixed
      EString_type string_type = (EString_type) rt;
      boolean width_present = string_type.testWidth(null);

      if (width_present) {
        EBound b_width = string_type.getWidth(null);

        if (b_width instanceof EInteger_bound) {
          EInteger_bound i_width = (EInteger_bound) b_width;
          boolean integer_bound_set = i_width.testBound_value(null);

          if (integer_bound_set) {
            int width_value = i_width.getBound_value(null);
            type_name += ("_" + width_value);
          }
        }

        boolean fixed_present = string_type.testFixed_width(null);

        if (fixed_present) {
          boolean fixed_value = string_type.getFixed_width(null);

          if (fixed_value) {
            type_name += "_FIXED";
          }
        }
      }
    } else if (rt instanceof EAggregation_type) {
      type_name = constructAggregationTypeBaseTypeNameString((EAggregation_type) rt, is_generic);
    } else if (rt instanceof EDefined_type) {
      // there is no need to get inside a defined type. The name string ends with the name of the defined_type.
      // so this method returns just the defined_type name, despite its misleading name.
      // besides, this case will never happen here.
      type_name = constructDefinedTypeUnderlyingTypeNameString((EDefined_type) rt);
    } else if (rt instanceof EData_type) {
      if (((EData_type) rt).testName(null)) {
        String dt_name = ((EData_type) rt).getName(null);

        if (dt_name.equals("_GENERIC")) {
          type_name = "_GENERIC";
        } else
        if (dt_name.equals("_ENTITY")) {
          type_name = "_ENTITY";
        } else {
          type_name = "_NOTGENERIC";
        }
      } else {
        type_name = "_NONAMEDATATYPE";
      }
    } else {
      // internal error
    }

    return type_name;
  }

  //------------ constructTypeName() end------------------------------------
  String constructBagListSetBoundNames(EVariable_size_aggregation_type vat)
                                throws SdaiException {
    // bounds may be absent.
    // if the lower bound is present, the upper bound may be ? - then I will have one bound only.
    // both bounds may be present. Bounds cannot be negative.   bound 2 >= bound 1
    // so we may have:
    // 1.  _SET_vector;
    // 2.  _SET_2_vector;
    // 3.  _SET_3_10_vector;
    String result = "";

    if (vat.testLower_bound(null)) {
      EBound lb = vat.getLower_bound(null);

      if (lb instanceof EInteger_bound) {
        EInteger_bound ilb = (EInteger_bound) lb;

        if (ilb.testBound_value(null)) {
          int lb_value = ilb.getBound_value(null);
          result += ("_" + lb_value);
        } else {
          // bound set but integer bound unset, strange - internal error
          result += "_1IUNSET";
        }
      } else {
        // may be population dependent bound
//        result += "_1PDB";
        result += "_1PDB" + extractUniquePDBNumber((EPopulation_dependent_bound)lb);
      }

      if (vat.testUpper_bound(null)) {
        EBound ub = vat.getUpper_bound(null);

        if (ub instanceof EInteger_bound) {
          EInteger_bound iub = (EInteger_bound) ub;

          if (iub.testBound_value(null)) {
            int ub_value = iub.getBound_value(null);
            result += ("_" + ub_value);
          } else {
            // bound set but integer bound unset, strange - internal error
            result += "_2IUNSET";
          }
        } else {
          // may be population dependent bound
//          result += "_2PDB";
        	result += "_2PDB" + extractUniquePDBNumber((EPopulation_dependent_bound)ub);
        }
      }
    } else {
      result += "_0";
    }

    return result;
  }

 
  String constructArrayBoundNames(EArray_type vat) throws SdaiException {
    // both bounds are mandatory, may be negative, bound1 <= bound2,
    String result = "";

    if (vat.testLower_index(null)) {
      EBound lb = vat.getLower_index(null);

      if (lb instanceof EInteger_bound) {
        EInteger_bound ilb = (EInteger_bound) lb;

        if (ilb.testBound_value(null)) {
          int lb_value = ilb.getBound_value(null);

          if (lb_value < 0) {
            lb_value = -lb_value;
            result += ("_MINUS" + lb_value);
          } else {
            result += ("_" + lb_value);
          }
        } else {
          // bound set but integer bound unset, strange - internal error
          result += "_1IUNSET";
        }
      } else {
        // may be population dependent bound
//        result += "_1PDB";
        	result += "_1PDB" + extractUniquePDBNumber((EPopulation_dependent_bound)lb);
      }
    } else {
      result += "_1UNSET";
    }

    if (vat.testUpper_index(null)) {
      EBound ub = vat.getUpper_index(null);

      if (ub instanceof EInteger_bound) {
        EInteger_bound iub = (EInteger_bound) ub;

        if (iub.testBound_value(null)) {
          int ub_value = iub.getBound_value(null);

          if (ub_value < 0) {
            ub_value = -ub_value;
            result += ("_MINUS" + ub_value);
          } else {
            result += ("_" + ub_value);
          }
        } else {
          // bound set but integer bound unset, strange - internal error
          result += "_2IUNSET";
        }
      } else {
        // may be population dependent bound
//        result += "_2PDB";
       	result += "_2PDB" + extractUniquePDBNumber((EPopulation_dependent_bound)ub);
      }
    } else {
      result += "_2UNSET";
    }

    return result;
  }

	// from calculatePDB3 returns 3
	String extractUniquePDBNumber(EPopulation_dependent_bound pdb) throws SdaiException {
		String result = "";
		if (pdb.testMethod_name(null)) {
			result = pdb.getMethod_name(null).substring(12);
		}
		return result;
	}

  //------------ constructAggregationTypeBaseTypeNameString() -------------
  String constructAggregationTypeBaseTypeNameString(EAggregation_type rt1, boolean is_generic)
                                             throws SdaiException {
    String type_name = "";
    String generic_name;

    if (is_generic) {
      generic_name = "GENERAL";
    } else {
      generic_name = "";
    }

    if (rt1 instanceof EArray_type) {
      type_name += ("_" + generic_name + "ARRAY");
      type_name += constructArrayBoundNames((EArray_type) rt1);

      // additionally - OPTIONAL and UNIQUE.
      if (((EArray_type) rt1).testOptional_flag(null)) {
        if (((EArray_type) rt1).getOptional_flag(null)) {
          type_name += "_OPTIONAL";
        }
      }

      if (((EArray_type) rt1).testUnique_flag(null)) {
        if (((EArray_type) rt1).getUnique_flag(null)) {
          type_name += "_UNIQUE";
        }
      }
    } else if (rt1 instanceof EBag_type) {
      type_name += ("_" + generic_name + "BAG");
      type_name += constructBagListSetBoundNames((EVariable_size_aggregation_type) rt1);
    } else if (rt1 instanceof ESet_type) {
      type_name += ("_" + generic_name + "SET");
      type_name += constructBagListSetBoundNames((EVariable_size_aggregation_type) rt1);
    } else if (rt1 instanceof EList_type) {
      type_name += ("_" + generic_name + "LIST");
      type_name += constructBagListSetBoundNames((EVariable_size_aggregation_type) rt1);

      // UNIQUE
      if (((EList_type) rt1).testUnique_flag(null)) {
        if (((EList_type) rt1).getUnique_flag(null)) {
          type_name += "_UNIQUE";
        }
      }
    } else {
      // maybe AGGREGATE
      String aggr_name;

      if (rt1.testName(null)) {
        aggr_name = rt1.getName(null);

        if (aggr_name.substring(0, "_AGGREGATE".length()).equals("_AGGREGATE")) {
          type_name = "_AGGREGATE"; //aggr_name; 
        } else {
          type_name += "_UNKNOWNAGGREGATE";
        }
      } else {
        type_name += "_NONAMEAGGREGATE";
      }
    }

    EEntity rt = null;
    int aggregate_depth = 1;
    EEntity an_ss = null;
    EEntity ass = rt1;
    String aggr_prefices = "";

    // an_ss = rt1.getElement_type(null);
    boolean element_type_set = rt1.testElement_type(null);

    if (element_type_set) {
      an_ss = rt1.getElement_type(null);
      rt = an_ss;
    } else {
      System.out.println("XP: In LocalVariable, aggregate element type value unset:" + rt1);
    }

    for (;;) {
      boolean done_something = false;

      if (an_ss instanceof EDefined_type) {
        //            ass = an_ss;
        //            boolean domain_set = ((EDefined_type)an_ss).testDomain(null);
        //            if (domain_set) {
        //               an_ss = ((EDefined_type)an_ss).getDomain(null);
        //               done_something = true;
        //            } else {
        //               System.out.println("XP: constructing type name, in aggregate nested defined type domain unset:" + an_ss);
        //            }
      } else if (an_ss instanceof EAggregation_type) {
        aggr_prefices += "a";
        aggregate_depth++;
        ass = an_ss;

        if (ass instanceof EArray_type) {
          type_name += ("_" + generic_name + "ARRAY");
          type_name += constructArrayBoundNames((EArray_type) ass);

          if (((EArray_type) ass).testOptional_flag(null)) {
            if (((EArray_type) ass).getOptional_flag(null)) {
              type_name += "_OPTIONAL";
            }
          }

          if (((EArray_type) ass).testUnique_flag(null)) {
            if (((EArray_type) ass).getUnique_flag(null)) {
              type_name += "_UNIQUE";
            }
          }
        } else if (ass instanceof EBag_type) {
          type_name += ("_" + generic_name + "BAG");
          type_name += constructBagListSetBoundNames((EVariable_size_aggregation_type) ass);
        } else if (ass instanceof ESet_type) {
          type_name += ("_" + generic_name + "SET");
          type_name += constructBagListSetBoundNames((EVariable_size_aggregation_type) ass);
        } else if (ass instanceof EList_type) {
          type_name += ("_" + generic_name + "LIST");
          type_name += constructBagListSetBoundNames((EVariable_size_aggregation_type) ass);

          if (((EList_type) ass).testUnique_flag(null)) {
            if (((EList_type) ass).getUnique_flag(null)) {
              type_name += "_UNIQUE";
            }
          }
        } else if (ass instanceof EAggregation_type) {
          // maybe AGGREGATE
          String aggr_name;

          if (((EAggregation_type) ass).testName(null)) {
            aggr_name = ((EAggregation_type) ass).getName(null);

            if (aggr_name.substring(0, "_AGGREGATE".length()).equals("_AGGREGATE")) {
              type_name = "_AGGREGATE"; //aggr_name;
            } else {
              type_name += "_UNKNOWNAGGREGATE";
            }
          } else {
            type_name += "_NONAMEAGGREGATE";
          }
        } else {
          type_name += "_NOTAGGREGATE";
        }

        element_type_set = ((EAggregation_type) an_ss).testElement_type(null);

        if (element_type_set) {
          an_ss = ((EAggregation_type) an_ss).getElement_type(null);
          done_something = true;
        } else {
          System.out.println(
                "XP: constructing type names, nested aggregate element type value unset:" + 
                an_ss);
        }
      }

      if (!done_something) {
        break;
      }
    }

    String aggr_prefix = "A" + aggr_prefices;
    rt = an_ss;

    if (rt == null) {
      type_name += "_NULL";
      System.out.println("XP: constructing type names: base type of aggregation type is null: " + 
                         rt1);
    } else if (rt instanceof EAggregation_type) {
      type_name += constructAggregationTypeBaseTypeNameString((EAggregation_type) rt, is_generic);
    } else
    //      if (rt instanceof EAggregation_type) {
    //         type_name += "_AGGREGATE";
    //    } else
    if (rt instanceof EDefined_type) {
      type_name += constructDefinedTypeUnderlyingTypeNameString((EDefined_type) rt);
    } else if (rt instanceof ESelect_type) {
      // will not reach this case
      type_name += constructNameWithAggregatePackage(aggr_prefix, ass);
    } else if (rt instanceof EEntity_definition) {
      type_name += constructNameWithAggregatePackage(aggr_prefix, rt);
    } else if (rt instanceof EInteger_type) {
      type_name += "_INTEGER";
    } else if (rt instanceof EReal_type) {
      type_name += "_REAL";

      EReal_type real_type = (EReal_type) rt;
      boolean precision_present = real_type.testPrecision(null);

      if (precision_present) {
        EBound b_precision = real_type.getPrecision(null);

        if (b_precision instanceof EInteger_bound) {
          EInteger_bound i_precision = (EInteger_bound) b_precision;
          boolean integer_bound_set = i_precision.testBound_value(null);

          if (integer_bound_set) {
            int precision_value = i_precision.getBound_value(null);
            type_name += ("_" + precision_value);
          }
        }
      }
    } else if (rt instanceof ENumber_type) {
      type_name += "_NUMBER";
    } else if (rt instanceof EBoolean_type) {
      type_name += "_BOOLEAN";
    } else if (rt instanceof EBinary_type) {
      type_name += "_BINARY";

      EBinary_type binary_type = (EBinary_type) rt;
      boolean width_present = binary_type.testWidth(null);

      if (width_present) {
        EBound b_width = binary_type.getWidth(null);

        if (b_width instanceof EInteger_bound) {
          EInteger_bound i_width = (EInteger_bound) b_width;
          boolean integer_bound_set = i_width.testBound_value(null);

          if (integer_bound_set) {
            int width_value = i_width.getBound_value(null);
            type_name += ("_" + width_value);
          }
        }

        boolean fixed_present = binary_type.testFixed_width(null);

        if (fixed_present) {
          boolean fixed_value = binary_type.getFixed_width(null);

          if (fixed_value) {
            type_name += "_FIXED";
          }
        }
      }
    } else if (rt instanceof EEnumeration_type) {
      // will not reach
      type_name += "_ENUMERATION";
    } else if (rt instanceof ELogical_type) {
      type_name += "_LOGICAL";
    } else if (rt instanceof EString_type) {
      type_name += "_STRING";

      EString_type string_type = (EString_type) rt;
      boolean width_present = string_type.testWidth(null);

      if (width_present) {
        EBound b_width = string_type.getWidth(null);

        if (b_width instanceof EInteger_bound) {
          EInteger_bound i_width = (EInteger_bound) b_width;
          boolean integer_bound_set = i_width.testBound_value(null);

          if (integer_bound_set) {
            int width_value = i_width.getBound_value(null);
            type_name += ("_" + width_value);
          }
        }

        boolean fixed_present = string_type.testFixed_width(null);

        if (fixed_present) {
          boolean fixed_value = string_type.getFixed_width(null);

          if (fixed_value) {
            type_name += "_FIXED";
          }
        }
      }
    } else if (rt instanceof EData_type) {
      if (((EData_type) rt).testName(null)) {
        String dt_name = ((EData_type) rt).getName(null);

        if (dt_name.equals("_GENERIC")) {
          type_name += "_GENERIC";
        } else
        if (dt_name.equals("_ENTITY")) {
          type_name += "_ENTITY";
        } else {
          type_name += "_NOTGENERIC";
        }
      } else {
        type_name += "_NONAMEDATATYPE";
      }
    } else {
      System.out.println(
            "XP: constructing type names, not yet supported element type in aggregate: " + rt);
      type_name += "_UNSUPPORTED";
    }

    return type_name;
  }

  //------------ constructAggregationTypeBaseTypeNameString()  end --------
  //------------ constructDefinedTypeUnderlyingTypeNameString() -----------
  String constructDefinedTypeUnderlyingTypeNameString(EDefined_type rt1)
                                               throws SdaiException {
    String type_name = null;
    boolean name_set = rt1.testName(null);

    if (name_set) {
      return "_" + rt1.getName(null);
    } else {
      return "_UNSET";
    }
  }

  //------------ constructDefinedTypeUnderlyingTypeNameString() end -------
  String constructNameWithAggregatePackage(String aggr_prefix, EEntity ee)
                                    throws SdaiException {
    String a_package = "";
    String a_name = "";

    if (ee instanceof ENamed_type) {
      a_name = ((ENamed_type) ee).getName(null);

      // a_name = a_name.substring(0,1).toUpperCase() + a_name.substring(1).toLowerCase();
    }

    SdaiModel a_model = ee.findEntityInstanceSdaiModel();

    if (a_model != model) {
      String a_schema_name = getSchema_definitionFromModel(a_model).getName(null);

      if (a_schema_name.equalsIgnoreCase("Sdai_dictionary_schema")) {
        a_package = "jsdai.dictionary.";
      } else {
        a_package = "jsdai.S" + a_schema_name.substring(0, 1).toUpperCase() + 
                    a_schema_name.substring(1).toLowerCase() + ".";
      }
    }

    //      return a_package;
    // the package must be handled differently.
    // return a_package + aggr_prefix + a_name;
    return "_" + a_name;
  }

  void generateSpecialClass(String schema_package, String schema_package_name, String schema_name)
                     throws SdaiException, IOException {
//FIXME: suspended;      pdb.clear();

    String special_class_name = "S" + schema_name.substring(0, 1).toUpperCase() + 
        schema_name.substring(1).toLowerCase();
    String schema_definition_name; 
		boolean a_match = false;
		if (Support.specialClassSuffixMatcher != null) {
			Support.specialClassSuffixMatcher.reset(schema_name);
			if(Support.specialClassSuffixMatcher.matches()) {
				a_match = true;
			}
    }
    if (a_match) {
    	schema_definition_name = special_class_name + Compiler2.specialClassSuffix;
	    
	    // let's generate the class, then

	    String schema_file2 = schema_package + File.separator + special_class_name + ".java";
    	PrintWriter pw2 = getPrintWriterIfNew(schema_file2);
			if (pw2 != null) {  // if such a file already exists, do nothing, no need to generate the file
		    pw2.println(lksoft_header);
  		  pw2.println("");
    		pw2.println("// Special class extension for schema definition");
		    pw2.println("");
  		  pw2.println("package " + schema_package_name + ";");
    		pw2.println("import jsdai.lang.*;");
		    pw2.println("");
//  	  pw2.println("import java.lang.reflect.*;");
//    	pw2.println("");
		    pw2.println("public class " + special_class_name + " extends " + schema_definition_name + " {");
  		  pw2.println("");

				pw2.println("\tpublic static final SSuper ss;");
				pw2.println("");

				pw2.println("\tstatic {");
	
				pw2.println("\t\tss = SSuper.initSuper(new " + special_class_name +"());");
				if(Compiler2.expression_instances){
					pw2.println("\t\tinitDefinedDataTypes();");
					pw2.println("\t\tinitNonDefinedDataTypes();");
				}
				pw2.println("\t}");
	
				pw2.println("\tprotected CEntity makeInstanceX(Class c) throws InstantiationException, IllegalAccessException {");
					pw2.println("\t\tClass xClass = findXClass(c);");
					pw2.println("\t\treturn super.makeInstanceX(xClass);");
				pw2.println("\t}");

  	    pw2.println("");
    	  pw2.println("}");
      	pw2.flush();
      	pw2.close();
			} // if pw2 not NULL (if such a file does not yet exist

    } else {
    	schema_definition_name = special_class_name;
    }
    String schema_file = schema_package + File.separator + schema_definition_name + ".java";
    PrintWriter pw = getPrintWriter(schema_file);
    pw.println(lksoft_header);
    pw.println("");
    pw.println("// Special class for schema definition");
    pw.println("");
    pw.println("package " + schema_package_name + ";");
    pw.println("import jsdai.lang.*;");
    pw.println("");
    pw.println("import java.lang.reflect.*;");
    pw.println("");
    pw.println("public class " + schema_definition_name + " extends SSuper {");
    pw.println("");
    pw.println("\tpublic static final String time_stamp = \"" + time_stamp + "\";");
//    pw.println("\tpublic static final String time_stamp = \"" + " temporarily disabled" + "\";");
//    pw.println("\tpublic static final String version = \"" + compiler_version + "\";");

//     if (Compiler2.specialClassSuffix.length() != 0) {
//       pw.print("//");
//     }


/*
		if(Compiler2.specialClassSuffix.length() == 0){
			pw.println("\tpublic static final SSuper ss;");
			pw.println("");

			pw.println("\tstatic{");
			pw.println("\t\tss = SSuper.initSuper(new " +schema_definition_name +"());");
			if(Compiler2.expression_instances){
				pw.println("\t\tinitDefinedDataTypes();");
				pw.println("\t\tinitNonDefinedDataTypes();");
			}
			pw.println("\t}");
		}
*/

	 // if suffix = Base, do not generate ss only, but still genarate init calls 


//System.out.println("<schema_definition_name>: " + schema_name);  

//		Support.specialClassSuffixMatcher.reset(schema_name);
//		if(!Support.specialClassSuffixMatcher.matches()) {
    if (!a_match) {

//		if(Support.specialClassSuffixMatcher.matches()) {
//System.out.println("<>: YES, matches");  
//		if(Compiler2.specialClassSuffix.length() != 0){

//RR			pw.println("/*\t// ==== Copy the lines bellow to your " + special_class_name + " class implementation");
//RR		} else {

//System.out.println("<>: NO match");  
//RR		}
		
		pw.println("\tpublic static final SSuper ss;");
		pw.println("");

		pw.println("\tstatic {");
	
		pw.println("\t\tss = SSuper.initSuper(new " + special_class_name +"());");
		if(Compiler2.expression_instances){
			pw.println("\t\tinitDefinedDataTypes();");
			pw.println("\t\tinitNonDefinedDataTypes();");
		}
		pw.println("\t}");

//RR		if(Support.specialClassSuffixMatcher.matches()) {
//		if(Compiler2.specialClassSuffix.length() != 0){
//RR			pw.println("\t// ==== Copy to this point");
//RR			pw.println("*/");
		}

    /*
    pw.println("\tpublic static jsdai.dictionary.ESchema_definition getDefinition() throws SdaiException {");
    //         pw.println("\t\treturn ss.model.described_schema;");
             pw.println("\t\treturn ss.getUnderlyingSchema();");
    getUnderlyingSchema()
          pw.println("\t}");
     */
    pw.println(
          "\tprotected CEntity makeInstanceX(Class c) throws java.lang.InstantiationException, java.lang.IllegalAccessException {");
    pw.println("\t\t\treturn (CEntity)c.newInstance();");
    pw.println("\t}");
    pw.println("");
    pw.println(
          "\tprotected void setDataField(Class cl, String name, Object value) throws NoSuchFieldException, IllegalAccessException {");
    pw.println("\t\tField fd = cl.getDeclaredField(name);");
    pw.println("\t\tfd.set(null, value);");
    pw.println("\t}");
    pw.println("");
    pw.println(
          "\tprotected Object getObject(Object obj, Field field) throws java.lang.IllegalArgumentException, java.lang.IllegalAccessException {");
    pw.println("\t\treturn field.get(obj);");
    pw.println("\t}");
    pw.println(
          "\tprotected int getInt(Object obj, Field field) throws java.lang.IllegalArgumentException, java.lang.IllegalAccessException {");
    pw.println("\t\treturn field.getInt(obj);");
    pw.println("\t}");
    pw.println(
          "\tprotected double getDouble(Object obj, Field field) throws java.lang.IllegalArgumentException, java.lang.IllegalAccessException {");
    pw.println("\t\treturn field.getDouble(obj);");
    pw.println("\t}");
    pw.println("");
    pw.println(
          "\tprotected void setObject(Object obj, Field field, Object value) throws java.lang.IllegalArgumentException, java.lang.IllegalAccessException {");
    pw.println("\t\tfield.set(obj, value);");
    pw.println("\t}");
    pw.println(
          "\tprotected void setInt(Object obj, Field field, int value) throws java.lang.IllegalArgumentException, java.lang.IllegalAccessException {");
    pw.println("\t\tfield.setInt(obj, value);");
    pw.println("\t}");
    pw.println(
          "\tprotected void setDouble(Object obj, Field field, double value) throws java.lang.IllegalArgumentException, java.lang.IllegalAccessException {");
    pw.println("\t\tfield.setDouble(obj, value);");
    pw.println("\t}");

    generateStaticFieldsForConstantsX(pw, schema_package, schema_package_name);


    //      generateStaticFieldsForDefinedTypes(pw);
    // generate static fields for defined types. Parameters may not be needed, if only for local.
    generateStaticFieldsForDefinedTypes(pw, schema_package, schema_package_name);

    generateDomainRuleMethodsForDefinedTypes(pw, schema_package, schema_package_name);

    // generate static fields for immediate types of attributes, parameters, local variables.
    // needed for aggregate types and for simple types with non-default specializations, such as WIDTH, PRECISION, FIXED
    generateStaticFieldsForNonDefinedTypes(pw, schema_package, schema_package_name);

    // generating functions and procedures.
    Aggregate afd = model.getEntityExtentInstances(EFunction_definition.class);
    SdaiIterator fdi = afd.createIterator();


/* old - not nested
    while (fdi.next()) {
      EFunction_definition fd = (EFunction_definition) afd.getCurrentMemberObject(fdi);
      String f_name = fd.getName(null);
      String class_name = "F" + f_name.substring(0, 1).toUpperCase() + 
                          f_name.substring(1).toLowerCase();
      String class_file = schema_package + File.separator + class_name + ".java";
      PrintWriter pwf = getPrintWriter(class_file);
      pwf.println(lksoft_header);
      pwf.println("");
      pwf.println("// Java class implementing EXPRESS function " + f_name);
      pwf.println("");
      pwf.println("package " + schema_package_name + ";");
      pwf.println("import jsdai.lang.*;");
      pwf.println("");
      pwf.println("public class " + class_name + " {");
      generateJavaExpression(pwf, fd, sd, null, model);
      pwf.println("");
      pwf.println("}");
      pwf.flush();
      pwf.close();
    }

*/


    while (fdi.next()) {
      EFunction_definition fd = (EFunction_definition) afd.getCurrentMemberObject(fdi);
      EEntity parent = Support.getParentFunctionProcedureRuleDefinition(fd);
      if (parent != null) continue; // inner function
      String f_name = fd.getName(null);
      String class_name = "F" + f_name.substring(0, 1).toUpperCase() + 
                          f_name.substring(1).toLowerCase();
      String class_file = schema_package + File.separator + class_name + ".java";
      PrintWriter pwf = getPrintWriter(class_file);
      pwf.println(lksoft_header);
      pwf.println("");
      pwf.println("// Java class implementing EXPRESS function " + f_name);
      pwf.println("");
      pwf.println("package " + schema_package_name + ";");
      pwf.println("import jsdai.lang.*;");
      pwf.println("");
      generateJavaExpression(pwf, fd, sd, null, model);
      pwf.flush();
      pwf.close();
    }

    Aggregate apd = model.getEntityExtentInstances(EProcedure_definition.class);
    SdaiIterator pdi = apd.createIterator();

    while (pdi.next()) {
      EProcedure_definition pd = (EProcedure_definition) apd.getCurrentMemberObject(pdi);
      EEntity parent = Support.getParentFunctionProcedureRuleDefinition(pd);
      if (parent != null) continue; // inner procedure
      String p_name = pd.getName(null);
      String class_name = "P" + p_name.substring(0, 1).toUpperCase() + 
                          p_name.substring(1).toLowerCase();
      String class_file = schema_package + File.separator + class_name + ".java";
      PrintWriter pwp = getPrintWriter(class_file);
      pwp.println(lksoft_header);
      pwp.println("");
      pwp.println("// Java class implementing EXPRESS procedure " + p_name);
      pwp.println("");
      pwp.println("package " + schema_package_name + ";");
      pwp.println("import jsdai.lang.*;");
      pwp.println("");
  //    pwp.println("public class " + class_name + " {");

      generateJavaExpression(pwp, pd, sd, null, model);
//      pwp.println("");
//      pwp.println("}");
      pwp.flush();
      pwp.close();
    }

    Aggregate agr = model.getEntityExtentInstances(EGlobal_rule.class);
    SdaiIterator gri = agr.createIterator();

    while (gri.next()) {
      EGlobal_rule gr = (EGlobal_rule) agr.getCurrentMemberObject(gri);
      String r_name = gr.getName(null);
      String class_name = "R" + r_name.substring(0, 1).toUpperCase() + 
                          r_name.substring(1).toLowerCase();
      String class_file = schema_package + File.separator + class_name + ".java";
      PrintWriter pwr = getPrintWriter(class_file);
      pwr.println(lksoft_header);
      pwr.println("");
      pwr.println("// Java class implementing EXPRESS global rule " + r_name);
      pwr.println("");
      pwr.println("package " + schema_package_name + ";");
      pwr.println("import jsdai.lang.*;");
      pwr.println("");

if (!flag_expressions) { // if expressions, that is done while traversing the tree

      pwr.println("public class " + class_name + " {");
			pwr.println("\tboolean _already_initialized = false;");
}
      generateJavaExpression(pwr, gr, sd, null, model);
      pwr.println("");
			// can add run method for all the global rules here or perhaps in ECxGenarateJava.java
			// information needed for it is probably all in the dictionary, so perhaps no difference.


				AWhere_rule awr = gr.getWhere_rules(null, null);
				SdaiIterator awri = awr.createIterator();
				int i = 0;
				boolean more_than_one = false;
				if (awr.getMemberCount() > 1) {
					more_than_one = true;
				}


	      pwr.println("\tpublic int run(SdaiContext _context, A_string violations) throws SdaiException {");
  	  

if (flag_expressions) {



//  	   	if (flag_process_all_domain_rules) {
//					pwr.println("\t\tint result = 2;");
//    		}
				pwr.println("\t\tint result;");
  			if (more_than_one) {
					pwr.println("\t\tint r;");
  			}
     	
     		// here, invoke the methods for all the domain rules
 				// INVERSE
				// 		where_rules : SET [1:?] OF where_rule FOR parent_item;
			
				// Inverse attribute - where_rules : SET[1:-2147483648] OF where_rule FOR parent_item
				// public AWhere_rule getWhere_rules(EGlobal_rule type, ASdaiModel domain) throws SdaiException;
				

  			if (!flag_print_failed_domain_rule) {
	  			flag_process_all_domain_rules = false;
  			}

				boolean first_time = true;
				while (awri.next()) {
					EWhere_rule wr = (EWhere_rule)awr.getCurrentMemberObject(awri);
					String label = "WR1"; //  if optional label is not present, assume that there is only one domain rule and label it WR1					
					if (wr.testLabel(null)) {
						label = wr.getLabel(null);
					}
					String normalized_where_rule_name = "r" + label.substring(0,1).toUpperCase() + label.substring(1).toLowerCase();
					

					/*
						 each domain rule can evaluate to true, false, unknown or indeterminate in our int representation: 2,1,3,0
						 if true - the rule is asserted, if false - the rule is violated.
						 if unknown or indeterminate - neither asserted nor violated, but only violating values are not acceptable,
						 so it seems it is improtant to catch violations, not to demand assertion.
						 if run method returns int, it may indicate pricisely the result of avaluation of more than one rule:
						 
						 
						 	true    true    true
							true    unknown unknown
							true    false   false
							unknown true    unknown
							unknown unknown unknown
							unknown false   false
							false   true    false
							false   unknown false
							false   false   false
						 
						 	our representation:  
						 	0 - unset (indeterminate? - indeterminate treated as unknown)
						 	1 - false
						 	2 - true
						 	3 - unknown
						 
              						
              if (at least one operand false) result = false
              else if (at least one operand unknown or indeterminate) result = unknown
              else  result = true 						
              						 
              result = rWr1();
     
              r = rWr2();
              
              if ((r == 1) || (result == 1)) result = 1
              else if ((r == 3) || (r == 0) || (result == 3) || (result == 0)) result = 3;
              else result = 2; 
              						 
              						 
              if (result == ) {
                	
              }			
              
              
              // the case when there is a check if r == 1 (need to return or to print)
              if (r == 1) {
              	result = 1;
              } else  
              if (result != 1) {
								if ((r == 3) || (r == 0) || (result == 3) || (result == 0)) result = 3;              	
              	else result = 2;
              }
              	
              }
              
              			 
						 
						 
					*/

					// if not true, then false (unknown (3) also violation)  - we could use condition < 2 or == 1 so that both true and unknown would be ok - look in part 11
				
				
					String wr_stuff = "\"" + label + "\"";

				
					if (more_than_one) {
						if (first_time) {
							first_time = false;
							pwr.println("\t\tresult = " + normalized_where_rule_name + "(_context);");
							if ((!flag_process_all_domain_rules) || flag_print_failed_domain_rule) {
								pwr.println("\t\tif (result == 1) {");
								if (flag_print_failed_domain_rule) {
//									pwr.println("\t\t\tSystem.out.println(\"Violation of domain rule " + label + " in global rule " + r_name + "\");");
									pwr.println("\t\t\tviolations.addUnordered(" + wr_stuff + ");");
								}	
								if (!flag_process_all_domain_rules) {
									pwr.println("\t\t\treturn 1;");
								}
								pwr.println("\t\t}");
							} 
						} else {
							pwr.println("\t\tr = " + normalized_where_rule_name + "(_context);");
							if ((!flag_process_all_domain_rules) || flag_print_failed_domain_rule) {
								pwr.println("\t\tif (r == 1) {");
									if (flag_print_failed_domain_rule) {
//										pwr.println("\t\t\tSystem.out.println(\"Violation of domain rule " + label + " in global rule " + r_name + "\");");
										pwr.println("\t\t\tviolations.addUnordered(" + wr_stuff + ");");
									}	
									if (!flag_process_all_domain_rules) {
										pwr.println("\t\t\treturn 1;");
									} else {
										pwr.println("\t\t\tresult = 1;");
									}
								pwr.println("\t\t} else");
//								pwr.println("\t\tif ((r == 3) || (r == 0) || (result == 3) || (result == 0)) result = 3;");             	
// 	          		pwr.println("\t\telse result = 2;");
								pwr.println("\t\tif ((result == 2) && (r == 2)) ;");             	
 	          	  if (flag_process_all_domain_rules) {
									pwr.println("\t\telse if (result != 1) result = 3;");
 	          	  } else { 
 	          			pwr.println("\t\telse result = 3;");
								}
							} else {
								//  check if (r == 1) is not needed, other ways are possible, including the check as well, if it seems to be optimal solution
	              pwr.println("\t\tif ((r == 1) || (result == 1)) result = 1;");
//  	            pwr.println("\t\telse if ((r == 3) || (r == 0) || (result == 3) || (result == 0)) result = 3;");
//    	          pwr.println("\t\telse result = 2;"); 
								pwr.println("\t\telse if ((result == 2) && (r == 2)) ;");             	
 	          		pwr.println("\t\telse result = 3;");
							} 
						}
					} else {
//						pwr.println("\t\treturn " + normalized_where_rule_name + "(_context);");

							pwr.println("\t\tresult = " + normalized_where_rule_name + "(_context);");
							pwr.println("\t\tif (result == 1) {");
								if (flag_print_failed_domain_rule) {
//									pw.println("\t\t\tSystem.out.println(\"Violation of domain rule " + label + " in global rule " + r_name + "\");");
									pwr.println("\t\t\tviolations.addUnordered(" + wr_stuff + ");");
								}	
							pwr.println("\t\t}");



					}

				} // while through domain rules
				
//				if (more_than_one) {
				pwr.println("\t\treturn result;");
//				}

// old 
/*
					pwr.println("\t\tif (" + normalized_where_rule_name + "(_context) != 2) {");
					if (flag_print_failed_domain_rule) {
						pwr.println("\t\t\tSystem.out.println(\"Violation of domain rule " + label + " in global rule " + r_name + "\");");
					}
					if (			
 	    		if (flag_process_all_domain_rules) {
						pwr.println("\t\t\tresult = false;");
  				} else {
						pwr.println("\t\t\treturn false;");
  				}
					pwr.println("\t\t}");
				}
    		if (flag_process_all_domain_rules) {
					pwr.println("\t\treturn result;");
				} else {
					pwr.println("\t\treturn true;");
				}

*/
// end old


} else {  // not flag_expressions
				pwr.println("\t\treturn 2;");
}

				
      pwr.println("\t}");
      
      pwr.println("");
      pwr.println("}");
      pwr.flush();
      pwr.close();
    }


    // to get pdb from defined types. Better to have a node for defined type, perhaps
    generateJavaExpression(pw, null, sd, null, model);

    // pw.println("##### number of elements in SPECIAL CLASS: " + pdb.size());

//FIXME: suspended;  
//     for (int i = 0; i < pdb.size(); i++) {
//       pw.println(pdb.elementAt(i));
//     }

//FIXME: suspended;      pdb.clear();

    pw.println("");
    pw.println("}");
    pw.flush();
    pw.close();
  }

  void generateAggregateClasses(String schema_package, String schema_package_name)
                         throws SdaiException, IOException {
    Aggregate ant = model.getEntityExtentInstances(ENamed_type.class);
    SdaiIterator nti = ant.createIterator();

    while (nti.next()) {
      ENamed_type nt = (ENamed_type) ant.getCurrentMemberObject(nti);

      if (nt instanceof EEntity_definition) {
        boolean is_complex = ((EEntity_definition) nt).getComplex(null);

        if (is_complex) // do not generate Aggregate classes for complex entities
        {
          continue;
        }
      }

      Object temp_obj = nt.getTemp();
      Integer temp_int = (Integer) temp_obj;
      int aggregate_depth = temp_int.intValue();
      String aggr_prefix = "A";
      String aggr_prefix1 = null;

      for (int i = 0; i < aggregate_depth; i++) {
        String nt_name = nt.getName(null);
        String class_name = aggr_prefix + nt_name.substring(0, 1).toUpperCase() + 
                            nt_name.substring(1).toLowerCase();
        String class_file = schema_package + File.separator + class_name + ".java";
        String single_name = "E" + nt_name.substring(0, 1).toUpperCase() + 
                             nt_name.substring(1).toLowerCase();
        String prev_name = aggr_prefix1 + nt_name.substring(0, 1).toUpperCase() + 
                           nt_name.substring(1).toLowerCase();
        PrintWriter pw = getPrintWriter(class_file);
        pw.println(lksoft_header);
        pw.println("");
        pw.println("// Java class implementing aggregate of  " + nt_name + " of level " + 
                   (i + 1));
        pw.println("");
        pw.println("package " + schema_package_name + ";");
        pw.println("import jsdai.lang.*;");
        pw.println("");
        pw.println("");

        // here goes methods
        if (i == 0) {
          if (nt instanceof EEntity_definition) {
            pw.println("public class " + class_name + " extends AEntity {");


            // generateEntityAggregateClassMethods((EEntity_definition)nt);
            pw.println("\tpublic " + single_name + 
                       " getByIndex(int index) throws SdaiException {");
            if (replace_object_by_entity) {
            	pw.println("\t\treturn (" + single_name + ")getByIndexEntity(index);");
            } else {
            	pw.println("\t\treturn (" + single_name + ")getByIndexObject(index);");
            }
            pw.println("\t}");
            pw.println("\tpublic " + single_name + 
                       " getCurrentMember(SdaiIterator iter) throws SdaiException {");
            pw.println("\t\treturn (" + single_name + ")getCurrentMemberObject(iter);");
            pw.println("\t}");
          } else if (nt instanceof EDefined_type) {
            EEntity ut = ((EDefined_type) nt).getDomain(null);

            // can be only select, but may include an additional check to catch an internal error
            if (ut instanceof ESelect_type) {
              // possibly ant not needed at all.
//              ANamed_type ant1 = ((ESelect_type) ut).getSelections(null);
//              ANamed_type ant1 = ((ESelect_type) ut).getLocal_selections(null);
              ANamed_type ant1 = getSelections((ESelect_type) ut);
              SelectPaths paths1 = null;
              int select_type = Integer.MIN_VALUE;
              Object temp_object = ut.getTemp();

              if (temp_object instanceof SelectPaths) {
                if (((SelectPaths) temp_object).owner == ut) {
                  paths1 = (SelectPaths) temp_object;
                  select_type = paths1.select_type;
                }
              }

              if (paths1 == null) {
                int count = 1;
                int[] indeces = new int[500];
                int depth = 0;
                int depth_count = 0;
                boolean with_type = false;
                Vector current_nodes = new Vector();
                Vector current_node_strings = new Vector();
                paths1 = new SelectPaths();
                paths1.owner = (ESelect_type) ut;
                select_type = calculateSelectPaths(count, current_nodes, current_node_strings, 
                                                   indeces, depth, depth_count, paths1, 
                                                   (ESelect_type) ut, with_type);
                paths1.removeIdentical();
                paths1.select_type = select_type;
                ut.setTemp(paths1);
              }

// extensible_select is assumed to include intities 
//             if ((select_type == 0) || (select_type == 2)) { // includes entities


/*

              if ((select_type == 0) || (select_type == 2) || (ut instanceof EExtensible_select_type)) { // includes entities
                pw.println("public class " + class_name + " extends AEntitySelect {");
              } else {
                pw.println("public class " + class_name + " extends CAggregate {");
              }

*/

              if ((select_type == 0) || (ut instanceof EEntity_select_type)) { // includes only entities
                pw.println("public class " + class_name + " extends AEntitySelect {");
              } else { // may include non-entities
                pw.println("public class " + class_name + " extends CAggregate {");
              }



							// what about extensible? simplified version anyway - is it working for the simplified version already?
              if (select_type > 0) { // includes defined_types

                //                        pw.println("\t// constants and methods for SELECT attribute: " + attr_name);
                paths1.generateAggregateConstants(pw);
                pw.println("");

                //                        paths1.generateAggregateMethods(pw);
              }

              paths1.generateTest(pw);
              paths1.generateIsMember(pw);
              paths1.generateGetByIndex(pw);
              paths1.generateGetCurrentMember(pw);
              paths1.generateSetByIndex(pw);
              paths1.generateSetCurrentMember(pw);
              paths1.generateAddBefore(pw);
              paths1.generateAddAfter(pw);
              paths1.generateAddUnordered(pw);
              paths1.generateAddByIndex(pw);
              paths1.generateRemoveUnordered(pw);
            } else {
              // not select - such aggregates not needed so far, should have depth count = 0 and this point should never be reached.
            }
          }
        } else if ((i > 0) && 
                       ((nt instanceof EEntity_definition) || (nt instanceof EDefined_type))) {
          pw.println("public class " + class_name + " extends CAggregate {");
          pw.println("\tpublic boolean isMember(" + prev_name + " value) throws SdaiException {");
          pw.println("\t\treturn isMember(value, null);");
          pw.println("\t}");
          pw.println("\tpublic " + prev_name + " getByIndex(int index) throws SdaiException {");
          if ((replace_object_by_entity) && (nt instanceof EEntity_definition)) {
// turns out, aggregates are not subtypes of Entity so cast to Entity is not possible, keep Object in this case
//            pw.println("\t\treturn (" + prev_name + ")getByIndexEntity(index);");
	          pw.println("\t\treturn (" + prev_name + ")getByIndexObject(index);");
	      	} else {
	          pw.println("\t\treturn (" + prev_name + ")getByIndexObject(index);");
        	}

          pw.println("\t}");


          //            pw.println("\tpublic void setByIndex(int index, " + prev_name + " value) throws SdaiException {");
          //                 pw.println("\t\tsetByIndex(index, value, null);");
          //             pw.println("\t}");
          pw.println("\tpublic " + prev_name + 
                     " createAggregateByIndex(int index) throws SdaiException {");
          pw.println("\t\treturn (" + prev_name + ")createAggregateByIndex(index, null);");
          pw.println("\t}");


          //            pw.println("\tpublic void addByIndex(int index, " + prev_name + " value) throws SdaiException {");
          //                 pw.println("\t\taddByIndex(index, value, null);");
          //             pw.println("\t}");
          pw.println("\tpublic " + prev_name + 
                     " addAggregateByIndex(int index) throws SdaiException {");
          pw.println("\t\treturn (" + prev_name + ")addAggregateByIndex(index, null);");
          pw.println("\t}");


          //            pw.println("\tpublic void addUnordered(" + prev_name + " value) throws SdaiException {");
          //               pw.println("\t\taddUnordered(value, null);");
          //             pw.println("\t}");
          pw.println("\tpublic " + prev_name + 
                     " createAggregateUnordered() throws SdaiException {");
          pw.println("\t\treturn (" + prev_name + ")createAggregateUnordered(null);");
          pw.println("\t}");
          pw.println("\tpublic void removeUnordered(" + prev_name + 
                     " value) throws SdaiException {");
          pw.println("\t\tremoveUnordered(value, null);");
          pw.println("\t}");
          pw.println("\tpublic " + prev_name + 
                     " getCurrentMember(SdaiIterator iter) throws SdaiException {");
          pw.println("\t\treturn (" + prev_name + ")getCurrentMemberObject(iter);");
          pw.println("\t}");
          pw.println("\tpublic " + prev_name + 
                     " createAggregateAsCurrentMember(SdaiIterator iter) throws SdaiException {");
          pw.println("\t\treturn (" + prev_name + ")createAggregateAsCurrentMember(iter, null);");
          pw.println("\t}");


          //            pw.println("\tpublic void setCurrentMember(SdaiIterator iter, " + prev_name + " value) throws SdaiException {");
          //                 pw.println("\t\tsetCurrentMember(iter, value, null);");
          //             pw.println("\t}");
          //            pw.println("\tpublic void addBefore(SdaiIterator iter, " + prev_name + " value) throws SdaiException {");
          //                 pw.println("\t\taddBefore(iter, value, null);");
          //             pw.println("\t}");
          //            pw.println("\tpublic void addAfter(SdaiIterator iter, " + prev_name + " value) throws SdaiException {");
          //                 pw.println("\t\taddAfter(iter, value, null);");
          //             pw.println("\t}");
          pw.println("\tpublic " + prev_name + 
                     " createAggregateBefore(SdaiIterator iter) throws SdaiException {");
          pw.println("\t\treturn (" + prev_name + ")createAggregateBefore(iter, null);");
          pw.println("\t}");
          pw.println("\tpublic " + prev_name + 
                     " createAggregateAfter(SdaiIterator iter) throws SdaiException {");
          pw.println("\t\treturn (" + prev_name + ")createAggregateAfter(iter, null);");
          pw.println("\t}");
        } else {
          System.out.println("Not really expected case - generating aggregate class");
        }

        pw.println("}");
        pw.flush();
        pw.close();
        aggr_prefix += "a";

        if (aggr_prefix1 == null) {
          aggr_prefix1 = "A";
        } else {
          aggr_prefix1 += "a";
        }
      }
    }
  }

  /*
  void generateEntityAggregateClassMethods(EEntity_definition ed) {
     AAttribute aa = ed.getAttributes(null, null);
  //RR-explicit_attribute removed-      AExplicit_attribute xa = ed.getExplicit_attributes(null);
        AExplicit_attribute xa = getExplicit_attributes(ed);
        SdaiIterator ia = null;
        EAttribute attr = null;
        ia = xa.createIterator();
        while (ia.next()) {
           EExplicit_attribute xattr = (EExplicit_attribute)xa.getCurrentMemberObject(ia);
           String attr_name = xattr.getName(null);
           String method_suffix = attr_name.substring(0,1).toUpperCase() + attr_name.substring(1).toLowerCase();
           EEntity bt = xattr.getDomain(null);
           if (bt instanceof ESimple_type) {
           } else
           if (bt instanceof EAggregation_type) {
           } else 
           if (bt instanceof EDefined_type) {
           } else
           if (bt instanceof EEntity_definition) {
              String base_entity_name = ((EEntity_definition)bt).getName(null);
              String base_name = getEntityPackage((EEntity_definition)bt) + "E" + base_entity_name.substring(0,1).toUpperCase() + base_entity_name.substring(1).toLowerCase();
            pw.println("\t// attribute:" + attr_name + ", base type: entity " + base_entity_name);
            pw.println("\tpublic boolean test" + method_suffix + "(" + entity_name + " type) throws " + "SdaiException;");
            pw.println("\tpublic " + base_name + " get" + method_suffix + "(" + entity_name + " type) throws " + "SdaiException;");
            pw.println("\tpublic void set" + method_suffix + "(" + entity_name + " type, " + base_name + " value) throws " + "SdaiException;"); 
            pw.println("\tpublic void unset" + method_suffix + "(" + entity_name + " type) throws " + "SdaiException;");
           }
        }
     }
   */
  void generateEntityNestedAggregateClassMethods(EEntity_definition ed, int depth) {
  }

  void clearAggregateDepths() throws SdaiException {
    Aggregate ia = model.getEntityExtentInstances(ENamed_type.class);
    SdaiIterator iter_inst = ia.createIterator();

    while (iter_inst.next()) {
      ENamed_type inst = (ENamed_type) ia.getCurrentMemberObject(iter_inst);

      if (inst instanceof EEntity_definition) {
        inst.setTemp(new Integer(1));
      } else {
        inst.setTemp(new Integer(0));
      }
    }
  }

  static EGeneric_schema_definition getSchema_definitionFromModel(SdaiModel sm)
                                                    throws SdaiException {
    Aggregate ia = sm.getEntityExtentInstances(EGeneric_schema_definition.class);
    SdaiIterator iter_inst = ia.createIterator();

    while (iter_inst.next()) {
      EGeneric_schema_definition inst = (EGeneric_schema_definition) ia.getCurrentMemberObject(
                                              iter_inst);

      return inst;
    }

    return null;
  }

  ESchema_definition getSchema_definitionFromModel_pre_X(SdaiModel sm)
                                                  throws SdaiException {
    Aggregate ia = sm.getEntityExtentInstances(ESchema_definition.class);
    SdaiIterator iter_inst = ia.createIterator();

    while (iter_inst.next()) {
      ESchema_definition inst = (ESchema_definition) ia.getCurrentMemberObject(iter_inst);

      return inst;
    }

    return null;
  }

  void generateEntities(String schema_package, String schema_package_name)
                 throws SdaiException, IOException {
    Aggregate aed = model.getEntityExtentInstances(EEntity_definition.class);
    SdaiIterator ied = aed.createIterator();

    while (ied.next()) {
      EEntity_definition ed = (EEntity_definition) aed.getCurrentMemberObject(ied);
      printVerbose("entity: " + ed.getName(null));

      boolean is_complex = ed.getComplex(null);

      if (!is_complex) {
        generateEntityInterface(ed, schema_package, schema_package_name);
      }

      generateEntityClass(ed, schema_package, schema_package_name);

      //         generateEntityAggregates();
    }
  }

  void generateMaps(String schema_package, String schema_package_name)
             throws SdaiException, IOException {
    Aggregate amd = model.getEntityExtentInstances(EMap_definition.class);
    SdaiIterator imd = amd.createIterator();

    while (imd.next()) {
      EMap_definition md = (EMap_definition) amd.getCurrentMemberObject(imd);
      printVerbose("map: " + md.getName(null));

      generateMapClass(md, schema_package, schema_package_name);
    }
  }

  void generateEntityInterface(EEntity_definition ed, String schema_package, 
                               String schema_package_name)
                        throws SdaiException, IOException {
    String entity_name = ed.getName(null);

    //      entity_name += getEntityPackage(ed); // - never different packages for interfaces.
    String entity_interface_name = "E" + entity_name.substring(0, 1).toUpperCase() + 
                                   entity_name.substring(1).toLowerCase();
    String interface_file = schema_package + File.separator + entity_interface_name + ".java";
    PrintWriter pw = getPrintWriter(interface_file);
    pw.println(lksoft_header);
    pw.println("");
    pw.println("// Java interface for entity " + entity_name);
    pw.println("");
    pw.println("package " + schema_package_name + ";");
    pw.println("import jsdai.lang.*;");
    pw.println("");
    pw.println("public interface " + entity_interface_name + " extends " + 
               getWhatInterfaceExtends(ed) + " {");
    pw.println("");

    // explicit attributes
//    AExplicit_attribute xa = getExplicit_attributes(ed);
    AExplicit_attribute xa = getExplicit_attributes2(ed);
    SdaiIterator ia = null;
    ia = xa.createIterator();

    while (ia.next()) {
      EExplicit_attribute xattr = (EExplicit_attribute) xa.getCurrentMemberObject(ia);

      // can also be later redeclared or redeclaring another explicit attribute itself, not interesting cases for interfaces?
      // boolean is_later_redeclared; // does not make sense for interfaces (although used in EC1?)
      boolean is_redeclaring = xattr.testRedeclaring(null);

// System.out.println("entity: " + ed.getName(null) + ", attribute: " + xattr.getName(null));

      if (!is_redeclaring) {
        if (debug_java) pw.println("\t// generateExplicitAttributeMethodDeclarations: 1");
        generateExplicitAttributeMethodDeclarations(xattr, entity_interface_name, pw);
      } else {
        if (debug_java) pw.println("\t// generateExplicitRedeclaringAttributeMethodDeclarations: 1");
      	generateExplicitRedeclaringAttributeMethodDeclarations(xattr, entity_interface_name, pw);
      }
    }

    // derived attributes
    ADerived_attribute da = getDerived_attributes(ed);
    ia = da.createIterator();

    while (ia.next()) {
      EDerived_attribute dat = (EDerived_attribute) da.getCurrentMemberObject(ia);

      // pure derived, not redeclaring, I think for redeclaring - nothing
      boolean is_redeclaring = dat.testRedeclaring(null);

      if (!is_redeclaring) {
        if (debug_java) pw.println("\t// generateDerivedAttributeMethodDeclarations: 1");
        generateDerivedAttributeMethodDeclarations(dat, entity_interface_name, pw);


      } else {
      	// add Value get... declarations for explicit-to-derived here
      	EAttribute redeclared_attr = (EAttribute)dat.getRedeclaring(null);
	      if (redeclared_attr instanceof EExplicit_attribute) {
    			// yes, here - it may be even a more complete implementation than for method bodies, check multiple inheritance, complex entities, etc.
//      		pw.println("\t/// additional method for explicit redeclared as derived attribute:" + attr_name );

	    		String attr_name = dat.getName(null);
  	  		String method_suffix = attr_name.substring(0, 1).toUpperCase() + 
    	    	                   attr_name.substring(1).toLowerCase();



					EEntity_definition redeclared_entity = redeclared_attr.getParent_entity(null);
					String redeclared_entity_name = redeclared_entity.getName(null);
					String redeclared_type_name = getEntityPackage(redeclared_entity) + "E" + redeclared_entity_name.substring(0,1).toUpperCase() + redeclared_entity_name.substring(1).toLowerCase();
//					String redeclared_type_name = "E" + redeclared_entity_name.substring(0,1).toUpperCase() + redeclared_entity_name.substring(1).toLowerCase();

					EAttribute original_attribute = findOriginalAttribute(dat);
					EEntity_definition original_redeclared_entity = original_attribute.getParent_entity(null);
					String original_redeclared_entity_name = original_redeclared_entity.getName(null);
					String original_redeclared_type_name = getEntityPackage(original_redeclared_entity) + "E" + original_redeclared_entity_name.substring(0,1).toUpperCase() + original_redeclared_entity_name.substring(1).toLowerCase();


	        if (debug_java) pw.println("\t// derived-redeclaring 1: direct, redeclared: " + redeclared_type_name + ", original: " + original_redeclared_type_name);

//TEST : experiment, generating Value method for the entity type of the original attribute

// this does not work for RENAMED, let's try to generate it only if the attribute name is the same
// but do we compare with one step back or with two steps back, or with the original name?				
				if (debug_java) pw.println("\t// attribute name, current: " + attr_name + ", previous: " + redeclared_attr.getName(null) + ", original: " + original_attribute.getName(null));

				if (attr_name.equalsIgnoreCase(original_attribute.getName(null))) {
		      pw.println("\tpublic Value get" + method_suffix + "(" + original_redeclared_type_name + 
          	" type, SdaiContext _context) throws " + "SdaiException;");
				} else {
		      pw.println("\tpublic Value get" + method_suffix + "(" + redeclared_type_name + 
          	" type, SdaiContext _context) throws " + "SdaiException;");
				}

// before TEST
/*
		      pw.println("\tpublic Value get" + method_suffix + "(" + original_redeclared_type_name + 
//		      pw.println("\tpublic Value get" + method_suffix + "(" + redeclared_type_name + 
          	" type, SdaiContext _context) throws " + "SdaiException;");
 */ 
      	}
      }
    }

    // inverse attributes
//System.out.println("><>< getInverse_attributes() in generateEntityInterface for entity: " + ed.getName(null));
    AInverse_attribute ina = getInverse_attributes(ed);
    ia = ina.createIterator();

    while (ia.next()) {
      EInverse_attribute inva = (EInverse_attribute) ina.getCurrentMemberObject(ia);

      // if redeclaring another inverse attribute, then nothing is needed.
      if (inva.testRedeclaring(null)) {
        continue;
      }

      EEntity_definition referencing_entity = null;

	    if (inva.testDomain(null)) {
	      referencing_entity = inva.getDomain(null);
			} else {
				pw.println("WARNING! Entity interface not generated - inverse attribute domain is NULL: " + inva);
				System.out.println("WARNING! Entity interface not generated - attribute domain is NULL: " + inva);
				return;
			}


      String referencing_entity_name = referencing_entity.getName(null);
      EExplicit_attribute inverted_attr = inva.getInverted_attr(null);
      String inverted_attr_name = inverted_attr.getName(null);
      boolean duplicates = inva.getDuplicates(null);
      EBound min_cardinality = null;
      EBound max_cardinality = null;
      int min_cardinality_int = Integer.MIN_VALUE;
      int max_cardinality_int = Integer.MIN_VALUE;

      if (inva.testMin_cardinality(null)) {
        min_cardinality = inva.getMin_cardinality(null);

        if (min_cardinality instanceof EInteger_bound) {
          min_cardinality_int = ((EInteger_bound) min_cardinality).getBound_value(null);
        }
      }

      if (inva.testMax_cardinality(null)) {
        max_cardinality = inva.getMax_cardinality(null);

        if (max_cardinality instanceof EInteger_bound) {
          max_cardinality_int = ((EInteger_bound) max_cardinality).getBound_value(null);
        }
      }

      if (min_cardinality_int == Integer.MIN_VALUE) { // single entity inverse attribute
        pw.println("\t// Inverse attribute - " + inva.getName(null) + " : " + 
                   referencing_entity_name + " FOR " + inverted_attr_name);
      } else { // set or bag inverse attribute

        if (duplicates) { // bag

          if (max_cardinality_int == Integer.MIN_VALUE) {
            pw.println("\t// Inverse attribute - " + inva.getName(null) + " : BAG[" + 
                       min_cardinality_int + ":?] OF " + referencing_entity_name + " FOR " + 
                       inverted_attr_name);
          } else {
            pw.println("\t// Inverse attribute - " + inva.getName(null) + " : BAG[" + 
                       min_cardinality_int + ":" + max_cardinality_int + "] OF " + 
                       referencing_entity_name + " FOR " + inverted_attr_name);
          }
        } else { // set

          if (max_cardinality_int == Integer.MIN_VALUE) {
            pw.println("\t// Inverse attribute - " + inva.getName(null) + " : SET[" + 
                       min_cardinality_int + ":" + max_cardinality_int + "] OF " + 
                       referencing_entity_name + " FOR " + inverted_attr_name);
          } else {
          }
        }
      }

      String inverse_aggregate = getEntityPackage(referencing_entity) + "A" + 
                                 referencing_entity_name.substring(0, 1).toUpperCase() + 
                                 referencing_entity_name.substring(1).toLowerCase();
      String attr_name1 = inva.getName(null);
      String attr_name = attr_name1.substring(0, 1).toUpperCase() + 
                         attr_name1.substring(1).toLowerCase();
      ;
      pw.println("\tpublic " + inverse_aggregate + " get" + attr_name + "(" + 
                 entity_interface_name + " type, ASdaiModel domain) throws SdaiException;");
    }


    //      EEntity_definition type, ASchemaInstance domain)
    pw.println("}");
    pw.flush();
    pw.close();
  }

  void generateDerivedAttributeMethodDeclarations(EDerived_attribute attr, String entity_name, 
                                                  PrintWriter pw)
                                           throws SdaiException {
    // boolean is_domain = attr.testDomain(null); // no need to test, I myself set domain.
    String attr_name = attr.getName(null);
    String method_suffix = attr_name.substring(0, 1).toUpperCase() + 
                           attr_name.substring(1).toLowerCase();

    // pre-X    EEntity_definition owner_entity = attr.getParent_entity(null);
    EEntity_definition owner_entity = (EEntity_definition) attr.getParent_entity(null);
    String owner_name = owner_entity.getName(null);
    String owning_entity_name = getEntityPackage(owner_entity) + "E" + 
                                owner_name.substring(0, 1).toUpperCase() + 
                                owner_name.substring(1).toLowerCase();
    ;

    EEntity bt = null;
    if (attr.testDomain(null)) {
	    bt = attr.getDomain(null);
		} else {
			pw.println("WARNING! Method declarations not generated - attribute domain is NULL: " + attr);
			System.out.println("WARNING! Method declarations not generated - attribute domain is NULL: " + attr);
			return;
		}

		if (bt instanceof EParameter) {
			bt = ((EParameter)bt).getParameter_type(null);
		}


    // simple_type, going directly to its subtypes
    if (bt instanceof ESimple_type) {
      generateDerivedAttributeSimpleTypeMethodDeclarations((ESimple_type) bt, pw, entity_name, 
                                                           attr_name, method_suffix);
    } else if (bt instanceof EAggregation_type) {
      generateDerivedAttributeAggregationTypeMethodDeclarations((EAggregation_type) bt, pw, 
                                                                entity_name, attr_name, 
                                                                method_suffix);
    } else if (bt instanceof EDefined_type) {
      generateDerivedAttributeDefinedTypeMethodDeclarations((EDefined_type) bt, pw, entity_name, 
                                                            attr_name, method_suffix, 
                                                            owning_entity_name);
    } else if (bt instanceof EEntity_definition) {
      String base_entity_name = ((EEntity_definition) bt).getName(null);
      String base_name = getEntityPackage((EEntity_definition) bt) + "E" + 
                         base_entity_name.substring(0, 1).toUpperCase() + 
                         base_entity_name.substring(1).toLowerCase();
      pw.println("\t// attribute:" + attr_name + ", base type: entity " + base_entity_name);
      pw.println("\tpublic boolean test" + method_suffix + "(" + entity_name + " type) throws " + 
                 "SdaiException;");
      pw.println("\tpublic " + base_name + " get" + method_suffix + "(" + entity_name + 
                 " type) throws " + "SdaiException;");
    }

    pw.println("");
  }

  void generateDerivedAttributeSimpleTypeMethodDeclarations(ESimple_type st, PrintWriter pw, 
                                                            String entity_name, String attr_name, 
                                                            String method_suffix) {
    if (st instanceof EInteger_type) {
      pw.println("\t/// methods for derived attribute:" + attr_name + ", base type: INTEGER");
      pw.println("\tpublic boolean test" + method_suffix + "(" + entity_name + " type) throws " + 
                 "SdaiException;");
      pw.println("\tpublic int get" + method_suffix + "(" + entity_name + " type) throws " + 
                 "SdaiException;");
      pw.println("\tpublic Value get" + method_suffix + "(" + entity_name + 
                 " type, SdaiContext _context) throws " + "SdaiException;");
    } else if (st instanceof ENumber_type) {
      pw.println("\t/// methods for attribute:" + attr_name + ", base type: NUMBER");
      pw.println("\tpublic boolean test" + method_suffix + "(" + entity_name + " type) throws " + 
                 "SdaiException;");
      pw.println("\tpublic double get" + method_suffix + "(" + entity_name + " type) throws " + 
                 "SdaiException;");
      pw.println("\tpublic Value get" + method_suffix + "(" + entity_name + 
                 " type, SdaiContext _context) throws " + "SdaiException;");
    } else if (st instanceof EReal_type) {
      pw.println("\t/// methods for attribute:" + attr_name + ", base type: REAL");
      pw.println("\tpublic boolean test" + method_suffix + "(" + entity_name + " type) throws " + 
                 "SdaiException;");
      pw.println("\tpublic double get" + method_suffix + "(" + entity_name + " type) throws " + 
                 "SdaiException;");
      pw.println("\tpublic Value get" + method_suffix + "(" + entity_name + 
                 " type, SdaiContext _context) throws " + "SdaiException;");
    } else if (st instanceof EBoolean_type) {
      pw.println("\t/// methods for attribute:" + attr_name + ", base type: BOOLEAN");
      pw.println("\tpublic boolean test" + method_suffix + "(" + entity_name + " type) throws " + 
                 "SdaiException;");
      pw.println("\tpublic int get" + method_suffix + "(" + entity_name + " type) throws " + 
                 "SdaiException;");
      pw.println("\tpublic Value get" + method_suffix + "(" + entity_name + 
                 " type, SdaiContext _context) throws " + "SdaiException;");
    } else if (st instanceof ELogical_type) {
      pw.println("\t/// methods for attribute:" + attr_name + ", base type: LOGICAL");
      pw.println("\tpublic boolean test" + method_suffix + "(" + entity_name + " type) throws " + 
                 "SdaiException;");
      pw.println("\tpublic int get" + method_suffix + "(" + entity_name + " type) throws " + 
                 "SdaiException;");
      pw.println("\tpublic Value get" + method_suffix + "(" + entity_name + 
                 " type, SdaiContext _context) throws " + "SdaiException;");
    } else if (st instanceof EBinary_type) {
      pw.println("\t/// methods for attribute:" + attr_name + ", base type: BINARY");
      pw.println("\tpublic boolean test" + method_suffix + "(" + entity_name + " type) throws " + 
                 "SdaiException;");
      pw.println("\tpublic Binary get" + method_suffix + "(" + entity_name + " type) throws " + 
                 "SdaiException;");
      pw.println("\tpublic Value get" + method_suffix + "(" + entity_name + 
                 " type, SdaiContext _context) throws " + "SdaiException;");
    } else if (st instanceof EString_type) {
      pw.println("\t/// methods for attribute:" + attr_name + ", base type: STRING");
      pw.println("\tpublic boolean test" + method_suffix + "(" + entity_name + " type) throws " + 
                 "SdaiException;");
      pw.println("\tpublic String get" + method_suffix + "(" + entity_name + " type) throws " + 
                 "SdaiException;");
      pw.println("\tpublic Value get" + method_suffix + "(" + entity_name + 
                 " type, SdaiContext _context) throws " + "SdaiException;");
    }
  }

  void generateDerivedAttributeAggregationTypeMethodDeclarations(EAggregation_type at, 
                                                                 PrintWriter pw, String entity_name, 
                                                                 String attr_name, 
                                                                 String method_suffix)
    throws SdaiException {
    String comment = "";

    if (at instanceof EArray_type) {
      comment += "ARRAY OF ";
    } else if (at instanceof EBag_type) {
      comment += "BAG OF ";
    } else if (at instanceof ESet_type) {
      comment += "SET OF ";
    } else if (at instanceof EList_type) {
      comment += "LIST OF ";
    }

    int aggregate_depth = 1;
    EEntity an_ss;
    EEntity ass = at;
    String aggr_prefices = "";
    an_ss = at.getElement_type(null);

    for (;;) {
      boolean done_something = false;

      if (an_ss instanceof EDefined_type) {
        ass = an_ss;
        an_ss = ((EDefined_type) an_ss).getDomain(null);
        done_something = true;
      } else if (an_ss instanceof EAggregation_type) {
        aggr_prefices += "a";
        aggregate_depth++;
        ass = an_ss;

        if (ass instanceof EArray_type) {
          comment += "ARRAY OF ";
        } else if (ass instanceof EBag_type) {
          comment += "BAG OF ";
        } else if (ass instanceof ESet_type) {
          comment += "SET OF ";
        } else if (ass instanceof EList_type) {
          comment += "LIST OF ";
        }

        an_ss = ((EAggregation_type) an_ss).getElement_type(null);
        done_something = true;
      }

      if (!done_something) {
        break;
      }
    }

    String aggr_prefix = "A" + aggr_prefices;

    if (an_ss instanceof ESelect_type) {
      pw.println("\t// methods for attribute: " + attr_name + ", base type: " + comment + 
                 "SELECT");
      pw.println("\tpublic boolean test" + method_suffix + "(" + entity_name + " type) throws " + 
                 "SdaiException;");
      pw.println("\tpublic Value get" + method_suffix + "(" + entity_name + 
                 " type, SdaiContext _context) throws " + "SdaiException;");
      pw.println("\tpublic " + getAggregatePackage(aggr_prefix, ass) + " get" + method_suffix + 
                 "(" + entity_name + " type) throws " + "SdaiException;");
//System.out.println("UAD-01");
      updateAggregateDepth((ENamed_type) ass, aggregate_depth);
    } else if (an_ss instanceof EEntity_definition) {
      pw.println("\t// methods for attribute: " + attr_name + ", base type: " + comment + 
                 "ENTITY");
      pw.println("\tpublic boolean test" + method_suffix + "(" + entity_name + " type) throws " + 
                 "SdaiException;");
      pw.println("\tpublic Value get" + method_suffix + "(" + entity_name + 
                 " type, SdaiContext _context) throws " + "SdaiException;");
      pw.println("\tpublic " + getAggregatePackage(aggr_prefix, an_ss) + " get" + method_suffix + 
                 "(" + entity_name + " type) throws " + "SdaiException;");
//System.out.println("UAD-02");
      updateAggregateDepth((ENamed_type) an_ss, aggregate_depth);
    } else if (an_ss instanceof EEnumeration_type) {
      pw.println("\t// methods for attribute: " + attr_name + ", base type: " + comment + 
                 "ENUMERATION");
      pw.println("\tpublic boolean test" + method_suffix + "(" + entity_name + " type) throws " + 
                 "SdaiException;");
      pw.println("\tpublic Value get" + method_suffix + "(" + entity_name + 
                 " type, SdaiContext _context) throws " + "SdaiException;");
      pw.println("\tpublic " + aggr_prefix + "_enumeration get" + method_suffix + "(" + 
                 entity_name + " type) throws " + "SdaiException;");
    } else if (an_ss instanceof EInteger_type) {
      pw.println("\t// methods for attribute: " + attr_name + ", base type: " + comment + 
                 "INTEGER");
      pw.println("\tpublic boolean test" + method_suffix + "(" + entity_name + " type) throws " + 
                 "SdaiException;");
      pw.println("\tpublic Value get" + method_suffix + "(" + entity_name + 
                 " type, SdaiContext _context) throws " + "SdaiException;");
      pw.println("\tpublic " + aggr_prefix + "_integer get" + method_suffix + "(" + entity_name + 
                 " type) throws " + "SdaiException;");
    } else if (an_ss instanceof ENumber_type) {
      pw.println("\t// methods for attribute: " + attr_name + ", base type: " + comment + 
                 "NUMBER");
      pw.println("\tpublic boolean test" + method_suffix + "(" + entity_name + " type) throws " + 
                 "SdaiException;");
      pw.println("\tpublic Value get" + method_suffix + "(" + entity_name + 
                 " type, SdaiContext _context) throws " + "SdaiException;");
      pw.println("\tpublic " + aggr_prefix + "_double get" + method_suffix + "(" + entity_name + 
                 " type) throws " + "SdaiException;");
    } else if (an_ss instanceof EReal_type) {
      pw.println("\t// methods for attribute: " + attr_name + ", base type: " + comment + "REAL");
      pw.println("\tpublic boolean test" + method_suffix + "(" + entity_name + " type) throws " + 
                 "SdaiException;");
      pw.println("\tpublic Value get" + method_suffix + "(" + entity_name + 
                 " type, SdaiContext _context) throws " + "SdaiException;");
      pw.println("\tpublic " + aggr_prefix + "_double get" + method_suffix + "(" + entity_name + 
                 " type) throws " + "SdaiException;");
    } else if (an_ss instanceof EString_type) {
      pw.println("\t// methods for attribute: " + attr_name + ", base type: " + comment + 
                 "STRING");
      pw.println("\tpublic boolean test" + method_suffix + "(" + entity_name + " type) throws " + 
                 "SdaiException;");
      pw.println("\tpublic Value get" + method_suffix + "(" + entity_name + 
                 " type, SdaiContext _context) throws " + "SdaiException;");
      pw.println("\tpublic " + aggr_prefix + "_string get" + method_suffix + "(" + entity_name + 
                 " type) throws " + "SdaiException;");
    } else if (an_ss instanceof ELogical_type) {
      pw.println("\t// methods for attribute: " + attr_name + ", base type: " + comment + 
                 "LOGICAL");
      pw.println("\tpublic boolean test" + method_suffix + "(" + entity_name + " type) throws " + 
                 "SdaiException;");
      pw.println("\tpublic Value get" + method_suffix + "(" + entity_name + 
                 " type, SdaiContext _context) throws " + "SdaiException;");
      pw.println("\tpublic " + aggr_prefix + "_enumeration get" + method_suffix + "(" + 
                 entity_name + " type) throws " + "SdaiException;");
    } else if (an_ss instanceof EBoolean_type) {
      pw.println("\t// methods for attribute: " + attr_name + ", base type: " + comment + 
                 "BOOLEAN");
      pw.println("\tpublic boolean test" + method_suffix + "(" + entity_name + " type) throws " + 
                 "SdaiException;");
      pw.println("\tpublic Value get" + method_suffix + "(" + entity_name + 
                 " type, SdaiContext _context) throws " + "SdaiException;");
      pw.println("\tpublic " + aggr_prefix + "_boolean get" + method_suffix + "(" + entity_name + 
                 " type) throws " + "SdaiException;");
    } else if (an_ss instanceof EBinary_type) {
      pw.println("\t// methods for attribute: " + attr_name + ", base type: " + comment + 
                 "BINARY");
      pw.println("\tpublic boolean test" + method_suffix + "(" + entity_name + " type) throws " + 
                 "SdaiException;");
      pw.println("\tpublic Value get" + method_suffix + "(" + entity_name + 
                 " type, SdaiContext _context) throws " + "SdaiException;");
      pw.println("\tpublic " + aggr_prefix + "_binary get" + method_suffix + "(" + entity_name + 
                 " type) throws " + "SdaiException;");
    }
  }

  void generateDerivedAttributeDefinedTypeMethodDeclarations(EDefined_type dt, PrintWriter pw, 
                                                             String entity_name, String attr_name, 
                                                             String method_suffix, 
                                                             String owning_entity_name)
                                                      throws SdaiException {
    EEntity ut = dt.getDomain(null);

    if (ut instanceof ESimple_type) {
      generateDerivedAttributeSimpleTypeMethodDeclarations((ESimple_type) ut, pw, entity_name, 
                                                           attr_name, method_suffix);
    } else if (ut instanceof EAggregation_type) {
      generateDerivedAttributeAggregationTypeMethodDeclarations((EAggregation_type) ut, pw, 
                                                                entity_name, attr_name, 
                                                                method_suffix);
    } else if (ut instanceof EDefined_type) {
      generateDerivedAttributeDefinedTypeMethodDeclarations((EDefined_type) ut, pw, entity_name, 
                                                            attr_name, method_suffix, 
                                                            owning_entity_name);
    } else if (ut instanceof EEnumeration_type) {
//      A_string enelements = ((EEnumeration_type) ut).getElements(null);
//      A_string enelements = ((EEnumeration_type) ut).getLocal_elements(null);
//      A_string enelements = getElements((EEnumeration_type) ut);
      Vector enelements = getElementsV((EEnumeration_type) ut);
      generateDerivedEnumerationMethodDeclarations((EEnumeration_type) ut, pw, entity_name, 
                                                   attr_name, method_suffix);
    } else if (ut instanceof ESelect_type) {
//      ANamed_type nt = ((ESelect_type) ut).getSelections(null);
//      ANamed_type nt = ((ESelect_type) ut).getLocal_selections(null);
      ANamed_type nt = getSelections((ESelect_type) ut);

      //         int select_type = calculateSelectPaths(nt); // 0 - pure entity, 1 - pure defined_type or 2 - mixed select
      SelectPaths paths1 = null;
      int select_type = Integer.MIN_VALUE;
      Object temp_object = ut.getTemp();

      if (temp_object instanceof SelectPaths) {
        if (((SelectPaths) temp_object).owner == (ESelect_type) ut) {
          paths1 = (SelectPaths) temp_object;
          select_type = paths1.select_type;
        }
      }

      if (paths1 == null) {
        int count = 1;
        int[] indeces = new int[500];
        int depth = 0;
        int depth_count = 0;
        boolean with_type = false;
        Vector current_nodes = new Vector();
        Vector current_node_strings = new Vector();
        paths1 = new SelectPaths();
        paths1.owner = (ESelect_type) ut;
        select_type = calculateSelectPaths(count, current_nodes, current_node_strings, indeces, 
                                           depth, depth_count, paths1, (ESelect_type) ut, with_type);
        paths1.removeIdentical();
        paths1.select_type = select_type;
        ut.setTemp(paths1);
      }


      // pw.println("debug: " + select_type);
      pw.println("\t// constants and methods for SELECT attribute: " + attr_name);

      if (select_type > 0) { // includes defined_types
        paths1.generateConstants(pw, attr_name);
        pw.println("");
      }

      /*
      if (select_type < 2) { // includes entieties
         generateEntityMethodDeclarationsForSelect((ESelect_type)ut, pw, entity_name, attr_name, method_suffix);
      } 
      if (select_type > 0) { // includes defined_types
         paths1.generateDefinedTypeGetMethodDeclarations((ESelect_type)ut, pw, entity_name, attr_name, method_suffix);
      }
       */
      if (select_type == 0) {
        pw.println("\tboolean test" + normalize(attr_name) + "(" + entity_name + 
                   " type) throws SdaiException;");
      } else {
        pw.println("\tint test" + normalize(attr_name) + "(" + entity_name + 
                   " type) throws SdaiException;");
      }

      pw.println("");
      paths1.generateGetDerivedInterfaces((ESelect_type) ut, pw, entity_name, attr_name, 
                                          method_suffix, select_type, owning_entity_name);
      pw.println("");
      pw.println("\tpublic Value get" + normalize(attr_name) + "(" + entity_name + 
                 " type, SdaiContext _context) throws " + "SdaiException;");
    }
  }


  void generateExplicitRedeclaringAttributeMethodDeclarations(EExplicit_attribute attr, String entity_name, PrintWriter pw) throws SdaiException {
    
		/*

				here's the thing:
				the name that is invoked internally is always previous, one step back (not important for interfaces)
				the type - not so simple:
				First we have to calculate what type was used for previous method, then to see if it can be changed to the current type
				For previous method, either its own type was used, or one step further back, etc.
				Seems that in order to calculate it, we need to go back step-by-step to the original attribute, and then forward again,
				calculating the type in each step on the way up until we reach the current attribute

		*/

	
	//EExplicit_attribute xattr_original = getOriginalExplicitAttribute(xattr);

  //EEntity bt = xattr_original.getDomain(null);

    String attr_name = attr.getName(null);
    String method_suffix = attr_name.substring(0, 1).toUpperCase() + 
                           attr_name.substring(1).toLowerCase();
		String attr_name_prev = attr.getRedeclaring(null).getName(null);
		if (attr_name.equalsIgnoreCase(attr_name_prev)) {
			// if not renamed, nothing is generated
			return;
		}
    String method_suffix_prev = attr_name_prev.substring(0, 1).toUpperCase() + 
                           attr_name_prev.substring(1).toLowerCase();
		
    EEntity bt = null;
    if (attr.testDomain(null)) {
      bt = attr.getDomain(null);
    } else {
      System.out.println("XP: >>> aattribute domain is NULL: " + attr.getName(null));
    }
	 bt = calculateTypeOfRedeclaredAttribute(attr);
  
    if (bt instanceof ESimple_type) {
    } else 
    if (bt instanceof EAggregation_type) {
      generateExplicitAttributeAggregationTypeMethodDeclarationsRenamed((EAggregation_type) bt, pw, 
                                                                 entity_name, attr_name, 
                                                                 method_suffix,
                                                                 attr,
                                                                 method_suffix_prev);
    } else
  	if (bt instanceof EDefined_type) {
      generateExplicitAttributeDefinedTypeMethodDeclarationsRenamed((EDefined_type) bt, pw, entity_name, 
                                                             attr_name, method_suffix,
                                                             attr,
                                                             method_suffix_prev);
    } else 
    if (bt instanceof EEntity_definition) {
      String base_entity_name = ((EEntity_definition) bt).getName(null);
      String base_name = getEntityPackage((EEntity_definition) bt) + "E" + 
                         base_entity_name.substring(0, 1).toUpperCase() + 
                         base_entity_name.substring(1).toLowerCase();
      pw.println("\t// attribute:" + attr_name + ", base type: entity " + base_entity_name);
      pw.println("\tpublic boolean test" + method_suffix + "(" + entity_name + " type) throws " + 
                 "SdaiException;");
      pw.println("\tpublic " + base_name + " get" + method_suffix + "(" + entity_name + 
                 " type) throws " + "SdaiException;");
      pw.println("\tpublic void set" + method_suffix + "(" + entity_name + " type, " + base_name + 
                 " value) throws " + "SdaiException;");
      pw.println("\tpublic void unset" + method_suffix + "(" + entity_name + " type) throws " + 
                 "SdaiException;");
		}		  	
  }

  void generateExplicitAttributeMethodDeclarations(EExplicit_attribute attr, String entity_name, PrintWriter pw) throws SdaiException {
    // boolean is_domain = attr.testDomain(null); // no need to test, I myself set domain.
    String attr_name = attr.getName(null);
    String method_suffix = attr_name.substring(0, 1).toUpperCase() + 
                           attr_name.substring(1).toLowerCase();

    // System.out.println("entity name: " + entity_name + ", attribute: " + attr.getName(null));
    EEntity bt = null;

    if (attr.testDomain(null)) {
      bt = attr.getDomain(null);
    } else {
      System.out.println("XP: >>> aattribute domain is NULL: " + attr.getName(null));
    }

// System.out.println("goOog bt: " + bt);

		if (bt instanceof EParameter) {
			bt = ((EParameter)bt).getParameter_type(null);
		}

// System.out.println("goOog new bt: " + bt);

    // simple_type, going directly to its subtypes
    if (bt instanceof ESimple_type) {
      generateExplicitAttributeSimpleTypeMethodDeclarations((ESimple_type) bt, pw, entity_name, 
                                                            attr_name, method_suffix);
    } else if (bt instanceof EAggregation_type) {
      generateExplicitAttributeAggregationTypeMethodDeclarations((EAggregation_type) bt, pw, 
                                                                 entity_name, attr_name, 
                                                                 method_suffix);
    } else
    /*
    if (bt instanceof EArray_type) {
    } else
    // variable_size_aggregation_type
    if (bt instanceof EBag_type) {
    } else
    if (bt instanceof ESet_type) {
    } else
    if (bt instanceof EList_type) {
    } else
     */

    // named type
    if (bt instanceof EDefined_type) {
      generateExplicitAttributeDefinedTypeMethodDeclarations((EDefined_type) bt, pw, entity_name, 
                                                             attr_name, method_suffix);
    } else if (bt instanceof EEntity_definition) {
      String base_entity_name = ((EEntity_definition) bt).getName(null);
      String base_name = getEntityPackage((EEntity_definition) bt) + "E" + 
                         base_entity_name.substring(0, 1).toUpperCase() + 
                         base_entity_name.substring(1).toLowerCase();
      pw.println("\t// attribute:" + attr_name + ", base type: entity " + base_entity_name);
      pw.println("\tpublic boolean test" + method_suffix + "(" + entity_name + " type) throws " + 
                 "SdaiException;");
      pw.println("\tpublic " + base_name + " get" + method_suffix + "(" + entity_name + 
                 " type) throws " + "SdaiException;");
      pw.println("\tpublic void set" + method_suffix + "(" + entity_name + " type, " + base_name + 
                 " value) throws " + "SdaiException;");
      pw.println("\tpublic void unset" + method_suffix + "(" + entity_name + " type) throws " + 
                 "SdaiException;");
    }

    pw.println("");
  }


  void generateExplicitAttributeAggregationTypeMethodDeclarationsRenamed(EAggregation_type at, 
                                                                  PrintWriter pw, 
                                                                  String entity_name, 
                                                                  String attr_name, 
                                                                  String method_suffix,
                                                                  EExplicit_attribute xattr,
                                                                  String method_suffix_prev) throws SdaiException {

//	EExplicit_attribute xattr_original = getOriginalExplicitAttribute(xattr);

//  EEntity bt = xattr_original.getDomain(null);
  
//  if (bt instanceof EAggregation_type) {
//		at = (EAggregation_type)bt;
//	}


    String comment = "";

    if (at instanceof EArray_type) {
      comment += "ARRAY OF ";
    } else if (at instanceof EBag_type) {
      comment += "BAG OF ";
    } else if (at instanceof ESet_type) {
      comment += "SET OF ";
    } else if (at instanceof EList_type) {
      comment += "LIST OF ";
    }

    int aggregate_depth = 1;
    EEntity an_ss;
    EEntity ass = at;
    String aggr_prefices = "";
printDDebug("aggregation type: " + at);
    an_ss = at.getElement_type(null);

    for (;;) {
      boolean done_something = false;

      if (an_ss instanceof EDefined_type) {
        ass = an_ss;
        an_ss = ((EDefined_type) an_ss).getDomain(null);
        done_something = true;
      } else if (an_ss instanceof EAggregation_type) {
        aggr_prefices += "a";
        aggregate_depth++;
        ass = an_ss;

        if (ass instanceof EArray_type) {
          comment += "ARRAY OF ";
        } else if (ass instanceof EBag_type) {
          comment += "BAG OF ";
        } else if (ass instanceof ESet_type) {
          comment += "SET OF ";
        } else if (ass instanceof EList_type) {
          comment += "LIST OF ";
        }

        an_ss = ((EAggregation_type) an_ss).getElement_type(null);
        done_something = true;
      }

      if (!done_something) {
        break;
      }
    }

    String aggr_prefix = "A" + aggr_prefices;

    if (an_ss instanceof ESelect_type) {
      pw.println("\t// methods for attribute: " + attr_name + ", base type: " + comment + 
                 "SELECT");
      pw.println("\tpublic boolean test" + method_suffix + "(" + entity_name + " type) throws " + 
                 "SdaiException;");
      pw.println("\tpublic " + getAggregatePackage(aggr_prefix, ass) + " get" + method_suffix + 
                 "(" + entity_name + " type) throws " + "SdaiException;");
      pw.println("\tpublic " + getAggregatePackage(aggr_prefix, ass) + " create" + method_suffix + 
                 "(" + entity_name + " type) throws " + "SdaiException;");
      pw.println("\tpublic void unset" + method_suffix + "(" + entity_name + " type) throws " + 
                 "SdaiException;");
//System.out.println("UAD-03");
      updateAggregateDepth((ENamed_type) ass, aggregate_depth);
    } else if (an_ss instanceof EEntity_definition) {
      pw.println("\t// methods for attribute: " + attr_name + ", base type: " + comment + 
                 "ENTITY");
      pw.println("\tpublic boolean test" + method_suffix + "(" + entity_name + " type) throws " + 
                 "SdaiException;");
      pw.println("\tpublic " + getAggregatePackage(aggr_prefix, an_ss) + " get" + method_suffix + 
                 "(" + entity_name + " type) throws " + "SdaiException;");
      pw.println("\tpublic " + getAggregatePackage(aggr_prefix, an_ss) + " create" + 
                 method_suffix + "(" + entity_name + " type) throws " + "SdaiException;");
      pw.println("\tpublic void unset" + method_suffix + "(" + entity_name + " type) throws " + 
                 "SdaiException;");
//System.out.println("UAD-04");
      updateAggregateDepth((ENamed_type) an_ss, aggregate_depth);
    } else if (an_ss instanceof EEnumeration_type) {
      pw.println("\t// methods for attribute: " + attr_name + ", base type: " + comment + 
                 "ENUMERATION");
      pw.println("\tpublic boolean test" + method_suffix + "(" + entity_name + " type) throws " + 
                 "SdaiException;");
      pw.println("\tpublic " + aggr_prefix + "_enumeration get" + method_suffix + "(" + 
                 entity_name + " type) throws " + "SdaiException;");
      pw.println("\tpublic " + aggr_prefix + "_enumeration create" + method_suffix + "(" + 
                 entity_name + " type) throws " + "SdaiException;");
      pw.println("\tpublic void unset" + method_suffix + "(" + entity_name + " type) throws " + 
                 "SdaiException;");
    } else if (an_ss instanceof EInteger_type) {
      pw.println("\t// methods for attribute: " + attr_name + ", base type: " + comment + 
                 "INTEGER");
      pw.println("\tpublic boolean test" + method_suffix + "(" + entity_name + " type) throws " + 
                 "SdaiException;");
      pw.println("\tpublic " + aggr_prefix + "_integer get" + method_suffix + "(" + entity_name + 
                 " type) throws " + "SdaiException;");
      pw.println("\tpublic " + aggr_prefix + "_integer create" + method_suffix + "(" + 
                 entity_name + " type) throws " + "SdaiException;");
      pw.println("\tpublic void unset" + method_suffix + "(" + entity_name + " type) throws " + 
                 "SdaiException;");
    } else if (an_ss instanceof ENumber_type) {
      pw.println("\t// methods for attribute: " + attr_name + ", base type: " + comment + 
                 "NUMBER");
      pw.println("\tpublic boolean test" + method_suffix + "(" + entity_name + " type) throws " + 
                 "SdaiException;");
      pw.println("\tpublic " + aggr_prefix + "_double get" + method_suffix + "(" + entity_name + 
                 " type) throws " + "SdaiException;");
      pw.println("\tpublic " + aggr_prefix + "_double create" + method_suffix + "(" + 
                 entity_name + " type) throws " + "SdaiException;");
      pw.println("\tpublic void unset" + method_suffix + "(" + entity_name + " type) throws " + 
                 "SdaiException;");
    } else if (an_ss instanceof EReal_type) {
      pw.println("\t// methods for attribute: " + attr_name + ", base type: " + comment + "REAL");
      pw.println("\tpublic boolean test" + method_suffix + "(" + entity_name + " type) throws " + 
                 "SdaiException;");
      pw.println("\tpublic " + aggr_prefix + "_double get" + method_suffix + "(" + entity_name + 
                 " type) throws " + "SdaiException;");
      pw.println("\tpublic " + aggr_prefix + "_double create" + method_suffix + "(" + 
                 entity_name + " type) throws " + "SdaiException;");
      pw.println("\tpublic void unset" + method_suffix + "(" + entity_name + " type) throws " + 
                 "SdaiException;");
    } else if (an_ss instanceof EString_type) {
      pw.println("\t// methods for attribute: " + attr_name + ", base type: " + comment + 
                 "STRING");
      pw.println("\tpublic boolean test" + method_suffix + "(" + entity_name + " type) throws " + 
                 "SdaiException;");
      pw.println("\tpublic " + aggr_prefix + "_string get" + method_suffix + "(" + entity_name + 
                 " type) throws " + "SdaiException;");
      pw.println("\tpublic " + aggr_prefix + "_string create" + method_suffix + "(" + 
                 entity_name + " type) throws " + "SdaiException;");
      pw.println("\tpublic void unset" + method_suffix + "(" + entity_name + " type) throws " + 
                 "SdaiException;");
    } else if (an_ss instanceof ELogical_type) {
      pw.println("\t// methods for attribute: " + attr_name + ", base type: " + comment + 
                 "LOGICAL");
      pw.println("\tpublic boolean test" + method_suffix + "(" + entity_name + " type) throws " + 
                 "SdaiException;");
      pw.println("\tpublic " + aggr_prefix + "_enumeration get" + method_suffix + "(" + 
                 entity_name + " type) throws " + "SdaiException;");
      pw.println("\tpublic " + aggr_prefix + "_enumeration create" + method_suffix + "(" + 
                 entity_name + " type) throws " + "SdaiException;");
      pw.println("\tpublic void unset" + method_suffix + "(" + entity_name + " type) throws " + 
                 "SdaiException;");
    } else if (an_ss instanceof EBoolean_type) {
      pw.println("\t// methods for attribute: " + attr_name + ", base type: " + comment + 
                 "BOOLEAN");
      pw.println("\tpublic boolean test" + method_suffix + "(" + entity_name + " type) throws " + 
                 "SdaiException;");
      pw.println("\tpublic " + aggr_prefix + "_boolean get" + method_suffix + "(" + entity_name + 
                 " type) throws " + "SdaiException;");
      pw.println("\tpublic " + aggr_prefix + "_boolean create" + method_suffix + "(" + 
                 entity_name + " type) throws " + "SdaiException;");
      pw.println("\tpublic void unset" + method_suffix + "(" + entity_name + " type) throws " + 
                 "SdaiException;");
    } else if (an_ss instanceof EBinary_type) {
      pw.println("\t// methods for attribute: " + attr_name + ", base type: " + comment + 
                 "BINARY");
      pw.println("\tpublic boolean test" + method_suffix + "(" + entity_name + " type) throws " + 
                 "SdaiException;");
      pw.println("\tpublic " + aggr_prefix + "_binary get" + method_suffix + "(" + entity_name + 
                 " type) throws " + "SdaiException;");
      pw.println("\tpublic " + aggr_prefix + "_binary create" + method_suffix + "(" + 
                 entity_name + " type) throws " + "SdaiException;");
      pw.println("\tpublic void unset" + method_suffix + "(" + entity_name + " type) throws " + 
                 "SdaiException;");
    }
  }



  void generateExplicitAttributeAggregationTypeMethodDeclarations(EAggregation_type at, 
                                                                  PrintWriter pw, 
                                                                  String entity_name, 
                                                                  String attr_name, 
                                                                  String method_suffix)
    throws SdaiException {
    String comment = "";

// System.out.println("goOog initial at: " + at);


    if (at instanceof EArray_type) {
      comment += "ARRAY OF ";
    } else if (at instanceof EBag_type) {
      comment += "BAG OF ";
    } else if (at instanceof ESet_type) {
      comment += "SET OF ";
    } else if (at instanceof EList_type) {
      comment += "LIST OF ";
    }

    int aggregate_depth = 1;
    EEntity an_ss;
    EEntity ass = at;
    String aggr_prefices = "";
printDDebug("aggregation type: " + at);
    an_ss = at.getElement_type(null);

    for (;;) {
      boolean done_something = false;

      if (an_ss instanceof EDefined_type) {
        ass = an_ss;
        an_ss = ((EDefined_type) an_ss).getDomain(null);
        done_something = true;
      } else if (an_ss instanceof EAggregation_type) {
        aggr_prefices += "a";
        aggregate_depth++;
        ass = an_ss;

        if (ass instanceof EArray_type) {
          comment += "ARRAY OF ";
        } else if (ass instanceof EBag_type) {
          comment += "BAG OF ";
        } else if (ass instanceof ESet_type) {
          comment += "SET OF ";
        } else if (ass instanceof EList_type) {
          comment += "LIST OF ";
        }

        an_ss = ((EAggregation_type) an_ss).getElement_type(null);
        done_something = true;
      }

      if (!done_something) {
        break;
      }
    }

    String aggr_prefix = "A" + aggr_prefices;

    if (an_ss instanceof ESelect_type) {
      pw.println("\t// methods for attribute: " + attr_name + ", base type: " + comment + 
                 "SELECT");
      pw.println("\tpublic boolean test" + method_suffix + "(" + entity_name + " type) throws " + 
                 "SdaiException;");
      pw.println("\tpublic " + getAggregatePackage(aggr_prefix, ass) + " get" + method_suffix + 
                 "(" + entity_name + " type) throws " + "SdaiException;");
      pw.println("\tpublic " + getAggregatePackage(aggr_prefix, ass) + " create" + method_suffix + 
                 "(" + entity_name + " type) throws " + "SdaiException;");
      pw.println("\tpublic void unset" + method_suffix + "(" + entity_name + " type) throws " + 
                 "SdaiException;");
//System.out.println("UAD-05");
      updateAggregateDepth((ENamed_type) ass, aggregate_depth);
    } else if (an_ss instanceof EEntity_definition) {
      pw.println("\t// methods for attribute: " + attr_name + ", base type: " + comment + 
                 "ENTITY");
      pw.println("\tpublic boolean test" + method_suffix + "(" + entity_name + " type) throws " + 
                 "SdaiException;");
      pw.println("\tpublic " + getAggregatePackage(aggr_prefix, an_ss) + " get" + method_suffix + 
                 "(" + entity_name + " type) throws " + "SdaiException;");
      pw.println("\tpublic " + getAggregatePackage(aggr_prefix, an_ss) + " create" + 
                 method_suffix + "(" + entity_name + " type) throws " + "SdaiException;");
      pw.println("\tpublic void unset" + method_suffix + "(" + entity_name + " type) throws " + 
                 "SdaiException;");
//System.out.println("UAD-06");
      updateAggregateDepth((ENamed_type) an_ss, aggregate_depth);
    } else if (an_ss instanceof EEnumeration_type) {
      pw.println("\t// methods for attribute: " + attr_name + ", base type: " + comment + 
                 "ENUMERATION");
      pw.println("\tpublic boolean test" + method_suffix + "(" + entity_name + " type) throws " + 
                 "SdaiException;");
      pw.println("\tpublic " + aggr_prefix + "_enumeration get" + method_suffix + "(" + 
                 entity_name + " type) throws " + "SdaiException;");
      pw.println("\tpublic " + aggr_prefix + "_enumeration create" + method_suffix + "(" + 
                 entity_name + " type) throws " + "SdaiException;");
      pw.println("\tpublic void unset" + method_suffix + "(" + entity_name + " type) throws " + 
                 "SdaiException;");
    } else if (an_ss instanceof EInteger_type) {
      pw.println("\t// methods for attribute: " + attr_name + ", base type: " + comment + 
                 "INTEGER");
      pw.println("\tpublic boolean test" + method_suffix + "(" + entity_name + " type) throws " + 
                 "SdaiException;");
      pw.println("\tpublic " + aggr_prefix + "_integer get" + method_suffix + "(" + entity_name + 
                 " type) throws " + "SdaiException;");
      pw.println("\tpublic " + aggr_prefix + "_integer create" + method_suffix + "(" + 
                 entity_name + " type) throws " + "SdaiException;");
      pw.println("\tpublic void unset" + method_suffix + "(" + entity_name + " type) throws " + 
                 "SdaiException;");
    } else if (an_ss instanceof ENumber_type) {
      pw.println("\t// methods for attribute: " + attr_name + ", base type: " + comment + 
                 "NUMBER");
      pw.println("\tpublic boolean test" + method_suffix + "(" + entity_name + " type) throws " + 
                 "SdaiException;");
      pw.println("\tpublic " + aggr_prefix + "_double get" + method_suffix + "(" + entity_name + 
                 " type) throws " + "SdaiException;");
      pw.println("\tpublic " + aggr_prefix + "_double create" + method_suffix + "(" + 
                 entity_name + " type) throws " + "SdaiException;");
      pw.println("\tpublic void unset" + method_suffix + "(" + entity_name + " type) throws " + 
                 "SdaiException;");
    } else if (an_ss instanceof EReal_type) {
      pw.println("\t// methods for attribute: " + attr_name + ", base type: " + comment + "REAL");
      pw.println("\tpublic boolean test" + method_suffix + "(" + entity_name + " type) throws " + 
                 "SdaiException;");
      pw.println("\tpublic " + aggr_prefix + "_double get" + method_suffix + "(" + entity_name + 
                 " type) throws " + "SdaiException;");
      pw.println("\tpublic " + aggr_prefix + "_double create" + method_suffix + "(" + 
                 entity_name + " type) throws " + "SdaiException;");
      pw.println("\tpublic void unset" + method_suffix + "(" + entity_name + " type) throws " + 
                 "SdaiException;");
    } else if (an_ss instanceof EString_type) {
      pw.println("\t// methods for attribute: " + attr_name + ", base type: " + comment + 
                 "STRING");
      pw.println("\tpublic boolean test" + method_suffix + "(" + entity_name + " type) throws " + 
                 "SdaiException;");
      pw.println("\tpublic " + aggr_prefix + "_string get" + method_suffix + "(" + entity_name + 
                 " type) throws " + "SdaiException;");
      pw.println("\tpublic " + aggr_prefix + "_string create" + method_suffix + "(" + 
                 entity_name + " type) throws " + "SdaiException;");
      pw.println("\tpublic void unset" + method_suffix + "(" + entity_name + " type) throws " + 
                 "SdaiException;");
    } else if (an_ss instanceof ELogical_type) {
      pw.println("\t// methods for attribute: " + attr_name + ", base type: " + comment + 
                 "LOGICAL");
      pw.println("\tpublic boolean test" + method_suffix + "(" + entity_name + " type) throws " + 
                 "SdaiException;");
      pw.println("\tpublic " + aggr_prefix + "_enumeration get" + method_suffix + "(" + 
                 entity_name + " type) throws " + "SdaiException;");
      pw.println("\tpublic " + aggr_prefix + "_enumeration create" + method_suffix + "(" + 
                 entity_name + " type) throws " + "SdaiException;");
      pw.println("\tpublic void unset" + method_suffix + "(" + entity_name + " type) throws " + 
                 "SdaiException;");
    } else if (an_ss instanceof EBoolean_type) {
      pw.println("\t// methods for attribute: " + attr_name + ", base type: " + comment + 
                 "BOOLEAN");
      pw.println("\tpublic boolean test" + method_suffix + "(" + entity_name + " type) throws " + 
                 "SdaiException;");
      pw.println("\tpublic " + aggr_prefix + "_boolean get" + method_suffix + "(" + entity_name + 
                 " type) throws " + "SdaiException;");
      pw.println("\tpublic " + aggr_prefix + "_boolean create" + method_suffix + "(" + 
                 entity_name + " type) throws " + "SdaiException;");
      pw.println("\tpublic void unset" + method_suffix + "(" + entity_name + " type) throws " + 
                 "SdaiException;");
    } else if (an_ss instanceof EBinary_type) {
      pw.println("\t// methods for attribute: " + attr_name + ", base type: " + comment + 
                 "BINARY");
      pw.println("\tpublic boolean test" + method_suffix + "(" + entity_name + " type) throws " + 
                 "SdaiException;");
      pw.println("\tpublic " + aggr_prefix + "_binary get" + method_suffix + "(" + entity_name + 
                 " type) throws " + "SdaiException;");
      pw.println("\tpublic " + aggr_prefix + "_binary create" + method_suffix + "(" + 
                 entity_name + " type) throws " + "SdaiException;");
      pw.println("\tpublic void unset" + method_suffix + "(" + entity_name + " type) throws " + 
                 "SdaiException;");
    }
  }

  void updateAggregateDepth(ENamed_type nt, int aggregate_depth)
                     throws SdaiException {
		SdaiModel mdl = nt.findEntityInstanceSdaiModel();
    if (mdl.getMode() != SdaiModel.READ_WRITE) {
			// this is an incremental case, we will generate nothing
			// however, there might be a problem if higher depth is needed
//	System.out.println("AGGREGATE DEPTH - PREVIOUS MODEL, named type: " + nt + ", model: " + mdl);
      return;
    }

	
    Object temp_obj = nt.getTemp();
//if (temp_obj == null) {
//	System.out.println("temp NULL, named type: " + nt + ", schema: " + sd);
	
//}

    Integer temp_int = (Integer) temp_obj;
    int current_depth = temp_int.intValue();

    if (current_depth < aggregate_depth) {
      nt.setTemp(new Integer(aggregate_depth));
    }
  }

  /*
  if (at instanceof EArray_type) {
  } else
  // variable_size_aggregation_type
  if (at instanceof EBag_type) {
  } else
  if (at instanceof ESet_type) {
  } else
  if (at instanceof EList_type) {
  }
  }   
   */




  void generateExplicitAttributeSimpleTypeMethodDeclarationsRenamed(ESimple_type st, PrintWriter pw, 
                                                             String entity_name, String attr_name, 
                                                             String method_suffix,
                                                             EExplicit_attribute xattr,
                                                             String method_suffix_prev) {
    if (st instanceof EInteger_type) {
      pw.println("\t/// methods for attribute:" + attr_name + ", base type: INTEGER");
      pw.println("\tpublic boolean test" + method_suffix + "(" + entity_name + " type) throws " + 
                 "SdaiException;");
      pw.println("\tpublic int get" + method_suffix + "(" + entity_name + " type) throws " + 
                 "SdaiException;");
      pw.println("\tpublic void set" + method_suffix + "(" + entity_name + 
                 " type, int value) throws " + "SdaiException;");
      pw.println("\tpublic void unset" + method_suffix + "(" + entity_name + " type) throws " + 
                 "SdaiException;");
    } else if (st instanceof ENumber_type) {
      pw.println("\t/// methods for attribute:" + attr_name + ", base type: NUMBER");
      pw.println("\tpublic boolean test" + method_suffix + "(" + entity_name + " type) throws " + 
                 "SdaiException;");
      pw.println("\tpublic double get" + method_suffix + "(" + entity_name + " type) throws " + 
                 "SdaiException;");
      pw.println("\tpublic void set" + method_suffix + "(" + entity_name + 
                 " type, double value) throws " + "SdaiException;");
      pw.println("\tpublic void unset" + method_suffix + "(" + entity_name + " type) throws " + 
                 "SdaiException;");
    } else if (st instanceof EReal_type) {
      pw.println("\t/// methods for attribute:" + attr_name + ", base type: REAL");
      pw.println("\tpublic boolean test" + method_suffix + "(" + entity_name + " type) throws " + 
                 "SdaiException;");
      pw.println("\tpublic double get" + method_suffix + "(" + entity_name + " type) throws " + 
                 "SdaiException;");
      pw.println("\tpublic void set" + method_suffix + "(" + entity_name + 
                 " type, double value) throws " + "SdaiException;");
      pw.println("\tpublic void unset" + method_suffix + "(" + entity_name + " type) throws " + 
                 "SdaiException;");
    } else if (st instanceof EBoolean_type) {
      pw.println("\t/// methods for attribute:" + attr_name + ", base type: BOOLEAN");
      pw.println("\tpublic boolean test" + method_suffix + "(" + entity_name + " type) throws " + 
                 "SdaiException;");
      pw.println("\tpublic boolean get" + method_suffix + "(" + entity_name + " type) throws " + 
                 "SdaiException;");
      pw.println("\tpublic void set" + method_suffix + "(" + entity_name + 
                 " type, boolean value) throws " + "SdaiException;");
      pw.println("\tpublic void unset" + method_suffix + "(" + entity_name + " type) throws " + 
                 "SdaiException;");
    } else if (st instanceof ELogical_type) {
      pw.println("\t/// methods for attribute:" + attr_name + ", base type: LOGICAL");
      pw.println("\tpublic boolean test" + method_suffix + "(" + entity_name + " type) throws " + 
                 "SdaiException;");
      pw.println("\tpublic int get" + method_suffix + "(" + entity_name + " type) throws " + 
                 "SdaiException;");
      pw.println("\tpublic void set" + method_suffix + "(" + entity_name + 
                 " type, int value) throws " + "SdaiException;");
      pw.println("\tpublic void unset" + method_suffix + "(" + entity_name + " type) throws " + 
                 "SdaiException;");
    } else if (st instanceof EBinary_type) {
      pw.println("\t/// methods for attribute:" + attr_name + ", base type: BINARY");
      pw.println("\tpublic boolean test" + method_suffix + "(" + entity_name + " type) throws " + 
                 "SdaiException;");
      pw.println("\tpublic Binary get" + method_suffix + "(" + entity_name + " type) throws " + 
                 "SdaiException;");
      pw.println("\tpublic void set" + method_suffix + "(" + entity_name + 
                 " type, Binary value) throws " + "SdaiException;");
      pw.println("\tpublic void unset" + method_suffix + "(" + entity_name + " type) throws " + 
                 "SdaiException;");
    } else if (st instanceof EString_type) {
      pw.println("\t/// methods for attribute:" + attr_name + ", base type: STRING");
      pw.println("\tpublic boolean test" + method_suffix + "(" + entity_name + " type) throws " + 
                 "SdaiException;");
      pw.println("\tpublic String get" + method_suffix + "(" + entity_name + " type) throws " + 
                 "SdaiException;");
      pw.println("\tpublic void set" + method_suffix + "(" + entity_name + 
                 " type, String value) throws " + "SdaiException;");
      pw.println("\tpublic void unset" + method_suffix + "(" + entity_name + " type) throws " + 
                 "SdaiException;");
    }
  }




  void generateExplicitAttributeSimpleTypeMethodDeclarations(ESimple_type st, PrintWriter pw, 
                                                             String entity_name, String attr_name, 
                                                             String method_suffix) {
    if (st instanceof EInteger_type) {
      pw.println("\t/// methods for attribute:" + attr_name + ", base type: INTEGER");
      pw.println("\tpublic boolean test" + method_suffix + "(" + entity_name + " type) throws " + 
                 "SdaiException;");
      pw.println("\tpublic int get" + method_suffix + "(" + entity_name + " type) throws " + 
                 "SdaiException;");
      pw.println("\tpublic void set" + method_suffix + "(" + entity_name + 
                 " type, int value) throws " + "SdaiException;");
      pw.println("\tpublic void unset" + method_suffix + "(" + entity_name + " type) throws " + 
                 "SdaiException;");
    } else if (st instanceof ENumber_type) {
      pw.println("\t/// methods for attribute:" + attr_name + ", base type: NUMBER");
      pw.println("\tpublic boolean test" + method_suffix + "(" + entity_name + " type) throws " + 
                 "SdaiException;");
      pw.println("\tpublic double get" + method_suffix + "(" + entity_name + " type) throws " + 
                 "SdaiException;");
      pw.println("\tpublic void set" + method_suffix + "(" + entity_name + 
                 " type, double value) throws " + "SdaiException;");
      pw.println("\tpublic void unset" + method_suffix + "(" + entity_name + " type) throws " + 
                 "SdaiException;");
    } else if (st instanceof EReal_type) {
      pw.println("\t/// methods for attribute:" + attr_name + ", base type: REAL");
      pw.println("\tpublic boolean test" + method_suffix + "(" + entity_name + " type) throws " + 
                 "SdaiException;");
      pw.println("\tpublic double get" + method_suffix + "(" + entity_name + " type) throws " + 
                 "SdaiException;");
      pw.println("\tpublic void set" + method_suffix + "(" + entity_name + 
                 " type, double value) throws " + "SdaiException;");
      pw.println("\tpublic void unset" + method_suffix + "(" + entity_name + " type) throws " + 
                 "SdaiException;");
    } else if (st instanceof EBoolean_type) {
      pw.println("\t/// methods for attribute:" + attr_name + ", base type: BOOLEAN");
      pw.println("\tpublic boolean test" + method_suffix + "(" + entity_name + " type) throws " + 
                 "SdaiException;");
      pw.println("\tpublic boolean get" + method_suffix + "(" + entity_name + " type) throws " + 
                 "SdaiException;");
      pw.println("\tpublic void set" + method_suffix + "(" + entity_name + 
                 " type, boolean value) throws " + "SdaiException;");
      pw.println("\tpublic void unset" + method_suffix + "(" + entity_name + " type) throws " + 
                 "SdaiException;");
    } else if (st instanceof ELogical_type) {
      pw.println("\t/// methods for attribute:" + attr_name + ", base type: LOGICAL");
      pw.println("\tpublic boolean test" + method_suffix + "(" + entity_name + " type) throws " + 
                 "SdaiException;");
      pw.println("\tpublic int get" + method_suffix + "(" + entity_name + " type) throws " + 
                 "SdaiException;");
      pw.println("\tpublic void set" + method_suffix + "(" + entity_name + 
                 " type, int value) throws " + "SdaiException;");
      pw.println("\tpublic void unset" + method_suffix + "(" + entity_name + " type) throws " + 
                 "SdaiException;");
    } else if (st instanceof EBinary_type) {
      pw.println("\t/// methods for attribute:" + attr_name + ", base type: BINARY");
      pw.println("\tpublic boolean test" + method_suffix + "(" + entity_name + " type) throws " + 
                 "SdaiException;");
      pw.println("\tpublic Binary get" + method_suffix + "(" + entity_name + " type) throws " + 
                 "SdaiException;");
      pw.println("\tpublic void set" + method_suffix + "(" + entity_name + 
                 " type, Binary value) throws " + "SdaiException;");
      pw.println("\tpublic void unset" + method_suffix + "(" + entity_name + " type) throws " + 
                 "SdaiException;");
    } else if (st instanceof EString_type) {
      pw.println("\t/// methods for attribute:" + attr_name + ", base type: STRING");
      pw.println("\tpublic boolean test" + method_suffix + "(" + entity_name + " type) throws " + 
                 "SdaiException;");
      pw.println("\tpublic String get" + method_suffix + "(" + entity_name + " type) throws " + 
                 "SdaiException;");
      pw.println("\tpublic void set" + method_suffix + "(" + entity_name + 
                 " type, String value) throws " + "SdaiException;");
      pw.println("\tpublic void unset" + method_suffix + "(" + entity_name + " type) throws " + 
                 "SdaiException;");
    }
  }


  void generateExplicitAttributeDefinedTypeMethodDeclarations(EDefined_type dt, PrintWriter pw, 
                                                              String entity_name, String attr_name, 
                                                              String method_suffix)
    throws SdaiException {
    EEntity ut = dt.getDomain(null);

    if (ut instanceof ESimple_type) {
      generateExplicitAttributeSimpleTypeMethodDeclarations((ESimple_type) ut, pw, entity_name, 
                                                            attr_name, method_suffix);
    } else if (ut instanceof EAggregation_type) {
      generateExplicitAttributeAggregationTypeMethodDeclarations((EAggregation_type) ut, pw, 
                                                                 entity_name, attr_name, 
                                                                 method_suffix);
    } else if (ut instanceof EDefined_type) {
      generateExplicitAttributeDefinedTypeMethodDeclarations((EDefined_type) ut, pw, entity_name, 
                                                             attr_name, method_suffix);
    } else if (ut instanceof EEnumeration_type) {
//      A_string enelements = ((EEnumeration_type) ut).getElements(null);
//      A_string enelements = ((EEnumeration_type) ut).getLocal_elements(null);
//      A_string enelements = getElements((EEnumeration_type) ut);
      Vector enelements = getElementsV((EEnumeration_type) ut);
      generateEnumerationMethodDeclarations((EEnumeration_type) ut, pw, entity_name, attr_name, 
                                            method_suffix);
    } else if (ut instanceof ESelect_type) {
//      ANamed_type nt = ((ESelect_type) ut).getSelections(null);
//      ANamed_type nt = ((ESelect_type) ut).getLocal_selections(null);
      ANamed_type nt = getSelections((ESelect_type) ut);

      //         int select_type = calculateSelectPaths(nt); // 0 - pure entity, 1 - pure defined_type or 2 - mixed select
      SelectPaths paths1 = null;
      int select_type = Integer.MIN_VALUE;
      Object temp_object = ut.getTemp();

      if (temp_object instanceof SelectPaths) {
        if (((SelectPaths) temp_object).owner == (ESelect_type) ut) {
          paths1 = (SelectPaths) temp_object;
          select_type = paths1.select_type;
        }
      }

      if (paths1 == null) {
        int count = 1;
        int[] indeces = new int[500];
        int depth = 0;
        int depth_count = 0;
        boolean with_type = false;
        Vector current_nodes = new Vector();
        Vector current_node_strings = new Vector();
        paths1 = new SelectPaths();
        paths1.owner = (ESelect_type) ut;
        select_type = calculateSelectPaths(count, current_nodes, current_node_strings, indeces, 
                                           depth, depth_count, paths1, (ESelect_type) ut, with_type);
        paths1.removeIdentical();
        paths1.select_type = select_type;
        ut.setTemp(paths1);
      }


      // pw.println("debug: " + select_type);
      pw.println("\t// constants and methods for SELECT attribute: " + attr_name);

      if (select_type > 0) { // includes defined_types
        paths1.generateConstants(pw, attr_name);
        pw.println("");
      }

      /*
      if (select_type < 2) { // includes entieties
         generateEntityMethodDeclarationsForSelect((ESelect_type)ut, pw, entity_name, attr_name, method_suffix);
      } 
      if (select_type > 0) { // includes defined_types
         paths1.generateDefinedTypeGetMethodDeclarations((ESelect_type)ut, pw, entity_name, attr_name, method_suffix);
      }
       */
      if (select_type == 0) {
        pw.println("\tboolean test" + normalize(attr_name) + "(" + entity_name + 
                   " type) throws SdaiException;");
      } else {
        pw.println("\tint test" + normalize(attr_name) + "(" + entity_name + 
                   " type) throws SdaiException;");
      }

      pw.println("");
      paths1.generateGetMethodDeclarations((ESelect_type) ut, pw, entity_name, attr_name, 
                                           method_suffix, select_type);
      pw.println("");
      paths1.generateSetMethodDeclarations((ESelect_type) ut, pw, entity_name, attr_name, 
                                           method_suffix, select_type);
      pw.println("");
      pw.println("\tvoid unset" + normalize(attr_name) + "(" + entity_name + 
                 " type) throws SdaiException;");
    }
  }


  void generateExplicitAttributeDefinedTypeMethodDeclarationsRenamed(EDefined_type dt, PrintWriter pw, 
                                                              String entity_name, String attr_name, 
                                                              String method_suffix,
                                                              EExplicit_attribute xattr,
                                                              String method_suffix_prev)
    throws SdaiException {

//	EExplicit_attribute xattr_original = getOriginalExplicitAttribute(xattr);

//  EEntity bt = xattr_original.getDomain(null);
  
//  if (bt instanceof EDefined_type) {
//		dt = (EDefined_type)bt;
//	}



    EEntity ut = dt.getDomain(null);

    if (ut instanceof ESimple_type) {
//t      generateExplicitAttributeSimpleTypeMethodDeclarations((ESimple_type) ut, pw, entity_name, 
//t                                                            attr_name, method_suffix);
      generateExplicitAttributeSimpleTypeMethodDeclarationsRenamed((ESimple_type) ut, pw, entity_name, 
                                                            attr_name, method_suffix,
                                                            xattr,
                                                            method_suffix_prev);
    } else if (ut instanceof EAggregation_type) {
//t      generateExplicitAttributeAggregationTypeMethodDeclarations((EAggregation_type) ut, pw, 
//t                                                                 entity_name, attr_name, 
//t                                                                 method_suffix);
      generateExplicitAttributeAggregationTypeMethodDeclarationsRenamed((EAggregation_type) ut, pw, 
                                                                 entity_name, attr_name, 
                                                                 method_suffix,
                                                                 xattr,
                                                                 method_suffix_prev);


    } else if (ut instanceof EDefined_type) {
//t      generateExplicitAttributeDefinedTypeMethodDeclarations((EDefined_type) ut, pw, entity_name, 
//t                                                             attr_name, method_suffix);
			generateExplicitAttributeDefinedTypeMethodDeclarationsRenamed((EDefined_type) ut, pw, 
                                                              entity_name, attr_name, 
                                                              method_suffix,
                                                              xattr,
                                                              method_suffix_prev);


    } else if (ut instanceof EEnumeration_type) {
//      A_string enelements = ((EEnumeration_type) ut).getElements(null);
//      A_string enelements = ((EEnumeration_type) ut).getLocal_elements(null);
//      A_string enelements = getElements((EEnumeration_type) ut);
//t      Vector enelements = getElementsV((EEnumeration_type) ut);
//t      generateEnumerationMethodDeclarations((EEnumeration_type) ut, pw, entity_name, attr_name, 
//t                                            method_suffix);
    } else if (ut instanceof ESelect_type) {
//      ANamed_type nt = ((ESelect_type) ut).getSelections(null);
//      ANamed_type nt = ((ESelect_type) ut).getLocal_selections(null);
      ANamed_type nt = getSelections((ESelect_type) ut);

      //         int select_type = calculateSelectPaths(nt); // 0 - pure entity, 1 - pure defined_type or 2 - mixed select
      SelectPaths paths1 = null;
      int select_type = Integer.MIN_VALUE;
      Object temp_object = ut.getTemp();

      if (temp_object instanceof SelectPaths) {
        if (((SelectPaths) temp_object).owner == (ESelect_type) ut) {
          paths1 = (SelectPaths) temp_object;
          select_type = paths1.select_type;
        }
      }

      if (paths1 == null) {
        int count = 1;
        int[] indeces = new int[500];
        int depth = 0;
        int depth_count = 0;
        boolean with_type = false;
        Vector current_nodes = new Vector();
        Vector current_node_strings = new Vector();
        paths1 = new SelectPaths();
        paths1.owner = (ESelect_type) ut;
        select_type = calculateSelectPaths(count, current_nodes, current_node_strings, indeces, 
                                           depth, depth_count, paths1, (ESelect_type) ut, with_type);
        paths1.removeIdentical();
        paths1.select_type = select_type;
        ut.setTemp(paths1);
      }


      // pw.println("debug: " + select_type);
      pw.println("\t// constants and methods for SELECT attribute: " + attr_name);

      if (select_type > 0) { // includes defined_types
        paths1.generateConstants(pw, attr_name);
        pw.println("");
      }

      /*
      if (select_type < 2) { // includes entieties
         generateEntityMethodDeclarationsForSelect((ESelect_type)ut, pw, entity_name, attr_name, method_suffix);
      } 
      if (select_type > 0) { // includes defined_types
         paths1.generateDefinedTypeGetMethodDeclarations((ESelect_type)ut, pw, entity_name, attr_name, method_suffix);
      }
       */
      if (select_type == 0) {
        pw.println("\tboolean test" + normalize(attr_name) + "(" + entity_name + 
                   " type) throws SdaiException;");
      } else {
        pw.println("\tint test" + normalize(attr_name) + "(" + entity_name + 
                   " type) throws SdaiException;");
      }

      pw.println("");
      paths1.generateGetMethodDeclarations((ESelect_type) ut, pw, entity_name, attr_name, 
                                           method_suffix, select_type);
      pw.println("");
      paths1.generateSetMethodDeclarations((ESelect_type) ut, pw, entity_name, attr_name, 
                                           method_suffix, select_type);
      pw.println("");
      pw.println("\tvoid unset" + normalize(attr_name) + "(" + entity_name + 
                 " type) throws SdaiException;");
    }
  }

  String normalize(String str) {
    return str.substring(0, 1).toUpperCase() + str.substring(1).toLowerCase();
  }

  void generateEntityMethodDeclarationsForSelect(ESelect_type st, PrintWriter pw, 
                                                 String entity_name1, String attr_name, 
                                                 String method_suffix) {
    ;
  }

  void generateDefinedTypeMethodDeclarationsForSelect(ESelect_type st, PrintWriter pw, 
                                                      String entity_name1, String attr_name, 
                                                      String method_suffix) {
    ;
  }

  void generateEnumerationMethodDeclarations(EEnumeration_type st, PrintWriter pw, 
                                             String entity_name1, String attr_name, 
                                             String method_suffix) {
    // no need for enumeration elements
    pw.println("\t// attribute:" + attr_name + ", base type: ENUMERATION");
    pw.println("\tpublic boolean test" + method_suffix + "(" + entity_name1 + " type) throws " + 
               "SdaiException;");
    pw.println("\tpublic int get" + method_suffix + "(" + entity_name1 + " type) throws " + 
               "SdaiException;");
    pw.println("\tpublic void set" + method_suffix + "(" + entity_name1 + 
               " type, int value) throws " + "SdaiException;");
    pw.println("\tpublic void unset" + method_suffix + "(" + entity_name1 + " type) throws " + 
               "SdaiException;");
  }

  void generateDerivedEnumerationMethodDeclarations(EEnumeration_type st, PrintWriter pw, 
                                                    String entity_name1, String attr_name, 
                                                    String method_suffix) {
    // no need for enumeration elements
    pw.println("\t// derived attribute:" + attr_name + ", base type: ENUMERATION");
    pw.println("\tpublic boolean test" + method_suffix + "(" + entity_name1 + " type) throws " + 
               "SdaiException;");
    pw.println("\tpublic int get" + method_suffix + "(" + entity_name1 + " type) throws " + 
               "SdaiException;");
  }

  void generateExplicitAttributeEnumerationMethodDeclarations(ESimple_type st, PrintWriter pw, 
                                                              String entity_name, String attr_name, 
                                                              String method_suffix) {
    pw.println("\t// attribute:" + attr_name + ", base type: ENUMERATION");
    pw.println("\tpublic int test" + method_suffix + "(" + entity_name + " type) throws " + 
               "SdaiException;");
    pw.println("\tpublic int get" + method_suffix + "(" + entity_name + " type) throws " + 
               "SdaiException;");
    pw.println("\tpublic void set" + method_suffix + "(" + entity_name + 
               " type, int value) throws " + "SdaiException;");
    pw.println("\tpublic void unset" + method_suffix + "(" + entity_name + " type) throws " + 
               "SdaiException;");
  }

  void generateSelectGetInterfaces() {
  }

  String getWhatInterfaceExtends(EEntity_definition ed)
                          throws SdaiException {
    // pre-X    AEntity_definition asuper = ed.getSupertypes(null);
//    AEntity_or_view_definition asuper = ed.getSupertypes(null);
    AEntity_or_view_definition asuper = ed.getGeneric_supertypes(null);
    int count = asuper.getMemberCount();

    if (count == 0) {
      return Compiler2.baseInterface;
    }

    String supertypes = "";
    SdaiIterator isuper = asuper.createIterator();
    boolean is_first = true;

    while (isuper.next()) {
      if (!is_first) {
        supertypes += ", ";
      } else {
        is_first = false;
      }

      EEntity_definition eds = (EEntity_definition) asuper.getCurrentMemberObject(isuper);
      String supertype_name = eds.getName(null);
      supertypes += (getEntityPackage(eds) + "E" + supertype_name.substring(0, 1).toUpperCase() + supertype_name.substring(1)
                                                                                                                .toLowerCase());
    }

    return supertypes;
  }

  String getEntityPackage(EEntity_or_view_definition eds)
                   throws SdaiException {
    // return an empty string if ed and eds in the same schema, and the package of eds otherwise
    String entity_package = "";
    SdaiModel entity_model = eds.findEntityInstanceSdaiModel();

    if (entity_model != model) {
      String entity_schema_name = getSchema_definitionFromModel(entity_model).getName(null);

      if (entity_schema_name.equalsIgnoreCase("Sdai_dictionary_schema")) {
        entity_package = "jsdai.dictionary.";
      } else {
        entity_package = "jsdai.S" + entity_schema_name.substring(0, 1).toUpperCase() + 
                         entity_schema_name.substring(1).toLowerCase() + ".";
      }
    }

    return entity_package;
  }

  String getMapPackage(EMap_definition md) throws SdaiException {
    // return an empty string if ed and eds in the same schema, and the package of eds otherwise
    String map_package = "";
    SdaiModel map_model = md.findEntityInstanceSdaiModel();

    if (map_model != model) {
      String map_schema_name = getSchema_definitionFromModel(map_model).getName(null);

      if (map_schema_name.equalsIgnoreCase("Sdai_dictionary_schema")) {
        map_package = "jsdai.dictionary.";
      } else {
        map_package = "jsdai.S" + map_schema_name.substring(0, 1).toUpperCase() + 
                      map_schema_name.substring(1).toLowerCase() + ".";
      }
    }

    return map_package;
  }

  String getAggregatePackage(String aggr_prefix, EEntity ee)
                      throws SdaiException {
    String a_package = "";
    String a_name = "";

    if (ee instanceof ENamed_type) {
      a_name = ((ENamed_type) ee).getName(null);
      a_name = a_name.substring(0, 1).toUpperCase() + a_name.substring(1).toLowerCase();
    }

    SdaiModel a_model = ee.findEntityInstanceSdaiModel();

    if (a_model != model) {
      String a_schema_name = getSchema_definitionFromModel(a_model).getName(null);

      if (a_schema_name.equalsIgnoreCase("Sdai_dictionary_schema")) {
        a_package = "jsdai.dictionary.";
      } else {
        a_package = "jsdai.S" + a_schema_name.substring(0, 1).toUpperCase() + 
                    a_schema_name.substring(1).toLowerCase() + ".";
      }
    }

    //      return a_package;
    return a_package + aggr_prefix + a_name;
  }

  String getEEntityPackage(EEntity ee) throws SdaiException {
    String a_package = "";
    String a_name = "";

    if (ee instanceof ENamed_type) {
      a_name = ((ENamed_type) ee).getName(null);
      a_name = "E" + a_name.substring(0, 1).toUpperCase() + a_name.substring(1).toLowerCase();
    }

    SdaiModel a_model = ee.findEntityInstanceSdaiModel();

    if (a_model != model) {
      String a_schema_name = getSchema_definitionFromModel(a_model).getName(null);

      if (a_schema_name.equalsIgnoreCase("Sdai_dictionary_schema")) {
        a_package = "jsdai.dictionary.";
      } else {
        a_package = "jsdai.S" + a_schema_name.substring(0, 1).toUpperCase() + 
                    a_schema_name.substring(1).toLowerCase() + ".";
      }
    }

    //      return a_package;
    return a_package + a_name;
  }

  String convertComplexName(String old_str) {
    return old_str.replace('+', '$');
  }

  void generateEntityClass(EEntity_definition ed, String schema_package, String schema_package_name)
                    throws SdaiException, IOException {
//FIXME: suspended;      pdb.clear();

    String entity_name = ed.getName(null);
    boolean is_complex = ed.getComplex(null);

    if (is_complex) {
      entity_name = convertComplexName(entity_name);
    }

    String entity_class_name = "C" + entity_name.substring(0, 1).toUpperCase() + 
                               entity_name.substring(1).toLowerCase();
    String entity_interface_name = "E" + entity_name.substring(0, 1).toUpperCase() + 
                                   entity_name.substring(1).toLowerCase();
    String class_file = schema_package + File.separator + entity_class_name + ".java";
    PrintWriter pw = getPrintWriter(class_file);
    pw.println(lksoft_header);
    pw.println("");
	    pw.println("// Java class implementing entity " + entity_name);
    pw.println("");
    pw.println("package " + schema_package_name + ";");
    pw.println("import jsdai.lang.*;");
    pw.println("");

    // approach as follows: if not complex, take the first supertype, otherwise, extend CEntity
    // and what if complex? Does that mean that we have the old style without java inheritance?
    //      boolean is_complex = ed.getComplex(null);
    if (!is_complex) {
      boolean has_supertype = false;
      boolean has_supertypes;

      if (java_inheritance_enabled) {
        // has_supertypes = ed.testSupertypes(null);
        has_supertypes = ed.testGeneric_supertypes(null);
      } else {
        has_supertypes = false;
      }

      if (has_supertypes) {
        // pre-X        AEntity_definition asuper = ed.getSupertypes(null);
//        AEntity_or_view_definition asuper = ed.getSupertypes(null);
        AEntity_or_view_definition asuper = ed.getGeneric_supertypes(null);

        if (asuper.getMemberCount() > 0) {
          // pre-X          EEntity_definition esuper = asuper.getByIndex(1);
          EEntity_definition esuper = (EEntity_definition) asuper.getByIndex(1);
          String supname = esuper.getName(null);
          supname = getEntityPackage(esuper) + "C" + supname.substring(0, 1).toUpperCase() + 
                    supname.substring(1).toLowerCase();
          pw.println("public class " + entity_class_name + " extends " + supname + 
                     " implements " + entity_interface_name + " {");
          has_supertype = true;
        }
      }

      if (!has_supertype) {
        pw.println("public class " + entity_class_name + " extends " + Compiler2.baseClass + 
                   " implements " + entity_interface_name + " {");
      }
    } else { // if complex entity

      // has to implement the list of leave enitity interfaces, with package prefices if needed (if in mixed complex types schema)
      // pre-X      AEntity_definition asuper = ed.getSupertypes(null); // new complex supertypes - leaves only.
//      AEntity_or_view_definition asuper = ed.getSupertypes(null); // new complex supertypes - leaves only.
      AEntity_or_view_definition asuper = ed.getGeneric_supertypes(null); // new complex supertypes - leaves only.
      SdaiIterator isuper = asuper.createIterator();
      String supertypes = "";
      boolean is_first = true;

      while (isuper.next()) {
        if (!is_first) {
          supertypes += ", ";
        } else {
          is_first = false;
        }

        EEntity_definition eds = (EEntity_definition) asuper.getCurrentMemberObject(isuper);
        String supertype_name = eds.getName(null);
        supertypes += (getEntityPackage(eds) + "E" + supertype_name.substring(0, 1).toUpperCase() + supertype_name.substring(1)
                                                                                                                  .toLowerCase());
      }

      pw.println("public class " + entity_class_name + " extends " + Compiler2.baseClass + 
                 " implements " + supertypes + " {");
    }

    String schema_name = schema_package_name.substring(schema_package_name.lastIndexOf('.') + 1);

    //      pw.println("\tstatic final jsdai.dictionary.CEntity_definition definition = CEntity.initEntityDefinition(" + entity_class_name + ".class, " + schema_name + ".ss);");
    //      pw.println("\tpublic static final jsdai.dictionary.CEntity_definition definition = CEntity.initEntityDefinition(" + entity_class_name + ".class, " + schema_name + ".ss);");
    String schema_name2 = null;

    if (schema_name.equalsIgnoreCase("mapping")) {
      schema_name2 = "SMapping";
    } else if (schema_name.equalsIgnoreCase("dictionary")) {
      schema_name2 = "SDictionary";
    } else {
      schema_name2 = schema_name;
    }

    pw.println(
          "\tpublic static final jsdai.dictionary.CEntity_definition definition = initEntityDefinition(" + 
          entity_class_name + ".class, " + schema_name2 + ".ss);");
    pw.println("");
    pw.println("\t/*----------------------------- Attributes -----------*/");
    pw.println("");
    pw.println("/*");

    Vector all_attributes = new Vector();
    Vector all_flags = new Vector();
    generateAttributes(ed, pw, all_attributes, all_flags);
    pw.println("*/");
		
		ArrayList all_attributes_all = new ArrayList();
	  ArrayList all_flags_all = new ArrayList(); // legacy	
		generateAllAttributes(ed, pw, all_attributes_all, all_flags_all);
	
		Vector all_attributes_ext = new Vector();
		Vector all_flags_ext = new Vector();
		getExtendedAttributes(ed, all_attributes_ext, all_flags_ext);


		global_all_attributes = all_attributes;
		global_all_flags = all_flags;
		global_all_attributes_all = all_attributes_all;
		global_all_flags_all = all_flags_all;
		global_all_attributes_ext = all_attributes_ext;
		global_all_flags_ext = all_flags_ext;


//System.out.println("entity : " + ed.getName(null) + ", attributes: " + all_attributes);

    /*
    if (!is_complex) {
       generateAttributes(ed, pw, all_attributes, all_flags);
    } else {
       generateComplexAttributes(ed, pw, all_attributes, all_flags);
    }
     */
    pw.println("");
    pw.println("\tpublic jsdai.dictionary.EEntity_definition getInstanceType() {");


    //     pw.println("\tpublic static jsdai.dictionary.EEntity_definition getEntityDefinition() {");
    pw.println("\t\treturn definition;");
    pw.println("\t}");


    /*
    // may not be needed anymore
    pw.println("");
     pw.println("\tprotected int getEntityExtentIndex() {");
        pw.println("\t\treturn " + getPartialEntityIndex(ed) + ";");
     pw.println("\t}");
     */
    pw.println("");
    pw.println("/* *** old implementation ***");
    pw.println("");
    pw.println("\tprotected void changeReferences(InverseEntity old, InverseEntity newer) throws SdaiException {");
    generateChangeReferences(ed, pw, all_attributes, all_flags);
    pw.println("\t}");
    pw.println("*/");
    pw.println("");
    pw.println("");
    pw.println("\tprotected void changeReferences(InverseEntity old, InverseEntity newer) throws SdaiException {");
// TEMP Removed
//    generateChangeReferences(ed, pw, all_attributes, all_flags);
    generateChangeReferencesX(ed, pw, all_attributes_all, all_flags_all);
    pw.println("\t}");
    pw.println("");
    pw.println("\t/*----------- Methods for attribute access -----------*/");
    pw.println("");
//    generateMethods(ed, pw, all_attributes, all_flags, all_attributes_ext, all_flags_ext);
    pw.println("");
    pw.println("\t/*----------- Methods for attribute access (new)-----------*/");
    pw.println("");
    generateAllMethods(ed, pw, all_attributes_all, all_flags_all);
    pw.println("");
    pw.println("\t/*---------------------- setAll() --------------------*/");
    pw.println("");
//  TEMP REMOVED
    pw.println("/* *** old implementation ***");
    generateSetAll(ed, pw, all_attributes, all_flags);
    pw.println("*/");
    pw.println("");
    generateSetAllX(ed, pw, all_attributes_all, all_flags_all);
    pw.println("");
    pw.println("\t/*---------------------- getAll() --------------------*/");
    pw.println("");
// TEMP REMOVED
    pw.println("/* *** old implementation ***");
    generateGetAll(ed, pw, all_attributes, all_flags);
    pw.println("*/");
    pw.println("");
    generateGetAllX(ed, pw, all_attributes_all, all_flags_all);
    generateWhereRules(ed, pw);

    // pw.println("##### number of elements: " + pdb.size());
//FIXME: suspended;  
//     for (int i = 0; i < pdb.size(); i++) {
//       pw.println(pdb.elementAt(i));
//     }

//     pdb.clear();


    generatePDBmethods(ed, pw);
    pw.println("}");
    pw.flush();
    pw.close();

		global_all_attributes = null;
		global_all_flags = null;
		global_all_attributes_all = null;
		global_all_flags_all = null;
		global_all_attributes_ext = null;
		global_all_flags_ext = null;

  }


  void generateMapClass(EMap_definition md, String schema_package, String schema_package_name)
                 throws SdaiException, IOException {

		if (flag_generate_map_methods_in_node) {
			  generateMapClass_in_node_version(md, schema_package, schema_package_name);
		} else {
		  generateMapClass_here(md, schema_package, schema_package_name);
		}
	}

  void generateMapClass_in_node_version(EMap_definition md, String schema_package, String schema_package_name)
//  void generateMapClass(EMap_definition md, String schema_package, String schema_package_name)
                 throws SdaiException, IOException {

// System.out.println("Generating MapClass: " + md);

    String map_name = md.getName(null);
    String map_class_name = "M" + map_name.substring(0, 1).toUpperCase() + 
                            map_name.substring(1).toLowerCase();

    String class_file = schema_package + File.separator + map_class_name + ".java";
    PrintWriter pw = getPrintWriter(class_file);
    pw.println(lksoft_header);
    pw.println("");
    pw.println("// Java class implementing map " + map_name);
    pw.println("");
    pw.println("package " + schema_package_name + ";");
    pw.println("");
    pw.println("import jsdai.lang.*;");
    pw.println("import java.util.*;");
    pw.println("");

	 if (flag_express_x) {
//    if (java_inheritance_enabled && map_definition.testSuper_type(null)) {
    if (java_inheritance_enabled && md.testSuper_type(null)) {
	    EMap_definition msuper = md.getSuper_type(null);
        
  	  String supname = msuper.getName(null);
	    supname = getMapPackage(msuper) + "M" + supname.substring(0, 1).toUpperCase() + supname.substring(1).toLowerCase();
//  	  pw.println("public class " + map_class_name + " extends " + supname + " {");
    	}else{
//    		pw.println("public class " + map_class_name + " {");
    	}
    
  	}
    generateJavaExpression(pw, md, sd, null, model);

	 if (flag_express_x) {
	 		ATarget_parameter atp = md.getTarget_parameters(null, null);
//    	generateExecuteMethods(md, pw, atp);
    	AMap_partition amp = md.getPartitions(null, null);
//    	generatePartitionMethods(md, pw, atp, amp);

//    	generateWhereRules(md, pw);
		}
    pw.println("}");
    pw.flush();
    pw.close();
  }

	// this is the version when map is generated here, instead of in map node


  void generateMapClass_here(EMap_definition md, String schema_package, String schema_package_name)

//  void generateMapClass(EMap_definition md, String schema_package, String schema_package_name)
//  void generateMapClass(EMap_definition md, String schema_package, String schema_package_name)
                 throws SdaiException, IOException {

// System.out.println("Generating MapClass: " + md);

    String map_name = md.getName(null);
    String map_class_name = "M" + map_name.substring(0, 1).toUpperCase() + 
                            map_name.substring(1).toLowerCase();

    String class_file = schema_package + File.separator + map_class_name + ".java";
    PrintWriter pw = getPrintWriter(class_file);
    pw.println(lksoft_header);
    pw.println("");
    pw.println("// Java class implementing map " + map_name);
    pw.println("");
    pw.println("package " + schema_package_name + ";");
    pw.println("");
    pw.println("import jsdai.lang.*;");
    pw.println("import java.util.*;");
    pw.println("");

	 if (flag_express_x) {
//    if (java_inheritance_enabled && map_definition.testSuper_type(null)) {
    if (java_inheritance_enabled && md.testSuper_type(null)) {
	    EMap_definition msuper = md.getSuper_type(null);
        
  	  String supname = msuper.getName(null);
	    supname = getMapPackage(msuper) + "M" + supname.substring(0, 1).toUpperCase() + supname.substring(1).toLowerCase();
//  	  pw.println("public class " + map_class_name + " extends " + supname + " {");
    	}else{
//    		pw.println("public class " + map_class_name + " {");
    	}
    
  	}
    // this was needed for in node version only?
//    generateJavaExpression(pw, md, sd, null, model);

	 if (flag_express_x) {
	 		ATarget_parameter atp = md.getTarget_parameters(null, null);
    	generateExecuteMethods(md, pw, atp);
// maybe internally
//    	AMap_partition amp = md.getPartitions(null, null);
//    	generatePartitionMethods(md, pw, atp, amp);

			// commenting out temporarily, because of javac 		problems only
    	//generateWhereRules(md, pw);
		}
    pw.println("}");
    pw.flush();
    pw.close();
  }

	// added Express-X related --- begin -----

//<> ----------------------- start ------------------------

  String getEntityPackage(EEntity_or_view_definition eds, SdaiModel current_model)
		throws jsdai.lang.SdaiException {

    // return an empty string if ed and eds in the same schema, and the package of eds otherwise
    String entity_package = "";
    SdaiModel entity_model = eds.findEntityInstanceSdaiModel();
		
    if (entity_model != current_model) {
      String entity_schema_name = getSchema_definitionFromModel(entity_model).getName(null);

      if (entity_schema_name.equalsIgnoreCase("Sdai_dictionary_schema")) {
        entity_package = "jsdai.dictionary.";
      } else {
        entity_package = "jsdai.S" + entity_schema_name.substring(0, 1).toUpperCase() + entity_schema_name.substring(1).toLowerCase() + ".";
      }
    }

    return entity_package;
  }

/*
	void tabByIndex(int ind, PrintWriter pw){
		pw.print("\t");
		for(int tt=0; tt < ind; tt++) pw.print("\t");
	}
*/
	String  tabByIndexToString(int ind, PrintWriter pw, String st){
		st += "\t";
		for(int tt=0; tt < ind; tt++)	st += "\t";
		return st;
	}


  void generateExecuteMethods(EMap_definition map_definition, PrintWriter pw, ATarget_parameter atp) throws jsdai.lang.SdaiException {

		String map_name = map_definition.getName(null);
		String map_class_name = "M" + map_name.substring(0, 1).toUpperCase() + map_name.substring(1).toLowerCase();

		pw.println("public class " + map_class_name + " {");

		pw.println("");
		pw.println("\t/*---------------------- methods to execute maps for each target --------------------*/");
		// ? for each target or everything together?
		pw.println("");

//		ATarget_parameter atp = map_definition.getTarget_parameters(null, null);
		
		jsdai.lang.SdaiIterator tpi = atp.createIterator();

		String etar_type = "" ;
		
		// need other approach for execute handling
		//		while (tpi.next()) {
		tpi.next();
		ETarget_parameter tp = (ETarget_parameter)atp.getCurrentMemberObject(tpi); //here
			String tp_name = tp.getName(null);
			EEntity_definition tp_extent = tp.getExtent(null);
			String tp_extent_name = tp_extent.getName(null);
//			String atar_type = getEntityPackage(tp_extent, jc.model) + "A" + tp_extent_name.substring(0, 1).toUpperCase() + tp_extent_name.substring(1).toLowerCase();
			String atar_type = getEntityPackage(tp_extent, model) + "A" + tp_extent_name.substring(0, 1).toUpperCase() + tp_extent_name.substring(1).toLowerCase();
//			etar_type = getEntityPackage(tp_extent, jc.model) + "E" + tp_extent_name.substring(0, 1).toUpperCase() + tp_extent_name.substring(1).toLowerCase();
			etar_type = getEntityPackage(tp_extent, model) + "E" + tp_extent_name.substring(0, 1).toUpperCase() + tp_extent_name.substring(1).toLowerCase();
//RR			pw.println("\tpublic " +atar_type +" execute(SdaiContext _context) throws SdaiException {");
			pw.println("\tpublic void  execute(SdaiContext _context) throws SdaiException {");
			//TODO: select appopriate partition: suspended, because em-planer doesn't use partitions - always call default partition. 
			pw.println("");
			pw.println("\t\tSdaiModel src_model = _context.src_model;");
			pw.println("\t\tSdaiModel tar_model = _context.tar_model;");
			pw.println("\t\tVector instances_partition_default;");
//RR			pw.println("\t\tHashtable target_instances;");
			pw.println("\t\tHashtable target_instances = new Hashtable();");
			pw.println("");
			pw.println("\t\t_context.mapHashTable = new Hashtable();");
			pw.println("");

			pw.println("\t\tSystem.out.println(\"processing partitions..\");");
			AMap_partition am_p = map_definition.getPartitions(null, null);
			SdaiIterator mp_i = am_p.createIterator();
			while (mp_i.next()) {
				EMap_partition m_p = (EMap_partition)am_p.getCurrentMemberObject(mp_i);
				String m_p_name = m_p.getName(null);
				if(m_p_name.equalsIgnoreCase("_implicit_partition_")){
					m_p_name = "default";
				}
				pw.println("\t\tprocessPartition_" + m_p_name + "(src_model, tar_model, target_instances, _context);");
			
			} // while mp_i - through map partitions
			pw.println("\t\treturn;");
			pw.println("\t}");

		// do we put those here or separately: generatePartitionMethods(...) ...

		pw.println("");
		pw.println("\t/*---------------------- methods to execute maps for each partition --------------------*/");
		pw.println("");

		if (map_definition.testSuper_type(null)) {

		} else { // has no supertype map - this is not a subtype map

			AMap_partition amp = map_definition.getPartitions(null, null);
			SdaiIterator mpi = amp.createIterator();

			boolean gone_to_node_already = false;
			boolean first_for_this_partition = true;
			while (mpi.next()) {

				EMap_partition mp = (EMap_partition)amp.getCurrentMemberObject(mpi);

				// jc.partition = mp;  // what to do with this?
				String mp_name = mp.getName(null);
				first_for_this_partition = true;

				if(mp_name.equalsIgnoreCase("_implicit_partition_")){
					mp_name = "default";
				}

				pw.println("\tpublic AEntity processPartition_" + mp_name +"(SdaiModel src_model, SdaiModel tar_model, Hashtable target_instances, SdaiContext _context) throws SdaiException {");

				// FROM part, generate source binding extent
				pw.println("\t// FROM part, generate source binding extent");

				ASource_parameter asp = mp.getSource_parameters(null, null);
	
				// jc.asp = asp; // save reference for src parameters to be used in Identified_by node

				SdaiIterator spi = asp.createIterator();
				int ind = 0;
				String add_instances="";

				pw.println("\t\tVector binding_inst_extent = new Vector();");
				pw.println("\t\tVector binding_inst = new Vector();");
				pw.println("\t\tHashtable src_id_map = new Hashtable();");

				while (spi.next()) {

					ind++;
					ESource_parameter sp = (ESource_parameter)asp.getCurrentMemberObject(spi);
					String sp_name = sp.getName(null);

					EEntity_or_view_definition sp_extent = (EEntity_or_view_definition)sp.getExtent(null);
					String sp_extent_name = sp_extent.getName(null);
//					String sp_package = getEntityPackage(sp_extent, jc.model); 
					String sp_package = getEntityPackage(sp_extent, model); 
					String normalized_name = sp_extent_name.substring(0, 1).toUpperCase() + sp_extent_name.substring(1).toLowerCase();
					String esrc_type = sp_package + "E" + normalized_name;
					String asrc_type = sp_package + "A" + normalized_name;

					pw.println("\t\t" + asrc_type +" a" +ind +"_inst = (" +asrc_type +")src_model.getInstances(" +esrc_type +".class);");

			
				} // while spi -  through source_parameters 

				spi.beginning();
				ind = 0;
				while (spi.next()) {

					ind++;
					ESource_parameter sp = (ESource_parameter)asp.getCurrentMemberObject(spi);
					String sp_name = sp.getName(null);

					EEntity_or_view_definition sp_extent = (EEntity_or_view_definition)sp.getExtent(null);
					String sp_extent_name = sp_extent.getName(null);
//				String sp_package = getEntityPackage(sp_extent, jc.model); 
					String sp_package = getEntityPackage(sp_extent, model); 
					String normalized_name = sp_extent_name.substring(0, 1).toUpperCase() + sp_extent_name.substring(1).toLowerCase();
					String esrc_type = sp_package + "E" + normalized_name;
					String csrc_type = sp_package + "C" + normalized_name;
					String asrc_type = sp_package + "A" + normalized_name;

					pw.println("");
					tabByIndex(ind, pw); pw.println("for (int i" +ind +" = 1; i" +ind +" < a" +ind +"_inst.getMemberCount()+1; i" +ind +"++) {");
					tabByIndex(ind, pw); pw.println("\tValue " +sp_name +" = Value.alloc(" +csrc_type +".definition).set(_context, a" +ind +"_inst.getByIndex(i" +ind +"));");
					add_instances = tabByIndexToString(asp.getMemberCount(), pw, add_instances); add_instances += "\tbinding_inst.addElement(" +sp_name +");\n";
					if(asp.getMemberCount() < 2) { tabByIndex(ind, pw); pw.println("\tbinding_inst.addElement(\"\");"); }
					if(ind == asp.getMemberCount()){ 
						tabByIndex(ind, pw); pw.println("\tbinding_inst = new Vector();");
						pw.println(add_instances);
					}
					tabByIndex(ind, pw); pw.println("\tsrc_id_map.put(\""+ sp_name +"\", new Integer(" +(ind-1) +"));");

	
				}	// while spi - through source_parameters again		

				//
				// WHERE part 
				//

				// try invoking the node processing here
		    // but perhaps do only once if handling map partitions in the node?
	 	    if (!gone_to_node_already) {
	 	    	generateJavaExpression(pw, map_definition, sd, null, model);
  				gone_to_node_already = true;
  			}

		pw.println("\t\t}");					
		pw.println("\t\treturn tar_model.getInstances(" +etar_type +".class);");
		pw.println("\t}");					

			} // while mpi - through map partitions

		}  // has no supertype map - this is not a subtype map

	}

//<> ----------------------- end -------------------------------------------



  void generateExecuteMethods_old(EMap_definition md, PrintWriter pw, ATarget_parameter atp) throws jsdai.lang.SdaiException {
//  void generateExecuteMethods(EMap_definition md, PrintWriter pw, ATarget_parameter atp) throws jsdai.lang.SdaiException {

// System.out.println("Generating ExecuteMethods: " + md);

			pw.println("");
			pw.println("\t/*---------------------- methods to execute maps for each target --------------------*/");
			pw.println("");

			jsdai.lang.SdaiIterator tpi = atp.createIterator();

			while (tpi.next()) {
					ETarget_parameter tp = (ETarget_parameter)atp.getCurrentMemberObject(tpi);
					String tp_name = tp.getName(null);
					EEntity_definition tp_extent = tp.getExtent(null);
					String tp_extent_name = tp_extent.getName(null);
					String atar_type = getEntityPackage(tp_extent) + "A" + tp_extent_name.substring(0, 1).toUpperCase() + tp_extent_name.substring(1).toLowerCase();

					pw.println("\tpublic " +atar_type +"execute(SdaiContext _context) throws SdaiException {");
					//TODO: select appopriate partition: suspended, because em-planer doesn't use partitions - always call default partition. 
					pw.println("");
					pw.println("\t\tSdaiModel src_model = _context.src_model;");
					pw.println("\t\tSdaiModel tar_model = _context.tar_model;");
					pw.println("\t\tVector instances_partition_default;");
					pw.println("\t\tHashTable target_instances;");
					pw.println("");
					pw.println("\t\t" +atar_type +"aggr_" +tp_name +"= new "+atar_type +"();");
					pw.println("");
					pw.println("\t\tif ( _context.mapHashTable.contains(this)){");
					pw.println("\t\t\ttarget_instances = _context.mapHashTable.get(this);");
					pw.println("\t\t\tIterator it = target_instances.Iterator();");
					pw.println("\t\t\twhile(it.next()){");
					pw.println("\t\t\t\taggr_" +tp_name +".addUnordered(target_instances.getCurrentMemberObject(it));");
					pw.println("\t\t\t}");
					pw.println("\t\t\treturn aggr_" +tp_name +";");
					pw.println("\t\t}else{");
					pw.println("\t\t\ttarget_instances = new HasTable();");
					pw.println("\t\t\t_context.mapHashTable.put(this, target_instances);");
					pw.println("\t\t}");
					pw.println("\t\tSystem.out.println(\"processing partition..\");");
					pw.println("\t\taggr_dep = (" +atar_type +")processPartition_default(src_model, tar_model, target_instances);");
					pw.println("\t\treturn aggr_dep;");
					pw.println("");
			}
  }

  void generatePartitionMethods_old(EMap_definition md, PrintWriter pw, ATarget_parameter atp, AMap_partition amp) throws jsdai.lang.SdaiException {
//  void generatePartitionMethods(EMap_definition md, PrintWriter pw, ATarget_parameter atp, AMap_partition amp) throws jsdai.lang.SdaiException {


// System.out.println("Generating PartitionMethods: " + md);

			pw.println("");
			pw.println("\t/*---------------------- methods to execute maps for each partition --------------------*/");
			pw.println("");

			SdaiIterator mpi = amp.createIterator();

			while (mpi.next()) {
					EMap_partition mp = (EMap_partition)amp.getCurrentMemberObject(mpi);
					String mp_name = mp.getName(null);
					// ...
					// only default partition supported - em-planner doesn't need others
					// ...

					if(mp_name.equalsIgnoreCase("_implicit_partition_")){
							mp_name = "default";
					}

					pw.println("\tpublic AEntity processPartition_" +mp_name +"(SdaiModel src_model, SdaiModel tar_model, HashTable target_instances) throws SdaiException {");

					// FROM part, generate source binding extent

					ASource_parameter asp = mp.getSource_parameters(null, null);
					SdaiIterator spi = asp.createIterator();
					int ind=0;

					pw.println("\t\tVector binding_inst_extent = new Vector();");
					pw.println("\t\tVector binding_inst = new Vector();");

					while (spi.next()) {
							ind++;
							ESource_parameter sp = (ESource_parameter)asp.getCurrentMemberObject(spi);
							String sp_name = sp.getName(null);

							EEntity_or_view_definition sp_extent = (EEntity_or_view_definition)sp.getExtent(null);
							String sp_extent_name = sp_extent.getName(null);
							String sp_package = getEntityPackage(sp_extent); 
							String normalized_name = sp_extent_name.substring(0, 1).toUpperCase() + sp_extent_name.substring(1).toLowerCase();
							String asrc_type = sp_package + "A" + normalized_name;
							String esrc_type = sp_package + "E" + normalized_name;

							tabByIndex(ind, pw);
							pw.println(asrc_type +" a" +ind +"_inst = (" +asrc_type +")src_model.getInstances(" +esrc_type +".class);");

							pw.println("");

							tabByIndex(ind, pw); pw.println("for (int i" +ind +" = 0; i" +ind +" < a" +ind +"_inst.getMemberCount(); i" +ind +"++) {");
							tabByIndex(ind, pw); pw.println("\tbinding_inst.addElement(a" +ind +"_inst.getByIndex(i" +ind +"));");
					}

					// WHERE part 
					tabByIndex(ind, pw); pw.println("\tif(" + /* where_clause */ "){"); 
					tabByIndex(ind, pw); pw.println("\t\tbinding_inst_extent.addElement(binding_inst);");
					tabByIndex(ind, pw); pw.println("\t}");

					while(ind > 0){
							tabByIndex(ind, pw); pw.println("}");
							ind--;
					}


					
					//
					// IDENTIFIED BY part
					//
					// calculate identified_by classes 
					// produce a hash for each eq class 

					// still missing 

					/* SELECT part which doesnt use equivalance classes */
					
					pw.println("\t\t");
					pw.println("\t\t");
					pw.println("\t\t");
					pw.println("\t\t");
					pw.println("\t\t");
					pw.println("\t\t");
					pw.println("\t\t");
					pw.println("\t\t");
					pw.println("\t\t");
					pw.println("\t\t");
					pw.println("\t\t");
					pw.println("\t\t");
					pw.println("\t\t");
					pw.println("\t\t");
					pw.println("\t\t");
					pw.println("\t\t");
					pw.println("\t\t");
					pw.println("\t\t");
					pw.println("\t\t");
					pw.println("\t\t");
					pw.println("\t\t");
					pw.println("\t\t");
					pw.println("\t\t");
					pw.println("\t\t");
					pw.println("\t\t");
					pw.println("\t\t");
					pw.println("\t\t");
					pw.println("\t\t");
					pw.println("\t\t");
					pw.println("\t\t");
					pw.println("\t\t");
					pw.println("\t\t");
					pw.println("\t\t");
			}
  }

	void tabByIndex(int ind, PrintWriter pw){
	  	pw.print("\t");
			for(int tt=0; tt < ind; tt++) pw.print("\t");
	}

	// added Express-X related --- end -----


  // to be deleted later, will be no longer needed
  void generateWhereRules_no_inheritance(EEntity_definition ed, PrintWriter pw)
                   throws SdaiException {
    // boolean where_rules_present = ((ENamed_type)ed).testWhere_rules(null);
    // if (where_rules_present) {
    // the second parameter - domain added. null so far.
    AWhere_rule awr = ((ENamed_type) ed).getWhere_rules(null, null);

    // I don't remember if an empty aggregate is always created, so if test returs true, that does not necessarily mean that some where rulesa are present.
    int where_rule_count = awr.getMemberCount();

    if (where_rule_count > 0) {
      pw.println("");
      pw.println(
            "\t/*---------------------- methods to validate WHERE rules --------------------*/");
      pw.println("");

      SdaiIterator wri = awr.createIterator();

      while (wri.next()) {
        EWhere_rule wr = (EWhere_rule) awr.getCurrentMemberObject(wri);
        generateJavaExpression(pw, wr, sd, _ed, model);
      }
    }

    // } where rules present
  }
  
  // new stuff here --- start ------------------------------------------------------------------------------------
  
  
    void generateWhereRules(EEntity_definition ed, PrintWriter pw)
                   throws SdaiException {
    // boolean where_rules_present = ((ENamed_type)ed).testWhere_rules(null);
    // if (where_rules_present) {
    // the second parameter - domain added. null so far.




//    AWhere_rule awr = ((ENamed_type) ed).getWhere_rules(null, null);
    
    // use this method to get all where rules, including from supertypes if there is no java inheritance 
    HashSet awr = getWhereRules(ed);







    // I don't remember if an empty aggregate is always created, so if test returs true, that does not necessarily mean that some where rulesa are present.
//    int where_rule_count = awr.getMemberCount();
    int where_rule_count = awr.size();

    if (where_rule_count > 0) {
      pw.println("");
      pw.println(
            "\t/*---------------------- methods to validate WHERE rules --------------------*/");
      pw.println("");



      Iterator wri = awr.iterator();

      while (wri.hasNext()) {
        EWhere_rule wr = (EWhere_rule) wri.next();
//        generateJavaExpression(pw, wr, sd, _ed, model);
        generateJavaExpressionForEntityRulesInc(pw, wr, sd, _ed, model);
      }
    }

    // } where rules present
    
    
  }


  void generateJavaExpressionForEntityRulesInc(PrintWriter pw, EWhere_rule wr, 
                                                     EGeneric_schema_definition __sd, 
                                                     EEntity_definition __ed, SdaiModel a_model)
                                              throws SdaiException {

		String name;
    String parameters;
    String signature;


// System.out.println("XOX - in generateJavaExpressionForDeriveMethodsInc, attribute: " + attr.getName(null));

    if (!flag_expressions) {
      return;
    }

// ########################### start

            //FIXME            pw.println("\t\t\treturn (" + base_name + ") (");
						//System.out.println("XIXI attr: " + attr.getName(null) + ", entity: " + _ed.getName(null) + ", schema: " + sd.getName(null));
            SdaiModel wr_model = wr.findEntityInstanceSdaiModel();
						ESchema_definition wr_schema = (ESchema_definition)getSchema_definitionFromModel(wr_model);



//            generateJavaExpression(pw, attr, sd, _ed, model);
            
            
//            generateJavaExpression(pw, attr, attr_schema, _ed, model);


  					// lets try to work directly on a fragment of a tree, just for an expression
							// check  if the schema is different and if it is not in the current parse tree
						// if so, construct the X_DerivedAttr node, set its attributes
						// owner_entity = ed;
					  // attribute = da;
		
						// run the parser on the fragment of the code of the expression of the derived attribute
						// in a string in express_code (previously - documentation)
						// the resulting tree fragment is returned by the parser with the root X_Expression
						// Add it as a child to the constructed X_DerivedAttr, run the expression generation backend
						// on X_DerivedAttr 




						
						// check if attribute schema is present in the tree.
						// one way to do it - perhaps to check if the model is read-write. 
						if (wr_model.getMode() == SdaiModel.READ_WRITE) {
							// ok, not incremental, schema present in the parse tree
							// because only models of currently parsed express schemas are read-write
// System.out.println("XOX local");
// pw.println("// XXX attr: " + attr);
// pw.println("// XXX attr schema: " + attr_schema);
// pw.println("// XXX _ed: " + _ed);
// pw.println("// XXX model: " + model);
	            generateJavaExpression(pw, wr, wr_schema, _ed, model);
						} else {

						if (!flag_incremental_enabled) {
							String rule_label = "";
							if (wr.testLabel(null)) {
								rule_label = wr.getLabel(null);
							}
							System.out.println("Warning! Incremental compilation is not supported or disabled. " + __sd.getName(null).toLowerCase() + " and " + wr_schema.getName(null).toLowerCase() + " have to be compiled together. Where rule " + rule_label + " in entity " + __ed.getName(null) + " not generated");
							return;
						}

							// disabling rule inheritance in incremental compilation
							if (true) return;


// System.out.println("XOX not local");
// pw.println("// XXX not local");
				      if (wr_model.getMode() == SdaiModel.NO_ACCESS) {
        				wr_model.startReadOnlyAccess();
      				}
							// schema is absent, an incremental case here

							// find the corresponding documentation model, find the express_code instance for the attribute,
							// get the expression string from it to parse.
						
							String str = null;
	  					String name_searched = "_EXPRESS_" + wr_schema.getName(null).toUpperCase();
	  					ASdaiModel models  = repo.getModels();
							SdaiIterator iter_models = models.createIterator();
							boolean all_done = false;
							while (iter_models.next()) {
								SdaiModel sm1 = models.getCurrentMember(iter_models);
								String model_name = sm1.getName();
// System.out.println("findModel - searching: " + name_searched + ", current: " + model_name + ", nr of models: " + models.getMemberCount());
								if (model_name.equalsIgnoreCase(name_searched)) {
									// now find the express_code instance for the attribute
									
									Aggregate ia = sm1.getEntityExtentInstances(EExpress_code.class);
									SdaiIterator iter_inst = ia.createIterator();
									while (iter_inst.next()) {
										EExpress_code xc = (EExpress_code)ia.getCurrentMemberObject(iter_inst);
									  EEntity target = xc.getTarget(null);
									  if (target == wr) {
											// found our attribute, get the string now
											A_string values = xc.getValues(null);
											str = values.getByIndex(1);										
											all_done = true;
											break;
										}	
									}
								}
								if (all_done) {
									break;
								}
							} // while models
	
							if (str != null) {
								X_Expression x_e = Compiler2.runParserEntityRuleExpression(str, wr_model, wr_schema, _ed, (jsdai.SExtended_dictionary_schema.EWhere_rule)wr, parser);

        boolean label_present = wr.testLabel(null);
				

				String original_name;
        if (label_present) {
        	original_name = wr.getLabel(null);
    		} else {
    			original_name = "WR1";
    		} 	
    			
				String entity_name = ((EEntity_definition)wr.getParent_item(null)).getName(null);

        name = "r" + entity_name.substring(0, 1).toUpperCase() + entity_name.substring(1).toLowerCase() + 
          		 original_name.substring(0, 1).toUpperCase() + original_name.substring(1).toLowerCase();

        parameters = "SdaiContext _context";

        signature = "\tpublic int " + name + "(" + parameters + ") throws SdaiException {\n\t";

        pw.println(signature);

//				String tmp_str = "\t\treturn (Value.alloc(ExpressTypes.LOGICAL_TYPE).set(_context, ";

//				pw.print(tmp_str);

	            	generateJavaExpressionInc(pw, wr, wr_schema, _ed, model, x_e);

//			pw.println(").getLogical());\n\t}");

							}

						}							

  
  }



    HashSet getWhereRules(EEntity_definition ed) throws SdaiException {


    /*
    
    		have to generate also where rules for cases of (chained) artificial inheritance
    		
    		Artificial inheritance
    		
    		1. if java inheritance is switched off - then for everything
    		2. complex entities - from all supertypes, including the 1st one. Similar to 1.
    		3. when mutiple inheritance - for the second and further supertypes
    		4. If a >= 2nd supertype itself has inherted a where rule through artificial inheritance from its >= 2nd supertype, then
    		   chained generation is needed 
    
    */
    

    HashSet entities = new HashSet();
    HashSet java_rules = new HashSet();
    HashSet non_java_rules = new HashSet();
    boolean inherited_branch = true;

		if ((!java_inheritance_enabled) || (ed.getComplex(null))) {
			// collect where rules from all supertypes, also from all remote supertypes
			collectAllDomainRules(ed, ed, non_java_rules, entities);
		} else {
			// collect from (chained) 2nd and further supertypes
		  // requires to generate where rules declared in all the supertypes of the 2nd and further supertypes
		  // except of those that are reached through diamond inheritance through the 1st supertype
		
			// perhaps we can do it this way:
			// collect all where rules that are reached through the 1st supertypes on all levels (java inheritance)
			// and collect all the rules that are reached through non-java inheritance branches
			// remove from non-java set those that are also in java set
			// generate methods for all the remaining rules in non-java set
			
			collectDomainRules(ed, ed, java_rules, non_java_rules, entities, inherited_branch);
			
		
		}    
		// take only those rules that are present in non_java_rules but not in java_rules

// System.out.println("before: " + non_java_rules);

		non_java_rules.removeAll(java_rules);

// System.out.println("after: " + non_java_rules);


		return non_java_rules;
	}



  void collectAllDomainRules(EEntity_definition current, EEntity_definition start, 
                         HashSet non_java_rules, HashSet entities) throws SdaiException {
    
    // perhaps it is not needed if we use java_rules and non_java_rules
    // or perhaps java_rules is not needed
    if (!entities.add(current)) {
      // repeated inheritance
// allow repeated inheritance, at least for now - use java_rules and non_java rules in sets instead
//      return;
    }

    // get supertypes
    
    // this method on non-complex and with java inheritance enabled only
    // boolean is_complex = start.getComplex(null);

//    if ((!is_complex) || (is_complex && (current == start))) {

      AEntity_or_view_definition asuper = current.getGeneric_supertypes(null);
      int count = asuper.getMemberCount();
      SdaiIterator isuper = asuper.createIterator();

      while (isuper.next()) {
        EEntity_definition eds = (EEntity_definition) asuper.getCurrentMemberObject(isuper);

//        collectAttributes(eds, start, all_attributes, all_flags, entities, inherited_branch);
					collectAllDomainRules(eds, start, non_java_rules, entities);

//    }
     }


		AWhere_rule awr = ((ENamed_type) current).getWhere_rules(null, null);

    SdaiIterator wri = awr.createIterator();

    while (wri.next()) {
      EWhere_rule wr = (EWhere_rule) awr.getCurrentMemberObject(wri);
			non_java_rules.add(wr);
		}


} // end of the method



  void collectDomainRules(EEntity_definition current, EEntity_definition start, 
                         HashSet java_rules, HashSet non_java_rules, HashSet entities, 
                         boolean inherited_branch) throws SdaiException {
    
    // perhaps it is not needed if we use java_rules and non_java_rules
    // or perhaps java_rules is not needed
    if (!entities.add(current)) {
      // repeated inheritance
// allow repeated inheritance, at least for now - use java_rules and non_java rules in sets instead
//      return;
    }

    // get supertypes
    
    // this method on non-complex and with java inheritance enabled only
    // boolean is_complex = start.getComplex(null);

//    if ((!is_complex) || (is_complex && (current == start))) {

      AEntity_or_view_definition asuper = current.getGeneric_supertypes(null);
      int count = asuper.getMemberCount();
      SdaiIterator isuper = asuper.createIterator();

      while (isuper.next()) {
        EEntity_definition eds = (EEntity_definition) asuper.getCurrentMemberObject(isuper);

//        collectAttributes(eds, start, all_attributes, all_flags, entities, inherited_branch);
					collectDomainRules(eds, start, java_rules, non_java_rules, entities, inherited_branch);


        if (inherited_branch && (current == start)) {
          inherited_branch = false;
        }
//    }
    	}

		AWhere_rule awr = ((ENamed_type) current).getWhere_rules(null, null);
// System.out.println("awr: " + awr);

    SdaiIterator wri = awr.createIterator();

    while (wri.next()) {
      EWhere_rule wr = (EWhere_rule) awr.getCurrentMemberObject(wri);
// System.out.println("wr: " + wr);
			if ((inherited_branch) && (current != start)) {
				java_rules.add(wr);
			} else {
				non_java_rules.add(wr);
			}
		}


} // end of the method

  
  
  // new stuff here -- end ------------------------------------------------------------------------------------
  

  void generatePDBmethodsForFunctions(EFunction_definition fd, PrintWriter pw)
                   throws SdaiException {
    APopulation_dependent_bound apdb = (APopulation_dependent_bound) model.getEntityExtentInstances(
                                             EPopulation_dependent_bound.class);

    SdaiIterator iter = apdb.createIterator();

    while (iter.next()) {
      EPopulation_dependent_bound pdb = (EPopulation_dependent_bound) apdb.getCurrentMemberObject(
                                              iter);

      if (pdb.testEntity_name(null)) {
        // we can assume that the schema_name is ok, because the model the same as the one with the entity
        String entity_name = pdb.getEntity_name(null);

        if (entity_name.equalsIgnoreCase(fd.getName(null))) {
          // we have to generate a method for this pdb here
          pw.println("\n\t/*---- population dependent bound*/");
          // System.out.println("### PDB: " + pdb + ", sd: " + sd + ", _ed: " + _ed + ", model: " + model);
          // pw.println("### PDB: " + pdb + ", sd: " + sd + ", _ed: " + _ed + ", model: " + model);
          generateJavaExpression(pw, pdb, sd, null, model);
        }
      }
    }
  }

  void generatePDBmethodsForProcedures(EProcedure_definition pd, PrintWriter pw)
                   throws SdaiException {
    APopulation_dependent_bound apdb = (APopulation_dependent_bound) model.getEntityExtentInstances(
                                             EPopulation_dependent_bound.class);

    SdaiIterator iter = apdb.createIterator();

    while (iter.next()) {
      EPopulation_dependent_bound pdb = (EPopulation_dependent_bound) apdb.getCurrentMemberObject(
                                              iter);

      if (pdb.testEntity_name(null)) {
        // we can assume that the schema_name is ok, because the model the same as the one with the entity
        String entity_name = pdb.getEntity_name(null);

        if (entity_name.equalsIgnoreCase(pd.getName(null))) {
          // we have to generate a method for this pdb here
          pw.println("\n\t/*---- population dependent bound*/");
          // System.out.println("### PDB: " + pdb + ", sd: " + sd + ", _ed: " + _ed + ", model: " + model);
          // pw.println("### PDB: " + pdb + ", sd: " + sd + ", _ed: " + _ed + ", model: " + model);
          generateJavaExpression(pw, pdb, sd, null, model);
        }
      }
    }
  }

  void generatePDBmethodsForRules(EFunction_definition gr, PrintWriter pw)
                   throws SdaiException {
    APopulation_dependent_bound apdb = (APopulation_dependent_bound) model.getEntityExtentInstances(
                                             EPopulation_dependent_bound.class);

    SdaiIterator iter = apdb.createIterator();

    while (iter.next()) {
      EPopulation_dependent_bound pdb = (EPopulation_dependent_bound) apdb.getCurrentMemberObject(
                                              iter);

      if (pdb.testEntity_name(null)) {
        // we can assume that the schema_name is ok, because the model the same as the one with the entity
        String entity_name = pdb.getEntity_name(null);

        if (entity_name.equalsIgnoreCase(gr.getName(null))) {
          // we have to generate a method for this pdb here
          pw.println("\n\t/*---- population dependent bound*/");
          // System.out.println("### PDB: " + pdb + ", sd: " + sd + ", _ed: " + _ed + ", model: " + model);
          // pw.println("### PDB: " + pdb + ", sd: " + sd + ", _ed: " + _ed + ", model: " + model);
          generateJavaExpression(pw, pdb, sd, null, model);
        }
      }
    }
  }

  void generatePDBmethods(EEntity_definition ed, PrintWriter pw)
                   throws SdaiException {
    APopulation_dependent_bound apdb = (APopulation_dependent_bound) model.getEntityExtentInstances(
                                             EPopulation_dependent_bound.class);

    SdaiIterator iter = apdb.createIterator();

    while (iter.next()) {
      EPopulation_dependent_bound pdb = (EPopulation_dependent_bound) apdb.getCurrentMemberObject(
                                              iter);

      if (pdb.testEntity_name(null)) {
        // we can assume that the schema_name is ok, because the model the same as the one with the entity
        String entity_name = pdb.getEntity_name(null);

        if (entity_name.equalsIgnoreCase(ed.getName(null))) {
          // we have to generate a method for this pdb here
          pw.println("\n\t/*---- population dependent bound*/");
          // System.out.println("### PDB: " + pdb + ", sd: " + sd + ", _ed: " + _ed + ", model: " + model);
          // pw.println("### PDB: " + pdb + ", sd: " + sd + ", _ed: " + _ed + ", model: " + model);
          generateJavaExpression(pw, pdb, sd, _ed, model);
        }
      }
    }
  }


  void generateChangeReferencesX(EEntity_definition ed, PrintWriter pw, ArrayList all_attributes, 
                                ArrayList all_flags) throws SdaiException {
    boolean super_generated = false;
    SdaiModel edmod = ed.findEntityInstanceSdaiModel();
		boolean is_xim = false;
//		if (edmod.getName().endsWith("_XIM_DICTIONARY_DATA")) {
		if ((edmod.getName().endsWith("_XIM_DICTIONARY_DATA")) || (edmod.getName().equalsIgnoreCase("MIXED_COMPLEX_TYPES_DICTIONARY_DATA"))) {
			is_xim = true;
		}


    for (int sj = 0; sj < all_attributes.size(); sj++) {
      TheAttribute tattr0 = (TheAttribute)all_attributes.get(sj);
      EAttribute attr0 = tattr0.attr;
			
			// going through consolidated attributes only
			if (!tattr0.consolidated)  continue;

// no substitute instance support    
//  		if ((tattr0.consolidated_type == 0) && (!(tattr0.consolidated_flag_explicit_to_derived))) {

//  		if (((tattr0.consolidated_type == 0) && (!(tattr0.consolidated_flag_explicit_to_derived))) || ((tattr0.consolidated_type == 0) && (is_xim))) {

  		if (((tattr0.consolidated_type == 0) && (!(tattr0.consolidated_flag_explicit_to_derived))) ||
  				((tattr0.consolidated_type == 1) && ((tattr0.consolidated_flag_explicit_to_derived)) && (is_xim))
  		) {

        EExplicit_attribute attr = (EExplicit_attribute) attr0;
        String entity_name = ed.getName(null);

        // pre-X        EEntity_definition owner_entity = attr.getParent_entity(null);
        EEntity_definition owner_entity = (EEntity_definition) attr.getParent_entity(null);
        String owner_name = owner_entity.getName(null);
        String owning_entity_name = getEntityPackage(owner_entity) + "E" + 
                                    owner_name.substring(0, 1).toUpperCase() + 
                                    owner_name.substring(1).toLowerCase();
        ;

        String attr_name = attr.getName(null);
        String attr_internal_name = "a" + tattr0.consolidated_explicit_index;

			
				if (tattr0.consolidated_inheritance == 1) {
          // methods are inherited, not generated.
          if (!super_generated) {
            pw.println("\t\tsuper.changeReferences(old, newer);");
          }

          super_generated = true;
        } else if ((tattr0.consolidated_inheritance == 0) || (tattr0.consolidated_inheritance  == 2)) {

          String method_suffix = attr_name.substring(0, 1).toUpperCase() + 
                                 attr_name.substring(1).toLowerCase();
          EEntity bt = null;

	    if (attr.testDomain(null)) {
          bt = attr.getDomain(null);
			} else {
				pw.println("WARNING! Change references were not generated - attribute domain is NULL: " + attr);
				System.out.println("WARNING! Change references was not generated - attribute domain is NULL: " + attr);
				return;
			}


// System.out.println("<CR> bt: " + bt);

          if (bt instanceof ESimple_type) {
            // nothing to do
          } else if (bt instanceof EAggregation_type) {
            generateAggregationTypeChangeReferences((EAggregation_type) bt, pw, entity_name, 
                                                    attr_name, method_suffix, owning_entity_name, 
                                                    attr_internal_name);
          } else if (bt instanceof EDefined_type) {
            generateDefinedTypeChangeReferences((EDefined_type) bt, pw, entity_name, attr_name, 
                                                method_suffix, owning_entity_name, 
                                                attr_internal_name);
          } else if (bt instanceof EEntity_definition) {
            pw.println("\t\tif (" + attr_internal_name + " == old) {");
            pw.println("\t\t\t" + attr_internal_name + " = newer;");
            pw.println("\t\t}");
          }
				}
      } // explicit attribute
    }
  }



  void generateChangeReferences(EEntity_definition ed, PrintWriter pw, Vector all_attributes, 
                                Vector all_flags) throws SdaiException {
    boolean super_generated = false;
    int internal = 0;

    for (int sj = 0; sj < all_attributes.size(); sj++) {
      EAttribute attr0 = (EAttribute) all_attributes.elementAt(sj);

      if (attr0 instanceof EExplicit_attribute) {
        EExplicit_attribute attr = (EExplicit_attribute) attr0;
        String entity_name = ed.getName(null);

        // pre-X        EEntity_definition owner_entity = attr.getParent_entity(null);
        EEntity_definition owner_entity = (EEntity_definition) attr.getParent_entity(null);
        String owner_name = owner_entity.getName(null);
        String owning_entity_name = getEntityPackage(owner_entity) + "E" + 
                                    owner_name.substring(0, 1).toUpperCase() + 
                                    owner_name.substring(1).toLowerCase();
        ;

        String attr_name = attr.getName(null);
        String attr_internal_name = "a" + internal;
        int attribute_flag = (int) ((Integer) all_flags.elementAt(sj)).intValue();

        if (attribute_flag == AA_JAVA_EXPLICIT) {
          // methods are inherited, not generated.
          if (!super_generated) {
            pw.println("\t\tsuper.changeReferences(old, newer);");
          }

          super_generated = true;
          internal++;
        } else if ((attribute_flag == AA_CURRENT_EXPLICIT) || 
                       (attribute_flag == AA_SUPERTYPE_EXPLICIT)) {
          // generate methods here
          String method_suffix = attr_name.substring(0, 1).toUpperCase() + 
                                 attr_name.substring(1).toLowerCase();
          EEntity bt = attr.getDomain(null);

          if (bt instanceof ESimple_type) {
            // nothing to do
          } else if (bt instanceof EAggregation_type) {
            generateAggregationTypeChangeReferences((EAggregation_type) bt, pw, entity_name, 
                                                    attr_name, method_suffix, owning_entity_name, 
                                                    attr_internal_name);
          } else if (bt instanceof EDefined_type) {
            generateDefinedTypeChangeReferences((EDefined_type) bt, pw, entity_name, attr_name, 
                                                method_suffix, owning_entity_name, 
                                                attr_internal_name);
          } else if (bt instanceof EEntity_definition) {
            pw.println("\t\tif (" + attr_internal_name + " == old) {");
            pw.println("\t\t\t" + attr_internal_name + " = newer;");
            pw.println("\t\t}");
          }

          internal++;
        } else if ((attribute_flag == AA_CURRENT_EXPLICIT_TO_DERIVED) || 
                       (attribute_flag == AA_SUPERTYPE_EXPLICIT_TO_DERIVED)) {
          internal++;
        } else if (attribute_flag == AA_JAVA_EXPLICIT_TO_DERIVED) {
          internal++;
        } else {
          // not explicit or internal error
        }
      } // explicit attribute
    }
  }

  void generateDefinedTypeChangeReferences(EDefined_type dt, PrintWriter pw, String entity_name, 
                                           String attr_name, String method_suffix, 
                                           String owning_entity_name, String attr_internal_name)
                                    throws SdaiException {
    EEntity ut = dt.getDomain(null);

//System.out.println("<CR> ut: " + ut);

    if (ut instanceof ESimple_type) {
      // nothing needed
    } else if (ut instanceof EAggregation_type) {
      generateAggregationTypeChangeReferences((EAggregation_type) ut, pw, entity_name, attr_name, 
                                              method_suffix, owning_entity_name, attr_internal_name);
    } else if (ut instanceof EDefined_type) {
      generateDefinedTypeChangeReferences((EDefined_type) ut, pw, entity_name, attr_name, 
                                          method_suffix, owning_entity_name, attr_internal_name);
    } else if (ut instanceof EEnumeration_type) {
      // nothing needed
    } else if (ut instanceof ESelect_type) {

				if (ut instanceof EExtensible_select_type) {
	        // case for POSSIBLE entity and/or aggregate with entities here - extensible select can be extended to anything
  	      pw.println("\t\tif (" + attr_internal_name + " == old) {");
    	    pw.println("\t\t\t" + attr_internal_name + " = newer;");
      	  pw.println("\t\t} else {");
        	pw.println("\t\t\tchangeReferencesAggregate(" + attr_internal_name + ", old, newer);");
	        pw.println("\t\t}");
 				} else {

//      ANamed_type nt = ((ESelect_type) ut).getSelections(null);
//      ANamed_type nt = ((ESelect_type) ut).getLocal_selections(null);
      ANamed_type nt = getSelections((ESelect_type) ut);

      //         int select_type = calculateSelectPaths(nt); // 0 - pure entity, 1 - pure defined_type or 2 - mixed select
      SelectPaths paths1 = null;
      int select_type = Integer.MIN_VALUE;
      Object temp_object = ut.getTemp();

      if (temp_object instanceof SelectPaths) {
        if (((SelectPaths) temp_object).owner == (ESelect_type) ut) {
          paths1 = (SelectPaths) temp_object;
          select_type = paths1.select_type;
        }
      }

      if (paths1 == null) {
        int count = 1;
        int[] indeces = new int[500];
        int depth = 0;
        int depth_count = 0;
        boolean with_type = false;
        Vector current_nodes = new Vector();
        Vector current_node_strings = new Vector();
        paths1 = new SelectPaths();
        paths1.owner = (ESelect_type) ut;
        select_type = calculateSelectPaths(count, current_nodes, current_node_strings, indeces, 
                                           depth, depth_count, paths1, (ESelect_type) ut, with_type);
        paths1.removeIdentical();
        paths1.select_type = select_type;
        ut.setTemp(paths1);
      }

      select_loops = new HashSet();
      int status = referencesInSelect((ESelect_type) ut, 0);

      if (status == 1) {
        // case for entity here
        pw.println("\t\tif (" + attr_internal_name + " == old) {");
        pw.println("\t\t\t" + attr_internal_name + " = newer;");
        pw.println("\t\t}");
      } else if (status == 10) {
        // case for aggregate with entities here
        pw.println("\t\tchangeReferencesAggregate(" + attr_internal_name + ", old, newer);");
      } else if (status == 11) {
        // case for entity + aggregate with entities here
        pw.println("\t\tif (" + attr_internal_name + " == old) {");
        pw.println("\t\t\t" + attr_internal_name + " = newer;");
        pw.println("\t\t} else {");
        pw.println("\t\t\tchangeReferencesAggregate(" + attr_internal_name + ", old, newer);");
        pw.println("\t\t}");
      }

 				}

    }
  }

  void generateAggregationTypeChangeReferences(EAggregation_type at, PrintWriter pw, 
                                               String entity_name, String attr_name, 
                                               String method_suffix, String owning_entity_name, 
                                               String attr_internal_name)
                                        throws SdaiException {
    int aggregate_depth = 1;
    EEntity an_ss;
    EEntity ass = at;
    String aggr_prefices = "";
    an_ss = at.getElement_type(null);

    for (;;) {
      boolean done_something = false;

      if (an_ss instanceof EDefined_type) {
        ass = an_ss;
        an_ss = ((EDefined_type) an_ss).getDomain(null);
        done_something = true;
      } else if (an_ss instanceof EAggregation_type) {
        aggr_prefices += "a";
        aggregate_depth++;
        ass = an_ss;
        an_ss = ((EAggregation_type) an_ss).getElement_type(null);
        done_something = true;
      }

      if (!done_something) {
        break;
      }
    }

    String aggr_prefix = "A" + aggr_prefices;
    String aggr_nesting = "";

    if (aggregate_depth > 1) {
      aggr_nesting += aggregate_depth;
    }

    if (an_ss instanceof ESelect_type) {
      select_loops = new HashSet();
      int status = referencesInSelect((ESelect_type) an_ss, 0);

      if ((status > 0) || (an_ss instanceof EExtensible_select_type)) {
        pw.println("\t\tchangeReferencesAggregate(" + attr_internal_name + ", old, newer);");
      }
    } else if (an_ss instanceof EEntity_definition) {
      pw.println("\t\tchangeReferencesAggregate(" + attr_internal_name + ", old, newer);");
    }
  }

  void generateMethods(EEntity_definition ed, PrintWriter pw, Vector all_attributes, Vector all_flags, Vector all_attributes_ext, Vector all_flags_ext) throws SdaiException {
    _ed = ed;

    int internal = 0;
    int count_derived = 0;
    int count_inverse = 0;

//    for (int sj = 0; sj < all_attributes.size(); sj++) {
    for (int sj = 0; sj < all_attributes_ext.size(); sj++) {
//      EAttribute attr = (EAttribute) all_attributes.elementAt(sj);
      EAttribute attr = (EAttribute) all_attributes_ext.elementAt(sj);
// pw.println("XXX all attributes: " + attr);
      String entity_name = ed.getName(null);

      // pre-x      EEntity_definition owner_entity = attr.getParent_entity(null);
      EEntity_definition owner_entity = (EEntity_definition) attr.getParent_entity(null);
      String owner_name = owner_entity.getName(null);
      String owning_entity_name = getEntityPackage(owner_entity) + "E" + 
                                  owner_name.substring(0, 1).toUpperCase() + 
                                  owner_name.substring(1).toLowerCase();
      ;

      String attr_name = attr.getName(null);
      String attr_internal_name = "a" + internal;
//      int attribute_flag = (int) ((Integer) all_flags.elementAt(sj)).intValue();
      int attribute_flag = (int) ((Integer) all_flags_ext.elementAt(sj)).intValue();


    pw.println("// XXX all attributes - attribute: " + attr + ", parent: " + attr.getParent(null).getName(null));
    pw.println("// XXX all attributes FLAG: " + attribute_flag);
    pw.println("// XXX explicit count: " + internal);
    pw.println("// XXX derived count: " + count_derived);

      
       
      if (attribute_flag == AA_JAVA_EXPLICIT) {
        // methods are inherited, not generated.
        internal++;

        EExplicit_attribute xattr = (EExplicit_attribute) attr;
        String method_suffix = attr_name.substring(0, 1).toUpperCase() + 
                               attr_name.substring(1).toLowerCase();
        EEntity bt = xattr.getDomain(null);

        if (bt instanceof EAggregation_type) {
          generateExplicitAttributeAggregationTypeMethodsUsedinOnly((EAggregation_type) bt, pw, 
                                                                    entity_name, attr_name, 
                                                                    method_suffix, 
                                                                    owning_entity_name, 
                                                                    attr_internal_name);
        } else if (bt instanceof EDefined_type) {
          generateExplicitAttributeDefinedTypeMethodsUsedinOnly((EDefined_type) bt, pw, entity_name, 
                                                                attr_name, method_suffix, 
                                                                owning_entity_name, 
                                                                attr_internal_name);
        } else if (bt instanceof EEntity_definition) {
          String base_entity_name = ((EEntity_definition) bt).getName(null);
          String base_name = getEntityPackage((EEntity_definition) bt) + "E" + 
                             base_entity_name.substring(0, 1).toUpperCase() + 
                             base_entity_name.substring(1).toLowerCase();
          pw.println("\t// attribute (java explicit): " + attr_name + ", base type: entity " + base_entity_name);


          // usedin
          pw.println("\tpublic static int usedin" + method_suffix + "(" + owning_entity_name + 
                     " type, " + base_name + 
                     " instance, ASdaiModel domain, AEntity result) throws SdaiException {");
          pw.println("\t\treturn ((CEntity)instance).makeUsedin(definition, " + 
                     attr_internal_name + "$, domain, result);");
          pw.println("\t}");
        }
      } else if (attribute_flag == AA_JAVA_EXPLICIT_REDECLARING) {

        EExplicit_attribute xattr = (EExplicit_attribute) attr;
        EExplicit_attribute xattr_prev = xattr.getRedeclaring(null);
      	String redeclaring_name = xattr.getName(null);
      	String redeclared_name = xattr_prev.getName(null);
      	if (!redeclaring_name.equalsIgnoreCase(redeclared_name)) {
					// still may be too many
//	      	internal++;
				}


      } else if ((attribute_flag == AA_CURRENT_EXPLICIT) || 
                     (attribute_flag == AA_SUPERTYPE_EXPLICIT)) {
        internal++;

        // generate methods here
        EExplicit_attribute xattr = (EExplicit_attribute) attr;
        String method_suffix = attr_name.substring(0, 1).toUpperCase() + 
                               attr_name.substring(1).toLowerCase();
        EEntity bt = xattr.getDomain(null);

        if (bt instanceof ESimple_type) {
          generateExplicitAttributeSimpleTypeMethods((ESimple_type) bt, pw, entity_name, attr_name, 
                                                     method_suffix, owning_entity_name, 
                                                     attr_internal_name);
        } else if (bt instanceof EAggregation_type) {
          generateExplicitAttributeAggregationTypeMethods((EAggregation_type) bt, pw, entity_name, 
                                                          attr_name, method_suffix, 
                                                          owning_entity_name, attr_internal_name);
        } else if (bt instanceof EDefined_type) {
          generateExplicitAttributeDefinedTypeMethods((EDefined_type) bt, pw, entity_name, 
                                                      attr_name, method_suffix, owning_entity_name, 
                                                      attr_internal_name);
        } else if (bt instanceof EEntity_definition) {
          String base_entity_name = ((EEntity_definition) bt).getName(null);
          String base_name = getEntityPackage((EEntity_definition) bt) + "E" + 
                             base_entity_name.substring(0, 1).toUpperCase() + 
                             base_entity_name.substring(1).toLowerCase();
          pw.println("\t// attribute (current explicit or supertype explicit) : " + attr_name + ", base type: entity " + base_entity_name);


          // usedin
          pw.println("\tpublic static int usedin" + method_suffix + "(" + owning_entity_name + 
                     " type, " + base_name + 
                     " instance, ASdaiModel domain, AEntity result) throws SdaiException {");
          pw.println("\t\treturn ((CEntity)instance).makeUsedin(definition, " + 
                     attr_internal_name + "$, domain, result);");
          pw.println("\t}");
          pw.println("\tpublic boolean test" + method_suffix + "(" + owning_entity_name + 
                     " type) throws " + "SdaiException {");
          pw.println("\t\treturn test_instance(" + attr_internal_name + ");");
          pw.println("\t}");
          pw.println("\tpublic " + base_name + " get" + method_suffix + "(" + owning_entity_name + 
                     " type) throws " + "SdaiException {");
//OPTIMIZED          pw.println("\t\t" + attr_internal_name + " = get_instance(" + attr_internal_name + ");");
          pw.println("\t\treturn (" + base_name + ")get_instance(" + attr_internal_name + ");");
          pw.println("\t}");
          pw.println("\tpublic void set" + method_suffix + "(" + owning_entity_name + " type, " + 
                     base_name + " value) throws " + "SdaiException {");
          pw.println("\t\t" + attr_internal_name + " = set_instance(" + attr_internal_name + 
                     ", value);");
          pw.println("\t}");
          pw.println("\tpublic void unset" + method_suffix + "(" + owning_entity_name + 
                     " type) throws " + "SdaiException {");
          pw.println("\t\t" + attr_internal_name + " = unset_instance(" + attr_internal_name + 
                     ");");
          pw.println("\t}");
        }

        pw.println("\tpublic static jsdai.dictionary.EAttribute attribute" + method_suffix + "(" + 
                   owning_entity_name + " type) throws SdaiException {");
        pw.println("\t\treturn " + attr_internal_name + "$;");
        pw.println("\t}");
        pw.println("");
      
      } else if ((attribute_flag == AA_CURRENT_EXPLICIT_REDECLARING) || (attribute_flag == AA_SUPERTYPE_EXPLICIT_REDECLARING)) {
        EExplicit_attribute xattr = (EExplicit_attribute) attr;
        EExplicit_attribute xattr_prev = xattr.getRedeclaring(null);
      	String redeclaring_name = xattr.getName(null);
      	String redeclared_name = xattr_prev.getName(null);
      	if (!redeclaring_name.equalsIgnoreCase(redeclared_name)) {
					// renamed attribute, generate methods for it

  	      String method_suffix = attr_name.substring(0, 1).toUpperCase() + attr_name.substring(1).toLowerCase();
//      	  EEntity bt = xattr.getDomain(null);
					EEntity bt_prev = xattr_prev.getDomain(null);

					EEntity bt = calculateTypeOfRedeclaredAttribute(xattr);


      		EEntity_definition owner_entity_prev = (EEntity_definition) xattr_prev.getParent_entity(null);
      		String owner_name_prev = owner_entity_prev.getName(null);
      		String owning_entity_name_prev = getEntityPackage(owner_entity_prev) + "E" + 
                                  owner_name_prev.substring(0, 1).toUpperCase() + 
                                  owner_name_prev.substring(1).toLowerCase();
  	      String method_suffix_prev = redeclared_name.substring(0, 1).toUpperCase() + redeclared_name.substring(1).toLowerCase();
          String package_prev = getEntityPackage(owner_entity_prev)  + "C" +
                                  owner_name_prev.substring(0, 1).toUpperCase() + 
                                  owner_name_prev.substring(1).toLowerCase() + ".";

         package_prev = "";



        if (bt instanceof ESimple_type) {
//          generateExplicitAttributeSimpleTypeMethods((ESimple_type) bt, pw, entity_name, attr_name, 
//                                                     method_suffix, owning_entity_name, 
//                                                     attr_internal_name);
          generateExplicitAttributeSimpleTypeMethodsRenamed((ESimple_type) bt, pw, entity_name, attr_name, 
                                                     method_suffix, owning_entity_name, 
                                                     attr_internal_name,
 																											xattr, method_suffix_prev, owning_entity_name_prev, package_prev);


        } else if (bt instanceof EAggregation_type) {
        	
        	// can the get the original aggregation type?
        	
        	
          generateExplicitAttributeAggregationTypeMethodsRenamed((EAggregation_type) bt, pw, entity_name, 
                                                          attr_name, method_suffix, 
                                                          owning_entity_name, attr_internal_name, xattr, method_suffix_prev, owning_entity_name_prev, package_prev);
        } else if (bt instanceof EDefined_type) {
          generateExplicitAttributeDefinedTypeMethodsRenamed((EDefined_type) bt, pw, entity_name, 
                                                      attr_name, method_suffix, owning_entity_name, 
                                                      attr_internal_name,
 																											xattr, method_suffix_prev, owning_entity_name_prev, package_prev);
        } else if (bt instanceof EEntity_definition) {

					// perhaps let's do it this way for now:
					// if both entities, then new entity (parser already ensures that it is a subtype
					// if prev entity and new is not entity - then prev entity type, at least for now, the new type is possibly select with subtypes in it

					String base_entity_name = null;
					String base_name = null;
		
          
//          if (bt instanceof EEntity_definition) {
          
	          base_entity_name = ((EEntity_definition) bt).getName(null);
  	        base_name = getEntityPackage((EEntity_definition) bt) + "E" + 
    	                         base_entity_name.substring(0, 1).toUpperCase() + 
      	                       base_entity_name.substring(1).toLowerCase();
          
          
//        	} else {
//	          base_entity_name = ((EEntity_definition) bt_prev).getName(null);
 // 	        base_name = getEntityPackage((EEntity_definition) bt_prev) + "E" + 
 //   	                         base_entity_name.substring(0, 1).toUpperCase() + 
  //    	                       base_entity_name.substring(1).toLowerCase();
  //      	}
          
          pw.println("\t//-1- attribute (current explicit redeclaring or supertype explicit redeclaring):  " + attr_name + ", base type: entity " + base_entity_name);



          // usedin
/*
	          pw.println("\tpublic static int usedin" + method_suffix + "(" + owning_entity_name + " type, " + base_name + " instance, ASdaiModel domain, AEntity result) throws SdaiException {");
//          pw.println("\t\treturn ((CEntity)instance).makeUsedin(definition, " + attr_internal_name + "$, domain, result);");
          pw.println("\t\treturn " + package_prev + "usedin" + method_suffix_prev + "((" + owning_entity_name_prev + ")null, instance, domain, result);");
          pw.println("\t}");
*/
//USEDIN-RENAMED

pw.println("// USEDIN-RENAMED-01");
          pw.println("\tpublic static int usedin" + method_suffix + "(" + owning_entity_name + " type, " + base_name + " instance, ASdaiModel domain, AEntity result) throws SdaiException {");
          pw.println("\t\treturn ((CEntity)instance).makeUsedin(definition, " + attr_internal_name + "$, domain, result);");
          pw.println("\t}");

  
   
          pw.println("\tpublic boolean test" + method_suffix + "(" + owning_entity_name + 
                     " type) throws " + "SdaiException {");
//          pw.println("\t\treturn test_instance(" + attr_internal_name + ");");
          pw.println("\t\treturn " + package_prev + "test" + method_suffix_prev + "((" + owning_entity_name_prev + ")null);");

          pw.println("\t}");

          pw.println("\tpublic " + base_name + " get" + method_suffix + "(" + owning_entity_name + 
                     " type) throws " + "SdaiException {");
//          pw.println("\t\t" + attr_internal_name + " = get_instance(" + attr_internal_name + ");");
//          pw.println("\t\treturn (" + base_name + ")" + attr_internal_name + ";");
          pw.println("\t\treturn (" + base_name + ")" + package_prev + "get" + method_suffix_prev + "((" + owning_entity_name_prev + ")null);");
          pw.println("\t}");

          pw.println("\tpublic void set" + method_suffix + "(" + owning_entity_name + " type, " + 
                     base_name + " value) throws " + "SdaiException {");
//          pw.println("\t\t" + attr_internal_name + " = set_instance(" + attr_internal_name + ", value);");
          pw.println("\t\t" + package_prev + "set" + method_suffix_prev + "((" + owning_entity_name_prev + ")null, value);");
          pw.println("\t}");

          pw.println("\tpublic void unset" + method_suffix + "(" + owning_entity_name + 
                     " type) throws " + "SdaiException {");
//          pw.println("\t\t" + attr_internal_name + " = unset_instance(" + attr_internal_name + ");");
          pw.println("\t\t" + package_prev + "unset" + method_suffix_prev + "((" + owning_entity_name_prev + ")null);");
          pw.println("\t}");
        }

        pw.println("\tpublic static jsdai.dictionary.EAttribute attribute" + method_suffix + "(" + owning_entity_name + " type) throws SdaiException {");
        pw.println("\t\treturn " + package_prev + "attribute" + method_suffix_prev + "((" + owning_entity_name_prev + ")null);");
        pw.println("\t}");
        pw.println("");






      		
      	} // renamed
      } else if ((attribute_flag == AA_CURRENT_DERIVED) || 
                     (attribute_flag == AA_SUPERTYPE_DERIVED)) {
        count_derived++;

        //            JavaClass expression_java = null;
        A_string expression_java = null;

        // if (flag_expressions) {
        //           EJava_code jc = findJava_codeForDerivedAttribute(attr);
        //           if (jc != null) {
        // System.out.println("### ### java code for derived attribute found");
        //                 expression_java = jc.getValues(null);
        //                 } else {
        // System.out.println("### ### java code for derived attribute NOT found");
        //                 }
        // }
        // test and get methods for all attribute types - different return types - also for select, with select path nodes - multiple methods.
        EDerived_attribute dattr = (EDerived_attribute) attr;
        String method_suffix = attr_name.substring(0, 1).toUpperCase() + 
                               attr_name.substring(1).toLowerCase();
        EEntity bt = dattr.getDomain(null);

        if (bt instanceof ESimple_type) {
          generateDerivedAttributeSimpleTypeMethods(attr, (ESimple_type) bt, pw, entity_name, 
                                                    attr_name, method_suffix, owning_entity_name, 
                                                    attr_internal_name, expression_java);
        } else if (bt instanceof EAggregation_type) {
          generateDerivedAttributeAggregationTypeMethods(attr, (EAggregation_type) bt, pw, 
                                                         entity_name, attr_name, method_suffix, 
                                                         owning_entity_name, attr_internal_name, 
                                                         expression_java);
        } else if (bt instanceof EDefined_type) {
          generateDerivedAttributeDefinedTypeMethods(attr, (EDefined_type) bt, pw, entity_name, 
                                                     attr_name, method_suffix, owning_entity_name, 
                                                     attr_internal_name, expression_java);
        } else if (bt instanceof EEntity_definition) {
          String base_entity_name = ((EEntity_definition) bt).getName(null);
          String base_name = getEntityPackage((EEntity_definition) bt) + "E" + 
                             base_entity_name.substring(0, 1).toUpperCase() + 
                             base_entity_name.substring(1).toLowerCase();
// System.out.println("<<<>>> entity: " + ed.getName(null) + ", derived attribute: " + attr_name + ", base type: entity " + base_entity_name);
          pw.println("\t// derived attribute (current derived or supertype derived): " + attr_name + ", base type: entity " + 
                     base_entity_name);
          pw.println("\tpublic boolean test" + method_suffix + "(" + owning_entity_name + 
                     " type) throws " + "SdaiException {");
          pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
          pw.println("\t}");

          pw.println("\tpublic " + "Value" + " get" + method_suffix + "(" + owning_entity_name + 
                     " type, SdaiContext _context) throws " + "SdaiException {");

          //               if ((flag_expressions) & (expression_java != null)) {
          if (flag_expressions) {
		        generateJavaExpressionForDeriveMethodsInc(pw, attr, sd, _ed, model);

          } else {
            pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
          }

          pw.println("\t}");

          pw.println("\tpublic " + base_name + " get" + method_suffix + "(" + owning_entity_name + 
                     " type) throws " + "SdaiException {");


          //               if ((flag_expressions) & (expression_java != null)) {

//RR-SdaiContext-temp
//          pw.println("\t\tSdaiContext _context = SdaiSession.getSdaiContext();");
          pw.println("\t\tSdaiContext _context = this.findEntityInstanceSdaiModel().getRepository().getSession().getSdaiContext();");

          if (flag_expressions) {
            //						pw.println("\t\t\tSdaiContext _context = this.findEntityInstanceSdaiModel().getRepository().getSession().getSdaiContext();");
//            pw.println("\t\t\treturn (" + base_name + ") get" + method_suffix + "(null, _context).getActualType();");
            pw.println("\t\t\treturn (" + base_name + ") get" + method_suffix + "(null, _context).getInstance();");
          } else {
            pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
          }

          pw.println("\t}");
        }

        pw.println("\tpublic static jsdai.dictionary.EAttribute attribute" + method_suffix + "(" + 
                   owning_entity_name + " type) throws SdaiException {");
        pw.println("\t\treturn d" + (count_derived - 1) + "$;");
        pw.println("\t}");
        pw.println("");
      } else if (attribute_flag == AA_JAVA_DERIVED) {
        count_derived++;
			
      } else if (attribute_flag == AA_CURRENT_EXPLICIT_TO_DERIVED) {

// probably never occurs? - redeclared as derived in the same entity, or what?

//                     (attribute_flag == AA_SUPERTYPE_EXPLICIT_TO_DERIVED)) { 
//                     (attribute_flag == AA_SUPERTYPE_EXPLICIT_TO_DERIVED) || 
//                     (attribute_flag == AA_JAVA_EXPLICIT_TO_DERIVED)) {
        // because all methods from interfaces must be implemented, I have to implement both inherited and non-inherited.
        // However, let's say that we have C subtype of B subtype of A. A has an explicit attribute, it is redeclared as derivid in B.
        // what needs to be generated in C? Methods are already redeclared in B and inherited in A, so nothing is needed in A.
        // But this more complex logic needs to be implemented. Maybe later. I can redeclare again, for now.


// debug

if (attribute_flag == AA_CURRENT_EXPLICIT_TO_DERIVED) {
//	pw.println("// DEBUG: current explicit to derived");
} else
if (attribute_flag == AA_SUPERTYPE_EXPLICIT_TO_DERIVED) {
//	pw.println("// DEBUG: supertype explicit to derived");
} else
if (attribute_flag == AA_JAVA_EXPLICIT_TO_DERIVED) {
//	pw.println("// DEBUG: java explicit to derived");
} else {
//	pw.println("// DEBUG: other: " + attribute_flag);
}
 
 
        internal++;
        count_derived++;

        EExplicit_attribute xattr = (EExplicit_attribute) attr;
        String method_suffix = attr_name.substring(0, 1).toUpperCase() + 
                               attr_name.substring(1).toLowerCase();
      
     
        EEntity bt = xattr.getDomain(null);

			
			


        if (bt instanceof ESimple_type) {
          generateLaterRedeclaredAttributeSimpleTypeMethods((ESimple_type) bt, pw, entity_name, 
                                                            attr_name, method_suffix, 
                                                            owning_entity_name, attr_internal_name);
        } else if (bt instanceof EAggregation_type) {
          generateLaterRedeclaredAttributeAggregationTypeMethods((EAggregation_type) bt, pw, 
                                                                 entity_name, attr_name, 
                                                                 method_suffix, owning_entity_name, 
                                                                 attr_internal_name);
        } else if (bt instanceof EDefined_type) {
          generateLaterRedeclaredAttributeDefinedTypeMethods((EDefined_type) bt, pw, entity_name, 
                                                             attr_name, method_suffix, 
                                                             owning_entity_name, attr_internal_name);
        } else if (bt instanceof EEntity_definition) {
          String base_entity_name = ((EEntity_definition) bt).getName(null);
          String base_name = getEntityPackage((EEntity_definition) bt) + "E" + 
                             base_entity_name.substring(0, 1).toUpperCase() + 
                             base_entity_name.substring(1).toLowerCase();
          pw.println("\t// -1- explicit redeclared as derived attribute: " + attr_name + 
                     ", base type: entity " + base_entity_name);
          pw.println("\tpublic boolean test" + method_suffix + "(" + owning_entity_name + 
                     " type) throws " + "SdaiException {");
          pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
          pw.println("\t}");


          // base_name get Method
          pw.println("\tpublic " + base_name + " get" + method_suffix + "(" + owning_entity_name + 
                     " type) throws " + "SdaiException {");
          pw.println("\t\t\t// FN_NAVL - 01");
          pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
          pw.println("\t}");
          pw.println("\tpublic void set" + method_suffix + "(" + owning_entity_name + " type, " + 
                     base_name + " value) throws SdaiException {");
          pw.println("\t\t\tthrow new SdaiException(SdaiException.AT_NVLD);");
          pw.println("\t}");
          pw.println("\tpublic void unset" + method_suffix + "(" + owning_entity_name + 
                     " type) throws SdaiException {");
          pw.println("\t\t\tthrow new SdaiException(SdaiException.AT_NVLD);");
          pw.println("\t}");
        }

        pw.println("\tpublic static jsdai.dictionary.EAttribute attribute" + method_suffix + "(" + 
                   owning_entity_name + " type) throws SdaiException {");
        pw.println("\t\treturn d" + (count_derived - 1) + "$;");
        pw.println("\t}");
        pw.println("");

// new stuff starts


      } else if ((attribute_flag == AA_JAVA_EXPLICIT_TO_DERIVED) ||
                     (attribute_flag == AA_SUPERTYPE_EXPLICIT_TO_DERIVED) ||
                     (attribute_flag == AA_SUPERTYPE_EXPLICIT_TO_DERIVED_RENAMED)
                     ) { 


// debug

if (attribute_flag == AA_CURRENT_EXPLICIT_TO_DERIVED) {
//	pw.println("// DEBUG: current explicit to derived");
} else
if (attribute_flag == AA_SUPERTYPE_EXPLICIT_TO_DERIVED) {
//	pw.println("// DEBUG: supertype explicit to derived");
} else
if (attribute_flag == AA_JAVA_EXPLICIT_TO_DERIVED) {
// 	pw.println("// DEBUG: NEW java explicit to derived");
} else {
//	pw.println("// DEBUG: other: " + attribute_flag);
}
 
 
 // will have to remove all this branch when AA_CURRENT_DERIVED_REDECLARING is fully implemented for all the cases
 // currently removing only for simple types.
 
 
// let's try not to increase this for renamed, but for not renamed even more, because we generate nothing?
//        internal++;


//        count_derived++;



/*

		if (attribute_flag == AA_SUPERTYPE_EXPLICIT_TO_DERIVED_RENAMED) {
experiment        internal++;
//        count_derived++;
    } else 
		if (attribute_flag == AA_SUPERTYPE_EXPLICIT_TO_DERIVED) {
        internal++;
//        count_derived++;
    } else 
    if (attribute_flag == AA_JAVA_EXPLICIT_TO_DERIVED) {
       internal++;
//        count_derived++;
		}
*/		



        EExplicit_attribute xattr = (EExplicit_attribute) attr;
        String method_suffix = attr_name.substring(0, 1).toUpperCase() + 
                               attr_name.substring(1).toLowerCase();
        EEntity bt = xattr.getDomain(null);


		if (attribute_flag == AA_SUPERTYPE_EXPLICIT_TO_DERIVED_RENAMED) {

  // was commented out
// complications with the case when explicit redeclared as derevid with renaming and again redeclared with renaming,
// the number runs too high or not enough fields - to see.
//        count_derived++;

  
        if (bt instanceof ESimple_type) {
//          generateJavaExplicit2DerivedAttributeSimpleTypeMethods(attr,(ESimple_type) bt, pw, entity_name, 
//                                                            attr_name, method_suffix, 
//                                                            owning_entity_name, attr_internal_name);


//          generateJavaExplicit2DerivedAttributeSimpleTypeMethods(attr, redeclared_attr,(ESimple_type) bt, pw, entity_name, 
//                                                            attr_name, method_suffix, 
//                                                            redeclared_owning_entity_name, attr_internal_name, expression_java);


//					internal--;
//					count_derived--;
        } else if (bt instanceof EAggregation_type) {
          generateLaterRedeclaredAttributeAggregationTypeMethods((EAggregation_type) bt, pw, 
                                                                 entity_name, attr_name, 
                                                                 method_suffix, owning_entity_name, 
                                                                 attr_internal_name);

//					internal--;
//					count_derived--;
        } else if (bt instanceof EDefined_type) {
          generateLaterRedeclaredAttributeDefinedTypeMethods((EDefined_type) bt, pw, entity_name, 
                                                             attr_name, method_suffix, 
                                                             owning_entity_name, attr_internal_name);
        } else if (bt instanceof EEntity_definition) {

          String base_entity_name = ((EEntity_definition) bt).getName(null);
          String base_name = getEntityPackage((EEntity_definition) bt) + "E" + 
                             base_entity_name.substring(0, 1).toUpperCase() + 
                             base_entity_name.substring(1).toLowerCase();
          pw.println("\t// -2- explicit redeclared as derived attribute: " + attr_name + 
                     ", base type: entity " + base_entity_name);
          pw.println("\tpublic boolean test" + method_suffix + "(" + owning_entity_name + 
                     " type) throws " + "SdaiException {");
          pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
          pw.println("\t}");


          // base_name get Method
          pw.println("\tpublic " + base_name + " get" + method_suffix + "(" + owning_entity_name + 
                     " type) throws " + "SdaiException {");
          pw.println("\t\t\t// FN_NAVL - 02");
          pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
          pw.println("\t}");
          pw.println("\tpublic void set" + method_suffix + "(" + owning_entity_name + " type, " + 
                     base_name + " value) throws SdaiException {");
          pw.println("\t\t\tthrow new SdaiException(SdaiException.AT_NVLD);");
          pw.println("\t}");
          pw.println("\tpublic void unset" + method_suffix + "(" + owning_entity_name + 
                     " type) throws SdaiException {");
          pw.println("\t\t\tthrow new SdaiException(SdaiException.AT_NVLD);");
          pw.println("\t}");
        
        
        }

//        if (!((bt instanceof ESimple_type) || (bt instanceof EAggregation_type) || (bt instanceof EDefined_type) || (bt instanceof EEntity_definition))) {

	        pw.println("\tpublic static jsdai.dictionary.EAttribute attribute" + method_suffix + "(" + 
  	                 owning_entity_name + " type) throws SdaiException {");
          pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
//    	    pw.println("\t\treturn d" + (count_derived - 1) + "$;");
      	  pw.println("\t}");
        	pw.println("");

//				}

// new stuff ends
//			} else if (attribute_flag == AA_CURRENT_DERIVED_REDECLARING) {
		   } // renamed
		
		
		if (attribute_flag == AA_SUPERTYPE_EXPLICIT_TO_DERIVED_RENAMED) {
// commenting out this internal++; seems to have no effect
//        internal++;
//        count_derived++;
    } else 
		if (attribute_flag == AA_SUPERTYPE_EXPLICIT_TO_DERIVED) {
        // commenting out this internal++ causes some erorrs to be fixed but others to appear.


				// however, let's say that the attribute is not renamed but was renamed previously in supertypes - we then need not to increase the number
				int count_renamed = countAttributeRenamings(attr);
				if (count_renamed == 0) {
	        // are we interested in the number itself? - make some tests with multiple chained renaming
	        internal++;
				}


//        count_derived++;
    } else 
    if (attribute_flag == AA_JAVA_EXPLICIT_TO_DERIVED) {
    	// commeting out this internal++ causes errors
       internal++;
//        count_derived++;
		}
		
		
		
			} else if ((attribute_flag == AA_CURRENT_DERIVED_REDECLARING) || (attribute_flag == AA_SUPERTYPE_DERIVED_REDECLARING)) {

// explicit to derived go here
// but AA_JAVA_EXPLICIT_TO_DERIVED has to be suppressed, no need for method duplication

//        internal++;
//        count_derived++;

        EDerived_attribute dattr = (EDerived_attribute) attr;

				EAttribute redeclared_attr = null;
				EEntity_definition redeclared_owner_entity = null;
				String redeclared_owner_name = null;
				String redeclared_owning_entity_name = null;
				
				if (dattr.testRedeclaring(null)) {
					redeclared_attr = (EAttribute)dattr.getRedeclaring(null);
				} 
				
				String redeclared_name = null;
				String redeclaring_name = attr.getName(null);
				
				if (redeclared_attr != null) {
				
					redeclared_name = redeclared_attr.getName(null);
	      	redeclared_owner_entity = (EEntity_definition) redeclared_attr.getParent_entity(null);
      		redeclared_owner_name = redeclared_owner_entity.getName(null);
      		redeclared_owning_entity_name = getEntityPackage(redeclared_owner_entity) + "E" + 
                                  redeclared_owner_name.substring(0, 1).toUpperCase() + 
                                  redeclared_owner_name.substring(1).toLowerCase();
				}	
				
        A_string expression_java = null;
				
				if (redeclared_attr instanceof EExplicit_attribute) {

  	      count_derived++;

//				if (attribute_flag == AA_SUPERTYPE_DERIVED_REDECLARING) {
//					internal++;
//				}
				
				
        String method_suffix = attr_name.substring(0, 1).toUpperCase() + 
                               attr_name.substring(1).toLowerCase();
//        EEntity bt = dattr.getDomain(null);
        EEntity bt = ((EExplicit_attribute)redeclared_attr).getDomain(null);

        if (bt instanceof ESimple_type) {
          if (debug_java) pw.println("\t// generateJavaExplicit2DerivedAttributeSimpleTypeMethods: 1");
          generateJavaExplicit2DerivedAttributeSimpleTypeMethods(attr, redeclared_attr,(ESimple_type) bt, pw, entity_name, 
                                                            attr_name, method_suffix, 
                                                            redeclared_owning_entity_name, attr_internal_name, expression_java);
        } else if (bt instanceof EAggregation_type) {
//          generateLaterRedeclaredAttributeAggregationTypeMethods((EAggregation_type) bt, pw, 
//                                                                 entity_name, attr_name, 
//                                                                 method_suffix, owning_entity_name, 
//                                                                 attr_internal_name);

          generateJavaExplicit2DerivedAttributeAggregationTypeMethods(attr, redeclared_attr,(EAggregation_type) bt, pw, entity_name, 
                                                            attr_name, method_suffix, 
                                                            redeclared_owning_entity_name, attr_internal_name, expression_java);

        } else if (bt instanceof EDefined_type) {
//          generateLaterRedeclaredAttributeDefinedTypeMethods((EDefined_type) bt, pw, entity_name, 
//                                                             attr_name, method_suffix, 
//                                                             owning_entity_name, attr_internal_name);

          generateJavaExplicit2DerivedAttributeDefinedTypeMethods(attr, redeclared_attr, (EDefined_type) bt, pw, entity_name, 
                                                             attr_name, method_suffix, 
                                                             redeclared_owning_entity_name, attr_internal_name, expression_java);
        } else if (bt instanceof EEntity_definition) {
// old
/*
          String base_entity_name = ((EEntity_definition) bt).getName(null);
          String base_name = getEntityPackage((EEntity_definition) bt) + "E" + 
                             base_entity_name.substring(0, 1).toUpperCase() + 
                             base_entity_name.substring(1).toLowerCase();
          pw.println("\t// explicit redeclared as derived attribute: " + attr_name + 
                     ", base type: entity " + base_entity_name);
          pw.println("\tpublic boolean test" + method_suffix + "(" + owning_entity_name + 
                     " type) throws " + "SdaiException {");
          pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
          pw.println("\t}");


          // base_name get Method
          pw.println("\tpublic " + base_name + " get" + method_suffix + "(" + owning_entity_name + 
                     " type) throws " + "SdaiException {");
          pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
          pw.println("\t}");
          pw.println("\tpublic void set" + method_suffix + "(" + owning_entity_name + " type, " + 
                     base_name + " value) throws SdaiException {");
          pw.println("\t\t\tthrow new SdaiException(SdaiException.AT_NVLD);");
          pw.println("\t}");
          pw.println("\tpublic void unset" + method_suffix + "(" + owning_entity_name + 
                     " type) throws SdaiException {");
          pw.println("\t\t\tthrow new SdaiException(SdaiException.AT_NVLD);");
          pw.println("\t}");
*/
// old end

// new        



          String base_entity_name = ((EEntity_definition) bt).getName(null);
          String base_name = getEntityPackage((EEntity_definition) bt) + "E" + 
                             base_entity_name.substring(0, 1).toUpperCase() + 
                             base_entity_name.substring(1).toLowerCase();
// System.out.println("<<<>>> entity: " + ed.getName(null) + ", derived attribute: " + attr_name + ", base type: entity " + base_entity_name);
          pw.println("\t// -3- explicit redeclared as derived attribute: " + attr_name + ", base type: entity " + 
                     base_entity_name);
          pw.println("\tpublic boolean test" + method_suffix + "(" + redeclared_owning_entity_name + 
                     " type) throws " + "SdaiException {");
          pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
          pw.println("\t}");

          pw.println("\tpublic " + "Value" + " get" + method_suffix + "(" + redeclared_owning_entity_name + 
                     " type, SdaiContext _context) throws " + "SdaiException {");

          //               if ((flag_expressions) & (expression_java != null)) {
          if (flag_expressions) {
		        generateJavaExpressionForDeriveMethodsInc(pw, attr, sd, _ed, model);

          } else {
            pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
          }

          pw.println("\t}");

          pw.println("\tpublic " + base_name + " get" + method_suffix + "(" + redeclared_owning_entity_name + 
                     " type) throws " + "SdaiException {");


          //               if ((flag_expressions) & (expression_java != null)) {

//RR-SdaiContext-temp
//          pw.println("\t\tSdaiContext _context = SdaiSession.getSdaiContext();");
          pw.println("\t\tSdaiContext _context = this.findEntityInstanceSdaiModel().getRepository().getSession().getSdaiContext();");

          if (flag_expressions) {
	            //						pw.println("\t\t\tSdaiContext _context = this.findEntityInstanceSdaiModel().getRepository().getSession().getSdaiContext();");
//            pw.println("\t\t\treturn (" + base_name + ") get" + method_suffix + "(null, _context).getActualType();");
            pw.println("\t\t\treturn (" + base_name + ") get" + method_suffix + "(null, _context).getInstance();");
          } else {
            pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
          }

          pw.println("\t}");
        
          pw.println("\tpublic void set" + method_suffix + "(" + redeclared_owning_entity_name + " type, " + 
                     base_name + " value) throws SdaiException {");
          pw.println("\t\t\tthrow new SdaiException(SdaiException.AT_NVLD);");
          pw.println("\t}");
          pw.println("\tpublic void unset" + method_suffix + "(" + redeclared_owning_entity_name + 
                     " type) throws SdaiException {");
          pw.println("\t\t\tthrow new SdaiException(SdaiException.AT_NVLD);");
          pw.println("\t}");
      
// new end        
        }

        pw.println("\tpublic static jsdai.dictionary.EAttribute attribute" + method_suffix + "(" + 
                   redeclared_owning_entity_name + " type) throws SdaiException {");
        pw.println("\t\treturn d" + (count_derived - 1) + "$;");
        pw.println("\t}");
        pw.println("");

				} else  //  above - the case when explicit redeclared as derived
				if (redeclared_attr instanceof EDerived_attribute) {
					// derived as derived
				} else {
				}
				

      } else if (attribute_flag == AA_JAVA_INVERSE) {
        count_inverse++;

        // inherited
      } else if ((attribute_flag == AA_CURRENT_INVERSE) || 
                     (attribute_flag == AA_SUPERTYPE_INVERSE)) {
        // inverse attributes
        count_inverse++;

        EInverse_attribute inva = (EInverse_attribute) attr;

        if (inva.testRedeclaring(null)) {
          continue;
        }

        EEntity_definition referencing_entity = inva.getDomain(null);
        String referencing_entity_name = referencing_entity.getName(null);
        EExplicit_attribute inverted_attr = inva.getInverted_attr(null);
        String inverted_attr_name = inverted_attr.getName(null);
				String original_inverted_attr_name = getOriginalAttributeName(inverted_attr);
        boolean duplicates = inva.getDuplicates(null);
        EBound min_cardinality = null;
        EBound max_cardinality = null;
        int min_cardinality_int = Integer.MIN_VALUE;
        int max_cardinality_int = Integer.MIN_VALUE;

        if (inva.testMin_cardinality(null)) {
          min_cardinality = inva.getMin_cardinality(null);

          if (min_cardinality instanceof EInteger_bound) {
            min_cardinality_int = ((EInteger_bound) min_cardinality).getBound_value(null);
          }
        }

        if (inva.testMax_cardinality(null)) {
          max_cardinality = inva.getMax_cardinality(null);

          if (max_cardinality instanceof EInteger_bound) {
            max_cardinality_int = ((EInteger_bound) max_cardinality).getBound_value(null);
          }
        }

        if (min_cardinality_int == Integer.MIN_VALUE) { // single entity inverse attribute
          pw.println("\t// Inverse attribute - " + inva.getName(null) + " : " + 
                     referencing_entity_name + " FOR " + inverted_attr_name);
        } else { // set or bag inverse attribute

          if (duplicates) { // bag

            if (max_cardinality_int == Integer.MIN_VALUE) {
              pw.println("\t// Inverse attribute - " + inva.getName(null) + " : BAG[" + 
                         min_cardinality_int + ":?] OF " + referencing_entity_name + " FOR " + 
                         inverted_attr_name);
            } else {
              pw.println("\t// Inverse attribute - " + inva.getName(null) + " : BAG[" + 
                         min_cardinality_int + ":" + max_cardinality_int + "] OF " + 
                         referencing_entity_name + " FOR " + inverted_attr_name);
            }
          } else { // set

            if (max_cardinality_int == Integer.MIN_VALUE) {
              pw.println("\t// Inverse attribute - " + inva.getName(null) + " : SET[" + 
                         min_cardinality_int + ":" + max_cardinality_int + "] OF " + 
                         referencing_entity_name + " FOR " + inverted_attr_name);
            } else {
            }
          }
        }

        String inverse_aggregate = getEntityPackage(referencing_entity) + "A" + 
                                   referencing_entity_name.substring(0, 1).toUpperCase() + 
                                   referencing_entity_name.substring(1).toLowerCase();
        String attr_name1 = inva.getName(null);
        String attr_name0 = attr_name1.substring(0, 1).toUpperCase() + 
                            attr_name1.substring(1).toLowerCase();
        ;

        String base_name = getEntityPackage(referencing_entity) + "C" + 
                           referencing_entity_name.substring(0, 1).toUpperCase() + 
                           referencing_entity_name.substring(1).toLowerCase();
        String entity_interface_name = "E" + entity_name.substring(0, 1).toUpperCase() + 
                                       entity_name.substring(1).toLowerCase();
        String inverted_name = original_inverted_attr_name.substring(0, 1).toUpperCase() + 
                               original_inverted_attr_name.substring(1).toLowerCase();
        pw.println("\tpublic " + inverse_aggregate + " get" + attr_name0 + "(" + 
                   owning_entity_name + " type, ASdaiModel domain) throws SdaiException {");
// old 
// ARectangular_composite_surface result = new ARectangular_composite_surface();
// new
// ARectangular_composite_surface result = (ARectangular_composite_surface) get_inverse_aggregate(i0$);

        if (min_cardinality_int == Integer.MIN_VALUE) { // single entity inverse attribute
        	pw.println("\t\t" + inverse_aggregate + " result = new " + inverse_aggregate + "();");
				} else {
        	pw.println("\t\t" + inverse_aggregate + " result = (" + inverse_aggregate + ")get_inverse_aggregate(i" + (count_inverse-1) + "$);");
      	}
        pw.println("\t\t" + base_name + ".usedin" + inverted_name + 
                   "(null, this, domain, result);");
        pw.println("\t\treturn result;");
        pw.println("\t}");

        String method_suffix = attr_name.substring(0, 1).toUpperCase() + 
                               attr_name.substring(1).toLowerCase();
        pw.println("\tpublic static jsdai.dictionary.EAttribute attribute" + method_suffix + "(" + 
                   owning_entity_name + " type) throws SdaiException {");
        pw.println("\t\treturn i" + (count_inverse - 1) + "$;");
        pw.println("\t}");
        pw.println("");
      } else {
        // other types, like redeclaring, or internal error
      }
    }
  }

	String getOriginalAttributeName(EAttribute attr) throws SdaiException {	
		
		EAttribute attr2 = attr;
		

		for (;;) {
	
			if (attr2 instanceof EExplicit_attribute) {
				if (((EExplicit_attribute)attr2).testRedeclaring(null)) {
					attr2 = ((EExplicit_attribute)attr2).getRedeclaring(null);
				} else {
					return attr2.getName(null);
				}			
			} else
			if (attr2 instanceof EDerived_attribute) {
				if (((EDerived_attribute)attr2).testRedeclaring(null)) {
					attr2 = (EAttribute)((EDerived_attribute)attr2).getRedeclaring(null);
				} else {
					return attr2.getName(null);
				}			
			} else
			if (attr2 instanceof EInverse_attribute) {
				if (((EInverse_attribute)attr2).testRedeclaring(null)) {
					attr2 = ((EInverse_attribute)attr2).getRedeclaring(null);
				} else {
					return attr2.getName(null);
				}			
			} else {
			// internal error 
				return "_WRONG_ATTRIBUTE_";
			}
		}
	}

	EExplicit_attribute getOriginalExplicitAttribute(EExplicit_attribute attr) throws SdaiException {	
		
		EExplicit_attribute attr2 = attr;
		

		for (;;) {
	
				if (attr2.testRedeclaring(null)) {
					attr2 = attr2.getRedeclaring(null);
				} else {
					return attr2;
				}			
		}
	}



	int countAttributeRenamings(EAttribute attr) throws SdaiException {
		int result = 0;
		EAttribute attr2 = attr;
		String current_name = attr.getName(null);
		String new_name = null;

		for (;;) {
	
				if (attr2 instanceof EExplicit_attribute) {
					if (((EExplicit_attribute)attr2).testRedeclaring(null)) {
						attr2 = ((EExplicit_attribute)attr2).getRedeclaring(null);
						new_name = attr2.getName(null);
						if (!(new_name.equalsIgnoreCase(current_name))) {
							result++;
							current_name = new_name;
						}
					} else {
						// done
						break;
					}
				} else				
				if (attr2 instanceof EDerived_attribute) {
					if (((EDerived_attribute)attr2).testRedeclaring(null)) {
					  attr2 = (EAttribute)((EDerived_attribute)attr2).getRedeclaring(null);
						new_name = attr2.getName(null);
						if (!(new_name.equalsIgnoreCase(current_name))) {
							result++;
							current_name = new_name;
						}
					} else {
						// done
						break;
					}
				} else
				if (attr2 instanceof EInverse_attribute) {
					if (((EInverse_attribute)attr2).testRedeclaring(null)) {
						attr2 = ((EInverse_attribute)attr2).getRedeclaring(null);
						new_name = attr2.getName(null);
						if (!(new_name.equalsIgnoreCase(current_name))) {
							result++;
							current_name = new_name;
						}
					} else {
						// done
						break;
					}
				} else {
					// internal error
					break;
				}
		}
		
		
		return result;
	}


	EEntity calculateTypeOfRedeclaredAttribute(EAttribute attr) throws SdaiException {

		/*
		
				ok, so the current implementation changes the type only in the case of entities.
				if attribute a redeclared as b, and b redecared as c and c redeclared as d, and d redeclared as e
				and  a-b entities, but c is not,
				then type b is in b and in c, and so one, once not entity, there is no way to go back to entities.
				
				So first, let's go throug the chain of redeclaring up to the original attribute, and calculate types on the way back down.
				Oh, and yes, we are generating methods for renamed only, so we are interested in renamed only, the type will not be changed on non-renamed,
				as there is no methods for non-renamed.
				
				When we go up, in order to be able to go back down, lets save intermediate attributes somewhere.
		
		
		*/


		EAttribute attr1 = null;
		EAttribute attr2 = attr;
		EAttribute attr3 = null;
		EEntity domain0 = null;
		EEntity domain1 = null;
		EEntity domain2 = null;
		EEntity domain3 = null;
		EEntity type1 = null;
		EEntity type2 = null;
		EEntity type3 = null;
		String name1 = null;
		String name2 = null;
		String name3 = null;
		
		Stack attributes = new Stack();
		attributes.push(attr);

		for (;;) {
	
				if (attr2 instanceof EExplicit_attribute) {
					if (((EExplicit_attribute)attr2).testRedeclaring(null)) {
						attr2 = ((EExplicit_attribute)attr2).getRedeclaring(null);
						attributes.push(attr2);
					} else {
						// done
						break;
					}
				} else				
				if (attr2 instanceof EDerived_attribute) {
					if (((EDerived_attribute)attr2).testRedeclaring(null)) {
					  attr2 = (EAttribute)((EDerived_attribute)attr2).getRedeclaring(null);
						attributes.push(attr2);
					} else {
						// done
						break;
					}
				} else
				if (attr2 instanceof EInverse_attribute) {
					if (((EInverse_attribute)attr2).testRedeclaring(null)) {
						attr2 = ((EInverse_attribute)attr2).getRedeclaring(null);
						attributes.push(attr2);
					} else {
						// done
						break;
					}
				} else {
					// internal error
					break;
				}
		}
		// ok, so now go back down

		
		attr2 = null;
		
		for (;;) {
			if (attributes.empty()) {
				break;
			}
			if (attr2 == null) {
				attr2 = (EAttribute)attributes.pop();
				name2 = attr2.getName(null);
				if (attr2 instanceof EExplicit_attribute) {
					if (((EExplicit_attribute)attr2).testDomain(null)) {
						domain2 = ((EExplicit_attribute)attr2).getDomain(null);
					}
				} else
				if (attr2 instanceof EDerived_attribute) {
					if (((EDerived_attribute)attr2).testDomain(null)) {
						domain2 = ((EDerived_attribute)attr2).getDomain(null);
					}
				} else
				if (attr2 instanceof EInverse_attribute) {
					if (((EInverse_attribute)attr2).testDomain(null)) {
						domain2 = ((EInverse_attribute)attr2).getDomain(null);
					}
				} 
        type2 = domain2;
        domain0 = domain2;			
			} else {
				attr3 = (EAttribute)attributes.pop();
				name3 = attr3.getName(null);
				if (name2.equalsIgnoreCase(name3)) {
					// no RENAMED, skip this attribute
				} else {
					attr1 = attr2;
					name1 = name2;
					domain1 = domain2;
					type1 = type2;
					attr2 = attr3;
					name2 = name3;

					if (attr2 instanceof EExplicit_attribute) {
						if (((EExplicit_attribute)attr2).testDomain(null)) {
							domain2 = ((EExplicit_attribute)attr2).getDomain(null);
						}
					} else
					if (attr2 instanceof EDerived_attribute) {
						if (((EDerived_attribute)attr2).testDomain(null)) {
							domain2 = ((EDerived_attribute)attr2).getDomain(null);
						}
					} else
					if (attr2 instanceof EInverse_attribute) {
						if (((EInverse_attribute)attr2).testDomain(null)) {
							domain2 = ((EInverse_attribute)attr2).getDomain(null);
						}
					} 
					if (domain2 == domain1) {
						// type is not changed
						type2 = type1;
					} else {
						if ((domain1 instanceof EEntity_definition) && (domain2 instanceof EEntity_definition)) {
							type2 = domain2;
						} else {
							type2 = type1;
							return type2; // the type will not be changed even if several entities follow
						}
					}
					
					 
				}
			}
		
		}
		if (type2 == null) type2 = domain0;
		
		return type2;
	}


	// will we need separate methods for this? using non-destructive approach, at least for now, adding separate methods
  void generateJavaExplicit2DerivedAttributeSimpleTypeMethods(EAttribute attr, EAttribute redeclared_attr, ESimple_type st, PrintWriter pw, 
                                                         String entity_name, String attr_name, 
                                                         String method_suffix, 
                                                         String owning_entity_name, 
                                                         String attr_internal_name,
																												 A_string expression_java)
                                          throws SdaiException {
    if (st instanceof EInteger_type) {
// old stuff
/*
      pw.println("\t// methods for explicit redeclared as derived attribute: " + attr_name + 
                 ", base type: INTEGER");
      pw.println("\tpublic boolean test" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      pw.println("\t}");
      pw.println("\tpublic int get" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      pw.println("\t}");
      pw.println("\tpublic void set" + method_suffix + "(" + owning_entity_name + 
                 " type, int value) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.AT_NVLD);");
      pw.println("\t}");
      pw.println("\tpublic void unset" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.AT_NVLD);");
      pw.println("\t}");
*/
// end old stuff
      pw.println("\t// -4- methods for explicit redeclared as derived attribute: " + attr_name + 
                 ", base type: INTEGER");
//      pw.println("\t// methods for derived attribute: " + attr_name + ", base type: INTEGER");
      pw.println("\tpublic boolean test" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      pw.println("\t}");
      pw.println("\tpublic Value get" + method_suffix + "(" + owning_entity_name + 
                 " type, SdaiContext _context) throws " + "SdaiException {");

      if (flag_expressions) {
//        generateJavaExpressionForDeriveMethods(pw, attr, sd, _ed, model);
        generateJavaExpressionForDeriveMethodsInc(pw, attr, sd, _ed, model);
      } else {
        pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      }

      pw.println("\t}");
      pw.println("\tpublic int get" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");

      if (flag_expressions) {
        //        pw.println("\t\t\tSdaiContext _context = this.findEntityInstanceSdaiModel().getRepository().getSession().getSdaiContext();");
//RR-SdaiContext-tmp
//        pw.println("\t\tSdaiContext _context = SdaiSession.getSdaiContext();");
        pw.println("\t\tSdaiContext _context = this.findEntityInstanceSdaiModel().getRepository().getSession().getSdaiContext();");
        pw.println("\t\t\treturn get" + method_suffix + "((" + owning_entity_name + 
                   ")null, _context).getInteger();");
      } else {
        pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      }

      pw.println("\t}");

      pw.println("\tpublic void set" + method_suffix + "(" + owning_entity_name + 
                 " type, int value) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.AT_NVLD);");
      pw.println("\t}");
      pw.println("\tpublic void unset" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.AT_NVLD);");
      pw.println("\t}");

    } else if (st instanceof ENumber_type) {
// old
/*
      pw.println("\t/// methods for attribute: " + attr_name + ", base type: NUMBER");
      pw.println("\tpublic boolean test" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      pw.println("\t}");
      pw.println("\tpublic double get" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      pw.println("\t}");
      pw.println("\tpublic void set" + method_suffix + "(" + owning_entity_name + 
                 " type, double value) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.AT_NVLD);");
      pw.println("\t}");
      pw.println("\tpublic void unset" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.AT_NVLD);");
      pw.println("\t}");
*/
// end old

      pw.println("\t// -5- methods for explicit redeclared as derived attribute: " + attr_name + ", base type: NUMBER");
      pw.println("\tpublic boolean test" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      pw.println("\t}");
      pw.println("\tpublic Value get" + method_suffix + "(" + owning_entity_name + 
                 " type, SdaiContext _context) throws " + "SdaiException {");

      if (flag_expressions) {
//        generateJavaExpressionForDeriveMethods(pw, attr, sd, _ed, model);
        generateJavaExpressionForDeriveMethodsInc(pw, attr, sd, _ed, model);
      } else {
        pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      }

      pw.println("\t}");
      pw.println("\tpublic double get" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");

      if (flag_expressions) {
        //        pw.println("\t\t\tSdaiContext _context = this.findEntityInstanceSdaiModel().getRepository().getSession().getSdaiContext();");
//RR-SdaiContext-tmp
//        pw.println("\t\tSdaiContext _context = SdaiSession.getSdaiContext();");
        pw.println("\t\tSdaiContext _context = this.findEntityInstanceSdaiModel().getRepository().getSession().getSdaiContext();");
        pw.println("\t\t\treturn get" + method_suffix + "((" + owning_entity_name + 
                   ")null, _context).getDouble();");
      } else {
        pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      }

      pw.println("\t}");

      pw.println("\tpublic void set" + method_suffix + "(" + owning_entity_name + 
                 " type, double value) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.AT_NVLD);");
      pw.println("\t}");
      pw.println("\tpublic void unset" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.AT_NVLD);");
      pw.println("\t}");



    } else if (st instanceof EReal_type) {
// old
/*
      pw.println("\t/// methods for attribute: " + attr_name + ", base type: REAL");
      pw.println("\tpublic boolean test" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      pw.println("\t}");
      pw.println("\tpublic double get" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      pw.println("\t}");
      pw.println("\tpublic void set" + method_suffix + "(" + owning_entity_name + 
                 " type, double value) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.AT_NVLD);");
      pw.println("\t}");
      pw.println("\tpublic void unset" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.AT_NVLD);");
      pw.println("\t}");
*/
// end old

      pw.println("\t// -6- methods for explicit redeclared as derived attribute: " + attr_name + ", base type: REAL");
      pw.println("\tpublic boolean test" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      pw.println("\t}");
      pw.println("\tpublic Value get" + method_suffix + "(" + owning_entity_name + 
                 " type, SdaiContext _context) throws " + "SdaiException {");

      if (flag_expressions) {
//        generateJavaExpressionForDeriveMethods(pw, attr, sd, _ed, model);
        generateJavaExpressionForDeriveMethodsInc(pw, attr, sd, _ed, model);
      } else {
        pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      }

      pw.println("\t}");
      pw.println("\tpublic double get" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");

      if (flag_expressions) {
        //        pw.println("\t\t\tSdaiContext _context = this.findEntityInstanceSdaiModel().getRepository().getSession().getSdaiContext();");
//RR-SdaiContext-tmp
//        pw.println("\t\tSdaiContext _context = SdaiSession.getSdaiContext();");
        pw.println("\t\tSdaiContext _context = this.findEntityInstanceSdaiModel().getRepository().getSession().getSdaiContext();");
        pw.println("\t\treturn get" + method_suffix + "((" + owning_entity_name + 
                   ")null, _context).getDouble();");
      } else {
        pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      }

      pw.println("\t}");

      pw.println("\tpublic void set" + method_suffix + "(" + owning_entity_name + 
                 " type, double value) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.AT_NVLD);");
      pw.println("\t}");
      pw.println("\tpublic void unset" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.AT_NVLD);");
      pw.println("\t}");

    } else if (st instanceof EBoolean_type) {
// old
/*
      pw.println("\t/// methods for attribute: " + attr_name + ", base type: BOOLEAN");
      pw.println("\tpublic boolean test" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      pw.println("\t}");
      pw.println("\tpublic boolean get" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      pw.println("\t}");
      pw.println("\tpublic void set" + method_suffix + "(" + owning_entity_name + 
                 " type, boolean value) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.AT_NVLD);");
      pw.println("\t}");
      pw.println("\tpublic void unset" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.AT_NVLD);");
      pw.println("\t}");
*/
// end old

      pw.println("\t// -7- methods for explicit redeclared as derived attribute: " + attr_name + ", base type: BOOLEAN");

/*
explicit:

      pw.println("\tpublic boolean test" + method_suffix + "(" + owning_entity_name + " type) throws " + "SdaiException {");
      pw.println("\t\treturn test_boolean(" + attr_internal_name + ");");
      pw.println("\t}");
      pw.println("\tpublic boolean get" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\treturn get_boolean(" + attr_internal_name + ");");
      pw.println("\t}");
      pw.println("\tpublic void set" + method_suffix + "(" + owning_entity_name + 
                 " type, boolean value) throws " + "SdaiException {");
      pw.println("\t\t" + attr_internal_name + " = set_boolean(value);");
      pw.println("\t}");
      pw.println("\tpublic void unset" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\t" + attr_internal_name + " = unset_boolean();");
      pw.println("\t}");

*/

      pw.println("\tpublic boolean test" + method_suffix + "(" + owning_entity_name + " type) throws " + "SdaiException {");
      if (flag_expressions) {

//      	pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
	      pw.println("\t\treturn test_boolean(" + attr_internal_name + ");");
			} else {
      	pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
			}
      pw.println("\t}");

      pw.println("\tpublic Value get" + method_suffix + "(" + owning_entity_name + 
                 " type, SdaiContext _context) throws " + "SdaiException {");

      if (flag_expressions) {
//        generateJavaExpressionForDeriveMethods(pw, attr, sd, _ed, model);
        generateJavaExpressionForDeriveMethodsInc(pw, attr, sd, _ed, model);
      } else {
        pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      }

      pw.println("\t}");
//fixed-2005-03-27-int changed to boolean      pw.println("\tpublic int get" + method_suffix + "(" + owning_entity_name + " type) throws " + "SdaiException {");
      pw.println("\tpublic boolean get" + method_suffix + "(" + owning_entity_name + " type) throws " + "SdaiException {");

      if (flag_expressions) {
        //        pw.println("\t\t\tSdaiContext _context = this.findEntityInstanceSdaiModel().getRepository().getSession().getSdaiContext();");
//RR-SdaiContext-tmp
//        pw.println("\t\tSdaiContext _context = SdaiSession.getSdaiContext();");
        pw.println("\t\tSdaiContext _context = this.findEntityInstanceSdaiModel().getRepository().getSession().getSdaiContext();");
//        pw.println("\t\treturn get" + method_suffix + "((" + owning_entity_name + ")null, _context).getBoolean();");

//        pw.println("\t\treturn (get" + method_suffix + "((" + owning_entity_name + ")null, _context).getBoolean() == 2) ? true: false;");
        pw.println("\t\t" + attr_internal_name + " = get" + method_suffix + "((" + owning_entity_name + ")null, _context).getBoolean();");
        pw.println("\t\treturn (" + attr_internal_name + " == 2) ? true: false;");
      } else {
        pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      }

      pw.println("\t}");

      pw.println("\tpublic void set" + method_suffix + "(" + owning_entity_name + 
                 " type, boolean value) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.AT_NVLD);");
      pw.println("\t}");
      pw.println("\tpublic void unset" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.AT_NVLD);");
      pw.println("\t}");

    } else if (st instanceof ELogical_type) {
// old 
/*
      pw.println("\t/// methods for attribute: " + attr_name + ", base type: LOGICAL");
      pw.println("\tpublic boolean test" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      pw.println("\t}");
      pw.println("\tpublic int get" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      pw.println("\t}");
      pw.println("\tpublic void set" + method_suffix + "(" + owning_entity_name + 
                 " type, int value) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.AT_NVLD);");
      pw.println("\t}");
      pw.println("\tpublic void unset" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.AT_NVLD);");
      pw.println("\t}");
*/
// end old

      pw.println("\t// -8- methods for explicit redeclared as derived attribute: " + attr_name + ", base type: LOGICAL");
      pw.println("\tpublic boolean test" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      pw.println("\t}");
      pw.println("\tpublic Value get" + method_suffix + "(" + owning_entity_name + 
                 " type, SdaiContext _context) throws " + "SdaiException {");

      if (flag_expressions) {
//        generateJavaExpressionForDeriveMethods(pw, attr, sd, _ed, model);
        generateJavaExpressionForDeriveMethodsInc(pw, attr, sd, _ed, model);
      } else {
        pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      }

      pw.println("\t}");
      pw.println("\tpublic int get" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");

      if (flag_expressions) {
        //        pw.println("\t\t\tSdaiContext _context = this.findEntityInstanceSdaiModel().getRepository().getSession().getSdaiContext();");
//RR-SdaiContext-tmp
//        pw.println("\t\tSdaiContext _context = SdaiSession.getSdaiContext();");
        pw.println("\t\tSdaiContext _context = this.findEntityInstanceSdaiModel().getRepository().getSession().getSdaiContext();");
        pw.println("\t\treturn get" + method_suffix + "((" + owning_entity_name + 
                   ")null, _context).getLogical();");
      } else {
        pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      }

      pw.println("\t}");

      pw.println("\tpublic void set" + method_suffix + "(" + owning_entity_name + 
                 " type, int value) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.AT_NVLD);");
      pw.println("\t}");
      pw.println("\tpublic void unset" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.AT_NVLD);");
      pw.println("\t}");


    } else if (st instanceof EBinary_type) {
// old
/*
      pw.println("\t/// methods for attribute: " + attr_name + ", base type: BINARY");
      pw.println("\tpublic boolean test" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      pw.println("\t}");
      pw.println("\tpublic Binary get" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      pw.println("\t}");
      pw.println("\tpublic void set" + method_suffix + "(" + owning_entity_name + 
                 " type, Binary value) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.AT_NVLD);");
      pw.println("\t}");
      pw.println("\tpublic void unset" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.AT_NVLD);");
      pw.println("\t}");
*/
// old end

      pw.println("\t// -9- methods for explicit redeclared as derived attribute: " + attr_name + ", base type: BINARY");
      pw.println("\tpublic boolean test" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      pw.println("\t}");
      pw.println("\tpublic Value get" + method_suffix + "(" + owning_entity_name + 
                 " type, SdaiContext _context) throws " + "SdaiException {");

      if (flag_expressions) {
//        generateJavaExpressionForDeriveMethods(pw, attr, sd, _ed, model);
        generateJavaExpressionForDeriveMethodsInc(pw, attr, sd, _ed, model);
      } else {
        pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      }

      pw.println("\t}");
      pw.println("\tpublic Binary get" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");

      if (flag_expressions) {
        //        pw.println("\t\t\tSdaiContext _context = this.findEntityInstanceSdaiModel().getRepository().getSession().getSdaiContext();");
//RR-SdaiContext-tmp
//        pw.println("\t\tSdaiContext _context = SdaiSession.getSdaiContext();");
        pw.println("\t\tSdaiContext _context = this.findEntityInstanceSdaiModel().getRepository().getSession().getSdaiContext();");
        pw.println("\t\treturn get" + method_suffix + "((" + owning_entity_name + 
                   ")null, _context).getBinary();");
      } else {
        pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      }

      pw.println("\t}");

      pw.println("\tpublic void set" + method_suffix + "(" + owning_entity_name + 
                 " type, Binary value) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.AT_NVLD);");
      pw.println("\t}");
      pw.println("\tpublic void unset" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.AT_NVLD);");
      pw.println("\t}");

    } else if (st instanceof EString_type) {
// old
/*
      pw.println("\t/// methods for attribute: " + attr_name + ", base type: STRING");
      pw.println("\tpublic boolean test" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      pw.println("\t}");
      pw.println("\tpublic String get" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      pw.println("\t}");
      pw.println("\tpublic void set" + method_suffix + "(" + owning_entity_name + 
                 " type, String value) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.AT_NVLD);");
      pw.println("\t}");
      pw.println("\tpublic void unset" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.AT_NVLD);");
      pw.println("\t}");
*/
// end old

      pw.println("\t// -10- methods for explicit redeclared as derived attribute: " + attr_name + ", base type: STRING");
      pw.println("\tpublic boolean test" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      pw.println("\t}");
      pw.println("\tpublic Value get" + method_suffix + "(" + owning_entity_name + 
                 " type, SdaiContext _context) throws " + "SdaiException {");

      if (flag_expressions) {

pw.println("\t\t// #X# - attr: " + attr + ", sd: " + sd + ", _ed: " + _ed + ", model: " + model);
pw.println("\t\t// #X# - redeclared_attr: " + redeclared_attr);

//        generateJavaExpressionForDeriveMethodsInc(pw, redeclared_attr, sd, _ed, model);
// originally this:
        generateJavaExpressionForDeriveMethodsInc(pw, attr, sd, _ed, model); 

//        generateJavaExpressionForDeriveMethodsInc(pw, redeclared_attr, sd, _ed, model); - explicit

	//        generateJavaExpressionForDeriveMethods(pw, attr, sd, _ed, model);
      } else {
        pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      }

      pw.println("\t}");
      pw.println("\tpublic String get" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");

      if (flag_expressions) {
//RR-SdaiContext-tmp
//        pw.println("\t\tSdaiContext _context = SdaiSession.getSdaiContext();");
        pw.println("\t\tSdaiContext _context = this.findEntityInstanceSdaiModel().getRepository().getSession().getSdaiContext();");
        pw.println("\t\treturn get" + method_suffix + "((" + owning_entity_name + 
                   ")null, _context).getString();");
      } else {
        pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      }

      pw.println("\t}");

      pw.println("\tpublic void set" + method_suffix + "(" + owning_entity_name + 
                 " type, String value) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.AT_NVLD);");
      pw.println("\t}");
      pw.println("\tpublic void unset" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.AT_NVLD);");
      pw.println("\t}");
    }
 
  }


  void generateLaterRedeclaredAttributeSimpleTypeMethods(ESimple_type st, PrintWriter pw, 
                                                         String entity_name, String attr_name, 
                                                         String method_suffix, 
                                                         String owning_entity_name, 
                                                         String attr_internal_name) {
    if (st instanceof EInteger_type) {
      pw.println("\t// -11- methods for explicit redeclared as derived attribute: " + attr_name + 
                 ", base type: INTEGER");
      pw.println("\tpublic boolean test" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      pw.println("\t}");
      pw.println("\tpublic int get" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
          pw.println("\t\t\t// FN_NAVL - 03");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      pw.println("\t}");
      pw.println("\tpublic void set" + method_suffix + "(" + owning_entity_name + 
                 " type, int value) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.AT_NVLD);");
      pw.println("\t}");
      pw.println("\tpublic void unset" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.AT_NVLD);");
      pw.println("\t}");
    } else if (st instanceof ENumber_type) {
      pw.println("\t/// methods for attribute: " + attr_name + ", base type: NUMBER");
      pw.println("\tpublic boolean test" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      pw.println("\t}");
      pw.println("\tpublic double get" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
          pw.println("\t\t\t// FN_NAVL - 04");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      pw.println("\t}");
      pw.println("\tpublic void set" + method_suffix + "(" + owning_entity_name + 
                 " type, double value) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.AT_NVLD);");
      pw.println("\t}");
      pw.println("\tpublic void unset" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.AT_NVLD);");
      pw.println("\t}");
    } else if (st instanceof EReal_type) {
      pw.println("\t/// methods for attribute: " + attr_name + ", base type: REAL");
      pw.println("\tpublic boolean test" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      pw.println("\t}");
      pw.println("\tpublic double get" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
          pw.println("\t\t\t// FN_NAVL - 05");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      pw.println("\t}");
      pw.println("\tpublic void set" + method_suffix + "(" + owning_entity_name + 
                 " type, double value) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.AT_NVLD);");
      pw.println("\t}");
      pw.println("\tpublic void unset" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.AT_NVLD);");
      pw.println("\t}");
    } else if (st instanceof EBoolean_type) {
      pw.println("\t/// methods for attribute: " + attr_name + ", base type: BOOLEAN");
      pw.println("\tpublic boolean test" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      pw.println("\t}");
      pw.println("\tpublic boolean get" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
          pw.println("\t\t\t// FN_NAVL - 06");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      pw.println("\t}");
      pw.println("\tpublic void set" + method_suffix + "(" + owning_entity_name + 
                 " type, boolean value) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.AT_NVLD);");
      pw.println("\t}");
      pw.println("\tpublic void unset" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.AT_NVLD);");
      pw.println("\t}");
    } else if (st instanceof ELogical_type) {
      pw.println("\t/// methods for attribute: " + attr_name + ", base type: LOGICAL");
      pw.println("\tpublic boolean test" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      pw.println("\t}");
      pw.println("\tpublic int get" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
          pw.println("\t\t\t// FN_NAVL - 07");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      pw.println("\t}");
      pw.println("\tpublic void set" + method_suffix + "(" + owning_entity_name + 
                 " type, int value) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.AT_NVLD);");
      pw.println("\t}");
      pw.println("\tpublic void unset" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.AT_NVLD);");
      pw.println("\t}");
    } else if (st instanceof EBinary_type) {
      pw.println("\t/// methods for attribute: " + attr_name + ", base type: BINARY");
      pw.println("\tpublic boolean test" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      pw.println("\t}");
      pw.println("\tpublic Binary get" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
          pw.println("\t\t\t// FN_NAVL - 08");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      pw.println("\t}");
      pw.println("\tpublic void set" + method_suffix + "(" + owning_entity_name + 
                 " type, Binary value) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.AT_NVLD);");
      pw.println("\t}");
      pw.println("\tpublic void unset" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.AT_NVLD);");
      pw.println("\t}");
    } else if (st instanceof EString_type) {
      pw.println("\t/// methods for attribute: " + attr_name + ", base type: STRING");
      pw.println("\tpublic boolean test" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      pw.println("\t}");
      pw.println("\tpublic String get" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
          pw.println("\t\t\t// FN_NAVL - 09");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      pw.println("\t}");
      pw.println("\tpublic void set" + method_suffix + "(" + owning_entity_name + 
                 " type, String value) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.AT_NVLD);");
      pw.println("\t}");
      pw.println("\tpublic void unset" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.AT_NVLD);");
      pw.println("\t}");
    }
  }

  void generateLaterRedeclaredAttributeDefinedTypeMethods(EDefined_type dt, PrintWriter pw, 
                                                          String entity_name, String attr_name, 
                                                          String method_suffix, 
                                                          String owning_entity_name, 
                                                          String attr_internal_name)
                                                   throws SdaiException {
    EEntity ut = dt.getDomain(null);

    if (ut instanceof ESimple_type) {
      generateLaterRedeclaredAttributeSimpleTypeMethods((ESimple_type) ut, pw, entity_name, 
                                                        attr_name, method_suffix, 
                                                        owning_entity_name, attr_internal_name);
    } else if (ut instanceof EAggregation_type) {
      generateLaterRedeclaredAttributeAggregationTypeMethods((EAggregation_type) ut, pw, 
                                                             entity_name, attr_name, method_suffix, 
                                                             owning_entity_name, attr_internal_name);
    } else if (ut instanceof EDefined_type) {
      generateLaterRedeclaredAttributeDefinedTypeMethods((EDefined_type) ut, pw, entity_name, 
                                                         attr_name, method_suffix, 
                                                         owning_entity_name, attr_internal_name);
    } else if (ut instanceof EEnumeration_type) {
//      A_string enelements = ((EEnumeration_type) ut).getElements(null);
//      A_string enelements = ((EEnumeration_type) ut).getLocal_elements(null);
//      A_string enelements = getElements((EEnumeration_type) ut);
      Vector enelements = getElementsV((EEnumeration_type) ut);


      //         generateEnumerationMethods((EEnumeration_type)ut, pw, entity_name, attr_name, method_suffix);
      pw.println("\t// attribute:" + attr_name + ", base type: ENUMERATION");
      pw.println("\tpublic boolean test" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      pw.println("\t}");
      pw.println("\tpublic int get" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
          pw.println("\t\t\t// FN_NAVL - 10");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      pw.println("\t}");
      pw.println("\tpublic void set" + method_suffix + "(" + owning_entity_name + 
                 " type, int value) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.AT_NVLD);");
      pw.println("\t}");
      pw.println("\tpublic void unset" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.AT_NVLD);");
      pw.println("\t}");
    } else if (ut instanceof ESelect_type) {
//      ANamed_type nt = ((ESelect_type) ut).getSelections(null);
//      ANamed_type nt = ((ESelect_type) ut).getLocal_selections(null);
      ANamed_type nt = getSelections((ESelect_type) ut);

      //         int select_type = calculateSelectPaths(nt); // 0 - pure entity, 1 - pure defined_type or 2 - mixed select
      SelectPaths paths1 = null;
      int select_type = Integer.MIN_VALUE;
      Object temp_object = ut.getTemp();

      if (temp_object instanceof SelectPaths) {
        if (((SelectPaths) temp_object).owner == (ESelect_type) ut) {
          paths1 = (SelectPaths) temp_object;
          select_type = paths1.select_type;
        }
      }

      if (paths1 == null) {
        int count = 1;
        int[] indeces = new int[500];
        int depth = 0;
        int depth_count = 0;
        boolean with_type = false;
        Vector current_nodes = new Vector();
        Vector current_node_strings = new Vector();
        paths1 = new SelectPaths();
        paths1.owner = (ESelect_type) ut;
        select_type = calculateSelectPaths(count, current_nodes, current_node_strings, indeces, 
                                           depth, depth_count, paths1, (ESelect_type) ut, with_type);
        paths1.removeIdentical();
        paths1.select_type = select_type;
        ut.setTemp(paths1);
      }

      pw.println("\t// -2- methods for explicit redeclared as derived SELECT attribute: " + 
                 attr_name);

      if (select_type == 0) { // only pure entity selects
        pw.println("\tpublic boolean test" + method_suffix + "(" + owning_entity_name + 
                   " type) throws SdaiException {");
        pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      } else {
        pw.println("\tpublic int test" + method_suffix + "(" + owning_entity_name + 
                   " type) throws SdaiException {");
        pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      }

      pw.println("\t}");
      pw.println("");
      paths1.generateGetLaterRedeclaredMethods((ESelect_type) ut, pw, entity_name, attr_name, 
                                               method_suffix, select_type, owning_entity_name, 
                                               attr_internal_name);
      pw.println("");
      paths1.generateSetLaterRedeclaredMethods((ESelect_type) ut, pw, entity_name, attr_name, 
                                               method_suffix, select_type, owning_entity_name, 
                                               attr_internal_name);
      pw.println("");
      pw.println("\tpublic void unset" + method_suffix + "(" + owning_entity_name + 
                 " type) throws SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.AT_NVLD);");
      pw.println("\t}");
      pw.println("");
    }
  }





  void generateLaterRedeclaredAttributeAggregationTypeMethods(EAggregation_type at, PrintWriter pw, 
                                                              String entity_name, String attr_name, 
                                                              String method_suffix, 
                                                              String owning_entity_name, 
                                                              String attr_internal_name)
    throws SdaiException {
    String comment = "";

    if (at instanceof EArray_type) {
      comment += "ARRAY OF ";
    } else if (at instanceof EBag_type) {
      comment += "BAG OF ";
    } else if (at instanceof ESet_type) {
      comment += "SET OF ";
    } else if (at instanceof EList_type) {
      comment += "LIST OF ";
    }

    int aggregate_depth = 1;
    EEntity an_ss;
    EEntity ass = at;
    String aggr_prefices = "";
    an_ss = at.getElement_type(null);

    for (;;) {
      boolean done_something = false;

      if (an_ss instanceof EDefined_type) {
        ass = an_ss;
        an_ss = ((EDefined_type) an_ss).getDomain(null);
        done_something = true;
      } else if (an_ss instanceof EAggregation_type) {
        aggr_prefices += "a";
        aggregate_depth++;
        ass = an_ss;

        if (ass instanceof EArray_type) {
          comment += "ARRAY OF ";
        } else if (ass instanceof EBag_type) {
          comment += "BAG OF ";
        } else if (ass instanceof ESet_type) {
          comment += "SET OF ";
        } else if (ass instanceof EList_type) {
          comment += "LIST OF ";
        }

        an_ss = ((EAggregation_type) an_ss).getElement_type(null);
        done_something = true;
      }

      if (!done_something) {
        break;
      }
    }

    String aggr_prefix = "A" + aggr_prefices;
    String aggr_nesting = "";

    if (aggregate_depth > 1) {
      aggr_nesting += aggregate_depth;
    }

    if (an_ss instanceof ESelect_type) {
      pw.println("\t// methods for attribute: " + attr_name + ", base type: " + comment + 
                 "SELECT");
      pw.println("\tpublic boolean test" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      pw.println("\t}");
      pw.println("\tpublic " + getAggregatePackage(aggr_prefix, ass) + " get" + method_suffix + 
                 "(" + owning_entity_name + " type) throws " + "SdaiException {");
          pw.println("\t\t\t// FN_NAVL - 11");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      pw.println("\t}");
      pw.println("\tpublic " + getAggregatePackage(aggr_prefix, ass) + " create" + method_suffix + 
                 "(" + owning_entity_name + " type) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.AT_NVLD);");
      pw.println("\t}");
      pw.println("\tpublic void unset" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.AT_NVLD);");
      pw.println("\t}");
    } else if (an_ss instanceof EEntity_definition) {
      String base_entity_name = ((EEntity_definition) an_ss).getName(null);
      String base_name = getEntityPackage((EEntity_definition) an_ss) + "E" + 
                         base_entity_name.substring(0, 1).toUpperCase() + 
                         base_entity_name.substring(1).toLowerCase();
      pw.println("\t// methods for attribute: " + attr_name + ", base type: " + comment + 
                 "ENTITY");
      pw.println("\tpublic boolean test" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      pw.println("\t}");
      pw.println("\tpublic " + getAggregatePackage(aggr_prefix, an_ss) + " get" + method_suffix + 
                 "(" + owning_entity_name + " type) throws " + "SdaiException {");
          pw.println("\t\t\t// FN_NAVL - 12");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      pw.println("\t}");
      pw.println("\tpublic " + getAggregatePackage(aggr_prefix, an_ss) + " create" + 
                 method_suffix + "(" + owning_entity_name + " type) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.AT_NVLD);");
      pw.println("\t}");
      pw.println("\tpublic void unset" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.AT_NVLD);");
      pw.println("\t}");
    } else if (an_ss instanceof EEnumeration_type) {
      pw.println("\t// methods for attribute: " + attr_name + ", base type: " + comment + 
                 "ENUMERATION");
      pw.println("\tpublic boolean test" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      pw.println("\t}");
      pw.println("\tpublic " + aggr_prefix + "_enumeration get" + method_suffix + "(" + 
                 owning_entity_name + " type) throws " + "SdaiException {");
          pw.println("\t\t\t// FN_NAVL - 13");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      pw.println("\t}");
      pw.println("\tpublic " + aggr_prefix + "_enumeration create" + method_suffix + "(" + 
                 owning_entity_name + " type) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.AT_NVLD);");
      pw.println("\t}");
      pw.println("\tpublic void unset" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.AT_NVLD);");
      pw.println("\t}");
    } else if (an_ss instanceof EInteger_type) {
      pw.println("\t// methods for attribute: " + attr_name + ", base type: " + comment + 
                 "INTEGER");
      pw.println("\tpublic boolean test" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      pw.println("\t}");
      pw.println("\tpublic " + aggr_prefix + "_integer get" + method_suffix + "(" + 
                 owning_entity_name + " type) throws " + "SdaiException {");
          pw.println("\t\t\t// FN_NAVL - 14");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      pw.println("\t}");
      pw.println("\tpublic " + aggr_prefix + "_integer create" + method_suffix + "(" + 
                 owning_entity_name + " type) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.AT_NVLD);");
      pw.println("\t}");
      pw.println("\tpublic void unset" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.AT_NVLD);");
      pw.println("\t}");
    } else if (an_ss instanceof ENumber_type) {
      pw.println("\t// methods for attribute: " + attr_name + ", base type: " + comment + 
                 "NUMBER");
      pw.println("\tpublic boolean test" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      pw.println("\t}");
      pw.println("\tpublic " + aggr_prefix + "_double get" + method_suffix + "(" + 
                 owning_entity_name + " type) throws " + "SdaiException {");
          pw.println("\t\t\t// FN_NAVL - 15");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      pw.println("\t}");
      pw.println("\tpublic " + aggr_prefix + "_double create" + method_suffix + "(" + 
                 owning_entity_name + " type) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.AT_NVLD);");
      pw.println("\t}");
      pw.println("\tpublic void unset" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.AT_NVLD);");
      pw.println("\t}");
    } else if (an_ss instanceof EReal_type) {
      pw.println("\t// methods for attribute: " + attr_name + ", base type: " + comment + "REAL");
      pw.println("\tpublic boolean test" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      pw.println("\t}");
      pw.println("\tpublic " + aggr_prefix + "_double get" + method_suffix + "(" + 
                 owning_entity_name + " type) throws " + "SdaiException {");
          pw.println("\t\t\t// FN_NAVL - 16");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      pw.println("\t}");
      pw.println("\tpublic " + aggr_prefix + "_double create" + method_suffix + "(" + 
                 owning_entity_name + " type) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.AT_NVLD);");
      pw.println("\t}");
      pw.println("\tpublic void unset" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.AT_NVLD);");
      pw.println("\t}");
    } else if (an_ss instanceof EString_type) {
      pw.println("\t// methods for attribute: " + attr_name + ", base type: " + comment + 
                 "STRING");
      pw.println("\tpublic boolean test" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      pw.println("\t}");
      pw.println("\tpublic " + aggr_prefix + "_string get" + method_suffix + "(" + 
                 owning_entity_name + " type) throws " + "SdaiException {");
          pw.println("\t\t\t// FN_NAVL - 17");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      pw.println("\t}");
      pw.println("\tpublic " + aggr_prefix + "_string create" + method_suffix + "(" + 
                 owning_entity_name + " type) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.AT_NVLD);");
      pw.println("\t}");
      pw.println("\tpublic void unset" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.AT_NVLD);");
      pw.println("\t}");
    } else if (an_ss instanceof ELogical_type) {
      pw.println("\t// methods for attribute: " + attr_name + ", base type: " + comment + 
                 "LOGICAL");
      pw.println("\tpublic boolean test" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      pw.println("\t}");
      pw.println("\tpublic " + aggr_prefix + "_enumeration get" + method_suffix + "(" + 
                 owning_entity_name + " type) throws " + "SdaiException {");
          pw.println("\t\t\t// FN_NAVL - 18");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      pw.println("\t}");
      pw.println("\tpublic " + aggr_prefix + "_enumeration create" + method_suffix + "(" + 
                 owning_entity_name + " type) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.AT_NVLD);");
      pw.println("\t}");
      pw.println("\tpublic void unset" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.AT_NVLD);");
      pw.println("\t}");
    } else if (an_ss instanceof EBoolean_type) {
      pw.println("\t// methods for attribute: " + attr_name + ", base type: " + comment + 
                 "BOOLEAN");
      pw.println("\tpublic boolean test" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      pw.println("\t}");
      pw.println("\tpublic " + aggr_prefix + "_boolean get" + method_suffix + "(" + 
                 owning_entity_name + " type) throws " + "SdaiException {");
          pw.println("\t\t\t// FN_NAVL - 19");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      pw.println("\t}");
      pw.println("\tpublic " + aggr_prefix + "_boolean create" + method_suffix + "(" + 
                 owning_entity_name + " type) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.AT_NVLD);");
      pw.println("\t}");
      pw.println("\tpublic void unset" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.AT_NVLD);");
      pw.println("\t}");
    } else if (an_ss instanceof EBinary_type) {
      pw.println("\t// methods for attribute: " + attr_name + ", base type: " + comment + 
                 "BINARY");
      pw.println("\tpublic boolean test" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      pw.println("\t}");
      pw.println("\tpublic " + aggr_prefix + "_binary get" + method_suffix + "(" + 
                 owning_entity_name + " type) throws " + "SdaiException {");
          pw.println("\t\t\t// FN_NAVL - 20");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      pw.println("\t}");
      pw.println("\tpublic " + aggr_prefix + "_binary create" + method_suffix + "(" + 
                 owning_entity_name + " type) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.AT_NVLD);");
      pw.println("\t}");
      pw.println("\tpublic void unset" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.AT_NVLD);");
      pw.println("\t}");
    }
  }



//


  void generateJavaExplicit2DerivedAttributeAggregationTypeMethods(EAttribute attr, EAttribute redeclared_attr, EAggregation_type at, 
                                                      PrintWriter pw, String entity_name, 
                                                      String attr_name, String method_suffix, 
                                                      String owning_entity_name, 
                                                      String attr_internal_name, 
                                                      A_string expression_java)
                                               throws SdaiException {
    String comment = "";

    if (at instanceof EArray_type) {
      comment += "ARRAY OF ";
    } else if (at instanceof EBag_type) {
      comment += "BAG OF ";
    } else if (at instanceof ESet_type) {
      comment += "SET OF ";
    } else if (at instanceof EList_type) {
      comment += "LIST OF ";
    }

    int aggregate_depth = 1;
    EEntity an_ss;
    EEntity ass = at;
    String aggr_prefices = "";
    an_ss = at.getElement_type(null);

    // here we need implement additional methods generation for aggregate run-time bounds evaluation
    for (;;) {
      boolean done_something = false;

      if (an_ss instanceof EDefined_type) {
        ass = an_ss;
        an_ss = ((EDefined_type) an_ss).getDomain(null);
        done_something = true;
      } else if (an_ss instanceof EAggregation_type) {
        aggr_prefices += "a";
        aggregate_depth++;
        ass = an_ss;

        if (ass instanceof EArray_type) {
          comment += "ARRAY OF ";
        } else if (ass instanceof EBag_type) {
          comment += "BAG OF ";
        } else if (ass instanceof ESet_type) {
          comment += "SET OF ";
        } else if (ass instanceof EList_type) {
          comment += "LIST OF ";
        }

        an_ss = ((EAggregation_type) an_ss).getElement_type(null);
        done_something = true;
      }

      if (!done_something) {
        break;
      }
    }

    String aggr_prefix = "A" + aggr_prefices;
    String aggr_nesting = "";

    if (aggregate_depth > 1) {
      aggr_nesting += aggregate_depth;
    }

    //zolia: unclear occurace of this type in express, so lets leave it unchanged for a while
    if (an_ss instanceof ESelect_type) {
      SelectPaths paths1 = null;
      int select_type = Integer.MIN_VALUE;
      Object temp_object = an_ss.getTemp();

      if (temp_object instanceof SelectPaths) {
        if (((SelectPaths) temp_object).owner == (ESelect_type) an_ss) {
          paths1 = (SelectPaths) temp_object;
          select_type = paths1.select_type;
        }
      }

      if (paths1 == null) {
        int count = 1;
        int[] indeces = new int[500];
        int depth = 0;
        int depth_count = 0;
        boolean with_type = false;
        Vector current_nodes = new Vector();
        Vector current_node_strings = new Vector();
        paths1 = new SelectPaths();
        paths1.owner = (ESelect_type) an_ss;
        select_type = calculateSelectPaths(count, current_nodes, current_node_strings, indeces, 
                                           depth, depth_count, paths1, (ESelect_type) an_ss, 
                                           with_type);
        paths1.removeIdentical();
        paths1.select_type = select_type;
        an_ss.setTemp(paths1);
      }



      pw.println("\t// -12- methods for explicit redeclared as derived attribute: " + attr_name + ", base type: " + comment + 
                 "SELECT");
      pw.println("\tpublic boolean test" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      pw.println("\t}");

      
      // old code ------------------
/*	
      pw.println("\tpublic " + getAggregatePackage(aggr_prefix, ass) + " get" + method_suffix + 
                 "(" + owning_entity_name + " type) throws " + "SdaiException {");

      //            if ((flag_expressions) & (expression_java != null)) {
      if (flag_expressions) {
        pw.println("\t\t\treturn (" + getAggregatePackage(aggr_prefix, ass) + ") (");

        generateJavaExpression(pw, attr, sd, _ed, model);
        pw.println("\t\t\t);");
      } else {
        pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      }

      pw.println("\t}");
      
*/
      // old code -end ----------------------

			// ass or an_ss ?
      pw.println("\tpublic " + getAggregatePackage(aggr_prefix, ass) + " get" + method_suffix + 
                 "(" + owning_entity_name + " type) throws " + "SdaiException {");

      if (flag_expressions) {
        pw.println("\t\tSdaiContext _context = this.findEntityInstanceSdaiModel().getRepository().getSession().getSdaiContext();");
				
// is it getInstanceAggregate(this) or what? perhaps depends on the select - mixed or pure entity


      if (select_type != 0) { // includes defined_types

        pw.println("\t\t\treturn (" + getAggregatePackage(aggr_prefix, ass) + ") get" + 
									 method_suffix + "((" + owning_entity_name + 
                   ")null, _context).getMixedAggregate(this);");
      } else {
        pw.println("\t\t\treturn (" + getAggregatePackage(aggr_prefix, ass) + ") get" + 
									 method_suffix + "((" + owning_entity_name + 
                   ")null, _context).getInstanceAggregate(this);");
      }
      
      } else {
        pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      }

      pw.println("\t}");
      generateDeriveAttrValueGetMethodX(method_suffix, owning_entity_name, pw, attr, sd, _ed, model);


      pw.println("\tpublic " + getAggregatePackage(aggr_prefix, ass) + " create" + method_suffix + 
                 "(" + owning_entity_name + " type) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.AT_NVLD);");
      pw.println("\t}");
      pw.println("\tpublic void unset" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.AT_NVLD);");
      pw.println("\t}");

      
    } else if (an_ss instanceof EEntity_definition) {
      String base_entity_name = ((EEntity_definition) an_ss).getName(null);
//       String base_name = getEntityPackage((EEntity_definition) an_ss) + "E" + 
//                          base_entity_name.substring(0, 1).toUpperCase() + 
//                          base_entity_name.substring(1).toLowerCase();
      pw.println("\t// derived attribute: " + attr_name + ", base type: entity " + 
                 base_entity_name);
      pw.println("\tpublic boolean test" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      pw.println("\t}");

      pw.println("\tpublic " + getAggregatePackage(aggr_prefix, an_ss) + " get" + method_suffix + 
                 "(" + owning_entity_name + " type) throws " + "SdaiException {");

      //               if ((flag_expressions) & (expression_java != null)) {
      if (flag_expressions) {
//RR-SdaiContext-tmp      	
//        pw.println("\t\tSdaiContext _context = SdaiSession.getSdaiContext();");
        pw.println("\t\tSdaiContext _context = this.findEntityInstanceSdaiModel().getRepository().getSession().getSdaiContext();");
				
        pw.println("\t\t\treturn (" + getAggregatePackage(aggr_prefix, an_ss) + ") get" + 
									 method_suffix + "((" + owning_entity_name + 
                   ")null, _context).getInstanceAggregate(this);");
      } else {
        pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      }

      pw.println("\t}");
      generateDeriveAttrValueGetMethod(method_suffix, owning_entity_name, pw, attr, sd, _ed, model);
    
      pw.println("\tpublic " + getAggregatePackage(aggr_prefix, an_ss) + " create" + 
                 method_suffix + "(" + owning_entity_name + " type) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.AT_NVLD);");
      pw.println("\t}");
      pw.println("\tpublic void unset" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.AT_NVLD);");
      pw.println("\t}");
    
    
    } else if (an_ss instanceof EEnumeration_type) {
      pw.println("\t// methods for attribute: " + attr_name + ", base type: " + comment + 
                 "ENUMERATION");
      pw.println("\tpublic boolean test" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      pw.println("\t}");

			// old code
			/*
      pw.println("\tpublic " + aggr_prefix + "_enumeration get" + method_suffix + "(" + 
                 owning_entity_name + " type) throws " + "SdaiException {");

      //            if ((flag_expressions) & (expression_java != null)) {
      if (flag_expressions) {
        generateJavaExpression(pw, attr, sd, _ed, model);
      } else {
        pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      }

      pw.println("\t}");
			*/
			
      pw.println("\tpublic " + aggr_prefix + "_enumeration get" + method_suffix + "(" + 
                 owning_entity_name + " type) throws " + "SdaiException {");

      if (flag_expressions) {
        pw.println("\t\tSdaiContext _context = this.findEntityInstanceSdaiModel().getRepository().getSession().getSdaiContext();");

        if (aggregate_depth > 1) {
          pw.println("\t\t\treturn get" + method_suffix + "((" + owning_entity_name + 
                     ")null, _context).getEnumeration" + aggregate_depth + "Aggregate(this);");
        } else {
          pw.println("\t\t\treturn get" + method_suffix + "((" + owning_entity_name + 
                     ")null, _context).getEnumerationAggregate(this);");
        }
      } else {
        pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      }

      pw.println("\t}");
      generateDeriveAttrValueGetMethod(method_suffix, owning_entity_name, pw, attr, sd, _ed, model);

      pw.println("\tpublic " + aggr_prefix + "_enumeration create" + method_suffix + "(" + 
                 owning_entity_name + " type) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.AT_NVLD);");
      pw.println("\t}");
      pw.println("\tpublic void unset" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.AT_NVLD);");
      pw.println("\t}");


    } else if (an_ss instanceof EInteger_type) {
      pw.println("\t// methods for attribute: " + attr_name + ", base type: " + comment + 
                 "INTEGER");
      pw.println("\tpublic boolean test" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      pw.println("\t}");

      pw.println("\tpublic " + aggr_prefix + "_integer get" + method_suffix + "(" + 
                 owning_entity_name + " type) throws " + "SdaiException {");

      if (flag_expressions) {
        //        pw.println("\t\t\tSdaiContext _context = this.findEntityInstanceSdaiModel().getRepository().getSession().getSdaiContext();");
//RR-SdaiContext-tmp
//        pw.println("\t\tSdaiContext _context = SdaiSession.getSdaiContext();");
        pw.println("\t\tSdaiContext _context = this.findEntityInstanceSdaiModel().getRepository().getSession().getSdaiContext();");

        if (aggregate_depth > 1) {
          pw.println("\t\t\treturn get" + method_suffix + "((" + owning_entity_name + 
                     ")null, _context).getInteger" + aggregate_depth + "Aggregate(this);");
        } else {
          pw.println("\t\t\treturn get" + method_suffix + "((" + owning_entity_name + 
                     ")null, _context).getIntegerAggregate(this);");
        }
      } else {
        pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      }

      pw.println("\t}");
      generateDeriveAttrValueGetMethod(method_suffix, owning_entity_name, pw, attr, sd, _ed, model);

      pw.println("\tpublic " + aggr_prefix + "_integer create" + method_suffix + "(" + 
                 owning_entity_name + " type) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.AT_NVLD);");
      pw.println("\t}");
      pw.println("\tpublic void unset" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.AT_NVLD);");
      pw.println("\t}");

    } else if (an_ss instanceof ENumber_type) {
      pw.println("\t// methods for attribute: " + attr_name + ", base type: " + comment + 
                 "NUMBER");
      pw.println("\tpublic boolean test" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      pw.println("\t}");
      pw.println("\tpublic " + aggr_prefix + "_double get" + method_suffix + "(" + 
                 owning_entity_name + " type) throws " + "SdaiException {");

      //            if ((flag_expressions) & (expression_java != null)) {
      if (flag_expressions) {
        //					pw.println("\t\tSdaiContext _context = this.findEntityInstanceSdaiModel().getRepository().getSession().getSdaiContext();");
//RR-SdaiContext-tmp
//        pw.println("\t\tSdaiContext _context = SdaiSession.getSdaiContext();");
        pw.println("\t\tSdaiContext _context = this.findEntityInstanceSdaiModel().getRepository().getSession().getSdaiContext();");

        if (aggregate_depth > 1) {
          pw.println("\t\treturn get" + method_suffix + "((" + owning_entity_name + 
                     ")null, _context).getDouble" + aggregate_depth + "Aggregate(this);");
        } else {
          pw.println("\t\treturn get" + method_suffix + "((" + owning_entity_name + 
                     ")null, _context).getDoubleAggregate(this);");
        }

        //					pw.println("\t\treturn get" +method_suffix +"(null, _context).getDoubleAggregate(this);" );
      } else {
        pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      }

      pw.println("\t}");
      generateDeriveAttrValueGetMethod(method_suffix, owning_entity_name, pw, attr, sd, _ed, model);

      pw.println("\tpublic " + aggr_prefix + "_double create" + method_suffix + "(" + 
                 owning_entity_name + " type) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.AT_NVLD);");
      pw.println("\t}");
      pw.println("\tpublic void unset" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.AT_NVLD);");
      pw.println("\t}");

    } else if (an_ss instanceof EReal_type) {
      pw.println("\t// methods for attribute: " + attr_name + ", base type: " + comment + "REAL");
      pw.println("\tpublic boolean test" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      pw.println("\t}");


      // double get method
      pw.println("\tpublic " + aggr_prefix + "_double get" + method_suffix + "(" + 
                 owning_entity_name + " type) throws " + "SdaiException {");

      //            if ((flag_expressions) & (expression_java != null)) {
      if (flag_expressions) {
        //					pw.println("\t\tSdaiContext _context = this.findEntityInstanceSdaiModel().getRepository().getSession().getSdaiContext();");
//RR-SdaiContext-tmp
//        pw.println("\t\tSdaiContext _context = SdaiSession.getSdaiContext();");
        pw.println("\t\tSdaiContext _context = this.findEntityInstanceSdaiModel().getRepository().getSession().getSdaiContext();");

        if (aggregate_depth > 1) {
          pw.println("\t\treturn get" + method_suffix + "((" + owning_entity_name + 
                     ")null, _context).getDouble" + aggregate_depth + "Aggregate(this);");
        } else {
          pw.println("\t\treturn get" + method_suffix + "((" + owning_entity_name + 
                     ")null, _context).getDoubleAggregate(this);");
        }
      } else {
        pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      }

      pw.println("\t}");
      generateDeriveAttrValueGetMethod(method_suffix, owning_entity_name, pw, attr, sd, _ed, model);

      pw.println("\tpublic " + aggr_prefix + "_double create" + method_suffix + "(" + 
                 owning_entity_name + " type) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.AT_NVLD);");
      pw.println("\t}");
      pw.println("\tpublic void unset" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.AT_NVLD);");
      pw.println("\t}");

    } else if (an_ss instanceof EString_type) {
      pw.println("\t// methods for attribute: " + attr_name + ", base type: " + comment + 
                 "STRING");
      pw.println("\tpublic boolean test" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      pw.println("\t}");
      pw.println("\tpublic " + aggr_prefix + "_string get" + method_suffix + "(" + 
                 owning_entity_name + " type) throws " + "SdaiException {");

      //            if ((flag_expressions) & (expression_java != null)) {
      if (flag_expressions) {
//RR-SdaiContext-tmp
//        pw.println("\t\tSdaiContext _context = SdaiSession.getSdaiContext();");
        pw.println("\t\tSdaiContext _context = this.findEntityInstanceSdaiModel().getRepository().getSession().getSdaiContext();");

        if (aggregate_depth > 1) {
          pw.println("\t\treturn get" + method_suffix + "((" + owning_entity_name + 
                     ")null, _context).getString" + aggregate_depth + "Aggregate(this);");
        } else {
          pw.println("\t\treturn get" + method_suffix + "((" + owning_entity_name + 
                     ")null, _context).getStringAggregate(this);");
        }
      } else {
        pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      }

      pw.println("\t}");
      generateDeriveAttrValueGetMethod(method_suffix, owning_entity_name, pw, attr, sd, _ed, model);

      pw.println("\tpublic " + aggr_prefix + "_string create" + method_suffix + "(" + 
                 owning_entity_name + " type) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.AT_NVLD);");
      pw.println("\t}");
      pw.println("\tpublic void unset" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.AT_NVLD);");
      pw.println("\t}");

    } else if (an_ss instanceof ELogical_type) {
      pw.println("\t// methods for attribute: " + attr_name + ", base type: " + comment + 
                 "LOGICAL");
      pw.println("\tpublic boolean test" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      pw.println("\t}");
      pw.println("\tpublic " + aggr_prefix + "_enumeration get" + method_suffix + "(" + 
                 owning_entity_name + " type) throws " + "SdaiException {");

      //            if ((flag_expressions) & (expression_java != null)) {
      if (flag_expressions) {
        if (aggregate_depth > 1) {
//RR-SdaiContext-tmp
//          pw.println("\t\tSdaiContext _context = SdaiSession.getSdaiContext();");
          pw.println("\t\tSdaiContext _context = this.findEntityInstanceSdaiModel().getRepository().getSession().getSdaiContext();");
          pw.println("\t\treturn get" + method_suffix + "((" + owning_entity_name + 
                     ")null, _context).getLogical" + aggregate_depth + "Aggregate(this);");
        } else {
          pw.println("\t\treturn get" + method_suffix + "((" + owning_entity_name + 
                     ")null, _context).getLogicalAggregate(this);");
        }
      } else {
        pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      }

      pw.println("\t}");
      generateDeriveAttrValueGetMethod(method_suffix, owning_entity_name, pw, attr, sd, _ed, model);

      pw.println("\tpublic " + aggr_prefix + "_enumeration create" + method_suffix + "(" + 
                 owning_entity_name + " type) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.AT_NVLD);");
      pw.println("\t}");
      pw.println("\tpublic void unset" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.AT_NVLD);");
      pw.println("\t}");

    } else if (an_ss instanceof EBoolean_type) {
      pw.println("\t// methods for attribute: " + attr_name + ", base type: " + comment + 
                 "BOOLEAN");
      pw.println("\tpublic boolean test" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      pw.println("\t}");
      pw.println("\tpublic " + aggr_prefix + "_boolean get" + method_suffix + "(" + 
                 owning_entity_name + " type) throws " + "SdaiException {");

      //            if ((flag_expressions) & (expression_java != null)) {
      if (flag_expressions) {
//RR-SdaiContext-tmp
//        pw.println("\t\tSdaiContext _context = SdaiSession.getSdaiContext();");
        pw.println("\t\tSdaiContext _context = this.findEntityInstanceSdaiModel().getRepository().getSession().getSdaiContext();");

        if (aggregate_depth > 1) {
          pw.println("\t\treturn get" + method_suffix + "((" + owning_entity_name + 
                     ")null, _context).getBoolean" + aggregate_depth + "Aggregate(this);");
        } else {
          pw.println("\t\treturn get" + method_suffix + "((" + owning_entity_name + 
                     ")null, _context).getBooleanAggregate(this);");
        }
      } else {
        pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      }

      pw.println("\t}");
      generateDeriveAttrValueGetMethod(method_suffix, owning_entity_name, pw, attr, sd, _ed, model);

      pw.println("\tpublic " + aggr_prefix + "_boolean create" + method_suffix + "(" + 
                 owning_entity_name + " type) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.AT_NVLD);");
      pw.println("\t}");
      pw.println("\tpublic void unset" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.AT_NVLD);");
      pw.println("\t}");

    } else if (an_ss instanceof EBinary_type) {
      pw.println("\t// methods for attribute: " + attr_name + ", base type: " + comment + 
                 "BINARY");
      pw.println("\tpublic boolean test" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      pw.println("\t}");
      pw.println("\tpublic " + aggr_prefix + "_binary get" + method_suffix + "(" + 
                 owning_entity_name + " type) throws " + "SdaiException {");

      //            if ((flag_expressions) & (expression_java != null)) {
      if (flag_expressions) {
//RR-SdaiContext-tmp
//        pw.println("\t\tSdaiContext _context = SdaiSession.getSdaiContext();");
        pw.println("\t\tSdaiContext _context = this.findEntityInstanceSdaiModel().getRepository().getSession().getSdaiContext();");

        if (aggregate_depth > 1) {
          // not really implemented in Value class!
          pw.println("\t\treturn get" + method_suffix + "((" + owning_entity_name + 
                     ")null, _context).getBinary" + aggregate_depth + "Aggregate(this);");
        } else {
          pw.println("\t\treturn get" + method_suffix + "((" + owning_entity_name + 
                     ")null, _context).getBinaryAggregate(this);");
        }
      } else {
        pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      }

      pw.println("\t}");
      generateDeriveAttrValueGetMethod(method_suffix, owning_entity_name, pw, attr, sd, _ed, model);

      pw.println("\tpublic " + aggr_prefix + "_binary create" + method_suffix + "(" + 
                 owning_entity_name + " type) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.AT_NVLD);");
      pw.println("\t}");
      pw.println("\tpublic void unset" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.AT_NVLD);");
      pw.println("\t}");

    }
  }



  void generateDerivedAttributeAggregationTypeMethods(EAttribute attr, EAggregation_type at, 
                                                      PrintWriter pw, String entity_name, 
                                                      String attr_name, String method_suffix, 
                                                      String owning_entity_name, 
                                                      String attr_internal_name, 
                                                      A_string expression_java)
                                               throws SdaiException {
    String comment = "";

    if (at instanceof EArray_type) {
      comment += "ARRAY OF ";
    } else if (at instanceof EBag_type) {
      comment += "BAG OF ";
    } else if (at instanceof ESet_type) {
      comment += "SET OF ";
    } else if (at instanceof EList_type) {
      comment += "LIST OF ";
    }

    int aggregate_depth = 1;
    EEntity an_ss;
    EEntity ass = at;
    String aggr_prefices = "";
    an_ss = at.getElement_type(null);

    // here we need implement additional methods generation for aggregate run-time bounds evaluation
    for (;;) {
      boolean done_something = false;

      if (an_ss instanceof EDefined_type) {
        ass = an_ss;
        an_ss = ((EDefined_type) an_ss).getDomain(null);
        done_something = true;
      } else if (an_ss instanceof EAggregation_type) {
        aggr_prefices += "a";
        aggregate_depth++;
        ass = an_ss;

        if (ass instanceof EArray_type) {
          comment += "ARRAY OF ";
        } else if (ass instanceof EBag_type) {
          comment += "BAG OF ";
        } else if (ass instanceof ESet_type) {
          comment += "SET OF ";
        } else if (ass instanceof EList_type) {
          comment += "LIST OF ";
        }

        an_ss = ((EAggregation_type) an_ss).getElement_type(null);
        done_something = true;
      }

      if (!done_something) {
        break;
      }
    }

    String aggr_prefix = "A" + aggr_prefices;
    String aggr_nesting = "";

    if (aggregate_depth > 1) {
      aggr_nesting += aggregate_depth;
    }

    //zolia: unclear occurace of this type in express, so lets leave it unchanged for a while
    if (an_ss instanceof ESelect_type) {
      SelectPaths paths1 = null;
      int select_type = Integer.MIN_VALUE;
      Object temp_object = an_ss.getTemp();

      if (temp_object instanceof SelectPaths) {
        if (((SelectPaths) temp_object).owner == (ESelect_type) an_ss) {
          paths1 = (SelectPaths) temp_object;
          select_type = paths1.select_type;
        }
      }

      if (paths1 == null) {
        int count = 1;
        int[] indeces = new int[500];
        int depth = 0;
        int depth_count = 0;
        boolean with_type = false;
        Vector current_nodes = new Vector();
        Vector current_node_strings = new Vector();
        paths1 = new SelectPaths();
        paths1.owner = (ESelect_type) an_ss;
        select_type = calculateSelectPaths(count, current_nodes, current_node_strings, indeces, 
                                           depth, depth_count, paths1, (ESelect_type) an_ss, 
                                           with_type);
        paths1.removeIdentical();
        paths1.select_type = select_type;
        an_ss.setTemp(paths1);
      }



      pw.println("\t// methods for attribute: " + attr_name + ", base type: " + comment + 
                 "SELECT");
      pw.println("\tpublic boolean test" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      pw.println("\t}");

      
      // old code ------------------
/*	
      pw.println("\tpublic " + getAggregatePackage(aggr_prefix, ass) + " get" + method_suffix + 
                 "(" + owning_entity_name + " type) throws " + "SdaiException {");

      //            if ((flag_expressions) & (expression_java != null)) {
      if (flag_expressions) {
        pw.println("\t\t\treturn (" + getAggregatePackage(aggr_prefix, ass) + ") (");

        generateJavaExpression(pw, attr, sd, _ed, model);
        pw.println("\t\t\t);");
      } else {
        pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      }

      pw.println("\t}");
      
*/
      // old code -end ----------------------

			// ass or an_ss ?
      pw.println("\tpublic " + getAggregatePackage(aggr_prefix, ass) + " get" + method_suffix + 
                 "(" + owning_entity_name + " type) throws " + "SdaiException {");

      if (flag_expressions) {
        pw.println("\t\tSdaiContext _context = this.findEntityInstanceSdaiModel().getRepository().getSession().getSdaiContext();");
				
// is it getInstanceAggregate(this) or what? perhaps depends on the select - mixed or pure entity


      if (select_type != 0) { // includes defined_types

        pw.println("\t\t\treturn (" + getAggregatePackage(aggr_prefix, ass) + ") get" + 
									 method_suffix + "((" + owning_entity_name + 
                   ")null, _context).getMixedAggregate(this);");
      } else {
        pw.println("\t\t\treturn (" + getAggregatePackage(aggr_prefix, ass) + ") get" + 
									 method_suffix + "((" + owning_entity_name + 
                   ")null, _context).getInstanceAggregate(this);");
      }
      
      } else {
        pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      }

      pw.println("\t}");
      generateDeriveAttrValueGetMethod(method_suffix, owning_entity_name, pw, attr, sd, _ed, model);



      
    } else if (an_ss instanceof EEntity_definition) {
      String base_entity_name = ((EEntity_definition) an_ss).getName(null);
//       String base_name = getEntityPackage((EEntity_definition) an_ss) + "E" + 
//                          base_entity_name.substring(0, 1).toUpperCase() + 
//                          base_entity_name.substring(1).toLowerCase();
      pw.println("\t// derived attribute: " + attr_name + ", base type: entity " + 
                 base_entity_name);
      pw.println("\tpublic boolean test" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      pw.println("\t}");

      pw.println("\tpublic " + getAggregatePackage(aggr_prefix, an_ss) + " get" + method_suffix + 
                 "(" + owning_entity_name + " type) throws " + "SdaiException {");

      //               if ((flag_expressions) & (expression_java != null)) {
      if (flag_expressions) {
//RR-SdaiContext-tmp      	
//        pw.println("\t\tSdaiContext _context = SdaiSession.getSdaiContext();");
        pw.println("\t\tSdaiContext _context = this.findEntityInstanceSdaiModel().getRepository().getSession().getSdaiContext();");
				
        pw.println("\t\t\treturn (" + getAggregatePackage(aggr_prefix, an_ss) + ") get" + 
									 method_suffix + "((" + owning_entity_name + 
                   ")null, _context).getInstanceAggregate(this);");
      } else {
        pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      }

      pw.println("\t}");
      generateDeriveAttrValueGetMethod(method_suffix, owning_entity_name, pw, attr, sd, _ed, model);
    } else if (an_ss instanceof EEnumeration_type) {
      pw.println("\t// methods for attribute: " + attr_name + ", base type: " + comment + 
                 "ENUMERATION");
      pw.println("\tpublic boolean test" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      pw.println("\t}");

			// old code
			/*
      pw.println("\tpublic " + aggr_prefix + "_enumeration get" + method_suffix + "(" + 
                 owning_entity_name + " type) throws " + "SdaiException {");

      //            if ((flag_expressions) & (expression_java != null)) {
      if (flag_expressions) {
        generateJavaExpression(pw, attr, sd, _ed, model);
      } else {
        pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      }

      pw.println("\t}");
			*/
			
      pw.println("\tpublic " + aggr_prefix + "_enumeration get" + method_suffix + "(" + 
                 owning_entity_name + " type) throws " + "SdaiException {");

      if (flag_expressions) {
        pw.println("\t\tSdaiContext _context = this.findEntityInstanceSdaiModel().getRepository().getSession().getSdaiContext();");

        if (aggregate_depth > 1) {
          pw.println("\t\t\treturn get" + method_suffix + "((" + owning_entity_name + 
                     ")null, _context).getEnumeration" + aggregate_depth + "Aggregate(this);");
        } else {
          pw.println("\t\t\treturn get" + method_suffix + "((" + owning_entity_name + 
                     ")null, _context).getEnumerationAggregate(this);");
        }
      } else {
        pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      }

      pw.println("\t}");
      generateDeriveAttrValueGetMethod(method_suffix, owning_entity_name, pw, attr, sd, _ed, model);


    } else if (an_ss instanceof EInteger_type) {
      pw.println("\t// methods for attribute: " + attr_name + ", base type: " + comment + 
                 "INTEGER");
      pw.println("\tpublic boolean test" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      pw.println("\t}");

      pw.println("\tpublic " + aggr_prefix + "_integer get" + method_suffix + "(" + 
                 owning_entity_name + " type) throws " + "SdaiException {");

      if (flag_expressions) {
        //        pw.println("\t\t\tSdaiContext _context = this.findEntityInstanceSdaiModel().getRepository().getSession().getSdaiContext();");
//RR-SdaiContext-tmp
//        pw.println("\t\tSdaiContext _context = SdaiSession.getSdaiContext();");
        pw.println("\t\tSdaiContext _context = this.findEntityInstanceSdaiModel().getRepository().getSession().getSdaiContext();");

        if (aggregate_depth > 1) {
          pw.println("\t\t\treturn get" + method_suffix + "((" + owning_entity_name + 
                     ")null, _context).getInteger" + aggregate_depth + "Aggregate(this);");
        } else {
          pw.println("\t\t\treturn get" + method_suffix + "((" + owning_entity_name + 
                     ")null, _context).getIntegerAggregate(this);");
        }
      } else {
        pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      }

      pw.println("\t}");
      generateDeriveAttrValueGetMethod(method_suffix, owning_entity_name, pw, attr, sd, _ed, model);
    } else if (an_ss instanceof ENumber_type) {
      pw.println("\t// methods for attribute: " + attr_name + ", base type: " + comment + 
                 "NUMBER");
      pw.println("\tpublic boolean test" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      pw.println("\t}");
      pw.println("\tpublic " + aggr_prefix + "_double get" + method_suffix + "(" + 
                 owning_entity_name + " type) throws " + "SdaiException {");

      //            if ((flag_expressions) & (expression_java != null)) {
      if (flag_expressions) {
        //					pw.println("\t\tSdaiContext _context = this.findEntityInstanceSdaiModel().getRepository().getSession().getSdaiContext();");
//RR-SdaiContext-tmp
//        pw.println("\t\tSdaiContext _context = SdaiSession.getSdaiContext();");
        pw.println("\t\tSdaiContext _context = this.findEntityInstanceSdaiModel().getRepository().getSession().getSdaiContext();");

        if (aggregate_depth > 1) {
          pw.println("\t\treturn get" + method_suffix + "((" + owning_entity_name + 
                     ")null, _context).getDouble" + aggregate_depth + "Aggregate(this);");
        } else {
          pw.println("\t\treturn get" + method_suffix + "((" + owning_entity_name + 
                     ")null, _context).getDoubleAggregate(this);");
        }

        //					pw.println("\t\treturn get" +method_suffix +"(null, _context).getDoubleAggregate(this);" );
      } else {
        pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      }

      pw.println("\t}");
      generateDeriveAttrValueGetMethod(method_suffix, owning_entity_name, pw, attr, sd, _ed, model);
    } else if (an_ss instanceof EReal_type) {
      pw.println("\t// methods for attribute: " + attr_name + ", base type: " + comment + "REAL");
      pw.println("\tpublic boolean test" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      pw.println("\t}");


      // double get method
      pw.println("\tpublic " + aggr_prefix + "_double get" + method_suffix + "(" + 
                 owning_entity_name + " type) throws " + "SdaiException {");

      //            if ((flag_expressions) & (expression_java != null)) {
      if (flag_expressions) {
        //					pw.println("\t\tSdaiContext _context = this.findEntityInstanceSdaiModel().getRepository().getSession().getSdaiContext();");
//RR-SdaiContext-tmp
//        pw.println("\t\tSdaiContext _context = SdaiSession.getSdaiContext();");
        pw.println("\t\tSdaiContext _context = this.findEntityInstanceSdaiModel().getRepository().getSession().getSdaiContext();");

        if (aggregate_depth > 1) {
          pw.println("\t\treturn get" + method_suffix + "((" + owning_entity_name + 
                     ")null, _context).getDouble" + aggregate_depth + "Aggregate(this);");
        } else {
          pw.println("\t\treturn get" + method_suffix + "((" + owning_entity_name + 
                     ")null, _context).getDoubleAggregate(this);");
        }
      } else {
        pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      }

      pw.println("\t}");
      generateDeriveAttrValueGetMethod(method_suffix, owning_entity_name, pw, attr, sd, _ed, model);
    } else if (an_ss instanceof EString_type) {
      pw.println("\t// methods for attribute: " + attr_name + ", base type: " + comment + 
                 "STRING");
      pw.println("\tpublic boolean test" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      pw.println("\t}");
      pw.println("\tpublic " + aggr_prefix + "_string get" + method_suffix + "(" + 
                 owning_entity_name + " type) throws " + "SdaiException {");

      //            if ((flag_expressions) & (expression_java != null)) {
      if (flag_expressions) {
//RR-SdaiContext-tmp
//        pw.println("\t\tSdaiContext _context = SdaiSession.getSdaiContext();");
        pw.println("\t\tSdaiContext _context = this.findEntityInstanceSdaiModel().getRepository().getSession().getSdaiContext();");

        if (aggregate_depth > 1) {
          pw.println("\t\treturn get" + method_suffix + "((" + owning_entity_name + 
                     ")null, _context).getString" + aggregate_depth + "Aggregate(this);");
        } else {
          pw.println("\t\treturn get" + method_suffix + "((" + owning_entity_name + 
                     ")null, _context).getStringAggregate(this);");
        }
      } else {
        pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      }

      pw.println("\t}");
      generateDeriveAttrValueGetMethod(method_suffix, owning_entity_name, pw, attr, sd, _ed, model);
    } else if (an_ss instanceof ELogical_type) {
      pw.println("\t// methods for attribute: " + attr_name + ", base type: " + comment + 
                 "LOGICAL");
      pw.println("\tpublic boolean test" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      pw.println("\t}");
      pw.println("\tpublic " + aggr_prefix + "_enumeration get" + method_suffix + "(" + 
                 owning_entity_name + " type) throws " + "SdaiException {");

      //            if ((flag_expressions) & (expression_java != null)) {
      if (flag_expressions) {
        if (aggregate_depth > 1) {
//RR-SdaiContext-tmp
//          pw.println("\t\tSdaiContext _context = SdaiSession.getSdaiContext();");
          pw.println("\t\tSdaiContext _context = this.findEntityInstanceSdaiModel().getRepository().getSession().getSdaiContext();");
          pw.println("\t\treturn get" + method_suffix + "((" + owning_entity_name + 
                     ")null, _context).getLogical" + aggregate_depth + "Aggregate(this);");
        } else {
          pw.println("\t\treturn get" + method_suffix + "((" + owning_entity_name + 
                     ")null, _context).getLogicalAggregate(this);");
        }
      } else {
        pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      }

      pw.println("\t}");
      generateDeriveAttrValueGetMethod(method_suffix, owning_entity_name, pw, attr, sd, _ed, model);
    } else if (an_ss instanceof EBoolean_type) {
      pw.println("\t// methods for attribute: " + attr_name + ", base type: " + comment + 
                 "BOOLEAN");
      pw.println("\tpublic boolean test" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      pw.println("\t}");
      pw.println("\tpublic " + aggr_prefix + "_boolean get" + method_suffix + "(" + 
                 owning_entity_name + " type) throws " + "SdaiException {");

      //            if ((flag_expressions) & (expression_java != null)) {
      if (flag_expressions) {
//RR-SdaiContext-tmp
//        pw.println("\t\tSdaiContext _context = SdaiSession.getSdaiContext();");
        pw.println("\t\tSdaiContext _context = this.findEntityInstanceSdaiModel().getRepository().getSession().getSdaiContext();");

        if (aggregate_depth > 1) {
          pw.println("\t\treturn get" + method_suffix + "((" + owning_entity_name + 
                     ")null, _context).getBoolean" + aggregate_depth + "Aggregate(this);");
        } else {
          pw.println("\t\treturn get" + method_suffix + "((" + owning_entity_name + 
                     ")null, _context).getBooleanAggregate(this);");
        }
      } else {
        pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      }

      pw.println("\t}");
      generateDeriveAttrValueGetMethod(method_suffix, owning_entity_name, pw, attr, sd, _ed, model);
    } else if (an_ss instanceof EBinary_type) {
      pw.println("\t// methods for attribute: " + attr_name + ", base type: " + comment + 
                 "BINARY");
      pw.println("\tpublic boolean test" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      pw.println("\t}");
      pw.println("\tpublic " + aggr_prefix + "_binary get" + method_suffix + "(" + 
                 owning_entity_name + " type) throws " + "SdaiException {");

      //            if ((flag_expressions) & (expression_java != null)) {
      if (flag_expressions) {
//RR-SdaiContext-tmp
//        pw.println("\t\tSdaiContext _context = SdaiSession.getSdaiContext();");
        pw.println("\t\tSdaiContext _context = this.findEntityInstanceSdaiModel().getRepository().getSession().getSdaiContext();");

        if (aggregate_depth > 1) {
          // not really implemented in Value class!
          pw.println("\t\treturn get" + method_suffix + "((" + owning_entity_name + 
                     ")null, _context).getBinary" + aggregate_depth + "Aggregate(this);");
        } else {
          pw.println("\t\treturn get" + method_suffix + "((" + owning_entity_name + 
                     ")null, _context).getBinaryAggregate(this);");
        }
      } else {
        pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      }

      pw.println("\t}");
      generateDeriveAttrValueGetMethod(method_suffix, owning_entity_name, pw, attr, sd, _ed, model);
    }
  }

  /* generates method for derive attributes, which return Value and is embeded in some other get 
   method with get_SomeType() */
  void generateDeriveAttrValueGetMethod(String method_suffix, String owning_entity_name, 
                                        PrintWriter pw, EAttribute attr, EGeneric_schema_definition sd, 
                                        EEntity_definition _ed, SdaiModel model)
                                 throws SdaiException {
    pw.println("\tpublic Value get" + method_suffix + "(" + owning_entity_name + 
               " type, SdaiContext _context) throws " + "SdaiException {");

    if (flag_expressions) {
//      generateJavaExpressionForDeriveMethods(pw, attr, sd, _ed, model);
      generateJavaExpressionForDeriveMethodsInc(pw, attr, sd, _ed, model);
    } else {
      pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
    }

    pw.println("\t}");
  }

  void generateDeriveAttrValueGetMethodX(String method_suffix, String owning_entity_name, 
                                        PrintWriter pw, EAttribute attr, EGeneric_schema_definition sd, 
                                        EEntity_definition _ed, SdaiModel model)
                                 throws SdaiException {
    pw.println("\tpublic Value get" + method_suffix + "(" + owning_entity_name + 
               " type, SdaiContext _context) throws " + "SdaiException {");

    if (flag_expressions) {
//      generateJavaExpressionForDeriveMethods(pw, attr, sd, _ed, model);

//TOFIX - temporarily off
      pw.println("\t\t\t// may need fixing - 01");
      generateJavaExpressionForDeriveMethodsInc(pw, attr, sd, _ed, model);
//      pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL); // C");
    } else {
      pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
    }

    pw.println("\t}");
  }






//

  void generateJavaExplicit2DerivedAttributeDefinedTypeMethods(EAttribute attr, EAttribute redeclared_attr, EDefined_type dt, PrintWriter pw, 
                                                  String entity_name, String attr_name, 
                                                  String method_suffix, String owning_entity_name, 
                                                  String attr_internal_name, 
                                                  A_string expression_java)
                                           throws SdaiException {

pw.println("//#X# 00 - attr: " + attr + ", redeclared_attr: " + redeclared_attr);

    EEntity ut = dt.getDomain(null);

    if (ut instanceof ESimple_type) {

      if (debug_java) pw.println("\t// generateJavaExplicit2DerivedAttributeSimpleTypeMethods: 2");
      generateJavaExplicit2DerivedAttributeSimpleTypeMethods(attr, redeclared_attr, (ESimple_type) ut, pw, entity_name, attr_name, 
                                                method_suffix, owning_entity_name, 
                                                attr_internal_name, expression_java);
    } else if (ut instanceof EAggregation_type) {
      generateJavaExplicit2DerivedAttributeAggregationTypeMethods(attr, redeclared_attr, (EAggregation_type) ut, pw, entity_name, 
                                                     attr_name, method_suffix, owning_entity_name, 
                                                     attr_internal_name, expression_java);
    } else if (ut instanceof EDefined_type) {
      generateJavaExplicit2DerivedAttributeDefinedTypeMethods(attr, redeclared_attr, (EDefined_type) ut, pw, entity_name, 
                                                 attr_name, method_suffix, owning_entity_name, 
                                                 attr_internal_name, expression_java);

    } else if (ut instanceof EEnumeration_type) {
//      A_string enelements = ((EEnumeration_type) ut).getElements(null);
//      A_string enelements = ((EEnumeration_type) ut).getLocal_elements(null);
//      A_string enelements = getElements((EEnumeration_type) ut);
      Vector enelements = getElementsV((EEnumeration_type) ut);


      //         generateEnumerationMethods((EEnumeration_type)ut, pw, entity_name, attr_name, method_suffix);
      pw.println("\t// -13- explicit redeclared as derived attribute:" + attr_name + ", base type: ENUMERATION");
      pw.println("\tpublic boolean test" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      pw.println("\t}");

      pw.println("\tpublic Value get" + method_suffix + "(" + owning_entity_name + " type, SdaiContext _context) throws " + "SdaiException {");
//      pw.println("\tpublic Value get" + method_suffix + "(" + owning_entity_name + " type) throws " + "SdaiException {");

      //         if ((flag_expressions) & (expression_java != null)) {
      if (flag_expressions) {
//        generateJavaExpressionForDeriveMethods(pw, attr, sd, _ed, model);
        generateJavaExpressionForDeriveMethodsInc(pw, attr, sd, _ed, model);
      } else {
        pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      }

      pw.println("\t}");
      pw.println("\tpublic int get" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");

      //         if ((flag_expressions) & (expression_java != null)) {
      if (flag_expressions) {
        // pw.println("\t\t\treturn (int) (");
        // null argument may be too simple, maybe some logic is needed for name conflicts.
        pw.println("\t\tSdaiContext _context = this.findEntityInstanceSdaiModel().getRepository().getSession().getSdaiContext();");
        pw.println("\t\t\treturn get" + method_suffix + "((" + owning_entity_name + ")null, _context).getInteger();");
//        pw.println("\t\t\treturn get" + method_suffix + "(null).getInteger();");

        // generateExpressionBody(pw, expression_java);
        //            generateJavaExpression(pw, attr, sd, _ed, model);
        //            pw.println("\t\t\t);");
      } else {
        pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      }

      pw.println("\t}");

      pw.println("\tpublic void set" + method_suffix + "(" + owning_entity_name + 
                 " type, int value) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.AT_NVLD);");
      pw.println("\t}");
      pw.println("\tpublic void unset" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.AT_NVLD);");
      pw.println("\t}");


    } else if (ut instanceof ESelect_type) {
//      ANamed_type nt = ((ESelect_type) ut).getSelections(null);
//      ANamed_type nt = ((ESelect_type) ut).getLocal_selections(null);
      ANamed_type nt = getSelections((ESelect_type) ut);

      //         int select_type = calculateSelectPaths(nt); // 0 - pure entity, 1 - pure defined_type or 2 - mixed select
      SelectPaths paths1 = null;
      int select_type = Integer.MIN_VALUE;
      Object temp_object = ut.getTemp();

      if (temp_object instanceof SelectPaths) {
        if (((SelectPaths) temp_object).owner == (ESelect_type) ut) {
          paths1 = (SelectPaths) temp_object;
          select_type = paths1.select_type;
        }
      }

      if (paths1 == null) {
        int count = 1;
        int[] indeces = new int[500];
        int depth = 0;
        int depth_count = 0;
        boolean with_type = false;
        Vector current_nodes = new Vector();
        Vector current_node_strings = new Vector();
        paths1 = new SelectPaths();
        paths1.owner = (ESelect_type) ut;
        select_type = calculateSelectPaths(count, current_nodes, current_node_strings, indeces, 
                                           depth, depth_count, paths1, (ESelect_type) ut, with_type);
        paths1.removeIdentical();
        paths1.select_type = select_type;
        ut.setTemp(paths1);
      }


      // pw.println("debug: " + select_type);
      pw.println("\t// -1- methods for explicit redeclared as derived SELECT attribute: " + attr_name);

      if (select_type > 0) { // includes defined_types

        //            paths1.generateConstants(pw, attr_name);
        //            pw.println("");
      }

      /*
      if (select_type < 2) { // includes entieties
         generateEntityMethodDeclarationsForSelect((ESelect_type)ut, pw, entity_name, attr_name, method_suffix);
      } 
      if (select_type > 0) { // includes defined_types
         paths1.generateDefinedTypeGetMethodDeclarations((ESelect_type)ut, pw, entity_name, attr_name, method_suffix);
      }
       */

      //         pw.println("\tint test" + normalize(attr_name) + "(" + owning_entity_name + " type) throws SdaiException {");
      if ((select_type == 0) || (select_type == 2)) { // includes direct entities

        // cannot use this, because in this case also may be one or more entities - a specific or a generic case
  	    }

      // so maybe also get/set methods should have not only generic EEntity return type/value but in case of only one entity - the specific one?
      //         Object result = entitiesInSelect((ESelect_type)ut, null);
      if (select_type == 0) { // only pure entity selects

        //            pw.println("\t\treturn test_select(" + attr_internal_name + ", 1);");
        pw.println("\tpublic boolean test" + method_suffix + "(" + owning_entity_name + 
                   " type) throws SdaiException {");
        pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      } else {
        pw.println("\tpublic int test" + method_suffix + "(" + owning_entity_name + 
                   " type) throws SdaiException {");
        pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      }

      pw.println("\t}");
      pw.println("");
//DEBUG
//pw.println("\t// attr: " + attr + ", select type ut: " + ut + ", entity_name: " + entity_name + ", attr_name: " + attr_name + ", select_type: " + select_type + ", owning_entity_name: " + owning_entity_name + 
//", attr_internal_name: " + attr_internal_name + ", expression_java: " + expression_java + ", sd: " + sd + ", _ed: " + _ed + ", model: " + model);
      paths1.generateGetDerivedMethods(attr, (ESelect_type) ut, pw, entity_name, attr_name, 
                                       method_suffix, select_type, owning_entity_name, 
                                       attr_internal_name, expression_java, flag_expressions, sd, 
                                       _ed, model, this);

      pw.println("");
			// is this method ok?
      paths1.generateSetLaterRedeclaredMethods((ESelect_type) ut, pw, entity_name, attr_name, 
                                               method_suffix, select_type, owning_entity_name, 
                                               attr_internal_name);
      pw.println("");
      pw.println("\tpublic void unset" + method_suffix + "(" + owning_entity_name + 
                 " type) throws SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.AT_NVLD);");
      pw.println("");
      pw.println("\t}");
	
    }
  }


//


  void generateDerivedAttributeDefinedTypeMethods(EAttribute attr, EDefined_type dt, PrintWriter pw, 
                                                  String entity_name, String attr_name, 
                                                  String method_suffix, String owning_entity_name, 
                                                  String attr_internal_name, 
                                                  A_string expression_java)
                                           throws SdaiException {
    EEntity ut = dt.getDomain(null);

    if (ut instanceof ESimple_type) {
      generateDerivedAttributeSimpleTypeMethods(attr, (ESimple_type) ut, pw, entity_name, attr_name, 
                                                method_suffix, owning_entity_name, 
                                                attr_internal_name, expression_java);
    } else if (ut instanceof EAggregation_type) {
      generateDerivedAttributeAggregationTypeMethods(attr, (EAggregation_type) ut, pw, entity_name, 
                                                     attr_name, method_suffix, owning_entity_name, 
                                                     attr_internal_name, expression_java);
    } else if (ut instanceof EDefined_type) {
      generateDerivedAttributeDefinedTypeMethods(attr, (EDefined_type) ut, pw, entity_name, 
	                                                 attr_name, method_suffix, owning_entity_name, 
                                                 attr_internal_name, expression_java);

    } else if (ut instanceof EEnumeration_type) {
//      A_string enelements = ((EEnumeration_type) ut).getElements(null);
//      A_string enelements = ((EEnumeration_type) ut).getLocal_elements(null);
//      A_string enelements = getElements((EEnumeration_type) ut);
      Vector enelements = getElementsV((EEnumeration_type) ut);


      //         generateEnumerationMethods((EEnumeration_type)ut, pw, entity_name, attr_name, method_suffix);
      pw.println("\t// attribute:" + attr_name + ", base type: ENUMERATION");
      pw.println("\tpublic boolean test" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      pw.println("\t}");

      pw.println("\tpublic Value get" + method_suffix + "(" + owning_entity_name + " type, SdaiContext _context) throws " + "SdaiException {");
//      pw.println("\tpublic Value get" + method_suffix + "(" + owning_entity_name + " type) throws " + "SdaiException {");

      //         if ((flag_expressions) & (expression_java != null)) {
      if (flag_expressions) {
//        generateJavaExpressionForDeriveMethods(pw, attr, sd, _ed, model);
        generateJavaExpressionForDeriveMethodsInc(pw, attr, sd, _ed, model);
      } else {
        pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      }

      pw.println("\t}");
      pw.println("\tpublic int get" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");

      //         if ((flag_expressions) & (expression_java != null)) {
      if (flag_expressions) {
        // pw.println("\t\t\treturn (int) (");
        // null argument may be too simple, maybe some logic is needed for name conflicts.
        pw.println("\t\tSdaiContext _context = this.findEntityInstanceSdaiModel().getRepository().getSession().getSdaiContext();");
        pw.println("\t\t\treturn get" + method_suffix + "((" + owning_entity_name + ")null, _context).getInteger();");
//        pw.println("\t\t\treturn get" + method_suffix + "(null).getInteger();");

        // generateExpressionBody(pw, expression_java);
        //            generateJavaExpression(pw, attr, sd, _ed, model);
        //            pw.println("\t\t\t);");
      } else {
        pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      }

      pw.println("\t}");
    } else if (ut instanceof ESelect_type) {
//      ANamed_type nt = ((ESelect_type) ut).getSelections(null);
//      ANamed_type nt = ((ESelect_type) ut).getLocal_selections(null);
      ANamed_type nt = getSelections((ESelect_type) ut);

      //         int select_type = calculateSelectPaths(nt); // 0 - pure entity, 1 - pure defined_type or 2 - mixed select
      SelectPaths paths1 = null;
      int select_type = Integer.MIN_VALUE;
      Object temp_object = ut.getTemp();

      if (temp_object instanceof SelectPaths) {
        if (((SelectPaths) temp_object).owner == (ESelect_type) ut) {
          paths1 = (SelectPaths) temp_object;
          select_type = paths1.select_type;
        }
      }

      if (paths1 == null) {
        int count = 1;
        int[] indeces = new int[500];
        int depth = 0;
        int depth_count = 0;
        boolean with_type = false;
        Vector current_nodes = new Vector();
        Vector current_node_strings = new Vector();
        paths1 = new SelectPaths();
        paths1.owner = (ESelect_type) ut;
        select_type = calculateSelectPaths(count, current_nodes, current_node_strings, indeces, 
                                           depth, depth_count, paths1, (ESelect_type) ut, with_type);
        paths1.removeIdentical();
        paths1.select_type = select_type;
        ut.setTemp(paths1);
      }


      // pw.println("debug: " + select_type);
      pw.println("\t// methods for derived SELECT attribute: " + attr_name);

      if (select_type > 0) { // includes defined_types

        //            paths1.generateConstants(pw, attr_name);
        //            pw.println("");
      }

      /*
      if (select_type < 2) { // includes entieties
         generateEntityMethodDeclarationsForSelect((ESelect_type)ut, pw, entity_name, attr_name, method_suffix);
      } 
      if (select_type > 0) { // includes defined_types
         paths1.generateDefinedTypeGetMethodDeclarations((ESelect_type)ut, pw, entity_name, attr_name, method_suffix);
      }
       */

      //         pw.println("\tint test" + normalize(attr_name) + "(" + owning_entity_name + " type) throws SdaiException {");
      if ((select_type == 0) || (select_type == 2)) { // includes direct entities

        // cannot use this, because in this case also may be one or more entities - a specific or a generic case
      }

      // so maybe also get/set methods should have not only generic EEntity return type/value but in case of only one entity - the specific one?
      //         Object result = entitiesInSelect((ESelect_type)ut, null);
      if (select_type == 0) { // only pure entity selects

        //            pw.println("\t\treturn test_select(" + attr_internal_name + ", 1);");
        pw.println("\tpublic boolean test" + method_suffix + "(" + owning_entity_name + 
                   " type) throws SdaiException {");
        pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      } else {
        pw.println("\tpublic int test" + method_suffix + "(" + owning_entity_name + 
                   " type) throws SdaiException {");
        pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      }

      pw.println("\t}");
      pw.println("");
      paths1.generateGetDerivedMethods(attr, (ESelect_type) ut, pw, entity_name, attr_name, 
                                       method_suffix, select_type, owning_entity_name, 
                                       attr_internal_name, expression_java, flag_expressions, sd, 
                                       _ed, model, this);

// just add here unset and see what happens

//        pw.println("\tpublic void unset" + method_suffix + "(" + owning_entity_name + 
//                   " type) throws SdaiException {");
//        pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
//	      pw.println("\t}");



      pw.println("");
    }
  }

  void generateDerivedAttributeSimpleTypeMethods(EAttribute attr, ESimple_type st, PrintWriter pw, 
                                                 String entity_name, String attr_name, 
                                                 String method_suffix, String owning_entity_name, 
                                                 String attr_internal_name, 
                                                 A_string expression_java)
                                          throws SdaiException {
    if (st instanceof EInteger_type) {
      pw.println("\t// methods for derived attribute: " + attr_name + ", base type: INTEGER");
      pw.println("\tpublic boolean test" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      pw.println("\t}");
      pw.println("\tpublic Value get" + method_suffix + "(" + owning_entity_name + 
                 " type, SdaiContext _context) throws " + "SdaiException {");

      if (flag_expressions) {
//        generateJavaExpressionForDeriveMethods(pw, attr, sd, _ed, model);
        generateJavaExpressionForDeriveMethodsInc(pw, attr, sd, _ed, model);
      } else {
        pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      }

      pw.println("\t}");
      pw.println("\tpublic int get" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");

      if (flag_expressions) {
        //        pw.println("\t\t\tSdaiContext _context = this.findEntityInstanceSdaiModel().getRepository().getSession().getSdaiContext();");
//RR-SdaiContext-tmp
//        pw.println("\t\tSdaiContext _context = SdaiSession.getSdaiContext();");
        pw.println("\t\tSdaiContext _context = this.findEntityInstanceSdaiModel().getRepository().getSession().getSdaiContext();");
        pw.println("\t\t\treturn get" + method_suffix + "((" + owning_entity_name + 
                   ")null, _context).getInteger();");
      } else {
        pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      }

      pw.println("\t}");
    } else if (st instanceof ENumber_type) {
      pw.println("\t// methods for derived attribute: " + attr_name + ", base type: NUMBER");
      pw.println("\tpublic boolean test" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      pw.println("\t}");
      pw.println("\tpublic Value get" + method_suffix + "(" + owning_entity_name + 
                 " type, SdaiContext _context) throws " + "SdaiException {");

      if (flag_expressions) {
//        generateJavaExpressionForDeriveMethods(pw, attr, sd, _ed, model);
        generateJavaExpressionForDeriveMethodsInc(pw, attr, sd, _ed, model);
      } else {
        pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      }

      pw.println("\t}");
      pw.println("\tpublic double get" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");

      if (flag_expressions) {
        //        pw.println("\t\t\tSdaiContext _context = this.findEntityInstanceSdaiModel().getRepository().getSession().getSdaiContext();");
//RR-SdaiContext-tmp
//        pw.println("\t\tSdaiContext _context = SdaiSession.getSdaiContext();");
        pw.println("\t\tSdaiContext _context = this.findEntityInstanceSdaiModel().getRepository().getSession().getSdaiContext();");
        pw.println("\t\t\treturn get" + method_suffix + "((" + owning_entity_name + 
                   ")null, _context).getDouble();");
      } else {
        pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      }

      pw.println("\t}");
    } else if (st instanceof EReal_type) {
      pw.println("\t// methods for derived attribute: " + attr_name + ", base type: REAL");
      pw.println("\tpublic boolean test" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      pw.println("\t}");
      pw.println("\tpublic Value get" + method_suffix + "(" + owning_entity_name + 
                 " type, SdaiContext _context) throws " + "SdaiException {");

      if (flag_expressions) {
//        generateJavaExpressionForDeriveMethods(pw, attr, sd, _ed, model);
        generateJavaExpressionForDeriveMethodsInc(pw, attr, sd, _ed, model);
      } else {
        pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      }

      pw.println("\t}");
      pw.println("\tpublic double get" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");

      if (flag_expressions) {
        //        pw.println("\t\t\tSdaiContext _context = this.findEntityInstanceSdaiModel().getRepository().getSession().getSdaiContext();");
//RR-SdaiContext-tmp
//        pw.println("\t\tSdaiContext _context = SdaiSession.getSdaiContext();");
        pw.println("\t\tSdaiContext _context = this.findEntityInstanceSdaiModel().getRepository().getSession().getSdaiContext();");
        pw.println("\t\treturn get" + method_suffix + "((" + owning_entity_name + 
                   ")null, _context).getDouble();");
      } else {
        pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      }

      pw.println("\t}");
    } else if (st instanceof EBoolean_type) {
      pw.println("\t// methods for derived attribute: " + attr_name + ", base type: BOOLEAN");
      pw.println("\tpublic boolean test" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      pw.println("\t}");
      pw.println("\tpublic Value get" + method_suffix + "(" + owning_entity_name + 
                 " type, SdaiContext _context) throws " + "SdaiException {");

      if (flag_expressions) {
//        generateJavaExpressionForDeriveMethods(pw, attr, sd, _ed, model);
        generateJavaExpressionForDeriveMethodsInc(pw, attr, sd, _ed, model);
      } else {
        pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      }

      pw.println("\t}");
      pw.println("\tpublic int get" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");

      if (flag_expressions) {
        //        pw.println("\t\t\tSdaiContext _context = this.findEntityInstanceSdaiModel().getRepository().getSession().getSdaiContext();");
//RR-SdaiContext-tmp
//        pw.println("\t\tSdaiContext _context = SdaiSession.getSdaiContext();");
        pw.println("\t\tSdaiContext _context = this.findEntityInstanceSdaiModel().getRepository().getSession().getSdaiContext();");
        pw.println("\t\treturn get" + method_suffix + "((" + owning_entity_name + 
                   ")null, _context).getBoolean();");
      } else {
        pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      }

      pw.println("\t}");
    } else if (st instanceof ELogical_type) {
      pw.println("\t// methods for derived attribute: " + attr_name + ", base type: LOGICAL");
      pw.println("\tpublic boolean test" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      pw.println("\t}");
      pw.println("\tpublic Value get" + method_suffix + "(" + owning_entity_name + 
                 " type, SdaiContext _context) throws " + "SdaiException {");

      if (flag_expressions) {
//        generateJavaExpressionForDeriveMethods(pw, attr, sd, _ed, model);
        generateJavaExpressionForDeriveMethodsInc(pw, attr, sd, _ed, model);
      } else {
        pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      }

      pw.println("\t}");
      pw.println("\tpublic int get" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");

      if (flag_expressions) {
        //        pw.println("\t\t\tSdaiContext _context = this.findEntityInstanceSdaiModel().getRepository().getSession().getSdaiContext();");
//RR-SdaiContext-tmp
//        pw.println("\t\tSdaiContext _context = SdaiSession.getSdaiContext();");
        pw.println("\t\tSdaiContext _context = this.findEntityInstanceSdaiModel().getRepository().getSession().getSdaiContext();");
        pw.println("\t\treturn get" + method_suffix + "((" + owning_entity_name + 
                   ")null, _context).getLogical();");
      } else {
        pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      }

      pw.println("\t}");
    } else if (st instanceof EBinary_type) {
      pw.println("\t// methods for derived attribute: " + attr_name + ", base type: BINARY");
      pw.println("\tpublic boolean test" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      pw.println("\t}");
      pw.println("\tpublic Value get" + method_suffix + "(" + owning_entity_name + 
                 " type, SdaiContext _context) throws " + "SdaiException {");

      if (flag_expressions) {
//        generateJavaExpressionForDeriveMethods(pw, attr, sd, _ed, model);
        generateJavaExpressionForDeriveMethodsInc(pw, attr, sd, _ed, model);
      } else {
        pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      }

      pw.println("\t}");
      pw.println("\tpublic Binary get" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");

      if (flag_expressions) {
        //        pw.println("\t\t\tSdaiContext _context = this.findEntityInstanceSdaiModel().getRepository().getSession().getSdaiContext();");
//RR-SdaiContext-tmp
//        pw.println("\t\tSdaiContext _context = SdaiSession.getSdaiContext();");
        pw.println("\t\tSdaiContext _context = this.findEntityInstanceSdaiModel().getRepository().getSession().getSdaiContext();");
        pw.println("\t\treturn get" + method_suffix + "((" + owning_entity_name + 
                   ")null, _context).getBinary();");
      } else {
        pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      }

      pw.println("\t}");
    } else if (st instanceof EString_type) {
      pw.println("\t// methods for derived attribute: " + attr_name + ", base type: STRING");
      pw.println("\tpublic boolean test" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      pw.println("\t}");
      pw.println("\tpublic Value get" + method_suffix + "(" + owning_entity_name + 
                 " type, SdaiContext _context) throws " + "SdaiException {");

      if (flag_expressions) {

        generateJavaExpressionForDeriveMethodsInc(pw, attr, sd, _ed, model);

	//        generateJavaExpressionForDeriveMethods(pw, attr, sd, _ed, model);
      } else {
        pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      }

      pw.println("\t}");
      pw.println("\tpublic String get" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
	
      if (flag_expressions) {
//RR-SdaiContext-tmp
//        pw.println("\t\tSdaiContext _context = SdaiSession.getSdaiContext();");
        pw.println("\t\tSdaiContext _context = this.findEntityInstanceSdaiModel().getRepository().getSession().getSdaiContext();");
        pw.println("\t\treturn get" + method_suffix + "((" + owning_entity_name + 
                   ")null, _context).getString();");
      } else {
        pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
      }

      pw.println("\t}");
    }
  }




  void generateExplicitAttributeSimpleTypeMethodsRenamed(ESimple_type st, PrintWriter pw, 
                                                  String entity_name, String attr_name, 
                                                  String method_suffix, String owning_entity_name, 
                                                  String attr_internal_name,
 																									EExplicit_attribute xattr, 
 																									String method_suffix_prev, 
 																									String owning_entity_name_prev, 
 																									String package_prev) {
    
    if (st instanceof EInteger_type) {
      pw.println("\t/// methods for attribute: " + attr_name + ", base type: INTEGER");

      pw.println("\tpublic boolean test" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\treturn " + package_prev + "test" + method_suffix_prev + "((" + owning_entity_name_prev + ")null);");
      pw.println("\t}");

      pw.println("\tpublic int get" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\treturn " + package_prev + "get" + method_suffix_prev + "((" + owning_entity_name_prev + ")null);");
      pw.println("\t}");

      pw.println("\tpublic void set" + method_suffix + "(" + owning_entity_name + 
                 " type, int value) throws " + "SdaiException {");
      pw.println("\t\t" + package_prev + "set" + method_suffix_prev + "((" + owning_entity_name_prev + ")null, value);");
      pw.println("\t}");

      pw.println("\tpublic void unset" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\t" + package_prev + "unset" + method_suffix_prev + "((" + owning_entity_name_prev + ")null);");
      pw.println("\t}");
    } else if (st instanceof ENumber_type) {
      pw.println("\t/// methods for attribute: " + attr_name + ", base type: NUMBER");

      pw.println("\tpublic boolean test" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\treturn " + package_prev + "test" + method_suffix_prev + "((" + owning_entity_name_prev + ")null);");
      pw.println("\t}");

      pw.println("\tpublic double get" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\treturn " + package_prev + "get" + method_suffix_prev + "((" + owning_entity_name_prev + ")null);");
      pw.println("\t}");

      pw.println("\tpublic void set" + method_suffix + "(" + owning_entity_name + 
                 " type, double value) throws " + "SdaiException {");
      pw.println("\t\t" + package_prev + "set" + method_suffix_prev + "((" + owning_entity_name_prev + ")null, value);");
      pw.println("\t}");

      pw.println("\tpublic void unset" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\t" + package_prev + "unset" + method_suffix_prev + "((" + owning_entity_name_prev + ")null);");
      pw.println("\t}");
    } else if (st instanceof EReal_type) {
      pw.println("\t/// methods for attribute: " + attr_name + ", base type: REAL");

      pw.println("\tpublic boolean test" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\treturn " + package_prev + "test" + method_suffix_prev + "((" + owning_entity_name_prev + ")null);");
      pw.println("\t}");

      pw.println("\tpublic double get" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\treturn " + package_prev + "get" + method_suffix_prev + "((" + owning_entity_name_prev + ")null);");
      pw.println("\t}");

      pw.println("\tpublic void set" + method_suffix + "(" + owning_entity_name + 
                 " type, double value) throws " + "SdaiException {");
      pw.println("\t\t" + package_prev + "set" + method_suffix_prev + "((" + owning_entity_name_prev + ")null, value);");
      pw.println("\t}");

      pw.println("\tpublic void unset" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\t" + package_prev + "unset" + method_suffix_prev + "((" + owning_entity_name_prev + ")null);");
      pw.println("\t}");
    } else if (st instanceof EBoolean_type) {
      pw.println("\t/// methods for attribute: " + attr_name + ", base type: BOOLEAN");

      pw.println("\tpublic boolean test" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\treturn " + package_prev + "test" + method_suffix_prev + "((" + owning_entity_name_prev + ")null);");
      pw.println("\t}");

      pw.println("\tpublic boolean get" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\treturn " + package_prev + "get" + method_suffix_prev + "((" + owning_entity_name_prev + ")null);");
      pw.println("\t}");

      pw.println("\tpublic void set" + method_suffix + "(" + owning_entity_name + 
                 " type, boolean value) throws " + "SdaiException {");
      pw.println("\t\t" + package_prev + "set" + method_suffix_prev + "((" + owning_entity_name_prev + ")null, value);");
      pw.println("\t}");

      pw.println("\tpublic void unset" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\t" + package_prev + "unset" + method_suffix_prev + "((" + owning_entity_name_prev + ")null);");
      pw.println("\t}");
    } else if (st instanceof ELogical_type) {
      pw.println("\t/// methods for attribute: " + attr_name + ", base type: LOGICAL");

      pw.println("\tpublic boolean test" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\treturn " + package_prev + "test" + method_suffix_prev + "((" + owning_entity_name_prev + ")null);");
      pw.println("\t}");

      pw.println("\tpublic int get" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\treturn " + package_prev + "get" + method_suffix_prev + "((" + owning_entity_name_prev + ")null);");
      pw.println("\t}");

      pw.println("\tpublic void set" + method_suffix + "(" + owning_entity_name + 
                 " type, int value) throws " + "SdaiException {");
      pw.println("\t\t" + package_prev + "set" + method_suffix_prev + "((" + owning_entity_name_prev + ")null, value);");
      pw.println("\t}");

      pw.println("\tpublic void unset" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\t" + package_prev + "unset" + method_suffix_prev + "((" + owning_entity_name_prev + ")null);");
      pw.println("\t}");
    } else if (st instanceof EBinary_type) {

      pw.println("\t/// methods for attribute: " + attr_name + ", base type: BINARY");
      pw.println("\tpublic boolean test" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\treturn " + package_prev + "test" + method_suffix_prev + "((" + owning_entity_name_prev + ")null);");
      pw.println("\t}");

      pw.println("\tpublic Binary get" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\treturn " + package_prev + "get" + method_suffix_prev + "((" + owning_entity_name_prev + ")null);");
      pw.println("\t}");

      pw.println("\tpublic void set" + method_suffix + "(" + owning_entity_name + 
                 " type, Binary value) throws " + "SdaiException {");
      pw.println("\t\t" + package_prev + "set" + method_suffix_prev + "((" + owning_entity_name_prev + ")null, value);");
      pw.println("\t}");

      pw.println("\tpublic void unset" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\t" + package_prev + "unset" + method_suffix_prev + "((" + owning_entity_name_prev + ")null);");
      pw.println("\t}");

    } else if (st instanceof EString_type) {

      pw.println("\t/// methods for attribute: " + attr_name + ", base type: STRING");

      pw.println("\tpublic boolean test" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\treturn " + package_prev + "test" + method_suffix_prev + "((" + owning_entity_name_prev + ")null);");
      pw.println("\t}");

      pw.println("\tpublic String get" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\treturn " + package_prev + "get" + method_suffix_prev + "((" + owning_entity_name_prev + ")null);");
      pw.println("\t}");

      pw.println("\tpublic void set" + method_suffix + "(" + owning_entity_name + 
                 " type, String value) throws " + "SdaiException {");
      pw.println("\t\t" + package_prev + "set" + method_suffix_prev + "((" + owning_entity_name_prev + ")null, value);");
      pw.println("\t}");

      pw.println("\tpublic void unset" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\t" + package_prev + "unset" + method_suffix_prev + "((" + owning_entity_name_prev + ")null);");
      pw.println("\t}");

    }
  }



  void generateExplicitAttributeSimpleTypeMethods(ESimple_type st, PrintWriter pw, 
                                                  String entity_name, String attr_name, 
                                                  String method_suffix, String owning_entity_name, 
                                                  String attr_internal_name) {
    if (st instanceof EInteger_type) {
      pw.println("\t/// methods for attribute: " + attr_name + ", base type: INTEGER");
      pw.println("\tpublic boolean test" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\treturn test_integer(" + attr_internal_name + ");");
      pw.println("\t}");
      pw.println("\tpublic int get" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\treturn get_integer(" + attr_internal_name + ");");
      pw.println("\t}");
      pw.println("\tpublic void set" + method_suffix + "(" + owning_entity_name + 
                 " type, int value) throws " + "SdaiException {");
      pw.println("\t\t" + attr_internal_name + " = set_integer(value);");
      pw.println("\t}");
      pw.println("\tpublic void unset" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\t" + attr_internal_name + " = unset_integer();");
      pw.println("\t}");
    } else if (st instanceof ENumber_type) {
      pw.println("\t/// methods for attribute: " + attr_name + ", base type: NUMBER");
      pw.println("\tpublic boolean test" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\treturn test_double(" + attr_internal_name + ");");
      pw.println("\t}");
      pw.println("\tpublic double get" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\treturn get_double(" + attr_internal_name + ");");
      pw.println("\t}");
      pw.println("\tpublic void set" + method_suffix + "(" + owning_entity_name + 
                 " type, double value) throws " + "SdaiException {");
      pw.println("\t\t" + attr_internal_name + " = set_double(value);");
      pw.println("\t}");
      pw.println("\tpublic void unset" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\t" + attr_internal_name + " = unset_double();");
      pw.println("\t}");
    } else if (st instanceof EReal_type) {
      pw.println("\t/// methods for attribute: " + attr_name + ", base type: REAL");
      pw.println("\tpublic boolean test" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\treturn test_double(" + attr_internal_name + ");");
      pw.println("\t}");
      pw.println("\tpublic double get" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\treturn get_double(" + attr_internal_name + ");");
      pw.println("\t}");
      pw.println("\tpublic void set" + method_suffix + "(" + owning_entity_name + 
                 " type, double value) throws " + "SdaiException {");
      pw.println("\t\t" + attr_internal_name + " = set_double(value);");
      pw.println("\t}");
      pw.println("\tpublic void unset" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\t" + attr_internal_name + " = unset_double();");
      pw.println("\t}");
    } else if (st instanceof EBoolean_type) {
      pw.println("\t/// methods for attribute: " + attr_name + ", base type: BOOLEAN");
      pw.println("\tpublic boolean test" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\treturn test_boolean(" + attr_internal_name + ");");
      pw.println("\t}");
      pw.println("\tpublic boolean get" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\treturn get_boolean(" + attr_internal_name + ");");
      pw.println("\t}");
      pw.println("\tpublic void set" + method_suffix + "(" + owning_entity_name + 
                 " type, boolean value) throws " + "SdaiException {");
      pw.println("\t\t" + attr_internal_name + " = set_boolean(value);");
      pw.println("\t}");
      pw.println("\tpublic void unset" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\t" + attr_internal_name + " = unset_boolean();");
      pw.println("\t}");
    } else if (st instanceof ELogical_type) {
      pw.println("\t/// methods for attribute: " + attr_name + ", base type: LOGICAL");
      pw.println("\tpublic boolean test" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\treturn test_logical(" + attr_internal_name + ");");
      pw.println("\t}");
      pw.println("\tpublic int get" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\treturn get_logical(" + attr_internal_name + ");");
      pw.println("\t}");
      pw.println("\tpublic void set" + method_suffix + "(" + owning_entity_name + 
                 " type, int value) throws " + "SdaiException {");
      pw.println("\t\t" + attr_internal_name + " = set_logical(value);");
      pw.println("\t}");
      pw.println("\tpublic void unset" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\t" + attr_internal_name + " = unset_logical();");
      pw.println("\t}");
    } else if (st instanceof EBinary_type) {
      pw.println("\t/// methods for attribute: " + attr_name + ", base type: BINARY");
      pw.println("\tpublic boolean test" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\treturn test_binary(" + attr_internal_name + ");");
      pw.println("\t}");
      pw.println("\tpublic Binary get" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\treturn get_binary(" + attr_internal_name + ");");
      pw.println("\t}");
      pw.println("\tpublic void set" + method_suffix + "(" + owning_entity_name + 
                 " type, Binary value) throws " + "SdaiException {");
      pw.println("\t\t" + attr_internal_name + " = set_binary(value);");
      pw.println("\t}");
      pw.println("\tpublic void unset" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\t" + attr_internal_name + " = unset_binary();");
      pw.println("\t}");
    } else if (st instanceof EString_type) {
      pw.println("\t/// methods for attribute: " + attr_name + ", base type: STRING");
      pw.println("\tpublic boolean test" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\treturn test_string(" + attr_internal_name + ");");
      pw.println("\t}");
      pw.println("\tpublic String get" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\treturn get_string(" + attr_internal_name + ");");
      pw.println("\t}");
      pw.println("\tpublic void set" + method_suffix + "(" + owning_entity_name + 
                 " type, String value) throws " + "SdaiException {");
      pw.println("\t\t" + attr_internal_name + " = set_string(value);");
      pw.println("\t}");
      pw.println("\tpublic void unset" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\t" + attr_internal_name + " = unset_string();");
      pw.println("\t}");
    }
  }



  void generateExplicitAttributeDefinedTypeMethodsUsedinOnlyRenamed(EDefined_type dt, PrintWriter pw, 
                                                             String entity_name, String attr_name, 
                                                             String method_suffix, 
                                                             String owning_entity_name, 
                                                             String attr_internal_name)
                                                      throws SdaiException {
  

// additional parameters - needed or not, considering that renamed only and previous name not needed?
// probably not needed with the current implementation (not using nested)
/*
                                                     EExplicit_attribute xattr, 
                                                   String method_suffix_prev, 
                                                   String owning_entity_name_prev, 
                                                   String package_prev)
*/
  
  
    EEntity ut = dt.getDomain(null);

    if (ut instanceof ESimple_type) {
    } else if (ut instanceof EAggregation_type) {
      generateExplicitAttributeAggregationTypeMethodsUsedinOnlyRenamed((EAggregation_type) ut, pw, 
                                                                entity_name, attr_name, 
                                                                method_suffix, owning_entity_name, 
                                                                attr_internal_name);
    } else if (ut instanceof EDefined_type) {
      generateExplicitAttributeDefinedTypeMethodsUsedinOnlyRenamed((EDefined_type) ut, pw, entity_name, 
                                                            attr_name, method_suffix, 
                                                            owning_entity_name, attr_internal_name);
    
    
    } else if (ut instanceof ESelect_type) {
//      ANamed_type nt = ((ESelect_type) ut).getSelections(null);
//      ANamed_type nt = ((ESelect_type) ut).getLocal_selections(null);
      ANamed_type nt = getSelections((ESelect_type) ut);

      //         int select_type = calculateSelectPaths(nt); // 0 - pure entity, 1 - pure defined_type or 2 - mixed select
      SelectPaths paths1 = null;
      int select_type = Integer.MIN_VALUE;
      Object temp_object = ut.getTemp();

      if (temp_object instanceof SelectPaths) {
        if (((SelectPaths) temp_object).owner == (ESelect_type) ut) {
          paths1 = (SelectPaths) temp_object;
          select_type = paths1.select_type;
        }
      }

      if (paths1 == null) {
        int count = 1;
        int[] indeces = new int[500];
        int depth = 0;
        int depth_count = 0;
        boolean with_type = false;
        Vector current_nodes = new Vector();
        Vector current_node_strings = new Vector();
        paths1 = new SelectPaths();
        paths1.owner = (ESelect_type) ut;
        select_type = calculateSelectPaths(count, current_nodes, current_node_strings, indeces, 
                                           depth, depth_count, paths1, (ESelect_type) ut, with_type);
        paths1.removeIdentical();
        paths1.select_type = select_type;
        ut.setTemp(paths1);
      }

      pw.println("\t// -1- methods for SELECT attribute: " + attr_name);

      if (select_type > 0) { // includes defined_types
      }

      if ((select_type == 0) || (select_type == 2)) { // includes direct entities

        // cannot use this, because in this case also may be one or more entities - a specific or a generic case
      }

      // so maybe also get/set methods should have not only generic EEntity return type/value but in case of only one entity - the specific one?
      select_loops = new HashSet();
      Object result = entitiesInSelect((ESelect_type) ut, null);

      if (result instanceof EEntity_definition) {
      
      	if (ut instanceof EExtensible_select_type) {
	        pw.println("\tpublic static int usedin" + method_suffix + "(" + owning_entity_name + 
  	                 " type, EEntity instance, ASdaiModel domain, AEntity result) throws SdaiException {");
    	    pw.println("\t\treturn ((CEntity)instance).makeUsedin(definition, " + attr_internal_name + 
      	             "$, domain, result);");
        	pw.println("\t}");
				} else {       
        // specific entity
        EEntity_definition spec_ed = (EEntity_definition) result;
        String spec_part_name = spec_ed.getName(null);
        String spec_name = getEntityPackage(spec_ed) + "E" + 
                           spec_part_name.substring(0, 1).toUpperCase() + 
                           spec_part_name.substring(1).toLowerCase();


        //            pw.println("\t// ******* usedin with specific entity: " + spec_name);
        pw.println("\tpublic static int usedin" + method_suffix + "(" + owning_entity_name + " type, " + spec_name + " instance, ASdaiModel domain, AEntity result) throws SdaiException {");
        pw.println("\t\treturn ((CEntity)instance).makeUsedin(definition, " + attr_internal_name + "$, domain, result);");
        pw.println("\t}");


      
    		}
      } else if (result instanceof Integer) {
        // general entity
        //            pw.println("\t// =========== usedin with generic entity");
        pw.println("\tpublic static int usedin" + method_suffix + "(" + owning_entity_name + 
                   " type, EEntity instance, ASdaiModel domain, AEntity result) throws SdaiException {");
        pw.println("\t\treturn ((CEntity)instance).makeUsedin(definition, " + attr_internal_name + 
                   "$, domain, result);");
        pw.println("\t}");
      } else {
        // should be null, no entity found, usedin() not needed.
      	if (ut instanceof EExtensible_select_type) {
	        pw.println("\tpublic static int usedin" + method_suffix + "(" + owning_entity_name + 
  	                 " type, EEntity instance, ASdaiModel domain, AEntity result) throws SdaiException {");
    	    pw.println("\t\treturn ((CEntity)instance).makeUsedin(definition, " + attr_internal_name + 
      	             "$, domain, result);");
        	pw.println("\t}");
      	}
      }
    }
  }





  void generateExplicitAttributeDefinedTypeMethodsUsedinOnly(EDefined_type dt, PrintWriter pw, 
                                                             String entity_name, String attr_name, 
                                                             String method_suffix, 
                                                             String owning_entity_name, 
                                                             String attr_internal_name)
                                                      throws SdaiException {
    EEntity ut = dt.getDomain(null);

    if (ut instanceof ESimple_type) {
    } else if (ut instanceof EAggregation_type) {
      generateExplicitAttributeAggregationTypeMethodsUsedinOnly((EAggregation_type) ut, pw, 
                                                                entity_name, attr_name, 
                                                                method_suffix, owning_entity_name, 
                                                                attr_internal_name);
    } else if (ut instanceof EDefined_type) {
      generateExplicitAttributeDefinedTypeMethodsUsedinOnly((EDefined_type) ut, pw, entity_name, 
                                                            attr_name, method_suffix, 
                                                            owning_entity_name, attr_internal_name);
    
    
    } else if (ut instanceof ESelect_type) {
//      ANamed_type nt = ((ESelect_type) ut).getSelections(null);
//      ANamed_type nt = ((ESelect_type) ut).getLocal_selections(null);
      ANamed_type nt = getSelections((ESelect_type) ut);

      //         int select_type = calculateSelectPaths(nt); // 0 - pure entity, 1 - pure defined_type or 2 - mixed select
      SelectPaths paths1 = null;
      int select_type = Integer.MIN_VALUE;
      Object temp_object = ut.getTemp();

      if (temp_object instanceof SelectPaths) {
        if (((SelectPaths) temp_object).owner == (ESelect_type) ut) {
          paths1 = (SelectPaths) temp_object;
          select_type = paths1.select_type;
        }
      }

      if (paths1 == null) {
        int count = 1;
        int[] indeces = new int[500];
        int depth = 0;
        int depth_count = 0;
        boolean with_type = false;
        Vector current_nodes = new Vector();
        Vector current_node_strings = new Vector();
        paths1 = new SelectPaths();
        paths1.owner = (ESelect_type) ut;
        select_type = calculateSelectPaths(count, current_nodes, current_node_strings, indeces, 
                                           depth, depth_count, paths1, (ESelect_type) ut, with_type);
        paths1.removeIdentical();
        paths1.select_type = select_type;
        ut.setTemp(paths1);
      }

      pw.println("\t// -1- methods for SELECT attribute: " + attr_name);

      if (select_type > 0) { // includes defined_types
      }

      if ((select_type == 0) || (select_type == 2)) { // includes direct entities

        // cannot use this, because in this case also may be one or more entities - a specific or a generic case
      }

      // so maybe also get/set methods should have not only generic EEntity return type/value but in case of only one entity - the specific one?
      select_loops = new HashSet();
      Object result = entitiesInSelect((ESelect_type) ut, null);

      if (result instanceof EEntity_definition) {
      
      	if (ut instanceof EExtensible_select_type) {
	        pw.println("\tpublic static int usedin" + method_suffix + "(" + owning_entity_name + 
  	                 " type, EEntity instance, ASdaiModel domain, AEntity result) throws SdaiException {");
    	    pw.println("\t\treturn ((CEntity)instance).makeUsedin(definition, " + attr_internal_name + 
      	             "$, domain, result);");
        	pw.println("\t}");
				} else {       
        // specific entity
        EEntity_definition spec_ed = (EEntity_definition) result;
        String spec_part_name = spec_ed.getName(null);
        String spec_name = getEntityPackage(spec_ed) + "E" + 
                           spec_part_name.substring(0, 1).toUpperCase() + 
                           spec_part_name.substring(1).toLowerCase();


        //            pw.println("\t// ******* usedin with specific entity: " + spec_name);
        pw.println("\tpublic static int usedin" + method_suffix + "(" + owning_entity_name + 
                   " type, " + spec_name + 
                   " instance, ASdaiModel domain, AEntity result) throws SdaiException {");
        pw.println("\t\treturn ((CEntity)instance).makeUsedin(definition, " + attr_internal_name + 
                   "$, domain, result);");
        pw.println("\t}");
      
    		}
      } else if (result instanceof Integer) {
        // general entity
        //            pw.println("\t// =========== usedin with generic entity");
        pw.println("\tpublic static int usedin" + method_suffix + "(" + owning_entity_name + 
                   " type, EEntity instance, ASdaiModel domain, AEntity result) throws SdaiException {");
        pw.println("\t\treturn ((CEntity)instance).makeUsedin(definition, " + attr_internal_name + 
                   "$, domain, result);");
        pw.println("\t}");
      } else {
        // should be null, no entity found, usedin() not needed.
      	if (ut instanceof EExtensible_select_type) {
	        pw.println("\tpublic static int usedin" + method_suffix + "(" + owning_entity_name + 
  	                 " type, EEntity instance, ASdaiModel domain, AEntity result) throws SdaiException {");
    	    pw.println("\t\treturn ((CEntity)instance).makeUsedin(definition, " + attr_internal_name + 
      	             "$, domain, result);");
        	pw.println("\t}");
      	}
      }
    }
  }




  void generateExplicitAttributeDefinedTypeMethods(EDefined_type dt, PrintWriter pw, 
                                                   String entity_name, String attr_name, 
                                                   String method_suffix, String owning_entity_name, 
                                                   String attr_internal_name)
                                            throws SdaiException {
    EEntity ut = dt.getDomain(null);

    if (ut instanceof ESimple_type) {
      generateExplicitAttributeSimpleTypeMethods((ESimple_type) ut, pw, entity_name, attr_name, 
                                                 method_suffix, owning_entity_name, 
                                                 attr_internal_name);
    } else if (ut instanceof EAggregation_type) {
      generateExplicitAttributeAggregationTypeMethods((EAggregation_type) ut, pw, entity_name, 
                                                      attr_name, method_suffix, owning_entity_name, 
                                                      attr_internal_name);
    } else if (ut instanceof EDefined_type) {
      generateExplicitAttributeDefinedTypeMethods((EDefined_type) ut, pw, entity_name, attr_name, 
                                                  method_suffix, owning_entity_name, 
                                                  attr_internal_name);
    } else if (ut instanceof EEnumeration_type) {
//      A_string enelements = ((EEnumeration_type) ut).getElements(null);
//      A_string enelements = ((EEnumeration_type) ut).getLocal_elements(null);
//      A_string enelements = getElements((EEnumeration_type) ut);
      Vector enelements = getElementsV((EEnumeration_type) ut);


      //         generateEnumerationMethods((EEnumeration_type)ut, pw, entity_name, attr_name, method_suffix);
      pw.println("\t// attribute:" + attr_name + ", base type: ENUMERATION");
      pw.println("\tpublic boolean test" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\treturn test_enumeration(" + attr_internal_name + ");");
      pw.println("\t}");
      pw.println("\tpublic int get" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\treturn get_enumeration(" + attr_internal_name + ");");
      pw.println("\t}");
      pw.println("\tpublic void set" + method_suffix + "(" + owning_entity_name + 
                 " type, int value) throws " + "SdaiException {");
      pw.println("\t\t" + attr_internal_name + " = set_enumeration(value, " + attr_internal_name + 
                 "$);");
      pw.println("\t}");
      pw.println("\tpublic void unset" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\t" + attr_internal_name + " = unset_enumeration();");
      pw.println("\t}");
    } else if (ut instanceof ESelect_type) {
//      ANamed_type nt = ((ESelect_type) ut).getSelections(null);
//      ANamed_type nt = ((ESelect_type) ut).getLocal_selections(null);
      ANamed_type nt = getSelections((ESelect_type) ut);

      //         int select_type = calculateSelectPaths(nt); // 0 - pure entity, 1 - pure defined_type or 2 - mixed select
      SelectPaths paths1 = null;
      int select_type = Integer.MIN_VALUE;
      Object temp_object = ut.getTemp();

      if (temp_object instanceof SelectPaths) {
        if (((SelectPaths) temp_object).owner == (ESelect_type) ut) {
          paths1 = (SelectPaths) temp_object;
          select_type = paths1.select_type;
        }
      }

      if (paths1 == null) {
        int count = 1;
        int[] indeces = new int[500];
        int depth = 0;
        int depth_count = 0;
        boolean with_type = false;
        Vector current_nodes = new Vector();
        Vector current_node_strings = new Vector();
        paths1 = new SelectPaths();
        paths1.owner = (ESelect_type) ut;
        select_type = calculateSelectPaths(count, current_nodes, current_node_strings, indeces, 
                                           depth, depth_count, paths1, (ESelect_type) ut, with_type);
        paths1.removeIdentical();
        paths1.select_type = select_type;
        ut.setTemp(paths1);
      }


      //         pw.println("\t// RRRRR select_type: " + select_type);
      // pw.println("debug: " + select_type);
      pw.println("\t// -2- methods for SELECT attribute: " + attr_name);

      if (select_type > 0) { // includes defined_types

        //            paths1.generateConstants(pw, attr_name);
        //            pw.println("");
      }

      /*
      if (select_type < 2) { // includes entieties
         generateEntityMethodDeclarationsForSelect((ESelect_type)ut, pw, entity_name, attr_name, method_suffix);
      } 
      if (select_type > 0) { // includes defined_types
         paths1.generateDefinedTypeGetMethodDeclarations((ESelect_type)ut, pw, entity_name, attr_name, method_suffix);
      }
       */

      //         pw.println("\tint test" + normalize(attr_name) + "(" + owning_entity_name + " type) throws SdaiException {");
      if ((select_type == 0) || (select_type == 2)) { // includes direct entities

        // cannot use this, because in this case also may be one or more entities - a specific or a generic case
      }

      // so maybe also get/set methods should have not only generic EEntity return type/value but in case of only one entity - the specific one?
      select_loops = new HashSet();
      Object result = entitiesInSelect((ESelect_type) ut, null);

      if (result instanceof EEntity_definition) {
	     	if (ut instanceof EExtensible_select_type) {










  	      pw.println("\tpublic static int usedin" + method_suffix + "(" + owning_entity_name + " type, EEntity instance, ASdaiModel domain, AEntity result) throws SdaiException {");
      	  pw.println("\t\treturn ((CEntity)instance).makeUsedin(definition, " + attr_internal_name + "$, domain, result);");
	        pw.println("\t}");



      	} else {

        // specific entity
        EEntity_definition spec_ed = (EEntity_definition) result;
        String spec_part_name = spec_ed.getName(null);
        String spec_name = getEntityPackage(spec_ed) + "E" + 
                           spec_part_name.substring(0, 1).toUpperCase() + 
                           spec_part_name.substring(1).toLowerCase();












        //            pw.println("\t// ******* usedin with specific entity: " + spec_name);
        pw.println("\tpublic static int usedin" + method_suffix + "(" + owning_entity_name + " type, " + spec_name + " instance, ASdaiModel domain, AEntity result) throws SdaiException {");
        pw.println("\t\treturn ((CEntity)instance).makeUsedin(definition, " + attr_internal_name + "$, domain, result);");
        pw.println("\t}");
				
				}
      } else if (result instanceof Integer) {
        // general entity
        //            pw.println("\t// =========== usedin with generic entity");
        pw.println("\tpublic static int usedin" + method_suffix + "(" + owning_entity_name + 
                   " type, EEntity instance, ASdaiModel domain, AEntity result) throws SdaiException {");
        pw.println("\t\treturn ((CEntity)instance).makeUsedin(definition, " + attr_internal_name + 
                   "$, domain, result);");
        pw.println("\t}");
      } else {
        // should be null, no entity found, usedin() not needed.
        //            pw.println("\t// usedin not needed");
      
	     	if (ut instanceof EExtensible_select_type) {
  	      pw.println("\tpublic static int usedin" + method_suffix + "(" + owning_entity_name + 
    	               " type, EEntity instance, ASdaiModel domain, AEntity result) throws SdaiException {");
      	  pw.println("\t\treturn ((CEntity)instance).makeUsedin(definition, " + attr_internal_name + 
        	           "$, domain, result);");
	        pw.println("\t}");
      	}
      }

      if (select_type == 0) { // only pure entity selects

        //            pw.println("\t\treturn test_select(" + attr_internal_name + ", 1);");
        pw.println("\tpublic boolean test" + method_suffix + "(" + owning_entity_name + 
                   " type) throws SdaiException {");
        pw.println("\t\treturn test_instance(" + attr_internal_name + ");");
      } else {
        pw.println("\tpublic int test" + method_suffix + "(" + owning_entity_name + 
                   " type) throws SdaiException {");
        pw.println("\t\treturn test_select(" + attr_internal_name + ", " + attr_internal_name + 
                   "$$);");
      }

      pw.println("\t}");
      pw.println("");
      paths1.generateGetMethods((ESelect_type) ut, pw, entity_name, attr_name, method_suffix, 
                                select_type, owning_entity_name, attr_internal_name);
      pw.println("");
      paths1.generateSetMethods((ESelect_type) ut, pw, entity_name, attr_name, method_suffix, 
                                select_type, owning_entity_name, attr_internal_name);
      pw.println("");


      //         pw.println("\tvoid unset" + normalize(attr_name) + "(" + entity_name + " type) throws SdaiException {");
      pw.println("\tpublic void unset" + method_suffix + "(" + owning_entity_name + 
                 " type) throws SdaiException {");

      if (select_type != 0) {
        pw.println("\t\t" + attr_internal_name + " = unset_select(" + attr_internal_name + ");");
        pw.println("\t\t" + attr_internal_name + "$$ = 0;");
      } else {
        pw.println("\t\t" + attr_internal_name + " = unset_instance(" + attr_internal_name + 
                   ");");
      }

      pw.println("\t}");
      pw.println("");
    }
  }



  void generateExplicitAttributeDefinedTypeMethodsRenamed(EDefined_type dt, PrintWriter pw, 
                                                   String entity_name, String attr_name, 
                                                   String method_suffix, String owning_entity_name, 
                                                   String attr_internal_name,
                                                   EExplicit_attribute xattr, 
                                                   String method_suffix_prev, 
                                                   String owning_entity_name_prev, 
                                                   String package_prev)
                                            throws SdaiException {


//	EExplicit_attribute xattr_original = getOriginalExplicitAttribute(xattr);

  // EEntity bt = xattr_original.getDomain(null);
  
//  if (bt instanceof EDefined_type) {
//		if (dt != bt - more complicated than that, will have to check domain below first?
//		dt = (EDefined_type)bt;
//	}




    EEntity ut = dt.getDomain(null);

    if (ut instanceof ESimple_type) {
//t      generateExplicitAttributeSimpleTypeMethods((ESimple_type) ut, pw, entity_name, attr_name, 
//t                                                 method_suffix, owning_entity_name, 
//t                                                 attr_internal_name);
			generateExplicitAttributeSimpleTypeMethodsRenamed((ESimple_type) ut, pw, entity_name, attr_name, 
                                                     method_suffix, owning_entity_name, 
                                                     attr_internal_name,
 																											xattr, method_suffix_prev, owning_entity_name_prev, package_prev);


    } else if (ut instanceof EAggregation_type) {
//t      generateExplicitAttributeAggregationTypeMethods((EAggregation_type) ut, pw, entity_name, 
//t                                                      attr_name, method_suffix, owning_entity_name, 
//t                                                      attr_internal_name);
			generateExplicitAttributeAggregationTypeMethodsRenamed((EAggregation_type)ut, pw, entity_name, 
                                                          attr_name, method_suffix, 
                                                          owning_entity_name, attr_internal_name, xattr, 
                                                          method_suffix_prev, owning_entity_name_prev, package_prev);


    } else if (ut instanceof EDefined_type) {
//t      generateExplicitAttributeDefinedTypeMethods((EDefined_type) ut, pw, entity_name, attr_name, 
//t                                                  method_suffix, owning_entity_name, 
//t                                                  attr_internal_name);
			generateExplicitAttributeDefinedTypeMethodsRenamed((EDefined_type)ut, pw, 
                                                   entity_name, attr_name, 
                                                   method_suffix, owning_entity_name, 
                                                   attr_internal_name,
                                                   xattr, 
                                                   method_suffix_prev, 
                                                   owning_entity_name_prev, 
                                                   package_prev);

    } else if (ut instanceof EEnumeration_type) {
//      A_string enelements = ((EEnumeration_type) ut).getElements(null);
//      A_string enelements = ((EEnumeration_type) ut).getLocal_elements(null);
//      A_string enelements = getElements((EEnumeration_type) ut);
      Vector enelements = getElementsV((EEnumeration_type) ut);


      //         generateEnumerationMethods((EEnumeration_type)ut, pw, entity_name, attr_name, method_suffix);
/* t
      pw.println("\t// attribute:" + attr_name + ", base type: ENUMERATION");
      pw.println("\tpublic boolean test" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\treturn test_enumeration(" + attr_internal_name + ");");
      pw.println("\t}");
      pw.println("\tpublic int get" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\treturn get_enumeration(" + attr_internal_name + ");");
      pw.println("\t}");
      pw.println("\tpublic void set" + method_suffix + "(" + owning_entity_name + 
                 " type, int value) throws " + "SdaiException {");
      pw.println("\t\t" + attr_internal_name + " = set_enumeration(value, " + attr_internal_name + 
                 "$);");
      pw.println("\t}");
      pw.println("\tpublic void unset" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\t" + attr_internal_name + " = unset_enumeration();");
      pw.println("\t}");
*/   
    } else if (ut instanceof ESelect_type) {
//      ANamed_type nt = ((ESelect_type) ut).getSelections(null);
//      ANamed_type nt = ((ESelect_type) ut).getLocal_selections(null);
      ANamed_type nt = getSelections((ESelect_type) ut);

      //         int select_type = calculateSelectPaths(nt); // 0 - pure entity, 1 - pure defined_type or 2 - mixed select
      SelectPaths paths1 = null;
      int select_type = Integer.MIN_VALUE;
      Object temp_object = ut.getTemp();

      if (temp_object instanceof SelectPaths) {
        if (((SelectPaths) temp_object).owner == (ESelect_type) ut) {
          paths1 = (SelectPaths) temp_object;
          select_type = paths1.select_type;
        }
      }

      if (paths1 == null) {
        int count = 1;
        int[] indeces = new int[500];
        int depth = 0;
        int depth_count = 0;
        boolean with_type = false;
        Vector current_nodes = new Vector();
        Vector current_node_strings = new Vector();
        paths1 = new SelectPaths();
        paths1.owner = (ESelect_type) ut;
        select_type = calculateSelectPaths(count, current_nodes, current_node_strings, indeces, 
                                           depth, depth_count, paths1, (ESelect_type) ut, with_type);
        paths1.removeIdentical();
        paths1.select_type = select_type;
        ut.setTemp(paths1);
      }


      //         pw.println("\t// RRRRR select_type: " + select_type);
      // pw.println("debug: " + select_type);
      pw.println("\t// -3- methods for SELECT attribute: " + attr_name);

      if (select_type > 0) { // includes defined_types

        //            paths1.generateConstants(pw, attr_name);
        //            pw.println("");
      }

      /*
      if (select_type < 2) { // includes entieties
         generateEntityMethodDeclarationsForSelect((ESelect_type)ut, pw, entity_name, attr_name, method_suffix);
      } 
      if (select_type > 0) { // includes defined_types
         paths1.generateDefinedTypeGetMethodDeclarations((ESelect_type)ut, pw, entity_name, attr_name, method_suffix);
      }
       */

      //         pw.println("\tint test" + normalize(attr_name) + "(" + owning_entity_name + " type) throws SdaiException {");
      if ((select_type == 0) || (select_type == 2)) { // includes direct entities

        // cannot use this, because in this case also may be one or more entities - a specific or a generic case
      }

      // so maybe also get/set methods should have not only generic EEntity return type/value but in case of only one entity - the specific one?
      select_loops = new HashSet();
      Object result = entitiesInSelect((ESelect_type) ut, null);

      if (result instanceof EEntity_definition) {
	     	if (ut instanceof EExtensible_select_type) {

/*
  	      pw.println("\tpublic static int usedin" + method_suffix + "(" + owning_entity_name + " type, EEntity instance, ASdaiModel domain, AEntity result) throws SdaiException {");
//      	  pw.println("\t\treturn ((CEntity)instance).makeUsedin(definition, " + attr_internal_name + "$, domain, result);");
  	      pw.println("\t\treturn usedin" + method_suffix_prev + "((" + owning_entity_name_prev + ")null, instance, domain, result);");
	        pw.println("\t}");
*/
//USEDIN-RENAMED
//          pw.println("\tpublic static int usedin" + method_suffix + "(" + owning_entity_name + " type, " + base_name + " instance, ASdaiModel domain, AEntity result) throws SdaiException {");
pw.println("// USEDIN-RENAMED-02");
  	      pw.println("\tpublic static int usedin" + method_suffix + "(" + owning_entity_name + " type, EEntity instance, ASdaiModel domain, AEntity result) throws SdaiException {");
          pw.println("\t\treturn ((CEntity)instance).makeUsedin(definition, " + attr_internal_name + "$, domain, result);");
          pw.println("\t}");



      	} else {

        // specific entity
        EEntity_definition spec_ed = (EEntity_definition) result;
        String spec_part_name = spec_ed.getName(null);
        String spec_name = getEntityPackage(spec_ed) + "E" + 
                           spec_part_name.substring(0, 1).toUpperCase() + 
                           spec_part_name.substring(1).toLowerCase();


        //            pw.println("\t// ******* usedin with specific entity: " + spec_name);
/*
        pw.println("\tpublic static int usedin" + method_suffix + "(" + owning_entity_name + " type, " + spec_name + " instance, ASdaiModel domain, AEntity result) throws SdaiException {");
//        pw.println("\t\treturn ((CEntity)instance).makeUsedin(definition, " + attr_internal_name + "$, domain, result);");
        pw.println("\t\treturn usedin" + method_suffix_prev + "((" + owning_entity_name_prev + ")null, instance, domain, result);");
        pw.println("\t}");
*/
//USEDIN-RENAMED
//          pw.println("\tpublic static int usedin" + method_suffix + "(" + owning_entity_name + " type, " + base_name + " instance, ASdaiModel domain, AEntity result) throws SdaiException {");
//  	      pw.println("\tpublic static int usedin" + method_suffix + "(" + owning_entity_name + " type, EEntity instance, ASdaiModel domain, AEntity result) throws SdaiException {");
pw.println("// USEDIN-RENAMED-03");
	       pw.println("\tpublic static int usedin" + method_suffix + "(" + owning_entity_name + " type, " + spec_name + " instance, ASdaiModel domain, AEntity result) throws SdaiException {");
         pw.println("\t\treturn ((CEntity)instance).makeUsedin(definition, " + attr_internal_name + "$, domain, result);");
         pw.println("\t}");


				
				}
      } else if (result instanceof Integer) {
        // general entity
        //            pw.println("\t// =========== usedin with generic entity");
//USEDIN-RENAMED
pw.println("// USEDIN-RENAMED-04");
        pw.println("\tpublic static int usedin" + method_suffix + "(" + owning_entity_name + " type, EEntity instance, ASdaiModel domain, AEntity result) throws SdaiException {");
//        pw.println("\t\treturn ((CEntity)instance).makeUsedin(definition, " + attr_internal_name + "$, domain, result);");
//        pw.println("\t\treturn usedin" + method_suffix_prev + "((" + owning_entity_name_prev + ")null, instance, domain, result);");
         pw.println("\t\treturn ((CEntity)instance).makeUsedin(definition, " + attr_internal_name + "$, domain, result);");
        pw.println("\t}");


      } else {
        // should be null, no entity found, usedin() not needed.
        //            pw.println("\t// usedin not needed");
      
	     	if (ut instanceof EExtensible_select_type) {
//USEDIN-RENAMED
pw.println("// USEDIN-RENAMED-05");
  	      pw.println("\tpublic static int usedin" + method_suffix + "(" + owning_entity_name + " type, EEntity instance, ASdaiModel domain, AEntity result) throws SdaiException {");
//      	  pw.println("\t\treturn ((CEntity)instance).makeUsedin(definition, " + attr_internal_name + "$, domain, result);");
//  	      pw.println("\t\treturn usedin" + method_suffix_prev + "((" + owning_entity_name_prev + ")null, instance, domain, result);");
	         pw.println("\t\treturn ((CEntity)instance).makeUsedin(definition, " + attr_internal_name + "$, domain, result);");
	        pw.println("\t}");
      	}
      }

      if (select_type == 0) { // only pure entity selects

        //            pw.println("\t\treturn test_select(" + attr_internal_name + ", 1);");
        pw.println("\tpublic boolean test" + method_suffix + "(" + owning_entity_name + " type) throws SdaiException {");
//        pw.println("\t\treturn test_instance(" + attr_internal_name + ");");
        pw.println("\t\treturn test" + method_suffix_prev + "((" + owning_entity_name_prev + ")null);");
      } else {
        pw.println("\tpublic int test" + method_suffix + "(" + owning_entity_name + " type) throws SdaiException {");
//        pw.println("\t\treturn test_select(" + attr_internal_name + ", " + attr_internal_name + "$$);");
        pw.println("\t\treturn test" + method_suffix_prev + "((" + owning_entity_name_prev + ")null);");
      }

      pw.println("\t}");
	      pw.println("");
      paths1.generateGetMethodsRenamed((ESelect_type) ut, pw, entity_name, attr_name, method_suffix, select_type, owning_entity_name, attr_internal_name, method_suffix_prev, owning_entity_name_prev);
      pw.println("");
      paths1.generateSetMethodsRenamed((ESelect_type) ut, pw, entity_name, attr_name, method_suffix, select_type, owning_entity_name, attr_internal_name, method_suffix_prev, owning_entity_name_prev);
      pw.println("");


      //         pw.println("\tvoid unset" + normalize(attr_name) + "(" + entity_name + " type) throws SdaiException {");
      pw.println("\tpublic void unset" + method_suffix + "(" + owning_entity_name + " type) throws SdaiException {");
      pw.println("\t\tunset" + method_suffix_prev + "((" + owning_entity_name_prev + ")null);");


/*
      if (select_type != 0) {
        pw.println("\t\t" + attr_internal_name + "$$ = 0;");
        pw.println("\t\t" + attr_internal_name + " = unset_select(" + attr_internal_name + ");");
      } else {
        pw.println("\t\t" + attr_internal_name + " = unset_instance(" + attr_internal_name + ");");
      }
*/
      pw.println("\t}");
      pw.println("");
    }
  }



  // spec aggregation method for usedin only
  void generateExplicitAttributeAggregationTypeMethodsUsedinOnlyRenamed(EAggregation_type at, 
                                                                 PrintWriter pw, String entity_name, 
                                                                 String attr_name, 
                                                                 String method_suffix, 
                                                                 String owning_entity_name, 
                                                                 String attr_internal_name)
    throws SdaiException {
    String comment = "";

    if (at instanceof EArray_type) {
      comment += "ARRAY OF ";
    } else if (at instanceof EBag_type) {
      comment += "BAG OF ";
    } else if (at instanceof ESet_type) {
      comment += "SET OF ";
    } else if (at instanceof EList_type) {
      comment += "LIST OF ";
    }

    int aggregate_depth = 1;
    EEntity an_ss;
    EEntity ass = at;
    String aggr_prefices = "";
    an_ss = at.getElement_type(null);

    for (;;) {
      boolean done_something = false;

      if (an_ss instanceof EDefined_type) {
        ass = an_ss;
        an_ss = ((EDefined_type) an_ss).getDomain(null);
        done_something = true;
      } else if (an_ss instanceof EAggregation_type) {
        aggr_prefices += "a";
        aggregate_depth++;
        ass = an_ss;

        if (ass instanceof EArray_type) {
          comment += "ARRAY OF ";
        } else if (ass instanceof EBag_type) {
          comment += "BAG OF ";
        } else if (ass instanceof ESet_type) {
          comment += "SET OF ";
        } else if (ass instanceof EList_type) {
          comment += "LIST OF ";
        }

        an_ss = ((EAggregation_type) an_ss).getElement_type(null);
        done_something = true;
      }

      if (!done_something) {
        break;
      }
    }

    String aggr_prefix = "A" + aggr_prefices;
    String aggr_nesting = "";

    if (aggregate_depth > 1) {
      aggr_nesting += aggregate_depth;
    }


    if (an_ss instanceof ESelect_type) {
      pw.println("\t// methods for attribute: " + attr_name + ", base type: " + comment + 
                 "SELECT");

      select_loops = new HashSet();
      Object result = entitiesInSelect((ESelect_type) an_ss, null);

      if (result instanceof EEntity_definition) {
	     	if (an_ss  instanceof EExtensible_select_type) {
	        pw.println("\tpublic static int usedin" + method_suffix + "(" + owning_entity_name + 
  	                 " type, EEntity instance, ASdaiModel domain, AEntity result) throws SdaiException {");
    	    pw.println("\t\treturn ((CEntity)instance).makeUsedin(definition, " + attr_internal_name + 
      	             "$, domain, result);");
        	pw.println("\t}");
      	} else {


        // specific entity
        EEntity_definition spec_ed = (EEntity_definition) result;
        String spec_part_name = spec_ed.getName(null);
        String spec_name = getEntityPackage(spec_ed) + "E" + 
                           spec_part_name.substring(0, 1).toUpperCase() + 
                           spec_part_name.substring(1).toLowerCase();
        pw.println("\tpublic static int usedin" + method_suffix + "(" + owning_entity_name + 
                   " type, " + spec_name + 
                   " instance, ASdaiModel domain, AEntity result) throws SdaiException {");
        pw.println("\t\treturn ((CEntity)instance).makeUsedin(definition, " + attr_internal_name + 
                   "$, domain, result);");
        pw.println("\t}");

}

      } else if (result instanceof Integer) {
        // general entity
        pw.println("\tpublic static int usedin" + method_suffix + "(" + owning_entity_name + 
                   " type, EEntity instance, ASdaiModel domain, AEntity result) throws SdaiException {");
        pw.println("\t\treturn ((CEntity)instance).makeUsedin(definition, " + attr_internal_name + 
                   "$, domain, result);");
        pw.println("\t}");
      } else {
        // should be null, no entity found, usedin() not needed.
	     	if (an_ss  instanceof EExtensible_select_type) {
	        pw.println("\tpublic static int usedin" + method_suffix + "(" + owning_entity_name + 
  	                 " type, EEntity instance, ASdaiModel domain, AEntity result) throws SdaiException {");
    	    pw.println("\t\treturn ((CEntity)instance).makeUsedin(definition, " + attr_internal_name + 
      	             "$, domain, result);");
        	pw.println("\t}");
      	}
      }
    } else if (an_ss instanceof EEntity_definition) {
      String base_entity_name = ((EEntity_definition) an_ss).getName(null);
      String base_name = getEntityPackage((EEntity_definition) an_ss) + "E" + 
                         base_entity_name.substring(0, 1).toUpperCase() + 
                         base_entity_name.substring(1).toLowerCase();
      pw.println("\t// methods for attribute: " + attr_name + ", base type: " + comment + 
                 "ENTITY");
      pw.println("\tpublic static int usedin" + method_suffix + "(" + owning_entity_name + 
                 " type, " + base_name + 
                 " instance, ASdaiModel domain, AEntity result) throws SdaiException {");
      pw.println("\t\treturn ((CEntity)instance).makeUsedin(definition, " + attr_internal_name + 
                 "$, domain, result);");
      pw.println("\t}");
    } else if (an_ss instanceof EEnumeration_type) {
    } else if (an_ss instanceof EInteger_type) {
    } else if (an_ss instanceof ENumber_type) {
    } else if (an_ss instanceof EReal_type) {
    } else if (an_ss instanceof EString_type) {
    } else if (an_ss instanceof ELogical_type) {
    } else if (an_ss instanceof EBoolean_type) {
    } else if (an_ss instanceof EBinary_type) {
    }
  }



  // spec aggregation method for usedin only
  void generateExplicitAttributeAggregationTypeMethodsUsedinOnly(EAggregation_type at, 
                                                                 PrintWriter pw, String entity_name, 
                                                                 String attr_name, 
                                                                 String method_suffix, 
                                                                 String owning_entity_name, 
                                                                 String attr_internal_name)
    throws SdaiException {
    String comment = "";

    if (at instanceof EArray_type) {
      comment += "ARRAY OF ";
    } else if (at instanceof EBag_type) {
      comment += "BAG OF ";
    } else if (at instanceof ESet_type) {
      comment += "SET OF ";
    } else if (at instanceof EList_type) {
      comment += "LIST OF ";
    }

    int aggregate_depth = 1;
    EEntity an_ss;
    EEntity ass = at;
    String aggr_prefices = "";
    an_ss = at.getElement_type(null);

    for (;;) {
      boolean done_something = false;

      if (an_ss instanceof EDefined_type) {
        ass = an_ss;
        an_ss = ((EDefined_type) an_ss).getDomain(null);
        done_something = true;
      } else if (an_ss instanceof EAggregation_type) {
        aggr_prefices += "a";
        aggregate_depth++;
        ass = an_ss;

        if (ass instanceof EArray_type) {
          comment += "ARRAY OF ";
        } else if (ass instanceof EBag_type) {
          comment += "BAG OF ";
        } else if (ass instanceof ESet_type) {
          comment += "SET OF ";
        } else if (ass instanceof EList_type) {
          comment += "LIST OF ";
        }

        an_ss = ((EAggregation_type) an_ss).getElement_type(null);
        done_something = true;
      }

      if (!done_something) {
        break;
      }
    }

    String aggr_prefix = "A" + aggr_prefices;
    String aggr_nesting = "";

    if (aggregate_depth > 1) {
      aggr_nesting += aggregate_depth;
    }


    if (an_ss instanceof ESelect_type) {
      pw.println("\t// methods for attribute: " + attr_name + ", base type: " + comment + 
                 "SELECT");

      select_loops = new HashSet();
      Object result = entitiesInSelect((ESelect_type) an_ss, null);

      if (result instanceof EEntity_definition) {
	     	if (an_ss  instanceof EExtensible_select_type) {
	        pw.println("\tpublic static int usedin" + method_suffix + "(" + owning_entity_name + 
  	                 " type, EEntity instance, ASdaiModel domain, AEntity result) throws SdaiException {");
    	    pw.println("\t\treturn ((CEntity)instance).makeUsedin(definition, " + attr_internal_name + 
      	             "$, domain, result);");
        	pw.println("\t}");
      	} else {


        // specific entity
        EEntity_definition spec_ed = (EEntity_definition) result;
        String spec_part_name = spec_ed.getName(null);
        String spec_name = getEntityPackage(spec_ed) + "E" + 
                           spec_part_name.substring(0, 1).toUpperCase() + 
                           spec_part_name.substring(1).toLowerCase();
        pw.println("\tpublic static int usedin" + method_suffix + "(" + owning_entity_name + 
                   " type, " + spec_name + 
                   " instance, ASdaiModel domain, AEntity result) throws SdaiException {");
        pw.println("\t\treturn ((CEntity)instance).makeUsedin(definition, " + attr_internal_name + 
                   "$, domain, result);");
        pw.println("\t}");

}

      } else if (result instanceof Integer) {
        // general entity
        pw.println("\tpublic static int usedin" + method_suffix + "(" + owning_entity_name + 
                   " type, EEntity instance, ASdaiModel domain, AEntity result) throws SdaiException {");
        pw.println("\t\treturn ((CEntity)instance).makeUsedin(definition, " + attr_internal_name + 
                   "$, domain, result);");
        pw.println("\t}");
      } else {
        // should be null, no entity found, usedin() not needed.
	     	if (an_ss  instanceof EExtensible_select_type) {
	        pw.println("\tpublic static int usedin" + method_suffix + "(" + owning_entity_name + 
  	                 " type, EEntity instance, ASdaiModel domain, AEntity result) throws SdaiException {");
    	    pw.println("\t\treturn ((CEntity)instance).makeUsedin(definition, " + attr_internal_name + 
      	             "$, domain, result);");
        	pw.println("\t}");
      	}
      }
    } else if (an_ss instanceof EEntity_definition) {
      String base_entity_name = ((EEntity_definition) an_ss).getName(null);
      String base_name = getEntityPackage((EEntity_definition) an_ss) + "E" + 
                         base_entity_name.substring(0, 1).toUpperCase() + 
                         base_entity_name.substring(1).toLowerCase();
      pw.println("\t// methods for attribute: " + attr_name + ", base type: " + comment + 
                 "ENTITY");
      pw.println("\tpublic static int usedin" + method_suffix + "(" + owning_entity_name + 
                 " type, " + base_name + 
                 " instance, ASdaiModel domain, AEntity result) throws SdaiException {");
      pw.println("\t\treturn ((CEntity)instance).makeUsedin(definition, " + attr_internal_name + 
                 "$, domain, result);");
      pw.println("\t}");
    } else if (an_ss instanceof EEnumeration_type) {
    } else if (an_ss instanceof EInteger_type) {
    } else if (an_ss instanceof ENumber_type) {
    } else if (an_ss instanceof EReal_type) {
    } else if (an_ss instanceof EString_type) {
    } else if (an_ss instanceof ELogical_type) {
    } else if (an_ss instanceof EBoolean_type) {
    } else if (an_ss instanceof EBinary_type) {
    }
  }

  void delete_generateExplicitAttributeAggregationTypeMethods(EAggregation_type at, PrintWriter pw, 
                                                              String entity_name, String attr_name, 
                                                              String method_suffix, 
                                                              String owning_entity_name, 
                                                              String attr_internal_name)
    throws SdaiException {
    String comment = "";

    if (at instanceof EArray_type) {
      comment += "ARRAY OF ";
    } else if (at instanceof EBag_type) {
      comment += "BAG OF ";
    } else if (at instanceof ESet_type) {
      comment += "SET OF ";
    } else if (at instanceof EList_type) {
      comment += "LIST OF ";
    }

    int aggregate_depth = 1;
    EEntity an_ss;
    EEntity ass = at;
    String aggr_prefices = "";
    an_ss = at.getElement_type(null);

    for (;;) {
      boolean done_something = false;

      if (an_ss instanceof EDefined_type) {
        ass = an_ss;
        an_ss = ((EDefined_type) an_ss).getDomain(null);
        done_something = true;
      } else if (an_ss instanceof EAggregation_type) {
        aggr_prefices += "a";
        aggregate_depth++;
        ass = an_ss;

        if (ass instanceof EArray_type) {
          comment += "ARRAY OF ";
        } else if (ass instanceof EBag_type) {
          comment += "BAG OF ";
        } else if (ass instanceof ESet_type) {
          comment += "SET OF ";
        } else if (ass instanceof EList_type) {
          comment += "LIST OF ";
        }

        an_ss = ((EAggregation_type) an_ss).getElement_type(null);
        done_something = true;
      }

      if (!done_something) {
        break;
      }
    }

    String aggr_prefix = "A" + aggr_prefices;
    String aggr_nesting = "";

    if (aggregate_depth > 1) {
      aggr_nesting += aggregate_depth;
    }


    if (an_ss instanceof ESelect_type) {
      pw.println("\t// methods for attribute: " + attr_name + ", base type: " + comment + 
                 "SELECT");

      select_loops = new HashSet();
      Object result = entitiesInSelect((ESelect_type) an_ss, null);

      if (result instanceof EEntity_definition) {
		    if (an_ss instanceof EExtensible_select_type) {
	        pw.println("\tpublic static int usedin" + method_suffix + "(" + owning_entity_name + 
  	                 " type, EEntity instance, ASdaiModel domain, AEntity result) throws SdaiException {");
    	    pw.println("\t\treturn ((CEntity)instance).makeUsedin(definition, " + attr_internal_name + 
      	             "$, domain, result);");
        	pw.println("\t}");
				} else {


        // specific entity
        EEntity_definition spec_ed = (EEntity_definition) result;
        String spec_part_name = spec_ed.getName(null);
        String spec_name = getEntityPackage(spec_ed) + "E" + 
                           spec_part_name.substring(0, 1).toUpperCase() + 
                           spec_part_name.substring(1).toLowerCase();
        pw.println("\tpublic static int usedin" + method_suffix + "(" + owning_entity_name + 
                   " type, " + spec_name + 
                   " instance, ASdaiModel domain, AEntity result) throws SdaiException {");
        pw.println("\t\treturn ((CEntity)instance).makeUsedin(definition, " + attr_internal_name + 
                   "$, domain, result);");
        pw.println("\t}");

}
      } else if (result instanceof Integer) {
        // general entity
        pw.println("\tpublic static int usedin" + method_suffix + "(" + owning_entity_name + 
                   " type, EEntity instance, ASdaiModel domain, AEntity result) throws SdaiException {");
        pw.println("\t\treturn ((CEntity)instance).makeUsedin(definition, " + attr_internal_name + 
                   "$, domain, result);");
        pw.println("\t}");
      } else {
        // should be null, no entity found, usedin() not needed.
		    if (an_ss instanceof EExtensible_select_type) {
	        pw.println("\tpublic static int usedin" + method_suffix + "(" + owning_entity_name + 
  	                 " type, EEntity instance, ASdaiModel domain, AEntity result) throws SdaiException {");
    	    pw.println("\t\treturn ((CEntity)instance).makeUsedin(definition, " + attr_internal_name + 
      	             "$, domain, result);");
        	pw.println("\t}");
				}
      }

      pw.println("\tpublic boolean test" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\treturn test_aggregate(" + attr_internal_name + ");");
      pw.println("\t}");
      pw.println("\tpublic " + getAggregatePackage(aggr_prefix, ass) + " get" + method_suffix + 
                 "(" + owning_entity_name + " type) throws " + "SdaiException {");


      // wrong - an internal method from lang should be used
      pw.println("\t\tif (" + attr_internal_name + " == null)");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.VA_NSET);");
      pw.println("\t\treturn " + attr_internal_name + ";");
      pw.println("\t}");
      pw.println("\tpublic " + getAggregatePackage(aggr_prefix, ass) + " create" + method_suffix + 
                 "(" + owning_entity_name + " type) throws " + "SdaiException {");
      pw.println("\t\t" + attr_internal_name + " = (" + getAggregatePackage(aggr_prefix, ass) + 
                 ")create_aggregate_class(" + attr_internal_name + ", " + attr_internal_name + 
                 "$, " + getAggregatePackage(aggr_prefix, ass) + ".class, 0);");
      pw.println("\t\treturn " + attr_internal_name + ";");
      pw.println("\t}");
      pw.println("\tpublic void unset" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\tunset_aggregate(" + attr_internal_name + ");");
      pw.println("\t\t" + attr_internal_name + " = null;");
      pw.println("\t}");

      //         updateAggregateDepth((ENamed_type)ass, aggregate_depth);
    } else if (an_ss instanceof EEntity_definition) {
      String base_entity_name = ((EEntity_definition) an_ss).getName(null);
      String base_name = getEntityPackage((EEntity_definition) an_ss) + "E" + 
                         base_entity_name.substring(0, 1).toUpperCase() + 
                         base_entity_name.substring(1).toLowerCase();
      pw.println("\t// methods for attribute: " + attr_name + ", base type: " + comment + 
                 "ENTITY");
      pw.println("\tpublic static int usedin" + method_suffix + "(" + owning_entity_name + 
                 " type, " + base_name + 
                 " instance, ASdaiModel domain, AEntity result) throws SdaiException {");
      pw.println("\t\treturn ((CEntity)instance).makeUsedin(definition, " + attr_internal_name + 
                 "$, domain, result);");
      pw.println("\t}");
      pw.println("\tpublic boolean test" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\treturn test_aggregate(" + attr_internal_name + ");");
      pw.println("\t}");
      pw.println("\tpublic " + getAggregatePackage(aggr_prefix, an_ss) + " get" + method_suffix + 
                 "(" + owning_entity_name + " type) throws " + "SdaiException {");
      pw.println("\t\treturn (" + getAggregatePackage(aggr_prefix, an_ss) + ")get_aggregate(" + 
                 attr_internal_name + ");");
      pw.println("\t}");
      pw.println("\tpublic " + getAggregatePackage(aggr_prefix, an_ss) + " create" + 
                 method_suffix + "(" + owning_entity_name + " type) throws " + "SdaiException {");
      pw.println("\t\t" + attr_internal_name + " = (" + getAggregatePackage(aggr_prefix, an_ss) + 
                 ")create_aggregate_class(" + attr_internal_name + ", " + attr_internal_name + 
                 "$,  " + getAggregatePackage(aggr_prefix, an_ss) + ".class, 0);");
      pw.println("\t\treturn " + attr_internal_name + ";");
      pw.println("\t}");
      pw.println("\tpublic void unset" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\tunset_aggregate(" + attr_internal_name + ");");
      pw.println("\t\t" + attr_internal_name + " = null;");
      pw.println("\t}");

      //         updateAggregateDepth((ENamed_type)an_ss, aggregate_depth);
    } else if (an_ss instanceof EEnumeration_type) {
      pw.println("\t// methods for attribute: " + attr_name + ", base type: " + comment + 
                 "ENUMERATION");
      pw.println("\tpublic boolean test" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\treturn test_aggregate(" + attr_internal_name + ");");
      pw.println("\t}");
      pw.println("\tpublic " + aggr_prefix + "_enumeration get" + method_suffix + "(" + 
                 owning_entity_name + " type) throws " + "SdaiException {");
      pw.println("\t\treturn (" + aggr_prefix + "_enumeration)get_aggregate(" + 
                 attr_internal_name + ");");
      pw.println("\t}");
      pw.println("\tpublic " + aggr_prefix + "_enumeration create" + method_suffix + "(" + 
                 owning_entity_name + " type) throws " + "SdaiException {");
      pw.println("\t\t" + attr_internal_name + " = create_aggregate" + aggr_nesting + 
                 "_enumeration(" + attr_internal_name + ", " + attr_internal_name + "$, 0);");
      pw.println("\t\treturn " + attr_internal_name + ";");
      pw.println("\t}");
      pw.println("\tpublic void unset" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\tunset_aggregate(" + attr_internal_name + ");");
      pw.println("\t\t" + attr_internal_name + " = null;");
      pw.println("\t}");
    } else if (an_ss instanceof EInteger_type) {
      pw.println("\t// methods for attribute: " + attr_name + ", base type: " + comment + 
                 "INTEGER");
      pw.println("\tpublic boolean test" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\treturn test_aggregate(" + attr_internal_name + ");");
      pw.println("\t}");
      pw.println("\tpublic " + aggr_prefix + "_integer get" + method_suffix + "(" + 
                 owning_entity_name + " type) throws " + "SdaiException {");
      pw.println("\t\treturn (" + aggr_prefix + "_integer)get_aggregate(" + attr_internal_name + 
                 ");");
      pw.println("\t}");
      pw.println("\tpublic " + aggr_prefix + "_integer create" + method_suffix + "(" + 
                 owning_entity_name + " type) throws " + "SdaiException {");
      pw.println("\t\t" + attr_internal_name + " = create_aggregate" + aggr_nesting + 
                 "_integer(" + attr_internal_name + ", " + attr_internal_name + "$, 0);");
      pw.println("\t\treturn " + attr_internal_name + ";");
      pw.println("\t}");
      pw.println("\tpublic void unset" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\tunset_aggregate(" + attr_internal_name + ");");
      pw.println("\t\t" + attr_internal_name + " = null;");
      pw.println("\t}");
    } else if (an_ss instanceof ENumber_type) {
      pw.println("\t// methods for attribute: " + attr_name + ", base type: " + comment + 
                 "NUMBER");
      pw.println("\tpublic boolean test" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\treturn test_aggregate(" + attr_internal_name + ");");
      pw.println("\t}");
      pw.println("\tpublic " + aggr_prefix + "_double get" + method_suffix + "(" + 
                 owning_entity_name + " type) throws " + "SdaiException {");
      pw.println("\t\treturn (" + aggr_prefix + "_double)get_aggregate(" + attr_internal_name + 
                 ");");
      pw.println("\t}");
      pw.println("\tpublic " + aggr_prefix + "_double create" + method_suffix + "(" + 
                 owning_entity_name + " type) throws " + "SdaiException {");
      pw.println("\t\t" + attr_internal_name + " = create_aggregate" + aggr_nesting + "_double(" + 
                 attr_internal_name + ", " + attr_internal_name + "$, 0);");
      pw.println("\t\treturn " + attr_internal_name + ";");
      pw.println("\t}");
      pw.println("\tpublic void unset" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\tunset_aggregate(" + attr_internal_name + ");");
      pw.println("\t\t" + attr_internal_name + " = null;");
      pw.println("\t}");
    } else if (an_ss instanceof EReal_type) {
      pw.println("\t// methods for attribute: " + attr_name + ", base type: " + comment + "REAL");
      pw.println("\tpublic boolean test" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\treturn test_aggregate(" + attr_internal_name + ");");
      pw.println("\t}");
      pw.println("\tpublic " + aggr_prefix + "_double get" + method_suffix + "(" + 
                 owning_entity_name + " type) throws " + "SdaiException {");
      pw.println("\t\treturn (" + aggr_prefix + "_double)get_aggregate(" + attr_internal_name + 
                 ");");
      pw.println("\t}");
      pw.println("\tpublic " + aggr_prefix + "_double create" + method_suffix + "(" + 
                 owning_entity_name + " type) throws " + "SdaiException {");
      pw.println("\t\t" + attr_internal_name + " = create_aggregate" + aggr_nesting + "_double(" + 
                 attr_internal_name + ", " + attr_internal_name + "$, 0);");
      pw.println("\t\treturn " + attr_internal_name + ";");
      pw.println("\t}");
      pw.println("\tpublic void unset" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\tunset_aggregate(" + attr_internal_name + ");");
      pw.println("\t\t" + attr_internal_name + " = null;");
      pw.println("\t}");
    } else if (an_ss instanceof EString_type) {
      pw.println("\t// methods for attribute: " + attr_name + ", base type: " + comment + 
                 "STRING");
      pw.println("\tpublic boolean test" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\treturn test_aggregate(" + attr_internal_name + ");");
      pw.println("\t}");
      pw.println("\tpublic " + aggr_prefix + "_string get" + method_suffix + "(" + 
                 owning_entity_name + " type) throws " + "SdaiException {");
      pw.println("\t\treturn (" + aggr_prefix + "_string)get_aggregate(" + attr_internal_name + 
                 ");");
      pw.println("\t}");
      pw.println("\tpublic " + aggr_prefix + "_string create" + method_suffix + "(" + 
                 owning_entity_name + " type) throws " + "SdaiException {");
      pw.println("\t\t" + attr_internal_name + " = create_aggregate" + aggr_nesting + "_string(" + 
                 attr_internal_name + ", " + attr_internal_name + "$, 0);");
      pw.println("\t\treturn " + attr_internal_name + ";");
      pw.println("\t}");
      pw.println("\tpublic void unset" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\tunset_aggregate(" + attr_internal_name + ");");
      pw.println("\t\t" + attr_internal_name + " = null;");
      pw.println("\t}");
    } else if (an_ss instanceof ELogical_type) {
      pw.println("\t// methods for attribute: " + attr_name + ", base type: " + comment + 
                 "LOGICAL");
      pw.println("\tpublic boolean test" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\treturn test_aggregate(" + attr_internal_name + ");");
      pw.println("\t}");
      pw.println("\tpublic " + aggr_prefix + "_enumeration get" + method_suffix + "(" + 
                 owning_entity_name + " type) throws " + "SdaiException {");
      pw.println("\t\treturn (" + aggr_prefix + "_enumeration)get_aggregate(" + 
                 attr_internal_name + ");");
      pw.println("\t}");
      pw.println("\tpublic " + aggr_prefix + "_enumeration create" + method_suffix + "(" + 
                 owning_entity_name + " type) throws " + "SdaiException {");
      pw.println("\t\t" + attr_internal_name + " = create_aggregate" + aggr_nesting + 
                 "_enumeration(" + attr_internal_name + ", " + attr_internal_name + "$, 0);");
      pw.println("\t\treturn " + attr_internal_name + ";");
      pw.println("\t}");
      pw.println("\tpublic void unset" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\tunset_aggregate(" + attr_internal_name + ");");
      pw.println("\t\t" + attr_internal_name + " = null;");
      pw.println("\t}");
    } else if (an_ss instanceof EBoolean_type) {
      pw.println("\t// methods for attribute: " + attr_name + ", base type: " + comment + 
                 "BOOLEAN");
      pw.println("\tpublic boolean test" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\treturn test_aggregate(" + attr_internal_name + ");");
      pw.println("\t}");
      pw.println("\tpublic " + aggr_prefix + "_boolean get" + method_suffix + "(" + 
                 owning_entity_name + " type) throws " + "SdaiException {");
      pw.println("\t\treturn (" + aggr_prefix + "_boolean)get_aggregate(" + attr_internal_name + 
                 ");");
      pw.println("\t}");
      pw.println("\tpublic " + aggr_prefix + "_boolean create" + method_suffix + "(" + 
                 owning_entity_name + " type) throws " + "SdaiException {");
      pw.println("\t\t" + attr_internal_name + " = create_aggregate" + aggr_nesting + 
                 "_boolean(" + attr_internal_name + ", " + attr_internal_name + "$, 0);");
      pw.println("\t\treturn " + attr_internal_name + ";");
      pw.println("\t}");
      pw.println("\tpublic void unset" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\tunset_aggregate(" + attr_internal_name + ");");
      pw.println("\t\t" + attr_internal_name + " = null;");
      pw.println("\t}");
    } else if (an_ss instanceof EBinary_type) {
      pw.println("\t// methods for attribute: " + attr_name + ", base type: " + comment + 
                 "BINARY");
      pw.println("\tpublic boolean test" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\treturn test_aggregate(" + attr_internal_name + ");");
      pw.println("\t}");
      pw.println("\tpublic " + aggr_prefix + "_binary get" + method_suffix + "(" + 
                 owning_entity_name + " type) throws " + "SdaiException {");
      pw.println("\t\treturn (" + aggr_prefix + "_binary)get_aggregate(" + attr_internal_name + 
                 ");");
      pw.println("\t}");
      pw.println("\tpublic " + aggr_prefix + "_binary create" + method_suffix + "(" + 
                 owning_entity_name + " type) throws " + "SdaiException {");
      pw.println("\t\t" + attr_internal_name + " = create_aggregate" + aggr_nesting + "_binary(" + 
                 attr_internal_name + ", " + attr_internal_name + "$, 0);");
      pw.println("\t\treturn " + attr_internal_name + ";");
      pw.println("\t}");
      pw.println("\tpublic void unset" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\tunset_aggregate(" + attr_internal_name + ");");
      pw.println("\t\t" + attr_internal_name + " = null;");
      pw.println("\t}");
    }
  }



  void generateExplicitAttributeAggregationTypeMethods(EAggregation_type at, PrintWriter pw, 
                                                       String entity_name, String attr_name, 
                                                       String method_suffix, 
                                                       String owning_entity_name, 
                                                       String attr_internal_name)
                                                throws SdaiException {
    String comment = "";

    if (at instanceof EArray_type) {
      comment += "ARRAY OF ";
    } else if (at instanceof EBag_type) {
      comment += "BAG OF ";
    } else if (at instanceof ESet_type) {
      comment += "SET OF ";
    } else if (at instanceof EList_type) {
      comment += "LIST OF ";
    }

    int aggregate_depth = 1;
    EEntity an_ss;
    EEntity ass = at;
    String aggr_prefices = "";
    an_ss = at.getElement_type(null);

    for (;;) {
      boolean done_something = false;

      if (an_ss instanceof EDefined_type) {
        ass = an_ss;
        an_ss = ((EDefined_type) an_ss).getDomain(null);
        done_something = true;
      } else if (an_ss instanceof EAggregation_type) {
        aggr_prefices += "a";
        aggregate_depth++;
        ass = an_ss;

        if (ass instanceof EArray_type) {
          comment += "ARRAY OF ";
        } else if (ass instanceof EBag_type) {
          comment += "BAG OF ";
        } else if (ass instanceof ESet_type) {
          comment += "SET OF ";
        } else if (ass instanceof EList_type) {
          comment += "LIST OF ";
        }

        an_ss = ((EAggregation_type) an_ss).getElement_type(null);
        done_something = true;
      }

      if (!done_something) {
        break;
      }
    }

    String aggr_prefix = "A" + aggr_prefices;
    String aggr_nesting = "";

    if (aggregate_depth > 1) {
      aggr_nesting += aggregate_depth;
    }


    if (an_ss instanceof ESelect_type) {
      pw.println("\t// methods for attribute: " + attr_name + ", base type: " + comment + 
                 "SELECT");

      select_loops = new HashSet();
      Object result = entitiesInSelect((ESelect_type) an_ss, null);

      if (result instanceof EEntity_definition) {
		    if (an_ss instanceof EExtensible_select_type) {
	        pw.println("\tpublic static int usedin" + method_suffix + "(" + owning_entity_name + 
  	                 " type, EEntity instance, ASdaiModel domain, AEntity result) throws SdaiException {");
    	    pw.println("\t\treturn ((CEntity)instance).makeUsedin(definition, " + attr_internal_name + 
      		             "$, domain, result);");
       	 	pw.println("\t}");

				} else {      


        // specific entity
        EEntity_definition spec_ed = (EEntity_definition) result;
        String spec_part_name = spec_ed.getName(null);
        String spec_name = getEntityPackage(spec_ed) + "E" + 
                           spec_part_name.substring(0, 1).toUpperCase() + 
                           spec_part_name.substring(1).toLowerCase();
        pw.println("\tpublic static int usedin" + method_suffix + "(" + owning_entity_name + 
                   " type, " + spec_name + 
                   " instance, ASdaiModel domain, AEntity result) throws SdaiException {");
        pw.println("\t\treturn ((CEntity)instance).makeUsedin(definition, " + attr_internal_name + 
                   "$, domain, result);");
        pw.println("\t}");
}

      } else if (result instanceof Integer) {
        // general entity
        pw.println("\tpublic static int usedin" + method_suffix + "(" + owning_entity_name + 
                   " type, EEntity instance, ASdaiModel domain, AEntity result) throws SdaiException {");
        pw.println("\t\treturn ((CEntity)instance).makeUsedin(definition, " + attr_internal_name + 
                   "$, domain, result);");
        pw.println("\t}");
      } else {
        // should be null, no entity found, usedin() not needed.
		    if (an_ss instanceof EExtensible_select_type) {
	        pw.println("\tpublic static int usedin" + method_suffix + "(" + owning_entity_name + 
  	                 " type, EEntity instance, ASdaiModel domain, AEntity result) throws SdaiException {");
    	    pw.println("\t\treturn ((CEntity)instance).makeUsedin(definition, " + attr_internal_name + 
      		             "$, domain, result);");
       	 	pw.println("\t}");

				}      
			}

      pw.println("\tpublic boolean test" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\treturn test_aggregate(" + attr_internal_name + ");");
      pw.println("\t}");
      pw.println("\tpublic " + getAggregatePackage(aggr_prefix, ass) + " get" + method_suffix + 
                 "(" + owning_entity_name + " type) throws " + "SdaiException {");


      // wrong - an internal method from lang should be used
      pw.println("\t\tif (" + attr_internal_name + " == null)");
      pw.println("\t\t\tthrow new SdaiException(SdaiException.VA_NSET);");
      pw.println("\t\treturn " + attr_internal_name + ";");
      pw.println("\t}");
      pw.println("\tpublic " + getAggregatePackage(aggr_prefix, ass) + " create" + method_suffix + 
                 "(" + owning_entity_name + " type) throws " + "SdaiException {");
      pw.println("\t\t" + attr_internal_name + " = (" + getAggregatePackage(aggr_prefix, ass) + 
                 ")create_aggregate_class(" + attr_internal_name + ", " + attr_internal_name + 
                 "$, " + getAggregatePackage(aggr_prefix, ass) + ".class, 0);");
      pw.println("\t\treturn " + attr_internal_name + ";");
      pw.println("\t}");
      pw.println("\tpublic void unset" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\tunset_aggregate(" + attr_internal_name + ");");
      pw.println("\t\t" + attr_internal_name + " = null;");
      pw.println("\t}");

      //         updateAggregateDepth((ENamed_type)ass, aggregate_depth);
    } else if (an_ss instanceof EEntity_definition) {
      String base_entity_name = ((EEntity_definition) an_ss).getName(null);
      String base_name = getEntityPackage((EEntity_definition) an_ss) + "E" + 
                         base_entity_name.substring(0, 1).toUpperCase() + 
                         base_entity_name.substring(1).toLowerCase();
      pw.println("\t// methods for attribute: " + attr_name + ", base type: " + comment + 
                 "ENTITY");
      pw.println("\tpublic static int usedin" + method_suffix + "(" + owning_entity_name + 
                 " type, " + base_name + 
                 " instance, ASdaiModel domain, AEntity result) throws SdaiException {");
      pw.println("\t\treturn ((CEntity)instance).makeUsedin(definition, " + attr_internal_name + 
                 "$, domain, result);");
      pw.println("\t}");
      pw.println("\tpublic boolean test" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\treturn test_aggregate(" + attr_internal_name + ");");
      pw.println("\t}");
      pw.println("\tpublic " + getAggregatePackage(aggr_prefix, an_ss) + " get" + method_suffix + 
                 "(" + owning_entity_name + " type) throws " + "SdaiException {");
      pw.println("\t\treturn (" + getAggregatePackage(aggr_prefix, an_ss) + ")get_aggregate(" + 
                 attr_internal_name + ");");
      pw.println("\t}");
      pw.println("\tpublic " + getAggregatePackage(aggr_prefix, an_ss) + " create" + 
                 method_suffix + "(" + owning_entity_name + " type) throws " + "SdaiException {");
      pw.println("\t\t" + attr_internal_name + " = (" + getAggregatePackage(aggr_prefix, an_ss) + 
                 ")create_aggregate_class(" + attr_internal_name + ", " + attr_internal_name + 
                 "$,  " + getAggregatePackage(aggr_prefix, an_ss) + ".class, 0);");
      pw.println("\t\treturn " + attr_internal_name + ";");
      pw.println("\t}");
      pw.println("\tpublic void unset" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\tunset_aggregate(" + attr_internal_name + ");");
      pw.println("\t\t" + attr_internal_name + " = null;");
      pw.println("\t}");

      //         updateAggregateDepth((ENamed_type)an_ss, aggregate_depth);
    } else if (an_ss instanceof EEnumeration_type) {
      pw.println("\t// methods for attribute: " + attr_name + ", base type: " + comment + 
                 "ENUMERATION");
      pw.println("\tpublic boolean test" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\treturn test_aggregate(" + attr_internal_name + ");");
      pw.println("\t}");
      pw.println("\tpublic " + aggr_prefix + "_enumeration get" + method_suffix + "(" + 
                 owning_entity_name + " type) throws " + "SdaiException {");
      pw.println("\t\treturn (" + aggr_prefix + "_enumeration)get_aggregate(" + 
                 attr_internal_name + ");");
      pw.println("\t}");
      pw.println("\tpublic " + aggr_prefix + "_enumeration create" + method_suffix + "(" + 
                 owning_entity_name + " type) throws " + "SdaiException {");
      pw.println("\t\t" + attr_internal_name + " = create_aggregate" + aggr_nesting + 
                 "_enumeration(" + attr_internal_name + ", " + attr_internal_name + "$, 0);");
      pw.println("\t\treturn " + attr_internal_name + ";");
      pw.println("\t}");
      pw.println("\tpublic void unset" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\tunset_aggregate(" + attr_internal_name + ");");
      pw.println("\t\t" + attr_internal_name + " = null;");
      pw.println("\t}");
    } else if (an_ss instanceof EInteger_type) {
      pw.println("\t// methods for attribute: " + attr_name + ", base type: " + comment + 
                 "INTEGER");
      pw.println("\tpublic boolean test" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\treturn test_aggregate(" + attr_internal_name + ");");
      pw.println("\t}");
      pw.println("\tpublic " + aggr_prefix + "_integer get" + method_suffix + "(" + 
                 owning_entity_name + " type) throws " + "SdaiException {");
      pw.println("\t\treturn (" + aggr_prefix + "_integer)get_aggregate(" + attr_internal_name + 
                 ");");
      pw.println("\t}");
      pw.println("\tpublic " + aggr_prefix + "_integer create" + method_suffix + "(" + 
                 owning_entity_name + " type) throws " + "SdaiException {");
      pw.println("\t\t" + attr_internal_name + " = create_aggregate" + aggr_nesting + 
                 "_integer(" + attr_internal_name + ", " + attr_internal_name + "$, 0);");
      pw.println("\t\treturn " + attr_internal_name + ";");
      pw.println("\t}");
      pw.println("\tpublic void unset" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\tunset_aggregate(" + attr_internal_name + ");");
      pw.println("\t\t" + attr_internal_name + " = null;");
      pw.println("\t}");
    } else if (an_ss instanceof ENumber_type) {
      pw.println("\t// methods for attribute: " + attr_name + ", base type: " + comment + 
                 "NUMBER");
      pw.println("\tpublic boolean test" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\treturn test_aggregate(" + attr_internal_name + ");");
      pw.println("\t}");
      pw.println("\tpublic " + aggr_prefix + "_double get" + method_suffix + "(" + 
                 owning_entity_name + " type) throws " + "SdaiException {");
      pw.println("\t\treturn (" + aggr_prefix + "_double)get_aggregate(" + attr_internal_name + 
                 ");");
      pw.println("\t}");
      pw.println("\tpublic " + aggr_prefix + "_double create" + method_suffix + "(" + 
                 owning_entity_name + " type) throws " + "SdaiException {");
      pw.println("\t\t" + attr_internal_name + " = create_aggregate" + aggr_nesting + "_double(" + 
                 attr_internal_name + ", " + attr_internal_name + "$, 0);");
      pw.println("\t\treturn " + attr_internal_name + ";");
      pw.println("\t}");
      pw.println("\tpublic void unset" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\tunset_aggregate(" + attr_internal_name + ");");
      pw.println("\t\t" + attr_internal_name + " = null;");
      pw.println("\t}");
    } else if (an_ss instanceof EReal_type) {
      pw.println("\t// methods for attribute: " + attr_name + ", base type: " + comment + "REAL");
      pw.println("\tpublic boolean test" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\treturn test_aggregate(" + attr_internal_name + ");");
      pw.println("\t}");
      pw.println("\tpublic " + aggr_prefix + "_double get" + method_suffix + "(" + 
                 owning_entity_name + " type) throws " + "SdaiException {");
      pw.println("\t\treturn (" + aggr_prefix + "_double)get_aggregate(" + attr_internal_name + 
                 ");");
      pw.println("\t}");
      pw.println("\tpublic " + aggr_prefix + "_double create" + method_suffix + "(" + 
                 owning_entity_name + " type) throws " + "SdaiException {");
      pw.println("\t\t" + attr_internal_name + " = create_aggregate" + aggr_nesting + "_double(" + 
                 attr_internal_name + ", " + attr_internal_name + "$, 0);");
      pw.println("\t\treturn " + attr_internal_name + ";");
      pw.println("\t}");
      pw.println("\tpublic void unset" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\tunset_aggregate(" + attr_internal_name + ");");
      pw.println("\t\t" + attr_internal_name + " = null;");
      pw.println("\t}");
    } else if (an_ss instanceof EString_type) {
      pw.println("\t// methods for attribute: " + attr_name + ", base type: " + comment + 
                 "STRING");
      pw.println("\tpublic boolean test" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\treturn test_aggregate(" + attr_internal_name + ");");
      pw.println("\t}");
      pw.println("\tpublic " + aggr_prefix + "_string get" + method_suffix + "(" + 
                 owning_entity_name + " type) throws " + "SdaiException {");
      pw.println("\t\treturn (" + aggr_prefix + "_string)get_aggregate(" + attr_internal_name + 
                 ");");
      pw.println("\t}");
      pw.println("\tpublic " + aggr_prefix + "_string create" + method_suffix + "(" + 
                 owning_entity_name + " type) throws " + "SdaiException {");
      pw.println("\t\t" + attr_internal_name + " = create_aggregate" + aggr_nesting + "_string(" + 
                 attr_internal_name + ", " + attr_internal_name + "$, 0);");
      pw.println("\t\treturn " + attr_internal_name + ";");
      pw.println("\t}");
      pw.println("\tpublic void unset" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\tunset_aggregate(" + attr_internal_name + ");");
      pw.println("\t\t" + attr_internal_name + " = null;");
      pw.println("\t}");
    } else if (an_ss instanceof ELogical_type) {
      pw.println("\t// methods for attribute: " + attr_name + ", base type: " + comment + 
                 "LOGICAL");
      pw.println("\tpublic boolean test" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\treturn test_aggregate(" + attr_internal_name + ");");
      pw.println("\t}");
      pw.println("\tpublic " + aggr_prefix + "_enumeration get" + method_suffix + "(" + 
                 owning_entity_name + " type) throws " + "SdaiException {");
      pw.println("\t\treturn (" + aggr_prefix + "_enumeration)get_aggregate(" + 
                 attr_internal_name + ");");
      pw.println("\t}");
      pw.println("\tpublic " + aggr_prefix + "_enumeration create" + method_suffix + "(" + 
                 owning_entity_name + " type) throws " + "SdaiException {");
      pw.println("\t\t" + attr_internal_name + " = create_aggregate" + aggr_nesting + 
                 "_enumeration(" + attr_internal_name + ", " + attr_internal_name + "$, 0);");
      pw.println("\t\treturn " + attr_internal_name + ";");
      pw.println("\t}");
      pw.println("\tpublic void unset" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\tunset_aggregate(" + attr_internal_name + ");");
      pw.println("\t\t" + attr_internal_name + " = null;");
      pw.println("\t}");
    } else if (an_ss instanceof EBoolean_type) {
      pw.println("\t// methods for attribute: " + attr_name + ", base type: " + comment + 
                 "BOOLEAN");
      pw.println("\tpublic boolean test" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\treturn test_aggregate(" + attr_internal_name + ");");
      pw.println("\t}");
      pw.println("\tpublic " + aggr_prefix + "_boolean get" + method_suffix + "(" + 
                 owning_entity_name + " type) throws " + "SdaiException {");
      pw.println("\t\treturn (" + aggr_prefix + "_boolean)get_aggregate(" + attr_internal_name + 
                 ");");
      pw.println("\t}");
      pw.println("\tpublic " + aggr_prefix + "_boolean create" + method_suffix + "(" + 
                 owning_entity_name + " type) throws " + "SdaiException {");
      pw.println("\t\t" + attr_internal_name + " = create_aggregate" + aggr_nesting + 
                 "_boolean(" + attr_internal_name + ", " + attr_internal_name + "$, 0);");
      pw.println("\t\treturn " + attr_internal_name + ";");
      pw.println("\t}");
      pw.println("\tpublic void unset" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\tunset_aggregate(" + attr_internal_name + ");");
      pw.println("\t\t" + attr_internal_name + " = null;");
      pw.println("\t}");
    } else if (an_ss instanceof EBinary_type) {
      pw.println("\t// methods for attribute: " + attr_name + ", base type: " + comment + 
                 "BINARY");
      pw.println("\tpublic boolean test" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\treturn test_aggregate(" + attr_internal_name + ");");
      pw.println("\t}");
      pw.println("\tpublic " + aggr_prefix + "_binary get" + method_suffix + "(" + 
                 owning_entity_name + " type) throws " + "SdaiException {");
      pw.println("\t\treturn (" + aggr_prefix + "_binary)get_aggregate(" + attr_internal_name + 
                 ");");
      pw.println("\t}");
      pw.println("\tpublic " + aggr_prefix + "_binary create" + method_suffix + "(" + 
                 owning_entity_name + " type) throws " + "SdaiException {");
      pw.println("\t\t" + attr_internal_name + " = create_aggregate" + aggr_nesting + "_binary(" + 
                 attr_internal_name + ", " + attr_internal_name + "$, 0);");
      pw.println("\t\treturn " + attr_internal_name + ";");
      pw.println("\t}");
      pw.println("\tpublic void unset" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\tunset_aggregate(" + attr_internal_name + ");");
      pw.println("\t\t" + attr_internal_name + " = null;");
      pw.println("\t}");
    }
  }




  void generateExplicitAttributeAggregationTypeMethodsRenamed(EAggregation_type at, PrintWriter pw, 
                                                       String entity_name, String attr_name, 
                                                       String method_suffix, 
                                                       String owning_entity_name, 
                                                       String attr_internal_name,
                                                       EExplicit_attribute xattr,
                                                       String method_suffix_prev,
                                                       String owning_entity_name_prev,
                                                       String package_prev)
                                                throws SdaiException {
/*

		NOTE:
		1. so far, implimented the case of entity
		2. ALREADY DONE - so far the type parameter in invoked methods with previous name is null, safer to implement null, casted to the prev type - to do
*/



// let's change at to the type of the original attribute

//	EExplicit_attribute xattr_original = getOriginalExplicitAttribute(xattr);

//  EEntity bt = xattr_original.getDomain(null);
  
//  if (bt instanceof EAggregation_type) {
//		at = (EAggregation_type)bt;
//	}



    String comment = "";

    if (at instanceof EArray_type) {
      comment += "ARRAY OF ";
    } else if (at instanceof EBag_type) {
      comment += "BAG OF ";
    } else if (at instanceof ESet_type) {
      comment += "SET OF ";
    } else if (at instanceof EList_type) {
      comment += "LIST OF ";
    }

    int aggregate_depth = 1;
    EEntity an_ss;
    EEntity ass = at;
    String aggr_prefices = "";
    an_ss = at.getElement_type(null);

    for (;;) {
      boolean done_something = false;

      if (an_ss instanceof EDefined_type) {
        ass = an_ss;
        an_ss = ((EDefined_type) an_ss).getDomain(null);
        done_something = true;
      } else if (an_ss instanceof EAggregation_type) {
        aggr_prefices += "a";
        aggregate_depth++;
        ass = an_ss;

        if (ass instanceof EArray_type) {
          comment += "ARRAY OF ";
        } else if (ass instanceof EBag_type) {
          comment += "BAG OF ";
        } else if (ass instanceof ESet_type) {
          comment += "SET OF ";
        } else if (ass instanceof EList_type) {
          comment += "LIST OF ";
        }

        an_ss = ((EAggregation_type) an_ss).getElement_type(null);
        done_something = true;
      }

      if (!done_something) {
        break;
      }
    }

    String aggr_prefix = "A" + aggr_prefices;
    String aggr_nesting = "";

    if (aggregate_depth > 1) {
      aggr_nesting += aggregate_depth;
    }


    if (an_ss instanceof ESelect_type) {
      pw.println("\t// methods for attribute: " + attr_name + ", base type: " + comment + 
                 "SELECT");

      select_loops = new HashSet();
      Object result = entitiesInSelect((ESelect_type) an_ss, null);

      if (result instanceof EEntity_definition) {
		    if (an_ss instanceof EExtensible_select_type) {

//USEDIN-RENAMED
pw.println("// USEDIN-RENAMED-06");
	        pw.println("\tpublic static int usedin" + method_suffix + "(" + owning_entity_name + " type, EEntity instance, ASdaiModel domain, AEntity result) throws SdaiException {");
    	    pw.println("\t\treturn ((CEntity)instance).makeUsedin(definition, " + attr_internal_name + "$, domain, result);");
//	        pw.println("\t\treturn usedin" + method_suffix_prev + "((" + owning_entity_name_prev + ")null, instance, domain, result);");
       	 	pw.println("\t}");

				} else {      


        // specific entity
        EEntity_definition spec_ed = (EEntity_definition) result;
        String spec_part_name = spec_ed.getName(null);
        String spec_name = getEntityPackage(spec_ed) + "E" + 
                           spec_part_name.substring(0, 1).toUpperCase() + 
                           spec_part_name.substring(1).toLowerCase();

//USEDIN-RENAMED
pw.println("// USEDIN-RENAMED-07");
        pw.println("\tpublic static int usedin" + method_suffix + "(" + owning_entity_name + " type, " + spec_name + " instance, ASdaiModel domain, AEntity result) throws SdaiException {");
        pw.println("\t\treturn ((CEntity)instance).makeUsedin(definition, " + attr_internal_name + "$, domain, result);");
//        pw.println("\t\treturn usedin" + method_suffix_prev + "((" + owning_entity_name_prev + ")null, instance, domain, result);");
        pw.println("\t}");
			}

      } else if (result instanceof Integer) {
        // general entity
//USEDIN-RENAMED
pw.println("// USEDIN-RENAMED-08");
        pw.println("\tpublic static int usedin" + method_suffix + "(" + owning_entity_name + " type, EEntity instance, ASdaiModel domain, AEntity result) throws SdaiException {");
        pw.println("\t\treturn ((CEntity)instance).makeUsedin(definition, " + attr_internal_name + "$, domain, result);");
//        pw.println("\t\treturn usedin" + method_suffix_prev + "((" + owning_entity_name_prev + ")null, instance, domain, result);");
        pw.println("\t}");
      } else {
        // should be null, no entity found, usedin() not needed.
		    if (an_ss instanceof EExtensible_select_type) {
//USEDIN-RENAMED
pw.println("// USEDIN-RENAMED-09");
	        pw.println("\tpublic static int usedin" + method_suffix + "(" + owning_entity_name + " type, EEntity instance, ASdaiModel domain, AEntity result) throws SdaiException {");
    	    pw.println("\t\treturn ((CEntity)instance).makeUsedin(definition, " + attr_internal_name + "$, domain, result);");
//	        pw.println("\t\treturn usedin" + method_suffix_prev + "((" + owning_entity_name_prev + ")null, instance, domain, result);");
       	 	pw.println("\t}");

				}      
			}

      pw.println("\tpublic boolean test" + method_suffix + "(" + owning_entity_name + " type) throws " + "SdaiException {");
//      pw.println("\t\treturn test_aggregate(" + attr_internal_name + ");");
      pw.println("\t\treturn test" + method_suffix_prev + "((" + owning_entity_name_prev + ")null);");
      pw.println("\t}");

      pw.println("\tpublic " + getAggregatePackage(aggr_prefix, ass) + " get" + method_suffix + "(" + owning_entity_name + " type) throws " + "SdaiException {");


      // wrong - an internal method from lang should be used
//      pw.println("\t\tif (" + attr_internal_name + " == null)");
//      pw.println("\t\t\tthrow new SdaiException(SdaiException.VA_NSET);");
//      pw.println("\t\treturn " + attr_internal_name + ";");
      pw.println("\t\treturn get" + method_suffix_prev + "((" + owning_entity_name_prev + ")null);");
      pw.println("\t}");

      pw.println("\tpublic " + getAggregatePackage(aggr_prefix, ass) + " create" + method_suffix + "(" + owning_entity_name + " type) throws " + "SdaiException {");
//      pw.println("\t\t" + attr_internal_name + " = (" + getAggregatePackage(aggr_prefix, ass) + ")create_aggregate_class(" + attr_internal_name + ", " + attr_internal_name + "$, " + getAggregatePackage(aggr_prefix, ass) + ".class, 0);");
//      pw.println("\t\treturn " + attr_internal_name + ";");
      pw.println("\t\treturn create" + method_suffix_prev + "((" + owning_entity_name_prev + ")null);");
      pw.println("\t}");

      pw.println("\tpublic void unset" + method_suffix + "(" + owning_entity_name + " type) throws " + "SdaiException {");
//      pw.println("\t\tunset_aggregate(" + attr_internal_name + ");");
//      pw.println("\t\t" + attr_internal_name + " = null;");
      pw.println("\t\tunset" + method_suffix_prev + "((" + owning_entity_name_prev + ")null);");
      pw.println("\t}");

      //         updateAggregateDepth((ENamed_type)ass, aggregate_depth);
    } else if (an_ss instanceof EEntity_definition) {
      String base_entity_name = ((EEntity_definition) an_ss).getName(null);
      String base_name = getEntityPackage((EEntity_definition) an_ss) + "E" + 
                         base_entity_name.substring(0, 1).toUpperCase() + 
                         base_entity_name.substring(1).toLowerCase();
      pw.println("\t// methods for attribute: " + attr_name + ", base type: " + comment + "ENTITY");

//USEDIN-RENAMED
pw.println("// USEDIN-RENAMED-10");
      pw.println("\tpublic static int usedin" + method_suffix + "(" + owning_entity_name + " type, " + base_name + " instance, ASdaiModel domain, AEntity result) throws SdaiException {");
      pw.println("\t\treturn ((CEntity)instance).makeUsedin(definition, " + attr_internal_name + "$, domain, result);");
//      pw.println("\t\treturn " + package_prev + "usedin" + method_suffix_prev + "((" + owning_entity_name_prev + ")null, instance, domain, result);");
      pw.println("\t}");

      pw.println("\tpublic boolean test" + method_suffix + "(" + owning_entity_name + " type) throws " + "SdaiException {");
//      pw.println("\t\treturn test_aggregate(" + attr_internal_name + ");");
      pw.println("\t\treturn " + package_prev + "test" + method_suffix_prev + "((" + owning_entity_name_prev + ")null);");
      pw.println("\t}");

      pw.println("\tpublic " + getAggregatePackage(aggr_prefix, an_ss) + " get" + method_suffix + "(" + owning_entity_name + " type) throws " + "SdaiException {");
//      pw.println("\t\treturn (" + getAggregatePackage(aggr_prefix, an_ss) + ")get_aggregate(" + attr_internal_name + ");");
      pw.println("\t\treturn " + package_prev + "get" + method_suffix_prev + "((" + owning_entity_name_prev + ")null);");
//		return getAggr_1(null);
//		return (AAaa)get_aggregate(a3);

      pw.println("\t}");

      pw.println("\tpublic " + getAggregatePackage(aggr_prefix, an_ss) + " create" + method_suffix + "(" + owning_entity_name + " type) throws " + "SdaiException {");
//      pw.println("\t\t" + attr_internal_name + " = (" + getAggregatePackage(aggr_prefix, an_ss) + 
//                 ")create_aggregate_class(" + attr_internal_name + ", " + attr_internal_name + 
//                 "$,  " + getAggregatePackage(aggr_prefix, an_ss) + ".class, 0);");
//      pw.println("\t\treturn " + attr_internal_name + ";");
      pw.println("\t\treturn " + package_prev + "create" + method_suffix_prev + "((" + owning_entity_name_prev + ")null);");
      pw.println("\t}");
      pw.println("\tpublic void unset" + method_suffix + "(" + owning_entity_name + " type) throws " + "SdaiException {");
//      pw.println("\t\tunset_aggregate(" + attr_internal_name + ");");
//      pw.println("\t\t" + attr_internal_name + " = null;");
      pw.println("\t\t" + package_prev + "unset" + method_suffix_prev + "((" + owning_entity_name_prev + ")null);");
      pw.println("\t}");

      //         updateAggregateDepth((ENamed_type)an_ss, aggregate_depth);
    } else if (an_ss instanceof EEnumeration_type) {
      pw.println("\t// methods for attribute: " + attr_name + ", base type: " + comment + "ENUMERATION");
      pw.println("\tpublic boolean test" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\treturn test_aggregate(" + attr_internal_name + ");");
      pw.println("\t}");
      pw.println("\tpublic " + aggr_prefix + "_enumeration get" + method_suffix + "(" + 
                 owning_entity_name + " type) throws " + "SdaiException {");
      pw.println("\t\treturn (" + aggr_prefix + "_enumeration)get_aggregate(" + 
                 attr_internal_name + ");");
      pw.println("\t}");
      pw.println("\tpublic " + aggr_prefix + "_enumeration create" + method_suffix + "(" + 
                 owning_entity_name + " type) throws " + "SdaiException {");
      pw.println("\t\t" + attr_internal_name + " = create_aggregate" + aggr_nesting + 
                 "_enumeration(" + attr_internal_name + ", " + attr_internal_name + "$, 0);");
      pw.println("\t\treturn " + attr_internal_name + ";");
      pw.println("\t}");
      pw.println("\tpublic void unset" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\tunset_aggregate(" + attr_internal_name + ");");
      pw.println("\t\t" + attr_internal_name + " = null;");
      pw.println("\t}");
    } else if (an_ss instanceof EInteger_type) {
      pw.println("\t// methods for attribute: " + attr_name + ", base type: " + comment + 
                 "INTEGER");
      pw.println("\tpublic boolean test" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\treturn test_aggregate(" + attr_internal_name + ");");
      pw.println("\t}");
      pw.println("\tpublic " + aggr_prefix + "_integer get" + method_suffix + "(" + 
                 owning_entity_name + " type) throws " + "SdaiException {");
      pw.println("\t\treturn (" + aggr_prefix + "_integer)get_aggregate(" + attr_internal_name + 
                 ");");
      pw.println("\t}");
      pw.println("\tpublic " + aggr_prefix + "_integer create" + method_suffix + "(" + 
                 owning_entity_name + " type) throws " + "SdaiException {");
      pw.println("\t\t" + attr_internal_name + " = create_aggregate" + aggr_nesting + 
                 "_integer(" + attr_internal_name + ", " + attr_internal_name + "$, 0);");
      pw.println("\t\treturn " + attr_internal_name + ";");
      pw.println("\t}");
      pw.println("\tpublic void unset" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\tunset_aggregate(" + attr_internal_name + ");");
      pw.println("\t\t" + attr_internal_name + " = null;");
      pw.println("\t}");
    } else if (an_ss instanceof ENumber_type) {
      pw.println("\t// methods for attribute: " + attr_name + ", base type: " + comment + 
                 "NUMBER");
      pw.println("\tpublic boolean test" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\treturn test_aggregate(" + attr_internal_name + ");");
      pw.println("\t}");
      pw.println("\tpublic " + aggr_prefix + "_double get" + method_suffix + "(" + 
                 owning_entity_name + " type) throws " + "SdaiException {");
      pw.println("\t\treturn (" + aggr_prefix + "_double)get_aggregate(" + attr_internal_name + 
                 ");");
      pw.println("\t}");
      pw.println("\tpublic " + aggr_prefix + "_double create" + method_suffix + "(" + 
                 owning_entity_name + " type) throws " + "SdaiException {");
      pw.println("\t\t" + attr_internal_name + " = create_aggregate" + aggr_nesting + "_double(" + 
                 attr_internal_name + ", " + attr_internal_name + "$, 0);");
      pw.println("\t\treturn " + attr_internal_name + ";");
      pw.println("\t}");
      pw.println("\tpublic void unset" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\tunset_aggregate(" + attr_internal_name + ");");
      pw.println("\t\t" + attr_internal_name + " = null;");
      pw.println("\t}");
    } else if (an_ss instanceof EReal_type) {
      pw.println("\t// methods for attribute: " + attr_name + ", base type: " + comment + "REAL");
      pw.println("\tpublic boolean test" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\treturn test_aggregate(" + attr_internal_name + ");");
      pw.println("\t}");
      pw.println("\tpublic " + aggr_prefix + "_double get" + method_suffix + "(" + 
                 owning_entity_name + " type) throws " + "SdaiException {");
      pw.println("\t\treturn (" + aggr_prefix + "_double)get_aggregate(" + attr_internal_name + 
                 ");");
      pw.println("\t}");
      pw.println("\tpublic " + aggr_prefix + "_double create" + method_suffix + "(" + 
                 owning_entity_name + " type) throws " + "SdaiException {");
      pw.println("\t\t" + attr_internal_name + " = create_aggregate" + aggr_nesting + "_double(" + 
                 attr_internal_name + ", " + attr_internal_name + "$, 0);");
      pw.println("\t\treturn " + attr_internal_name + ";");
      pw.println("\t}");
      pw.println("\tpublic void unset" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\tunset_aggregate(" + attr_internal_name + ");");
      pw.println("\t\t" + attr_internal_name + " = null;");
      pw.println("\t}");
    } else if (an_ss instanceof EString_type) {
      pw.println("\t// methods for attribute: " + attr_name + ", base type: " + comment + 
                 "STRING");
      pw.println("\tpublic boolean test" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\treturn test_aggregate(" + attr_internal_name + ");");
      pw.println("\t}");
      pw.println("\tpublic " + aggr_prefix + "_string get" + method_suffix + "(" + 
                 owning_entity_name + " type) throws " + "SdaiException {");
      pw.println("\t\treturn (" + aggr_prefix + "_string)get_aggregate(" + attr_internal_name + 
                 ");");
      pw.println("\t}");
      pw.println("\tpublic " + aggr_prefix + "_string create" + method_suffix + "(" + 
                 owning_entity_name + " type) throws " + "SdaiException {");
      pw.println("\t\t" + attr_internal_name + " = create_aggregate" + aggr_nesting + "_string(" + 
                 attr_internal_name + ", " + attr_internal_name + "$, 0);");
      pw.println("\t\treturn " + attr_internal_name + ";");
      pw.println("\t}");
      pw.println("\tpublic void unset" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\tunset_aggregate(" + attr_internal_name + ");");
      pw.println("\t\t" + attr_internal_name + " = null;");
      pw.println("\t}");
    } else if (an_ss instanceof ELogical_type) {
      pw.println("\t// methods for attribute: " + attr_name + ", base type: " + comment + 
                 "LOGICAL");
      pw.println("\tpublic boolean test" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\treturn test_aggregate(" + attr_internal_name + ");");
      pw.println("\t}");
      pw.println("\tpublic " + aggr_prefix + "_enumeration get" + method_suffix + "(" + 
                 owning_entity_name + " type) throws " + "SdaiException {");
      pw.println("\t\treturn (" + aggr_prefix + "_enumeration)get_aggregate(" + 
                 attr_internal_name + ");");
      pw.println("\t}");
      pw.println("\tpublic " + aggr_prefix + "_enumeration create" + method_suffix + "(" + 
                 owning_entity_name + " type) throws " + "SdaiException {");
      pw.println("\t\t" + attr_internal_name + " = create_aggregate" + aggr_nesting + 
                 "_enumeration(" + attr_internal_name + ", " + attr_internal_name + "$, 0);");
      pw.println("\t\treturn " + attr_internal_name + ";");
      pw.println("\t}");
      pw.println("\tpublic void unset" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\tunset_aggregate(" + attr_internal_name + ");");
      pw.println("\t\t" + attr_internal_name + " = null;");
      pw.println("\t}");
    } else if (an_ss instanceof EBoolean_type) {
      pw.println("\t// methods for attribute: " + attr_name + ", base type: " + comment + 
                 "BOOLEAN");
      pw.println("\tpublic boolean test" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\treturn test_aggregate(" + attr_internal_name + ");");
      pw.println("\t}");
      pw.println("\tpublic " + aggr_prefix + "_boolean get" + method_suffix + "(" + 
                 owning_entity_name + " type) throws " + "SdaiException {");
      pw.println("\t\treturn (" + aggr_prefix + "_boolean)get_aggregate(" + attr_internal_name + 
                 ");");
      pw.println("\t}");
      pw.println("\tpublic " + aggr_prefix + "_boolean create" + method_suffix + "(" + 
                 owning_entity_name + " type) throws " + "SdaiException {");
      pw.println("\t\t" + attr_internal_name + " = create_aggregate" + aggr_nesting + 
                 "_boolean(" + attr_internal_name + ", " + attr_internal_name + "$, 0);");
      pw.println("\t\treturn " + attr_internal_name + ";");
      pw.println("\t}");
      pw.println("\tpublic void unset" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\tunset_aggregate(" + attr_internal_name + ");");
      pw.println("\t\t" + attr_internal_name + " = null;");
      pw.println("\t}");
    } else if (an_ss instanceof EBinary_type) {
      pw.println("\t// methods for attribute: " + attr_name + ", base type: " + comment + 
                 "BINARY");
      pw.println("\tpublic boolean test" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\treturn test_aggregate(" + attr_internal_name + ");");
      pw.println("\t}");
      pw.println("\tpublic " + aggr_prefix + "_binary get" + method_suffix + "(" + 
                 owning_entity_name + " type) throws " + "SdaiException {");
      pw.println("\t\treturn (" + aggr_prefix + "_binary)get_aggregate(" + attr_internal_name + 
                 ");");
      pw.println("\t}");
      pw.println("\tpublic " + aggr_prefix + "_binary create" + method_suffix + "(" + 
                 owning_entity_name + " type) throws " + "SdaiException {");
      pw.println("\t\t" + attr_internal_name + " = create_aggregate" + aggr_nesting + "_binary(" + 
                 attr_internal_name + ", " + attr_internal_name + "$, 0);");
      pw.println("\t\treturn " + attr_internal_name + ";");
      pw.println("\t}");
      pw.println("\tpublic void unset" + method_suffix + "(" + owning_entity_name + 
                 " type) throws " + "SdaiException {");
      pw.println("\t\tunset_aggregate(" + attr_internal_name + ");");
      pw.println("\t\t" + attr_internal_name + " = null;");
      pw.println("\t}");
    }
  }


          

	void generateExplicitCurrentEntityMethodsX(EEntity_definition ed, TheAttribute tattr, PrintWriter pw) throws SdaiException {  
		// for now, use the same for the current entity and for the supertype non-java inheritance
		generateExplicitNoJavaInheritanceMethodsX(ed, tattr, pw);	
	}
	     
	void generateExplicitSupertypeNoJavaInheritanceMethodsX(EEntity_definition ed, TheAttribute tattr, PrintWriter pw) throws SdaiException {  
		// for now, use the same for the current entity and for the supertype non-java inheritance
		generateExplicitNoJavaInheritanceMethodsX(ed, tattr, pw);	
	}

	void generateExplicitNoJavaInheritanceMethodsX(EEntity_definition ed, TheAttribute tattr, PrintWriter pw) throws SdaiException {  


    String entity_name = ed.getName(null);


        // not needed
//        internal++;

      EAttribute attr = tattr.attr;

      EEntity_definition owner_entity = (EEntity_definition) attr.getParent_entity(null);
      String owner_name = owner_entity.getName(null);
      String owning_entity_name = getEntityPackage(owner_entity) + "E" + 
                                  owner_name.substring(0, 1).toUpperCase() + 
                                  owner_name.substring(1).toLowerCase();
      ;

      String attr_name = attr.getName(null);
      String attr_internal_name = "a" + tattr.consolidated_explicit_index;


        // generate methods here
        EExplicit_attribute xattr = (EExplicit_attribute) attr;
        String method_suffix = attr_name.substring(0, 1).toUpperCase() + 
                               attr_name.substring(1).toLowerCase();
        EEntity bt = null;

	    if (xattr.testDomain(null)) {
        bt = xattr.getDomain(null);
			} else {
				pw.println("WARNING! Methods not generated - generate-Explicit-No-Java-Inheritance-MethodsX - attribute domain is NULL: " + xattr);
				System.out.println("WARNING! Methods not generated - generate-Explicit-No-Java-Inheritance-MethodsX - attribute domain is NULL: " + xattr);
				return;
			}


// System.out.println("goOog bt: " + bt);

				if (bt instanceof EParameter) {
					bt = ((EParameter)bt).getParameter_type(null);
				}

// System.out.println("goOog new bt: " + bt);

        if (bt instanceof ESimple_type) {
          generateExplicitAttributeSimpleTypeMethods((ESimple_type) bt, pw, entity_name, attr_name, 
                                                     method_suffix, owning_entity_name, 
                                                     attr_internal_name);
        } else if (bt instanceof EAggregation_type) {
          generateExplicitAttributeAggregationTypeMethods((EAggregation_type) bt, pw, entity_name, 
                                                          attr_name, method_suffix, 
                                                          owning_entity_name, attr_internal_name);
        } else if (bt instanceof EDefined_type) {
          generateExplicitAttributeDefinedTypeMethods((EDefined_type) bt, pw, entity_name, 
                                                      attr_name, method_suffix, owning_entity_name, 
                                                      attr_internal_name);
        } else if (bt instanceof EEntity_definition) {
          String base_entity_name = ((EEntity_definition) bt).getName(null);
          String base_name = getEntityPackage((EEntity_definition) bt) + "E" + 
                             base_entity_name.substring(0, 1).toUpperCase() + 
                             base_entity_name.substring(1).toLowerCase();
          pw.println("\t// attribute (current explicit or supertype explicit) : " + attr_name + ", base type: entity " + base_entity_name);


          // usedin
          pw.println("\tpublic static int usedin" + method_suffix + "(" + owning_entity_name + 
                     " type, " + base_name + 
                     " instance, ASdaiModel domain, AEntity result) throws SdaiException {");
          pw.println("\t\treturn ((CEntity)instance).makeUsedin(definition, " + 
                     attr_internal_name + "$, domain, result);");
          pw.println("\t}");
          pw.println("\tpublic boolean test" + method_suffix + "(" + owning_entity_name + 
                     " type) throws " + "SdaiException {");
          pw.println("\t\treturn test_instance(" + attr_internal_name + ");");
          pw.println("\t}");
          pw.println("\tpublic " + base_name + " get" + method_suffix + "(" + owning_entity_name + 
                     " type) throws " + "SdaiException {");
//OPTIMIZED          pw.println("\t\t" + attr_internal_name + " = get_instance(" + attr_internal_name + ");");
          pw.println("\t\treturn (" + base_name + ")get_instance(" + attr_internal_name + ");");
          pw.println("\t}");
          pw.println("\tpublic void set" + method_suffix + "(" + owning_entity_name + " type, " + 
                     base_name + " value) throws " + "SdaiException {");
          pw.println("\t\t" + attr_internal_name + " = set_instance(" + attr_internal_name + 
                     ", value);");
          pw.println("\t}");
          pw.println("\tpublic void unset" + method_suffix + "(" + owning_entity_name + 
                     " type) throws " + "SdaiException {");
          pw.println("\t\t" + attr_internal_name + " = unset_instance(" + attr_internal_name + 
                     ");");
          pw.println("\t}");
        }

        pw.println("\tpublic static jsdai.dictionary.EAttribute attribute" + method_suffix + "(" + 
                   owning_entity_name + " type) throws SdaiException {");
        pw.println("\t\treturn " + attr_internal_name + "$;");
        pw.println("\t}");
        pw.println("");

	}


	void generateDerivedCurrentEntityMethodsX(EEntity_definition ed, TheAttribute tattr, PrintWriter pw)  throws SdaiException  {
		// for now, the same for the current entity and for a supertype, non-java inheritance
		generateDerivedNoJavaInheritanceMethodsX(ed, tattr, pw);	
	}	

	void generateDerivedSupertypeNoJavaInheritanceMethodsX(EEntity_definition ed, TheAttribute tattr, PrintWriter pw)  throws SdaiException  {
		// for now, the same for the current entity and for a supertype, non-java inheritance
		generateDerivedNoJavaInheritanceMethodsX(ed, tattr, pw);	
	}

	void generateDerivedNoJavaInheritanceMethodsX(EEntity_definition ed, TheAttribute tattr, PrintWriter pw)  throws SdaiException  {

//		System.out.println("entity: " + ed);
//		System.out.println("attribute: " + tattr.attr);
		


    String entity_name = ed.getName(null);

      EAttribute attr = tattr.attr;

      EEntity_definition owner_entity = (EEntity_definition) attr.getParent_entity(null);
      String owner_name = owner_entity.getName(null);
      String owning_entity_name = getEntityPackage(owner_entity) + "E" + 
                                  owner_name.substring(0, 1).toUpperCase() + 
                                  owner_name.substring(1).toLowerCase();
      ;

      String attr_name = attr.getName(null);
      String attr_internal_name = "a" + tattr.consolidated_explicit_index;


        //            JavaClass expression_java = null;
        A_string expression_java = null;

        // if (flag_expressions) {
        //           EJava_code jc = findJava_codeForDerivedAttribute(attr);
        //           if (jc != null) {
        // System.out.println("### ### java code for derived attribute found");
        //                 expression_java = jc.getValues(null);
        //                 } else {
        // System.out.println("### ### java code for derived attribute NOT found");
        //                 }
        // }
        // test and get methods for all attribute types - different return types - also for select, with select path nodes - multiple methods.
        EDerived_attribute dattr = (EDerived_attribute) attr;
        String method_suffix = attr_name.substring(0, 1).toUpperCase() + 
                               attr_name.substring(1).toLowerCase();
        EEntity bt = null;

	    if (dattr.testDomain(null)) {
        bt = dattr.getDomain(null);
			} else {
				pw.println("WARNING! Methods not generated - generate-Derived-No-Java-Inheritance-MethodsX - attribute domain is NULL: " + dattr);
				System.out.println("WARNING! Methods not generated - generate-Derived-No-Java-Inheritance-MethodsX - attribute domain is NULL: " + dattr);
				return;
			}



        if (bt instanceof EParameter) {
        	bt = ((EParameter)bt).getParameter_type(null);
        }

        if (bt instanceof ESimple_type) {
          generateDerivedAttributeSimpleTypeMethods(attr, (ESimple_type) bt, pw, entity_name, 
                                                    attr_name, method_suffix, owning_entity_name, 
                                                    attr_internal_name, expression_java);
        } else if (bt instanceof EAggregation_type) {
          generateDerivedAttributeAggregationTypeMethods(attr, (EAggregation_type) bt, pw, 
                                                         entity_name, attr_name, method_suffix, 
                                                         owning_entity_name, attr_internal_name, 
                                                         expression_java);
        } else if (bt instanceof EDefined_type) {
          generateDerivedAttributeDefinedTypeMethods(attr, (EDefined_type) bt, pw, entity_name, 
                                                     attr_name, method_suffix, owning_entity_name, 
                                                     attr_internal_name, expression_java);
        } else if (bt instanceof EEntity_definition) {
          String base_entity_name = ((EEntity_definition) bt).getName(null);
          String base_name = getEntityPackage((EEntity_definition) bt) + "E" + 
                             base_entity_name.substring(0, 1).toUpperCase() + 
                             base_entity_name.substring(1).toLowerCase();
// System.out.println("<<<>>> entity: " + ed.getName(null) + ", derived attribute: " + attr_name + ", base type: entity " + base_entity_name);
          pw.println("\t// derived attribute (current derived or supertype derived): " + attr_name + ", base type: entity " + 
                     base_entity_name);
          pw.println("\tpublic boolean test" + method_suffix + "(" + owning_entity_name + 
                     " type) throws " + "SdaiException {");
          pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
          pw.println("\t}");

          pw.println("\tpublic " + "Value" + " get" + method_suffix + "(" + owning_entity_name + 
                     " type, SdaiContext _context) throws " + "SdaiException {");

          //               if ((flag_expressions) & (expression_java != null)) {
          if (flag_expressions) {
		        generateJavaExpressionForDeriveMethodsInc(pw, attr, sd, _ed, model);

          } else {
            pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
          }

          pw.println("\t}");

          pw.println("\tpublic " + base_name + " get" + method_suffix + "(" + owning_entity_name + 
                     " type) throws " + "SdaiException {");


          //               if ((flag_expressions) & (expression_java != null)) {

//RR-SdaiContext-temp
//          pw.println("\t\tSdaiContext _context = SdaiSession.getSdaiContext();");
          pw.println("\t\tSdaiContext _context = this.findEntityInstanceSdaiModel().getRepository().getSession().getSdaiContext();");

          if (flag_expressions) {
            //						pw.println("\t\t\tSdaiContext _context = this.findEntityInstanceSdaiModel().getRepository().getSession().getSdaiContext();");
//            pw.println("\t\t\treturn (" + base_name + ") get" + method_suffix + "(null, _context).getActualType();");
//            pw.println("\t\t\treturn (" + base_name + ") get" + method_suffix + "(null, _context).getInstance();");
// adding type in the call to resolve ambiguous cases
            pw.println("\t\t\treturn (" + base_name + ") get" + method_suffix + "((" + owning_entity_name + ")null, _context).getInstance();");
          } else {
            pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
          }

          pw.println("\t}");
        }

        pw.println("\tpublic static jsdai.dictionary.EAttribute attribute" + method_suffix + "(" + 
                   owning_entity_name + " type) throws SdaiException {");
//NEW_IMPLEMENTATION
//        pw.println("\t\treturn d" + (count_derived - 1) + "$;");
        pw.println("\t\treturn d" + tattr.consolidated_derived_index + "$;");
        pw.println("\t}");
        pw.println("");


	}

	void generateInverseCurrentEntityMethodsX(EEntity_definition ed, TheAttribute tattr, PrintWriter pw)  throws SdaiException {
		// no differente between current entity and supertype without java inheritance, at least so far
		generateInverseNoJavaInheritanceMethodsX(ed, tattr, pw);
	}
	void generateInverseSupertypeNoJavaInheritanceMethodsX(EEntity_definition ed, TheAttribute tattr, PrintWriter pw)  throws SdaiException {
		// no differente between current entity and supertype without java inheritance, at least so far
		generateInverseNoJavaInheritanceMethodsX(ed, tattr, pw);
	}

	void generateInverseNoJavaInheritanceMethodsX(EEntity_definition ed, TheAttribute tattr, PrintWriter pw)  throws SdaiException {

    String entity_name = ed.getName(null);

      EAttribute attr = tattr.attr;

      EEntity_definition owner_entity = (EEntity_definition) attr.getParent_entity(null);
      String owner_name = owner_entity.getName(null);
      String owning_entity_name = getEntityPackage(owner_entity) + "E" + 
                                  owner_name.substring(0, 1).toUpperCase() + 
                                  owner_name.substring(1).toLowerCase();
      ;

      String attr_name = attr.getName(null);
      String attr_internal_name = "a" + tattr.consolidated_explicit_index;


        EInverse_attribute inva = (EInverse_attribute) attr;

        // cannot happen in this new implementation, because the attribute is consolidated
        if (inva.testRedeclaring(null)) {
          return;
        }

        EEntity_definition referencing_entity = null;

	    if (inva.testDomain(null)) {
       	referencing_entity = inva.getDomain(null);
			} else {
				pw.println("WARNING! Methods not generated - generate-Inverse-No-Java-Inheritance-MethodsX - inverse attribute domain is NULL: " + inva);
				System.out.println("WARNING! Methods not generated - generate-Inverse-No-Java-Inheritance-MethodsX - inverse attribute domain is NULL: " + inva);
				return;
			}
      


        String referencing_entity_name = referencing_entity.getName(null);
        EExplicit_attribute inverted_attr = inva.getInverted_attr(null);
        String inverted_attr_name = inverted_attr.getName(null);
				String original_inverted_attr_name = getOriginalAttributeName(inverted_attr);
        boolean duplicates = inva.getDuplicates(null);
        EBound min_cardinality = null;
        EBound max_cardinality = null;
        int min_cardinality_int = Integer.MIN_VALUE;
        int max_cardinality_int = Integer.MIN_VALUE;

        if (inva.testMin_cardinality(null)) {
          min_cardinality = inva.getMin_cardinality(null);

          if (min_cardinality instanceof EInteger_bound) {
            min_cardinality_int = ((EInteger_bound) min_cardinality).getBound_value(null);
          }
        }

        if (inva.testMax_cardinality(null)) {
          max_cardinality = inva.getMax_cardinality(null);

          if (max_cardinality instanceof EInteger_bound) {
            max_cardinality_int = ((EInteger_bound) max_cardinality).getBound_value(null);
          }
        }

        if (min_cardinality_int == Integer.MIN_VALUE) { // single entity inverse attribute
          pw.println("\t// Inverse attribute - " + inva.getName(null) + " : " + 
                     referencing_entity_name + " FOR " + inverted_attr_name);
        } else { // set or bag inverse attribute

          if (duplicates) { // bag

            if (max_cardinality_int == Integer.MIN_VALUE) {
              pw.println("\t// Inverse attribute - " + inva.getName(null) + " : BAG[" + 
                         min_cardinality_int + ":?] OF " + referencing_entity_name + " FOR " + 
                         inverted_attr_name);
            } else {
              pw.println("\t// Inverse attribute - " + inva.getName(null) + " : BAG[" + 
                         min_cardinality_int + ":" + max_cardinality_int + "] OF " + 
                         referencing_entity_name + " FOR " + inverted_attr_name);
            }
          } else { // set

            if (max_cardinality_int == Integer.MIN_VALUE) {
              pw.println("\t// Inverse attribute - " + inva.getName(null) + " : SET[" + 
                         min_cardinality_int + ":" + max_cardinality_int + "] OF " + 
                         referencing_entity_name + " FOR " + inverted_attr_name);
            } else {
            }
          }
        }

        String inverse_aggregate = getEntityPackage(referencing_entity) + "A" + 
                                   referencing_entity_name.substring(0, 1).toUpperCase() + 
                                   referencing_entity_name.substring(1).toLowerCase();
        String attr_name1 = inva.getName(null);
        String attr_name0 = attr_name1.substring(0, 1).toUpperCase() + 
                            attr_name1.substring(1).toLowerCase();
        ;

        String base_name = getEntityPackage(referencing_entity) + "C" + 
                           referencing_entity_name.substring(0, 1).toUpperCase() + 
                           referencing_entity_name.substring(1).toLowerCase();
        String entity_interface_name = "E" + entity_name.substring(0, 1).toUpperCase() + 
                                       entity_name.substring(1).toLowerCase();
        String inverted_name = original_inverted_attr_name.substring(0, 1).toUpperCase() + 
                               original_inverted_attr_name.substring(1).toLowerCase();
        pw.println("\tpublic " + inverse_aggregate + " get" + attr_name0 + "(" + 
                   owning_entity_name + " type, ASdaiModel domain) throws SdaiException {");
// old 
// ARectangular_composite_surface result = new ARectangular_composite_surface();
// new
// ARectangular_composite_surface result = (ARectangular_composite_surface) get_inverse_aggregate(i0$);

        if (min_cardinality_int == Integer.MIN_VALUE) { // single entity inverse attribute
        	pw.println("\t\t" + inverse_aggregate + " result = new " + inverse_aggregate + "();");
				} else {
//NEW_IMPLEMENTATION
//        	pw.println("\t\t" + inverse_aggregate + " result = (" + inverse_aggregate + ")get_inverse_aggregate(i" + (count_inverse-1) + "$);");
        	pw.println("\t\t" + inverse_aggregate + " result = (" + inverse_aggregate + ")get_inverse_aggregate(i" + tattr.consolidated_inverse_index + "$);");
      	}
        pw.println("\t\t" + base_name + ".usedin" + inverted_name + 
                   "(null, this, domain, result);");
        pw.println("\t\treturn result;");
        pw.println("\t}");

        String method_suffix = attr_name.substring(0, 1).toUpperCase() + 
                               attr_name.substring(1).toLowerCase();
        pw.println("\tpublic static jsdai.dictionary.EAttribute attribute" + method_suffix + "(" + 
                   owning_entity_name + " type) throws SdaiException {");
//NEW_IMPLEMENTATION
//        pw.println("\t\treturn i" + (count_inverse - 1) + "$;");
        pw.println("\t\treturn i" + tattr.consolidated_inverse_index + "$;");
        pw.println("\t}");
        pw.println("");

	}

	void generateExplicitSupertypeJavaInheritedMethodsX(EEntity_definition ed, TheAttribute tattr, PrintWriter pw) throws SdaiException {
        // methods are inherited, not generated.
//        internal++;

    String entity_name = ed.getName(null);

      EAttribute attr = tattr.attr;

      EEntity_definition owner_entity = (EEntity_definition) attr.getParent_entity(null);
      String owner_name = owner_entity.getName(null);
      String owning_entity_name = getEntityPackage(owner_entity) + "E" + 
                                  owner_name.substring(0, 1).toUpperCase() + 
                                  owner_name.substring(1).toLowerCase();
      ;

      String attr_name = attr.getName(null);
      String attr_internal_name = "a" + tattr.consolidated_explicit_index;




        EExplicit_attribute xattr = (EExplicit_attribute) attr;
        String method_suffix = attr_name.substring(0, 1).toUpperCase() + 
                               attr_name.substring(1).toLowerCase();
        EEntity bt = xattr.getDomain(null);

        if (bt instanceof EAggregation_type) {
          generateExplicitAttributeAggregationTypeMethodsUsedinOnly((EAggregation_type) bt, pw, 
                                                                    entity_name, attr_name, 
                                                                    method_suffix, 
                                                                    owning_entity_name, 
                                                                    attr_internal_name);
        } else if (bt instanceof EDefined_type) {
          generateExplicitAttributeDefinedTypeMethodsUsedinOnly((EDefined_type) bt, pw, entity_name, 
                                                                attr_name, method_suffix, 
                                                                owning_entity_name, 
                                                                attr_internal_name);
        } else if (bt instanceof EEntity_definition) {
          String base_entity_name = ((EEntity_definition) bt).getName(null);
          String base_name = getEntityPackage((EEntity_definition) bt) + "E" + 
                             base_entity_name.substring(0, 1).toUpperCase() + 
                             base_entity_name.substring(1).toLowerCase();
          pw.println("\t// attribute (java explicit): " + attr_name + ", base type: entity " + base_entity_name);


          // usedin
          pw.println("\tpublic static int usedin" + method_suffix + "(" + owning_entity_name + 
                     " type, " + base_name + 
                     " instance, ASdaiModel domain, AEntity result) throws SdaiException {");
          pw.println("\t\treturn ((CEntity)instance).makeUsedin(definition, " + 
                     attr_internal_name + "$, domain, result);");
          pw.println("\t}");
        }

	}

//	void generateDerivedSupertypeJavaInheritedMethodsX(EEntity_definition ed, TheAttribute tattr, PrintWriter pw)  throws SdaiException {
	void generateDerivedSupertypeJavaInheritedMethodsX(EEntity_definition ed, TheAttribute tattr, PrintWriter pw)  throws SdaiException {
		// nothing to generate?
		// not true - for example, a derived attribute declared in entity a, redeclared in subtype entity b - 
		// if we want to generate the correct expression for b, we need to generate, java inheritance not enough
		// 

//			generateDerivedCurrentEntityMethodsXX(ed, tattr, pw);
			generateDerivedNoJavaInheritanceMethodsXX(ed, tattr, pw);

	}

//##########

	// actually, when redeclaring-as-derived, java inheritance is not good enough, because the expression may be different,
	// espectially when redeclaring a (already) derived attribute

	void generateDerivedNoJavaInheritanceMethodsXX(EEntity_definition ed, TheAttribute tattr, PrintWriter pw)  throws SdaiException  {

//		System.out.println("entity: " + ed);
//		System.out.println("attribute: " + tattr.attr);
		


    String entity_name = ed.getName(null);

      EAttribute attr = tattr.attr;

      EEntity_definition owner_entity = (EEntity_definition) attr.getParent_entity(null);
      String owner_name = owner_entity.getName(null);
      String owning_entity_name = getEntityPackage(owner_entity) + "E" + 
                                  owner_name.substring(0, 1).toUpperCase() + 
                                  owner_name.substring(1).toLowerCase();
      ;

      String attr_name = attr.getName(null);
      String attr_internal_name = "a" + tattr.consolidated_explicit_index;


        //            JavaClass expression_java = null;
        A_string expression_java = null;

        // if (flag_expressions) {
        //           EJava_code jc = findJava_codeForDerivedAttribute(attr);
        //           if (jc != null) {
        // System.out.println("### ### java code for derived attribute found");
        //                 expression_java = jc.getValues(null);
        //                 } else {
        // System.out.println("### ### java code for derived attribute NOT found");
        //                 }
        // }
        // test and get methods for all attribute types - different return types - also for select, with select path nodes - multiple methods.
        EDerived_attribute dattr = (EDerived_attribute) attr;
        String method_suffix = attr_name.substring(0, 1).toUpperCase() + 
                               attr_name.substring(1).toLowerCase();
        EEntity bt = dattr.getDomain(null);

				EAttribute last_attr = attr;
				if (tattr != null) {
					if (tattr.last_redeclared_by != null) {
						if (tattr.last_redeclared_by.attr != null) {
							last_attr = tattr.last_redeclared_by.attr;
						} else {
//							System.out.println("null - location 001"); 
						}
					} else {
//						System.out.println("null - location 002"); 
					}
				} else {
//						System.out.println("null - location 003"); 
				}

				if (bt instanceof EParameter) {
					bt = ((EParameter)bt).getParameter_type(null);
				}


        if (bt instanceof ESimple_type) {
//          generateDerivedAttributeSimpleTypeMethods(attr, (ESimple_type) bt, pw, entity_name, 
//                                                    attr_name, method_suffix, owning_entity_name, 
//                                                    attr_internal_name, expression_java);
          generateDerivedAttributeSimpleTypeMethods(last_attr, (ESimple_type) bt, pw, entity_name, 
                                                    attr_name, method_suffix, owning_entity_name, 
                                                    attr_internal_name, expression_java);


        } else if (bt instanceof EAggregation_type) {
//          generateDerivedAttributeAggregationTypeMethods(attr, (EAggregation_type) bt, pw, 
//                                                         entity_name, attr_name, method_suffix, 
//                                                         owning_entity_name, attr_internal_name, 
//                                                         expression_java);
          generateDerivedAttributeAggregationTypeMethods(last_attr, (EAggregation_type) bt, pw, 
                                                         entity_name, attr_name, method_suffix, 
                                                         owning_entity_name, attr_internal_name, 
                                                         expression_java);
        } else if (bt instanceof EDefined_type) {
//          generateDerivedAttributeDefinedTypeMethods(attr, (EDefined_type) bt, pw, entity_name, 
//                                                     attr_name, method_suffix, owning_entity_name, 
//                                                     attr_internal_name, expression_java);
          generateDerivedAttributeDefinedTypeMethods(last_attr, (EDefined_type) bt, pw, entity_name, 
                                                     attr_name, method_suffix, owning_entity_name, 
                                                     attr_internal_name, expression_java);
        } else if (bt instanceof EEntity_definition) {
          String base_entity_name = ((EEntity_definition) bt).getName(null);
          String base_name = getEntityPackage((EEntity_definition) bt) + "E" + 
                             base_entity_name.substring(0, 1).toUpperCase() + 
                             base_entity_name.substring(1).toLowerCase();
// System.out.println("<<<>>> entity: " + ed.getName(null) + ", derived attribute: " + attr_name + ", base type: entity " + base_entity_name);
          pw.println("\t// derived attribute (current derived or supertype derived): " + attr_name + ", base type: entity " + 
                     base_entity_name);
          pw.println("\tpublic boolean test" + method_suffix + "(" + owning_entity_name + 
                     " type) throws " + "SdaiException {");
          pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
          pw.println("\t}");

          pw.println("\tpublic " + "Value" + " get" + method_suffix + "(" + owning_entity_name + 
                     " type, SdaiContext _context) throws " + "SdaiException {");

          //               if ((flag_expressions) & (expression_java != null)) {
          if (flag_expressions) {
//		        generateJavaExpressionForDeriveMethodsInc(pw, attr, sd, _ed, model);
		        generateJavaExpressionForDeriveMethodsInc(pw, last_attr, sd, _ed, model);

          } else {
            pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
          }

          pw.println("\t}");

          pw.println("\tpublic " + base_name + " get" + method_suffix + "(" + owning_entity_name + 
                     " type) throws " + "SdaiException {");


          //               if ((flag_expressions) & (expression_java != null)) {

//RR-SdaiContext-temp
//          pw.println("\t\tSdaiContext _context = SdaiSession.getSdaiContext();");
          pw.println("\t\tSdaiContext _context = this.findEntityInstanceSdaiModel().getRepository().getSession().getSdaiContext();");

          if (flag_expressions) {
            //						pw.println("\t\t\tSdaiContext _context = this.findEntityInstanceSdaiModel().getRepository().getSession().getSdaiContext();");
//            pw.println("\t\t\treturn (" + base_name + ") get" + method_suffix + "(null, _context).getActualType();");
            pw.println("\t\t\treturn (" + base_name + ") get" + method_suffix + "(null, _context).getInstance();");
          } else {
            pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
          }

          pw.println("\t}");
        }

        pw.println("\tpublic static jsdai.dictionary.EAttribute attribute" + method_suffix + "(" + 
                   owning_entity_name + " type) throws SdaiException {");
//NEW_IMPLEMENTATION
//        pw.println("\t\treturn d" + (count_derived - 1) + "$;");
        pw.println("\t\treturn d" + tattr.consolidated_derived_index + "$;");
        pw.println("\t}");
        pw.println("");


	}

//##########

//	void generateInverseSupertypeJavaInheritedMethodsX(EEntity_definition ed, TheAttribute tattr, PrintWriter pw)  throws SdaiException {
	void generateInverseSupertypeJavaInheritedMethodsX(EEntity_definition ed, TheAttribute tattr, PrintWriter pw) {
		 // nothing to generate
	}


	void generateExplicit2DerivedCurrentEntityMethodsX(EEntity_definition ed, TheAttribute tattr, PrintWriter pw, boolean is_original) throws SdaiException {
		if (debug_java) pw.println("\t// generateExplicit2DerivedNonJavaMethodsX: 1");
		generateExplicit2DerivedNonJavaMethodsX(ed, tattr, pw, is_original);
	}

	void generateExplicit2DerivedCurrentEntityMethodsXAlt(EEntity_definition ed, TheAttribute tattr, PrintWriter pw) throws SdaiException {

	    String entity_name = ed.getName(null);

      EAttribute attr = tattr.attr;

      EEntity_definition owner_entity = (EEntity_definition) attr.getParent_entity(null);
      String owner_name = owner_entity.getName(null);
      String owning_entity_name = getEntityPackage(owner_entity) + "E" + 
                                  owner_name.substring(0, 1).toUpperCase() + 
                                  owner_name.substring(1).toLowerCase();
      ;

      String attr_name = attr.getName(null);
      String attr_internal_name = "a" + tattr.consolidated_explicit_index;



        EExplicit_attribute xattr = (EExplicit_attribute) attr;
        String method_suffix = attr_name.substring(0, 1).toUpperCase() + 
                               attr_name.substring(1).toLowerCase();
      
     
        EEntity bt = xattr.getDomain(null);

			
			


        if (bt instanceof ESimple_type) {
          generateLaterRedeclaredAttributeSimpleTypeMethods((ESimple_type) bt, pw, entity_name, 
                                                            attr_name, method_suffix, 
                                                            owning_entity_name, attr_internal_name);
        } else if (bt instanceof EAggregation_type) {
          generateLaterRedeclaredAttributeAggregationTypeMethods((EAggregation_type) bt, pw, 
                                                                 entity_name, attr_name, 
                                                                 method_suffix, owning_entity_name, 
                                                                 attr_internal_name);
        } else if (bt instanceof EDefined_type) {
          generateLaterRedeclaredAttributeDefinedTypeMethods((EDefined_type) bt, pw, entity_name, 
                                                             attr_name, method_suffix, 
                                                             owning_entity_name, attr_internal_name);
        } else if (bt instanceof EEntity_definition) {
          String base_entity_name = ((EEntity_definition) bt).getName(null);
          String base_name = getEntityPackage((EEntity_definition) bt) + "E" + 
                             base_entity_name.substring(0, 1).toUpperCase() + 
                             base_entity_name.substring(1).toLowerCase();
          pw.println("\t// -14- explicit redeclared as derived attribute: " + attr_name + 
                     ", base type: entity " + base_entity_name);
          pw.println("\tpublic boolean test" + method_suffix + "(" + owning_entity_name + 
                     " type) throws " + "SdaiException {");
          pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
          pw.println("\t}");

          // we have Value method in interface but not here?
          // trying to add one:

          pw.println("\tpublic " + "Value" + " get" + method_suffix + "(" + owning_entity_name + 
                     " type, SdaiContext _context) throws " + "SdaiException {");

            pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");

          pw.println("\t}");
          


          // base_name get Method
          pw.println("\tpublic " + base_name + " get" + method_suffix + "(" + owning_entity_name + 
                     " type) throws " + "SdaiException {");
          pw.println("\t\t\t// FN_NAVL - 21");
          pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
          pw.println("\t}");
          pw.println("\tpublic void set" + method_suffix + "(" + owning_entity_name + " type, " + 
                     base_name + " value) throws SdaiException {");
          pw.println("\t\t\tthrow new SdaiException(SdaiException.AT_NVLD);");
          pw.println("\t}");
          pw.println("\tpublic void unset" + method_suffix + "(" + owning_entity_name + 
                     " type) throws SdaiException {");
          pw.println("\t\t\tthrow new SdaiException(SdaiException.AT_NVLD);");
          pw.println("\t}");
        }

        pw.println("\tpublic static jsdai.dictionary.EAttribute attribute" + method_suffix + "(" + 
                   owning_entity_name + " type) throws SdaiException {");
//NEW_IMPLEMENTATION
//        pw.println("\t\treturn d" + (count_derived - 1) + "$;");
        pw.println("\t\treturn d" + tattr.consolidated_derived_index + "$;");
        pw.println("\t}");
        pw.println("");


	}

	void generateExplicit2DerivedSupertypeJavaInheritedMethodsXX(EEntity_definition ed, TheAttribute tattr, PrintWriter pw, boolean is_original) throws SdaiException {
//	void generateExplicit2DerivedSupertypeJavaInheritedMethodsX(EEntity_definition ed, TheAttribute tattr, PrintWriter pw, boolean is_original) {
		// not sure if needed anything
		
		// experiment:
//		if (is_original) {
		
		if (tattr.consolidated_derived_count > 1) {
			generateExplicit2DerivedNonJavaMethodsXX(ed, tattr, pw, is_original);
		}
//		}
	}


	void generateExplicit2DerivedSupertypeJavaInheritedMethodsX(EEntity_definition ed, TheAttribute tattr, PrintWriter pw, boolean is_original) throws SdaiException {
//	void generateExplicit2DerivedSupertypeJavaInheritedMethodsX(EEntity_definition ed, TheAttribute tattr, PrintWriter pw, boolean is_original) {
		// not sure if needed anything
		
		// experiment:
		if (is_original) {
		
		  if (debug_java) pw.println("\t// generateExplicit2DerivedNonJavaMethodsX: 2");
			generateExplicit2DerivedNonJavaMethodsX(ed, tattr, pw, is_original);
		} else {
			if (tattr.consolidated) {

				if (debug_java) pw.println("\t// generateExplicit2DerivedNonJavaMethodsX: 3");
				generateExplicit2DerivedNonJavaMethodsX(ed, tattr, pw, is_original);
			} else {
//				System.out.println("non-original non-consolidated: " + ed + "\n" + tattr);
//				pw.println("/* non-original non-consolidated: " + ed + "\n" + tattr + "\n*/");
			}
		}
	}

	void generateExplicit2DerivedSupertypeNoJavaInheritanceMethodsX(EEntity_definition ed, TheAttribute tattr, PrintWriter pw, boolean is_original) throws SdaiException {
		if (debug_java) pw.println("\t// generateExplicit2DerivedNonJavaMethodsX: 4");
		// this is a fix for bug 2473
		if (ed.getComplex(null)) {
			pw.println("\t // <><> to change the type of type parameter ####");

      String current_name1 = tattr.attr.getName(null);
      String current_name2 = tattr.consolidated_explicit_to_derived.attr.getName(null);
      if (current_name1.equalsIgnoreCase(current_name2)) {
				is_original = true;
				pw.println("\t // <><> DONE - changing!");
      }

		}
		generateExplicit2DerivedNonJavaMethodsX(ed, tattr, pw, is_original);
	}


 void generateExplicit2DerivedNonJavaMethodsXX(EEntity_definition ed, TheAttribute tattr, PrintWriter pw, boolean is_original) throws SdaiException {

//		pw.println("/*\n\t entity: " + ed + "\n*/");
//		pw.println("/*\n\nattribute: " + tattr + "\n*/");

    String entity_name = ed.getName(null);
    String current_name = null;

      //EAttribute attr = tattr.attr;
      EAttribute attr = null;
      if (is_original) {
      	// two possible interpretations - the whole original attribute, or only original name
      	// the interpretation with the whole attribute is not good, because it becomes explicit instead of derived,
      	// perhaps completely differnt method better be used (of the explicit later redeclared variety)
      	// or try to use the original name only
      	attr = tattr.attr;
      	current_name = tattr.attr.getName(null);


				if (attr instanceof EExplicit_attribute) {
					// wrong, we need derived here, have to handle the case when first redeclared as derived is with new name, 
					// we may want to find the original name even when it is not the first

      
     
      
   			  				for (int j = 0; j < tattr.consolidated_primary_derived.size(); j++) {
			  						TheAttribute tattr3 = (TheAttribute)tattr.consolidated_primary_derived.get(j);
			  						// String tattr_name = tattr.attr.getName(null);
			  						EAttribute attr3 = tattr3.attr;
			  						String tattr3_name = attr3.getName(null);
										if (attr3 instanceof EDerived_attribute) {
											// it should be
											if (tattr3_name.equalsIgnoreCase(current_name)) {
												attr = attr3;
												break;
											}
										}			  					
			  					
			  					}

				}
      
      
      
      
      
      } else {
      	current_name = tattr.consolidated_explicit_to_derived.attr.getName(null);
	//     	attr = tattr.consolidated_explicit_to_derived.attr;
     		attr = tattr.consolidated_explicit_to_derived.attr;
			}

//			if (tattr.consolidated_explicit_to_derived != null) {
//			} else {
//				attr = tattr.attr;
//			}

			// so which exactly entity is needed in the case of is_original?

      EEntity_definition owner_entity = (EEntity_definition) attr.getParent_entity(null);
      String owner_name = owner_entity.getName(null);
      String owning_entity_name = getEntityPackage(owner_entity) + "E" + 
                                  owner_name.substring(0, 1).toUpperCase() + 
                                  owner_name.substring(1).toLowerCase();
      ;

      //String attr_name = attr.getName(null);
      String attr_name = current_name;
      String attr_internal_name = "a" + tattr.consolidated_explicit_index;


//        EDerived_attribute dattr = (EDerived_attribute) attr;
        EDerived_attribute dattr = (EDerived_attribute) tattr.consolidated_explicit_to_derived.attr;

				EAttribute redeclared_attr = null;
				EEntity_definition redeclared_owner_entity = null;
				String redeclared_owner_name = null;
				String redeclared_owning_entity_name = null;
				
				if (dattr.testRedeclaring(null)) {
					redeclared_attr = (EAttribute)dattr.getRedeclaring(null);
				} 
				
				String redeclared_name = null;
				String redeclaring_name = attr.getName(null);
				
				if (redeclared_attr != null) {
				
					redeclared_name = redeclared_attr.getName(null);
	      	redeclared_owner_entity = (EEntity_definition) redeclared_attr.getParent_entity(null);
      		redeclared_owner_name = redeclared_owner_entity.getName(null);
      		redeclared_owning_entity_name = getEntityPackage(redeclared_owner_entity) + "E" + 
                                  redeclared_owner_name.substring(0, 1).toUpperCase() + 
                                  redeclared_owner_name.substring(1).toLowerCase();
				}	
				
        A_string expression_java = null;
				
				if (redeclared_attr instanceof EExplicit_attribute) {

//  	      count_derived++;

//				if (attribute_flag == AA_SUPERTYPE_DERIVED_REDECLARING) {
//					internal++;
//				}
				
				
        String method_suffix = attr_name.substring(0, 1).toUpperCase() + 
                               attr_name.substring(1).toLowerCase();
//        EEntity bt = dattr.getDomain(null);

  // trying to replace with the method that calculates the type
 //       EEntity bt = ((EExplicit_attribute)redeclared_attr).getDomain(null);

//					EEntity bt_prev = xattr_prev.getDomain(null);
					EEntity bt = calculateTypeOfRedeclaredAttribute(attr);


					if (is_original) {
			      EEntity_definition owner_entity_x = (EEntity_definition) tattr.attr.getParent_entity(null);
      			String owner_name_x = owner_entity_x.getName(null);
      			String owning_entity_name_x = getEntityPackage(owner_entity_x) + "E" + 
                                  owner_name_x.substring(0, 1).toUpperCase() + 
                                  owner_name_x.substring(1).toLowerCase();


						redeclared_owning_entity_name = owning_entity_name_x;
					}


        if (bt instanceof ESimple_type) {
          if (debug_java) pw.println("\t// generateJavaExplicit2DerivedAttributeSimpleTypeMethods: 3");
          generateJavaExplicit2DerivedAttributeSimpleTypeMethods(attr, redeclared_attr,(ESimple_type) bt, pw, entity_name, 
                                                            attr_name, method_suffix, 
                                                            redeclared_owning_entity_name, attr_internal_name, expression_java);
        } else if (bt instanceof EAggregation_type) {
//          generateLaterRedeclaredAttributeAggregationTypeMethods((EAggregation_type) bt, pw, 
//                                                                 entity_name, attr_name, 
//                                                                 method_suffix, owning_entity_name, 
//                                                                 attr_internal_name);

          generateJavaExplicit2DerivedAttributeAggregationTypeMethods(attr, redeclared_attr,(EAggregation_type) bt, pw, entity_name, 
                                                            attr_name, method_suffix, 
                                                            redeclared_owning_entity_name, attr_internal_name, expression_java);

        } else if (bt instanceof EDefined_type) {
//          generateLaterRedeclaredAttributeDefinedTypeMethods((EDefined_type) bt, pw, entity_name, 
//                                                             attr_name, method_suffix, 
//                                                             owning_entity_name, attr_internal_name);

          generateJavaExplicit2DerivedAttributeDefinedTypeMethods(attr, redeclared_attr, (EDefined_type) bt, pw, entity_name, 
                                                             attr_name, method_suffix, 
                                                             redeclared_owning_entity_name, attr_internal_name, expression_java);
        } else if (bt instanceof EEntity_definition) {
// old
/*
          String base_entity_name = ((EEntity_definition) bt).getName(null);
          String base_name = getEntityPackage((EEntity_definition) bt) + "E" + 
                             base_entity_name.substring(0, 1).toUpperCase() + 
                             base_entity_name.substring(1).toLowerCase();
          pw.println("\t// explicit redeclared as derived attribute: " + attr_name + 
                     ", base type: entity " + base_entity_name);
          pw.println("\tpublic boolean test" + method_suffix + "(" + owning_entity_name + 
                     " type) throws " + "SdaiException {");
          pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
          pw.println("\t}");


          // base_name get Method
          pw.println("\tpublic " + base_name + " get" + method_suffix + "(" + owning_entity_name + 
                     " type) throws " + "SdaiException {");
          pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
          pw.println("\t}");
          pw.println("\tpublic void set" + method_suffix + "(" + owning_entity_name + " type, " + 
                     base_name + " value) throws SdaiException {");
          pw.println("\t\t\tthrow new SdaiException(SdaiException.AT_NVLD);");
          pw.println("\t}");
          pw.println("\tpublic void unset" + method_suffix + "(" + owning_entity_name + 
                     " type) throws SdaiException {");
          pw.println("\t\t\tthrow new SdaiException(SdaiException.AT_NVLD);");
          pw.println("\t}");
*/
// old end

// new        



          String base_entity_name = ((EEntity_definition) bt).getName(null);
          String base_name = getEntityPackage((EEntity_definition) bt) + "E" + 
                             base_entity_name.substring(0, 1).toUpperCase() + 
                             base_entity_name.substring(1).toLowerCase();
// System.out.println("<<<>>> entity: " + ed.getName(null) + ", derived attribute: " + attr_name + ", base type: entity " + base_entity_name);
          pw.println("\t// -15A- explicit redeclared as derived attribute: " + attr_name + ", base type: entity " + 
                     base_entity_name);


					
          pw.println("\tpublic static int usedin" + method_suffix + "(" + redeclared_owning_entity_name + 
                     " type, " + base_name + 
                     " instance, ASdaiModel domain, AEntity result) throws SdaiException {");
          pw.println("\t\t\t// FN_NAVL - 22 - USEDIN");
          pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
//          pw.println("\t\treturn ((CEntity)instance).makeUsedin(definition, " + 
//                     attr_internal_name + "$, domain, result);");
          pw.println("\t}");

          pw.println("\tpublic boolean test" + method_suffix + "(" + redeclared_owning_entity_name + 
                     " type) throws " + "SdaiException {");
          pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
          pw.println("\t}");

          pw.println("\tpublic " + "Value" + " get" + method_suffix + "(" + redeclared_owning_entity_name + 
                     " type, SdaiContext _context) throws " + "SdaiException {");

          //               if ((flag_expressions) & (expression_java != null)) {
          if (flag_expressions) {
pw.println("//HEHE invoking expression generation, attr: " + attr + ", sd: " + sd + ", _ed: " + _ed + ", model: " + model);
		        generateJavaExpressionForDeriveMethodsInc(pw, attr, sd, _ed, model);

          } else {
            pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
          }

          pw.println("\t}");



          pw.println("\tpublic " + base_name + " get" + method_suffix + "(" + redeclared_owning_entity_name + 
                     " type) throws " + "SdaiException {");


          //               if ((flag_expressions) & (expression_java != null)) {

//RR-SdaiContext-temp
//          pw.println("\t\tSdaiContext _context = SdaiSession.getSdaiContext();");
          pw.println("\t\tSdaiContext _context = this.findEntityInstanceSdaiModel().getRepository().getSession().getSdaiContext();");

          if (flag_expressions) {
            //						pw.println("\t\t\tSdaiContext _context = this.findEntityInstanceSdaiModel().getRepository().getSession().getSdaiContext();");
//            pw.println("\t\t\treturn (" + base_name + ") get" + method_suffix + "(null, _context).getActualType();");
            pw.println("\t\t\treturn (" + base_name + ") get" + method_suffix + "(null, _context).getInstance();");
          } else {
            pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
          }

          pw.println("\t}");

// let's have  another method with sdaicontext parameter, just in case
// no - we cannot have it, because we already have Value, so only return type is different,
// we need to change the order of parameters, if we really need this method

/*
          pw.println("\tpublic " + base_name + " get" + method_suffix + "(" + redeclared_owning_entity_name + 
                     " type, SdaiContext _context) throws " + "SdaiException {");


          //               if ((flag_expressions) & (expression_java != null)) {

//RR-SdaiContext-temp
//          pw.println("\t\tSdaiContext _context = SdaiSession.getSdaiContext();");

//          pw.println("\t\tSdaiContext _context = this.findEntityInstanceSdaiModel().getRepository().getSession().getSdaiContext();");

          if (flag_expressions) {
            //						pw.println("\t\t\tSdaiContext _context = this.findEntityInstanceSdaiModel().getRepository().getSession().getSdaiContext();");
//            pw.println("\t\t\treturn (" + base_name + ") get" + method_suffix + "(null, _context).getActualType();");
            pw.println("\t\t\treturn (" + base_name + ") get" + method_suffix + "(null, _context).getInstance();");
          } else {
            pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
          }

          pw.println("\t}");

*/


        
          pw.println("\tpublic void set" + method_suffix + "(" + redeclared_owning_entity_name + " type, " + 
                     base_name + " value) throws SdaiException {");
          pw.println("\t\t\tthrow new SdaiException(SdaiException.AT_NVLD);");
          pw.println("\t}");
          pw.println("\tpublic void unset" + method_suffix + "(" + redeclared_owning_entity_name + 
                     " type) throws SdaiException {");
          pw.println("\t\t\tthrow new SdaiException(SdaiException.AT_NVLD);");
          pw.println("\t}");
      
// new end        
        }

        pw.println("\tpublic static jsdai.dictionary.EAttribute attribute" + method_suffix + "(" + 
                   redeclared_owning_entity_name + " type) throws SdaiException {");
//NEW_IMPLEMENTATION
//        pw.println("\t\treturn d" + (count_derived - 1) + "$;");

       // let's better give it consolidated node, and extract explicit2derived here in the method

// should be ok for both values of is_original - because the derived field is used and not explicit
        pw.println("\t\treturn d" + tattr.consolidated_derived_index + "$;");

        // not the consolidated given here, but the derived that later redeclares it, and its consolidated fields are empty
//        pw.println("\t\treturn d" + tattr.derived_index + "$;");

        pw.println("\t}");
        pw.println("");

				} else  //  above - the case when explicit redeclared as derived
				if (redeclared_attr instanceof EDerived_attribute) {
					// derived as derived
				} else {
				}
			


 }

//#### back-up


 void generateExplicit2DerivedNonJavaMethodsXB(EEntity_definition ed, TheAttribute tattr, PrintWriter pw, boolean is_original) throws SdaiException {

//		System.out.println("entity: " + ed);
//		System.out.println("the attribute: " + tattr.attr);
//		System.out.println("the attribute: " + tattr);





    String entity_name = ed.getName(null);
    String current_name = null;

      //EAttribute attr = tattr.attr;
      EAttribute attr = null;
      if (is_original) {
      	// two possible interpretations - the whole original attribute, or only original name
      	// the interpretation with the whole attribute is not good, because it becomes explicit instead of derived,
      	// perhaps completely differnt method better be used (of the explicit later redeclared variety)
      	// or try to use the original name only
      	//attr = tattr.attr;
      	current_name = tattr.attr.getName(null);
      } else {
      	current_name = tattr.consolidated_explicit_to_derived.attr.getName(null);
	//     	attr = tattr.consolidated_explicit_to_derived.attr;
			}

//			if (tattr.consolidated_explicit_to_derived != null) {
     		attr = tattr.consolidated_explicit_to_derived.attr;
//			} else {
//				attr = tattr.attr;
//			}

			// so which exactly entity is needed in the case of is_original?

      EEntity_definition owner_entity = (EEntity_definition) attr.getParent_entity(null);
      String owner_name = owner_entity.getName(null);
      String owning_entity_name = getEntityPackage(owner_entity) + "E" + 
                                  owner_name.substring(0, 1).toUpperCase() + 
                                  owner_name.substring(1).toLowerCase();
      ;

      //String attr_name = attr.getName(null);
      String attr_name = current_name;
      String attr_internal_name = "a" + tattr.consolidated_explicit_index;


        EDerived_attribute dattr = (EDerived_attribute) attr;

				EAttribute redeclared_attr = null;
				EEntity_definition redeclared_owner_entity = null;
				String redeclared_owner_name = null;
				String redeclared_owning_entity_name = null;
				
				if (dattr.testRedeclaring(null)) {
					redeclared_attr = (EAttribute)dattr.getRedeclaring(null);
				} 
				
				String redeclared_name = null;
				String redeclaring_name = attr.getName(null);
				
				if (redeclared_attr != null) {
				
					redeclared_name = redeclared_attr.getName(null);
	      	redeclared_owner_entity = (EEntity_definition) redeclared_attr.getParent_entity(null);
      		redeclared_owner_name = redeclared_owner_entity.getName(null);
      		redeclared_owning_entity_name = getEntityPackage(redeclared_owner_entity) + "E" + 
                                  redeclared_owner_name.substring(0, 1).toUpperCase() + 
                                  redeclared_owner_name.substring(1).toLowerCase();
				}	
				
        A_string expression_java = null;
				
				if (redeclared_attr instanceof EExplicit_attribute) {

//  	      count_derived++;

//				if (attribute_flag == AA_SUPERTYPE_DERIVED_REDECLARING) {
//					internal++;
//				}
				
				String before_name = redeclared_owning_entity_name;
				String after_name = null;
				
        String method_suffix = attr_name.substring(0, 1).toUpperCase() + 
                               attr_name.substring(1).toLowerCase();
//        EEntity bt = dattr.getDomain(null);

  // trying to replace with the method that calculates the type
 //       EEntity bt = ((EExplicit_attribute)redeclared_attr).getDomain(null);

//					EEntity bt_prev = xattr_prev.getDomain(null);
					EEntity bt = calculateTypeOfRedeclaredAttribute(attr);


//					if (is_original) {
			      EEntity_definition owner_entity_x = (EEntity_definition) tattr.attr.getParent_entity(null);
      			String owner_name_x = owner_entity_x.getName(null);
      			String owning_entity_name_x = getEntityPackage(owner_entity_x) + "E" + 
                                  owner_name_x.substring(0, 1).toUpperCase() + 
                                  owner_name_x.substring(1).toLowerCase();

					after_name = owning_entity_name_x;
					if (is_original) {

						redeclared_owning_entity_name = owning_entity_name_x;
					}


        if (bt instanceof ESimple_type) {

          if (debug_java) pw.println("\t// generateJavaExplicit2DerivedAttributeSimpleTypeMethods: 4");
          if (debug_java) {
          	pw.println("\t //is_original: " + is_original);
          	pw.println("\t //redeclared_owning_entity_name: " + before_name);
          	pw.println("\t //redeclared_owning_entity_name, if is_original: " + after_name);
          	pw.println("\t //current_name: " + tattr.consolidated_explicit_to_derived.attr.getName(null));
          	pw.println("\t //current_name, if is_original: " + tattr.attr.getName(null));
          }
System.out.println("//####### tattr.attr: " + tattr.last_redeclared_by.attr);

          generateJavaExplicit2DerivedAttributeSimpleTypeMethods(attr, redeclared_attr,(ESimple_type) bt, pw, entity_name, 
// the above gives first redeclared as derived instead of the last one - wrong expression generated

//	TheAttribute last_redeclared_by;

//          generateJavaExplicit2DerivedAttributeSimpleTypeMethods(tattr.last_redeclared_by.attr, redeclared_attr,(ESimple_type) bt, pw, entity_name, 
                                                            attr_name, method_suffix, 
                                                            redeclared_owning_entity_name, attr_internal_name, expression_java);
        } else if (bt instanceof EAggregation_type) {
//          generateLaterRedeclaredAttributeAggregationTypeMethods((EAggregation_type) bt, pw, 
//                                                                 entity_name, attr_name, 
//                                                                 method_suffix, owning_entity_name, 
//                                                                 attr_internal_name);

          generateJavaExplicit2DerivedAttributeAggregationTypeMethods(attr, redeclared_attr,(EAggregation_type) bt, pw, entity_name, 
                                                            attr_name, method_suffix, 
                                                            redeclared_owning_entity_name, attr_internal_name, expression_java);

        } else if (bt instanceof EDefined_type) {
//          generateLaterRedeclaredAttributeDefinedTypeMethods((EDefined_type) bt, pw, entity_name, 
//                                                             attr_name, method_suffix, 
//                                                             owning_entity_name, attr_internal_name);

          generateJavaExplicit2DerivedAttributeDefinedTypeMethods(attr, redeclared_attr, (EDefined_type) bt, pw, entity_name, 
                                                             attr_name, method_suffix, 
                                                             redeclared_owning_entity_name, attr_internal_name, expression_java);
        } else if (bt instanceof EEntity_definition) {
// old
/*
          String base_entity_name = ((EEntity_definition) bt).getName(null);
          String base_name = getEntityPackage((EEntity_definition) bt) + "E" + 
                             base_entity_name.substring(0, 1).toUpperCase() + 
                             base_entity_name.substring(1).toLowerCase();
          pw.println("\t// explicit redeclared as derived attribute: " + attr_name + 
                     ", base type: entity " + base_entity_name);
          pw.println("\tpublic boolean test" + method_suffix + "(" + owning_entity_name + 
                     " type) throws " + "SdaiException {");
          pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
          pw.println("\t}");


          // base_name get Method
          pw.println("\tpublic " + base_name + " get" + method_suffix + "(" + owning_entity_name + 
                     " type) throws " + "SdaiException {");
          pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
          pw.println("\t}");
          pw.println("\tpublic void set" + method_suffix + "(" + owning_entity_name + " type, " + 
                     base_name + " value) throws SdaiException {");
          pw.println("\t\t\tthrow new SdaiException(SdaiException.AT_NVLD);");
          pw.println("\t}");
          pw.println("\tpublic void unset" + method_suffix + "(" + owning_entity_name + 
                     " type) throws SdaiException {");
          pw.println("\t\t\tthrow new SdaiException(SdaiException.AT_NVLD);");
          pw.println("\t}");
*/
// old end

// new        



          String base_entity_name = ((EEntity_definition) bt).getName(null);
          String base_name = getEntityPackage((EEntity_definition) bt) + "E" + 
                             base_entity_name.substring(0, 1).toUpperCase() + 
                             base_entity_name.substring(1).toLowerCase();
// System.out.println("<<<>>> entity: " + ed.getName(null) + ", derived attribute: " + attr_name + ", base type: entity " + base_entity_name);
          pw.println("\t// -15B- explicit redeclared as derived attribute: " + attr_name + ", base type: entity " + 
                     base_entity_name);


					
          pw.println("\tpublic static int usedin" + method_suffix + "(" + redeclared_owning_entity_name + 
                     " type, " + base_name + 
                     " instance, ASdaiModel domain, AEntity result) throws SdaiException {");
          pw.println("\t\t\t// FN_NAVL - 23 - USEDIN");
          pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
//          pw.println("\t\treturn ((CEntity)instance).makeUsedin(definition, " + 
//                     attr_internal_name + "$, domain, result);");
          pw.println("\t}");

          pw.println("\tpublic boolean test" + method_suffix + "(" + redeclared_owning_entity_name + 
                     " type) throws " + "SdaiException {");
          pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
          pw.println("\t}");

          pw.println("\tpublic " + "Value" + " get" + method_suffix + "(" + redeclared_owning_entity_name + 
                     " type, SdaiContext _context) throws " + "SdaiException {");

          //               if ((flag_expressions) & (expression_java != null)) {
          if (flag_expressions) {

pw.println("//HOHO invoking expression generation, attr: " + attr + ", sd: " + sd + ", _ed: " + _ed + ", model: " + model);
		        generateJavaExpressionForDeriveMethodsInc(pw, attr, sd, _ed, model);

          } else {
            pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
          }

          pw.println("\t}");



          pw.println("\tpublic " + base_name + " get" + method_suffix + "(" + redeclared_owning_entity_name + 
                     " type) throws " + "SdaiException {");


          //               if ((flag_expressions) & (expression_java != null)) {

//RR-SdaiContext-temp
//          pw.println("\t\tSdaiContext _context = SdaiSession.getSdaiContext();");
          pw.println("\t\tSdaiContext _context = this.findEntityInstanceSdaiModel().getRepository().getSession().getSdaiContext();");

          if (flag_expressions) {
            //						pw.println("\t\t\tSdaiContext _context = this.findEntityInstanceSdaiModel().getRepository().getSession().getSdaiContext();");
//            pw.println("\t\t\treturn (" + base_name + ") get" + method_suffix + "(null, _context).getActualType();");
            pw.println("\t\t\treturn (" + base_name + ") get" + method_suffix + "(null, _context).getInstance();");
          } else {
            pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
          }

          pw.println("\t}");

// let's have  another method with sdaicontext parameter, just in case
// no - we cannot have it, because we already have Value, so only return type is different,
// we need to change the order of parameters, if we really need this method

/*
          pw.println("\tpublic " + base_name + " get" + method_suffix + "(" + redeclared_owning_entity_name + 
                     " type, SdaiContext _context) throws " + "SdaiException {");


          //               if ((flag_expressions) & (expression_java != null)) {

//RR-SdaiContext-temp
//          pw.println("\t\tSdaiContext _context = SdaiSession.getSdaiContext();");

//          pw.println("\t\tSdaiContext _context = this.findEntityInstanceSdaiModel().getRepository().getSession().getSdaiContext();");

          if (flag_expressions) {
            //						pw.println("\t\t\tSdaiContext _context = this.findEntityInstanceSdaiModel().getRepository().getSession().getSdaiContext();");
//            pw.println("\t\t\treturn (" + base_name + ") get" + method_suffix + "(null, _context).getActualType();");
            pw.println("\t\t\treturn (" + base_name + ") get" + method_suffix + "(null, _context).getInstance();");
          } else {
            pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
          }

          pw.println("\t}");

*/


        
          pw.println("\tpublic void set" + method_suffix + "(" + redeclared_owning_entity_name + " type, " + 
                     base_name + " value) throws SdaiException {");
          pw.println("\t\t\tthrow new SdaiException(SdaiException.AT_NVLD);");
          pw.println("\t}");
          pw.println("\tpublic void unset" + method_suffix + "(" + redeclared_owning_entity_name + 
                     " type) throws SdaiException {");
          pw.println("\t\t\tthrow new SdaiException(SdaiException.AT_NVLD);");
          pw.println("\t}");
      
// new end        
        }

        pw.println("\tpublic static jsdai.dictionary.EAttribute attribute" + method_suffix + "(" + 
                   redeclared_owning_entity_name + " type) throws SdaiException {");
//NEW_IMPLEMENTATION
//        pw.println("\t\treturn d" + (count_derived - 1) + "$;");

       // let's better give it consolidated node, and extract explicit2derived here in the method

// should be ok for both values of is_original - because the derived field is used and not explicit
        pw.println("\t\treturn d" + tattr.consolidated_derived_index + "$;");

        // not the consolidated given here, but the derived that later redeclares it, and its consolidated fields are empty
//        pw.println("\t\treturn d" + tattr.derived_index + "$;");

        pw.println("\t}");
        pw.println("");

				} else  //  above - the case when explicit redeclared as derived
				if (redeclared_attr instanceof EDerived_attribute) {
					// derived as derived
				} else {
				}
				



 }

//#### back-up


 void generateExplicit2DerivedNonJavaMethodsX(EEntity_definition ed, TheAttribute tattr, PrintWriter pw, boolean is_original) throws SdaiException {

//		System.out.println("entity: " + ed);
//		System.out.println("the attribute: " + tattr.attr);
//		System.out.println("the attribute: " + tattr);


pw.println("\t\t//#X# 01");



    String entity_name = ed.getName(null);
    String current_name = null;

      //EAttribute attr = tattr.attr;
      EAttribute attr = null;
      if (is_original) {
      	// two possible interpretations - the whole original attribute, or only original name
      	// the interpretation with the whole attribute is not good, because it becomes explicit instead of derived,
      	// perhaps completely differnt method better be used (of the explicit later redeclared variety)
      	// or try to use the original name only
      	//attr = tattr.attr;
      	current_name = tattr.attr.getName(null);
      } else {
      	current_name = tattr.consolidated_explicit_to_derived.attr.getName(null);
	//     	attr = tattr.consolidated_explicit_to_derived.attr;
			}

//			if (tattr.consolidated_explicit_to_derived != null) {
     		attr = tattr.consolidated_explicit_to_derived.attr;
//			} else {
//				attr = tattr.attr;
//			}

			// so which exactly entity is needed in the case of is_original?

      EEntity_definition owner_entity = (EEntity_definition) attr.getParent_entity(null);
      String owner_name = owner_entity.getName(null);
      String owning_entity_name = getEntityPackage(owner_entity) + "E" + 
                                  owner_name.substring(0, 1).toUpperCase() + 
                                  owner_name.substring(1).toLowerCase();
      ;

      //String attr_name = attr.getName(null);
      String attr_name = current_name;
      String attr_internal_name = "a" + tattr.consolidated_explicit_index;


        EDerived_attribute dattr = (EDerived_attribute) attr;

				EAttribute redeclared_attr = null;
				EEntity_definition redeclared_owner_entity = null;
				String redeclared_owner_name = null;
				String redeclared_owning_entity_name = null;
				
				if (dattr.testRedeclaring(null)) {
					redeclared_attr = (EAttribute)dattr.getRedeclaring(null);
				} 
				
				String redeclared_name = null;
				String redeclaring_name = attr.getName(null);
				
				if (redeclared_attr != null) {
				
					redeclared_name = redeclared_attr.getName(null);
	      	redeclared_owner_entity = (EEntity_definition) redeclared_attr.getParent_entity(null);
      		redeclared_owner_name = redeclared_owner_entity.getName(null);
      		redeclared_owning_entity_name = getEntityPackage(redeclared_owner_entity) + "E" + 
                                  redeclared_owner_name.substring(0, 1).toUpperCase() + 
                                  redeclared_owner_name.substring(1).toLowerCase();
				}	
				
pw.println("\t //<><> redeclared_owning_entity_name: " + redeclared_owning_entity_name);
				
        A_string expression_java = null;
				
				if (redeclared_attr instanceof EExplicit_attribute) {

//  	      count_derived++;

//				if (attribute_flag == AA_SUPERTYPE_DERIVED_REDECLARING) {
//					internal++;
//				}
				
				String before_name = redeclared_owning_entity_name;
				String after_name = null;
				
        String method_suffix = attr_name.substring(0, 1).toUpperCase() + 
                               attr_name.substring(1).toLowerCase();
//        EEntity bt = dattr.getDomain(null);

  // trying to replace with the method that calculates the type
 //       EEntity bt = ((EExplicit_attribute)redeclared_attr).getDomain(null);

//					EEntity bt_prev = xattr_prev.getDomain(null);
					EEntity bt = calculateTypeOfRedeclaredAttribute(attr);


//					if (is_original) {
			      EEntity_definition owner_entity_x = (EEntity_definition) tattr.attr.getParent_entity(null);
      			String owner_name_x = owner_entity_x.getName(null);
      			String owning_entity_name_x = getEntityPackage(owner_entity_x) + "E" + 
                                  owner_name_x.substring(0, 1).toUpperCase() + 
                                  owner_name_x.substring(1).toLowerCase();

					after_name = owning_entity_name_x;
					if (is_original) {

						redeclared_owning_entity_name = owning_entity_name_x;
					}
pw.println("\t //<><> owning_entity_name_x: " + owning_entity_name_x);

				EAttribute last_attr = attr;
				if (tattr != null) {
					if (tattr.last_redeclared_by != null) {
						if (tattr.last_redeclared_by.attr != null) {
							if ((tattr.last_redeclared_by.attr instanceof EDerived_attribute) &&
							    (attr instanceof EDerived_attribute)) {
							last_attr = tattr.last_redeclared_by.attr;
						 } else {
						 	last_attr = attr;
						 }
						} else {
							System.out.println("null - location 001"); 
            	pw.println("\t //last_redeclared_by.attr is null");
						}
					} else {
						System.out.println("null - location 002"); 
           	pw.println("\t //last_redeclared_by is null");
					}
				} else {
						System.out.println("null - location 003"); 
          	pw.println("\t //tattr is null");
				}


				if (bt instanceof EParameter) {
					bt = ((EParameter)bt).getParameter_type(null);
				}
		

        if (bt instanceof ESimple_type) {

          if (debug_java) pw.println("\t// generateJavaExplicit2DerivedAttributeSimpleTypeMethods: 4");
          if (debug_java) {
          	pw.println("\t //is_original: " + is_original);
          	pw.println("\t //redeclared_owning_entity_name: " + before_name);
          	pw.println("\t //redeclared_owning_entity_name, if is_original: " + after_name);
          	pw.println("\t //current_name: " + tattr.consolidated_explicit_to_derived.attr.getName(null));
          	pw.println("\t //current_name, if is_original: " + tattr.attr.getName(null));
           	pw.println("\t //initial attr: " + attr);
           	pw.println("\t //last_redeclared_by.attr  (last_attr): " + last_attr);
          }
//System.out.println("//####### tattr.attr: " + tattr.last_redeclared_by.attr);

//          generateJavaExplicit2DerivedAttributeSimpleTypeMethods(attr, redeclared_attr,(ESimple_type) bt, pw, entity_name, 
// the above gives first redeclared as derived instead of the last one - wrong expression generated

//	TheAttribute last_redeclared_by;

          generateJavaExplicit2DerivedAttributeSimpleTypeMethods(last_attr, redeclared_attr,(ESimple_type) bt, pw, entity_name, 
                                                            attr_name, method_suffix, 
                                                            redeclared_owning_entity_name, attr_internal_name, expression_java);
        } else if (bt instanceof EAggregation_type) {
//          generateLaterRedeclaredAttributeAggregationTypeMethods((EAggregation_type) bt, pw, 
//                                                                 entity_name, attr_name, 
//                                                                 method_suffix, owning_entity_name, 
//                                                                 attr_internal_name);

//          generateJavaExplicit2DerivedAttributeAggregationTypeMethods(attr, redeclared_attr,(EAggregation_type) bt, pw, entity_name, 
//                                                            attr_name, method_suffix, 
//                                                            redeclared_owning_entity_name, attr_internal_name, expression_java);
          generateJavaExplicit2DerivedAttributeAggregationTypeMethods(last_attr, redeclared_attr,(EAggregation_type) bt, pw, entity_name, 
                                                            attr_name, method_suffix, 
                                                            redeclared_owning_entity_name, attr_internal_name, expression_java);

        } else if (bt instanceof EDefined_type) {
//          generateLaterRedeclaredAttributeDefinedTypeMethods((EDefined_type) bt, pw, entity_name, 
//                                                             attr_name, method_suffix, 
//                                                             owning_entity_name, attr_internal_name);

//          generateJavaExplicit2DerivedAttributeDefinedTypeMethods(attr, redeclared_attr, (EDefined_type) bt, pw, entity_name, 
//                                                             attr_name, method_suffix, 
//                                                             redeclared_owning_entity_name, attr_internal_name, expression_java);

          if (debug_java) pw.println("\t// generateJavaExplicit2DerivedAttributeDefinedTypeMethods: 4B");
          if (debug_java) {
          	pw.println("\t //is_original: " + is_original);
          	pw.println("\t //redeclared_owning_entity_name: " + before_name);
          	pw.println("\t //redeclared_owning_entity_name, if is_original: " + after_name);
          	pw.println("\t //current_name: " + tattr.consolidated_explicit_to_derived.attr.getName(null));
          	pw.println("\t //current_name, if is_original: " + tattr.attr.getName(null));
           	pw.println("\t //initial attr: " + attr);
           	pw.println("\t //last_redeclared_by.attr  (last_attr): " + last_attr);
          }


          generateJavaExplicit2DerivedAttributeDefinedTypeMethods(last_attr, redeclared_attr, (EDefined_type) bt, pw, entity_name, 
                                                             attr_name, method_suffix, 
                                                             redeclared_owning_entity_name, attr_internal_name, expression_java);

        } else if (bt instanceof EEntity_definition) {
// old
/*
          String base_entity_name = ((EEntity_definition) bt).getName(null);
          String base_name = getEntityPackage((EEntity_definition) bt) + "E" + 
                             base_entity_name.substring(0, 1).toUpperCase() + 
                             base_entity_name.substring(1).toLowerCase();
          pw.println("\t// explicit redeclared as derived attribute: " + attr_name + 
                     ", base type: entity " + base_entity_name);
          pw.println("\tpublic boolean test" + method_suffix + "(" + owning_entity_name + 
                     " type) throws " + "SdaiException {");
          pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
          pw.println("\t}");


          // base_name get Method
          pw.println("\tpublic " + base_name + " get" + method_suffix + "(" + owning_entity_name + 
                     " type) throws " + "SdaiException {");
          pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
          pw.println("\t}");
          pw.println("\tpublic void set" + method_suffix + "(" + owning_entity_name + " type, " + 
                     base_name + " value) throws SdaiException {");
          pw.println("\t\t\tthrow new SdaiException(SdaiException.AT_NVLD);");
          pw.println("\t}");
          pw.println("\tpublic void unset" + method_suffix + "(" + owning_entity_name + 
                     " type) throws SdaiException {");
          pw.println("\t\t\tthrow new SdaiException(SdaiException.AT_NVLD);");
          pw.println("\t}");
*/
// old end

// new        



          String base_entity_name = ((EEntity_definition) bt).getName(null);
          String base_name = getEntityPackage((EEntity_definition) bt) + "E" + 
                             base_entity_name.substring(0, 1).toUpperCase() + 
                             base_entity_name.substring(1).toLowerCase();
// System.out.println("<<<>>> entity: " + ed.getName(null) + ", derived attribute: " + attr_name + ", base type: entity " + base_entity_name);
          pw.println("\t// -15C- explicit redeclared as derived attribute: " + attr_name + ", base type: entity " + 
                     base_entity_name);


					
          pw.println("\tpublic static int usedin" + method_suffix + "(" + redeclared_owning_entity_name + 
                     " type, " + base_name + 
                     " instance, ASdaiModel domain, AEntity result) throws SdaiException {");
          pw.println("\t\t\t// FN_NAVL - 24 - USEDIN");
          pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
//          pw.println("\t\treturn ((CEntity)instance).makeUsedin(definition, " + 
//                     attr_internal_name + "$, domain, result);");
          pw.println("\t}");

          pw.println("\tpublic boolean test" + method_suffix + "(" + redeclared_owning_entity_name + 
                     " type) throws " + "SdaiException {");
          pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
          pw.println("\t}");

          pw.println("\tpublic " + "Value" + " get" + method_suffix + "(" + redeclared_owning_entity_name + 
                     " type, SdaiContext _context) throws " + "SdaiException {");

          //               if ((flag_expressions) & (expression_java != null)) {
          if (flag_expressions) {

pw.println("//HOHO invoking expression generation, attr: " + attr + ", sd: " + sd + ", _ed: " + _ed + ", model: " + model);
//		        generateJavaExpressionForDeriveMethodsInc(pw, attr, sd, _ed, model);
		        generateJavaExpressionForDeriveMethodsInc(pw, last_attr, sd, _ed, model);

          } else {
            pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
          }

          pw.println("\t}");



          pw.println("\tpublic " + base_name + " get" + method_suffix + "(" + redeclared_owning_entity_name + 
                     " type) throws " + "SdaiException {");


          //               if ((flag_expressions) & (expression_java != null)) {

//RR-SdaiContext-temp
//          pw.println("\t\tSdaiContext _context = SdaiSession.getSdaiContext();");
          pw.println("\t\tSdaiContext _context = this.findEntityInstanceSdaiModel().getRepository().getSession().getSdaiContext();");

          if (flag_expressions) {
            //						pw.println("\t\t\tSdaiContext _context = this.findEntityInstanceSdaiModel().getRepository().getSession().getSdaiContext();");
//            pw.println("\t\t\treturn (" + base_name + ") get" + method_suffix + "(null, _context).getActualType();");
            pw.println("\t\t\treturn (" + base_name + ") get" + method_suffix + "(null, _context).getInstance();");
          } else {
            pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
          }

          pw.println("\t}");

// let's have  another method with sdaicontext parameter, just in case
// no - we cannot have it, because we already have Value, so only return type is different,
// we need to change the order of parameters, if we really need this method

/*
          pw.println("\tpublic " + base_name + " get" + method_suffix + "(" + redeclared_owning_entity_name + 
                     " type, SdaiContext _context) throws " + "SdaiException {");


          //               if ((flag_expressions) & (expression_java != null)) {

//RR-SdaiContext-temp
//          pw.println("\t\tSdaiContext _context = SdaiSession.getSdaiContext();");

//          pw.println("\t\tSdaiContext _context = this.findEntityInstanceSdaiModel().getRepository().getSession().getSdaiContext();");

          if (flag_expressions) {
            //						pw.println("\t\t\tSdaiContext _context = this.findEntityInstanceSdaiModel().getRepository().getSession().getSdaiContext();");
//            pw.println("\t\t\treturn (" + base_name + ") get" + method_suffix + "(null, _context).getActualType();");
            pw.println("\t\t\treturn (" + base_name + ") get" + method_suffix + "(null, _context).getInstance();");
          } else {
            pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
          }

          pw.println("\t}");

*/


        
          pw.println("\tpublic void set" + method_suffix + "(" + redeclared_owning_entity_name + " type, " + 
                     base_name + " value) throws SdaiException {");
          pw.println("\t\t\tthrow new SdaiException(SdaiException.AT_NVLD);");
          pw.println("\t}");
          pw.println("\tpublic void unset" + method_suffix + "(" + redeclared_owning_entity_name + 
                     " type) throws SdaiException {");
          pw.println("\t\t\tthrow new SdaiException(SdaiException.AT_NVLD);");
          pw.println("\t}");
      
// new end        
        }

        pw.println("\tpublic static jsdai.dictionary.EAttribute attribute" + method_suffix + "(" + 
                   redeclared_owning_entity_name + " type) throws SdaiException {");
//NEW_IMPLEMENTATION
//        pw.println("\t\treturn d" + (count_derived - 1) + "$;");

       // let's better give it consolidated node, and extract explicit2derived here in the method

// should be ok for both values of is_original - because the derived field is used and not explicit
        pw.println("\t\treturn d" + tattr.consolidated_derived_index + "$;");

        // not the consolidated given here, but the derived that later redeclares it, and its consolidated fields are empty
//        pw.println("\t\treturn d" + tattr.derived_index + "$;");

        pw.println("\t}");
        pw.println("");

				} else  //  above - the case when explicit redeclared as derived
				if (redeclared_attr instanceof EDerived_attribute) {
					// derived as derived
				} else {
				}
				



 }



// void generateExplicit2DerivedNonJavaMethodsXS(EEntity_definition ed, TheAttribute tattr, PrintWriter pw, boolean is_original) throws SdaiException {
 void generateExplicit2DerivedNonJavaMethodsXS(EEntity_definition ed, TheMethod tm, PrintWriter pw, boolean is_original) throws SdaiException {

//		System.out.println("entity: " + ed);
//		System.out.println("the attribute: " + tattr.attr);
//		System.out.println("the attribute: " + tattr);





			TheAttribute tattr = tm.current;
    String entity_name = ed.getName(null);
    String current_name = null;

      //EAttribute attr = tattr.attr;
      EAttribute attr = null;
      if (is_original) {
      	// two possible interpretations - the whole original attribute, or only original name
      	// the interpretation with the whole attribute is not good, because it becomes explicit instead of derived,
      	// perhaps completely differnt method better be used (of the explicit later redeclared variety)
      	// or try to use the original name only
      	//attr = tattr.attr;
      	current_name = tattr.attr.getName(null);
      } else {
  
//  System.out.println("<TheAttribute>: " + tattr);
      	current_name = tattr.consolidated_explicit_to_derived.attr.getName(null);
	//     	attr = tattr.consolidated_explicit_to_derived.attr;
			}

//			if (tattr.consolidated_explicit_to_derived != null) {

//     		attr = tattr.consolidated_explicit_to_derived.attr;


//			} else {

//				attr = tattr.attr;
				attr = tattr.last_redeclared_by.attr;
//System.out.println("<attribute>: " +  attr);
//System.out.println("<tatr>: " +  tattr);

//			}

			// so which exactly entity is needed in the case of is_original?

      EEntity_definition owner_entity = (EEntity_definition) attr.getParent_entity(null);
      String owner_name = owner_entity.getName(null);
      String owning_entity_name = getEntityPackage(owner_entity) + "E" + 
                                  owner_name.substring(0, 1).toUpperCase() + 
                                  owner_name.substring(1).toLowerCase();
      ;

      //String attr_name = attr.getName(null);
      String attr_name = current_name;
      String attr_internal_name = "a" + tattr.consolidated_explicit_index;


        EDerived_attribute dattr = (EDerived_attribute) attr;

				EAttribute redeclared_attr = null;
				EEntity_definition redeclared_owner_entity = null;
				String redeclared_owner_name = null;
				String redeclared_owning_entity_name = null;
				
				if (dattr.testRedeclaring(null)) {
					redeclared_attr = (EAttribute)dattr.getRedeclaring(null);
				} 
				
				String redeclared_name = null;
				String redeclaring_name = attr.getName(null);
				
				if (redeclared_attr != null) {
				
					redeclared_name = redeclared_attr.getName(null);
	      	redeclared_owner_entity = (EEntity_definition) redeclared_attr.getParent_entity(null);
      		redeclared_owner_name = redeclared_owner_entity.getName(null);
      		redeclared_owning_entity_name = getEntityPackage(redeclared_owner_entity) + "E" + 
                                  redeclared_owner_name.substring(0, 1).toUpperCase() + 
                                  redeclared_owner_name.substring(1).toLowerCase();
				}	
				
        A_string expression_java = null;
				
				if (redeclared_attr instanceof EExplicit_attribute) {

//  	      count_derived++;

//				if (attribute_flag == AA_SUPERTYPE_DERIVED_REDECLARING) {
//					internal++;
//				}
				
				String before_name = redeclared_owning_entity_name;
				String after_name = null;
				
        String method_suffix = attr_name.substring(0, 1).toUpperCase() + 
                               attr_name.substring(1).toLowerCase();
//        EEntity bt = dattr.getDomain(null);

  // trying to replace with the method that calculates the type
 //       EEntity bt = ((EExplicit_attribute)redeclared_attr).getDomain(null);

//					EEntity bt_prev = xattr_prev.getDomain(null);
					EEntity bt = calculateTypeOfRedeclaredAttribute(attr);


//					if (is_original) {
			      EEntity_definition owner_entity_x = (EEntity_definition) tattr.attr.getParent_entity(null);
      			String owner_name_x = owner_entity_x.getName(null);
      			String owning_entity_name_x = getEntityPackage(owner_entity_x) + "E" + 
                                  owner_name_x.substring(0, 1).toUpperCase() + 
                                  owner_name_x.substring(1).toLowerCase();

					after_name = owning_entity_name_x;
					if (is_original) {

						redeclared_owning_entity_name = owning_entity_name_x;
					}


        if (bt instanceof ESimple_type) {

          if (debug_java) pw.println("\t// generateJavaExplicit2DerivedAttributeSimpleTypeMethods: 4");
          if (debug_java) {
          	pw.println("\t //is_original: " + is_original);
          	pw.println("\t //redeclared_owning_entity_name: " + before_name);
          	pw.println("\t //redeclared_owning_entity_name, if is_original: " + after_name);
          	pw.println("\t //current_name: " + tattr.consolidated_explicit_to_derived.attr.getName(null));
          	pw.println("\t //current_name, if is_original: " + tattr.attr.getName(null));
          }
          generateJavaExplicit2DerivedAttributeSimpleTypeMethods(attr, redeclared_attr,(ESimple_type) bt, pw, entity_name, 
                                                            attr_name, method_suffix, 
                                                            redeclared_owning_entity_name, attr_internal_name, expression_java);
        } else if (bt instanceof EAggregation_type) {
//          generateLaterRedeclaredAttributeAggregationTypeMethods((EAggregation_type) bt, pw, 
//                                                                 entity_name, attr_name, 
//                                                                 method_suffix, owning_entity_name, 
//                                                                 attr_internal_name);

          generateJavaExplicit2DerivedAttributeAggregationTypeMethods(attr, redeclared_attr,(EAggregation_type) bt, pw, entity_name, 
                                                            attr_name, method_suffix, 
                                                            redeclared_owning_entity_name, attr_internal_name, expression_java);

        } else if (bt instanceof EDefined_type) {
//          generateLaterRedeclaredAttributeDefinedTypeMethods((EDefined_type) bt, pw, entity_name, 
//                                                             attr_name, method_suffix, 
//                                                             owning_entity_name, attr_internal_name);

          generateJavaExplicit2DerivedAttributeDefinedTypeMethods(attr, redeclared_attr, (EDefined_type) bt, pw, entity_name, 
                                                             attr_name, method_suffix, 
                                                             redeclared_owning_entity_name, attr_internal_name, expression_java);
        } else if (bt instanceof EEntity_definition) {
// old
/*
          String base_entity_name = ((EEntity_definition) bt).getName(null);
          String base_name = getEntityPackage((EEntity_definition) bt) + "E" + 
                             base_entity_name.substring(0, 1).toUpperCase() + 
                             base_entity_name.substring(1).toLowerCase();
          pw.println("\t// explicit redeclared as derived attribute: " + attr_name + 
                     ", base type: entity " + base_entity_name);
          pw.println("\tpublic boolean test" + method_suffix + "(" + owning_entity_name + 
                     " type) throws " + "SdaiException {");
          pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
          pw.println("\t}");


          // base_name get Method
          pw.println("\tpublic " + base_name + " get" + method_suffix + "(" + owning_entity_name + 
                     " type) throws " + "SdaiException {");
          pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
          pw.println("\t}");
          pw.println("\tpublic void set" + method_suffix + "(" + owning_entity_name + " type, " + 
                     base_name + " value) throws SdaiException {");
          pw.println("\t\t\tthrow new SdaiException(SdaiException.AT_NVLD);");
          pw.println("\t}");
          pw.println("\tpublic void unset" + method_suffix + "(" + owning_entity_name + 
                     " type) throws SdaiException {");
          pw.println("\t\t\tthrow new SdaiException(SdaiException.AT_NVLD);");
          pw.println("\t}");
*/
// old end

// new        



          String base_entity_name = ((EEntity_definition) bt).getName(null);
          String base_name = getEntityPackage((EEntity_definition) bt) + "E" + 
                             base_entity_name.substring(0, 1).toUpperCase() + 
                             base_entity_name.substring(1).toLowerCase();
// System.out.println("<<<>>> entity: " + ed.getName(null) + ", derived attribute: " + attr_name + ", base type: entity " + base_entity_name);
          pw.println("\t// -15S- explicit redeclared as derived attribute: " + attr_name + ", base type: entity " + 
                     base_entity_name);


					
          pw.println("\tpublic static int usedin" + method_suffix + "(" + redeclared_owning_entity_name + 
                     " type, " + base_name + 
                     " instance, ASdaiModel domain, AEntity result) throws SdaiException {");
          pw.println("\t\t\t// FN_NAVL - 25 - USEDIN");
          pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
//          pw.println("\t\treturn ((CEntity)instance).makeUsedin(definition, " + 
//                     attr_internal_name + "$, domain, result);");
          pw.println("\t}");



          pw.println("\tpublic boolean test" + method_suffix + "(" + redeclared_owning_entity_name + 
                     " type) throws " + "SdaiException {");
          pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
          pw.println("\t}");

  
          pw.println("\tpublic " + "Value" + " get" + method_suffix + "(" + redeclared_owning_entity_name + 
                     " type, SdaiContext _context) throws " + "SdaiException {");

          //               if ((flag_expressions) & (expression_java != null)) {
          if (flag_expressions) {

pw.println("//HOHO invoking expression generation, attr: " + attr + ", sd: " + sd + ", _ed: " + _ed + ", model: " + model);
		        generateJavaExpressionForDeriveMethodsInc(pw, attr, sd, _ed, model);

          } else {
            pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
          }

          pw.println("\t}");



          pw.println("\tpublic " + base_name + " get" + method_suffix + "(" + redeclared_owning_entity_name + 
                     " type) throws " + "SdaiException {");


          //               if ((flag_expressions) & (expression_java != null)) {

//RR-SdaiContext-temp
//          pw.println("\t\tSdaiContext _context = SdaiSession.getSdaiContext();");
          pw.println("\t\tSdaiContext _context = this.findEntityInstanceSdaiModel().getRepository().getSession().getSdaiContext();");

          if (flag_expressions) {
            //						pw.println("\t\t\tSdaiContext _context = this.findEntityInstanceSdaiModel().getRepository().getSession().getSdaiContext();");
//            pw.println("\t\t\treturn (" + base_name + ") get" + method_suffix + "(null, _context).getActualType();");
            pw.println("\t\t\treturn (" + base_name + ") get" + method_suffix + "(null, _context).getInstance();");
          } else {
            pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
          }

          pw.println("\t}");

// let's have  another method with sdaicontext parameter, just in case
// no - we cannot have it, because we already have Value, so only return type is different,
// we need to change the order of parameters, if we really need this method

/*
          pw.println("\tpublic " + base_name + " get" + method_suffix + "(" + redeclared_owning_entity_name + 
                     " type, SdaiContext _context) throws " + "SdaiException {");


          //               if ((flag_expressions) & (expression_java != null)) {

//RR-SdaiContext-temp
//          pw.println("\t\tSdaiContext _context = SdaiSession.getSdaiContext();");

//          pw.println("\t\tSdaiContext _context = this.findEntityInstanceSdaiModel().getRepository().getSession().getSdaiContext();");

          if (flag_expressions) {
            //						pw.println("\t\t\tSdaiContext _context = this.findEntityInstanceSdaiModel().getRepository().getSession().getSdaiContext();");
//            pw.println("\t\t\treturn (" + base_name + ") get" + method_suffix + "(null, _context).getActualType();");
            pw.println("\t\t\treturn (" + base_name + ") get" + method_suffix + "(null, _context).getInstance();");
          } else {
            pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
          }

          pw.println("\t}");

*/


        
          pw.println("\tpublic void set" + method_suffix + "(" + redeclared_owning_entity_name + " type, " + 
                     base_name + " value) throws SdaiException {");
          pw.println("\t\t\tthrow new SdaiException(SdaiException.AT_NVLD);");
          pw.println("\t}");
          pw.println("\tpublic void unset" + method_suffix + "(" + redeclared_owning_entity_name + 
                     " type) throws SdaiException {");
          pw.println("\t\t\tthrow new SdaiException(SdaiException.AT_NVLD);");
          pw.println("\t}");
      
// new end        
        }



// consolidated_derived_index results in -1

/*

        pw.println("\tpublic static jsdai.dictionary.EAttribute attribute" + method_suffix + "(" + 
                   redeclared_owning_entity_name + " type) throws SdaiException {");
//NEW_IMPLEMENTATION
//        pw.println("\t\treturn d" + (count_derived - 1) + "$;");

       // let's better give it consolidated node, and extract explicit2derived here in the method

// should be ok for both values of is_original - because the derived field is used and not explicit
        pw.println("\t\treturn d" + tattr.consolidated_derived_index + "$;");

        // not the consolidated given here, but the derived that later redeclares it, and its consolidated fields are empty
//        pw.println("\t\treturn d" + tattr.derived_index + "$;");

        pw.println("\t}");


*/


        pw.println("");

				} else  //  above - the case when explicit redeclared as derived
				if (redeclared_attr instanceof EDerived_attribute) {
					// derived as derived
				} else {
				}
				



 }






// void generateExplicit2DerivedNonJavaMethodsXS(EEntity_definition ed, TheAttribute tattr, PrintWriter pw, boolean is_original) throws SdaiException {
 void generateExplicit2DerivedNonJavaMethodsXSX(EEntity_definition ed, TheAttribute tattr, PrintWriter pw, boolean is_original) throws SdaiException {

//		System.out.println("entity: " + ed);
//		System.out.println("the attribute: " + tattr.attr);
//		System.out.println("the attribute: " + tattr);





	//		TheAttribute tattr = tm.current;
    String entity_name = ed.getName(null);
    String current_name = null;

      //EAttribute attr = tattr.attr;
      EAttribute attr = null;
      if (is_original) {
      	// two possible interpretations - the whole original attribute, or only original name
      	// the interpretation with the whole attribute is not good, because it becomes explicit instead of derived,
      	// perhaps completely differnt method better be used (of the explicit later redeclared variety)
      	// or try to use the original name only
      	//attr = tattr.attr;
      	current_name = tattr.attr.getName(null);
      } else {
  
//  System.out.println("<TheAttribute>: " + tattr);
      	current_name = tattr.consolidated_explicit_to_derived.attr.getName(null);
	//     	attr = tattr.consolidated_explicit_to_derived.attr;
			}

//			if (tattr.consolidated_explicit_to_derived != null) {

//     		attr = tattr.consolidated_explicit_to_derived.attr;


//			} else {

//				attr = tattr.attr;
				attr = tattr.last_redeclared_by.attr;
//System.out.println("<attribute>: " +  attr);
//System.out.println("<tatr>: " +  tattr);

//			}

			// so which exactly entity is needed in the case of is_original?

      EEntity_definition owner_entity = (EEntity_definition) attr.getParent_entity(null);
      String owner_name = owner_entity.getName(null);
      String owning_entity_name = getEntityPackage(owner_entity) + "E" + 
                                  owner_name.substring(0, 1).toUpperCase() + 
                                  owner_name.substring(1).toLowerCase();
      ;

      //String attr_name = attr.getName(null);
      String attr_name = current_name;
      String attr_internal_name = "a" + tattr.consolidated_explicit_index;


        EDerived_attribute dattr = (EDerived_attribute) attr;

				EAttribute redeclared_attr = null;
				EEntity_definition redeclared_owner_entity = null;
				String redeclared_owner_name = null;
				String redeclared_owning_entity_name = null;
				
				if (dattr.testRedeclaring(null)) {
					redeclared_attr = (EAttribute)dattr.getRedeclaring(null);
				} 
				
				String redeclared_name = null;
				String redeclaring_name = attr.getName(null);
				
				if (redeclared_attr != null) {
				
					redeclared_name = redeclared_attr.getName(null);
	      	redeclared_owner_entity = (EEntity_definition) redeclared_attr.getParent_entity(null);
      		redeclared_owner_name = redeclared_owner_entity.getName(null);
      		redeclared_owning_entity_name = getEntityPackage(redeclared_owner_entity) + "E" + 
                                  redeclared_owner_name.substring(0, 1).toUpperCase() + 
                                  redeclared_owner_name.substring(1).toLowerCase();
				}	
				
        A_string expression_java = null;
				
				if (redeclared_attr instanceof EExplicit_attribute) {

//  	      count_derived++;

//				if (attribute_flag == AA_SUPERTYPE_DERIVED_REDECLARING) {
//					internal++;
//				}
				
				String before_name = redeclared_owning_entity_name;
				String after_name = null;
				
        String method_suffix = attr_name.substring(0, 1).toUpperCase() + 
                               attr_name.substring(1).toLowerCase();
//        EEntity bt = dattr.getDomain(null);

  // trying to replace with the method that calculates the type
 //       EEntity bt = ((EExplicit_attribute)redeclared_attr).getDomain(null);

//					EEntity bt_prev = xattr_prev.getDomain(null);
					EEntity bt = calculateTypeOfRedeclaredAttribute(attr);


//					if (is_original) {
			      EEntity_definition owner_entity_x = (EEntity_definition) tattr.attr.getParent_entity(null);
      			String owner_name_x = owner_entity_x.getName(null);
      			String owning_entity_name_x = getEntityPackage(owner_entity_x) + "E" + 
                                  owner_name_x.substring(0, 1).toUpperCase() + 
                                  owner_name_x.substring(1).toLowerCase();

					after_name = owning_entity_name_x;
					if (is_original) {

						redeclared_owning_entity_name = owning_entity_name_x;
					}


        if (bt instanceof ESimple_type) {

          if (debug_java) pw.println("\t// generateJavaExplicit2DerivedAttributeSimpleTypeMethods: 4");
          if (debug_java) {
          	pw.println("\t //is_original: " + is_original);
          	pw.println("\t //redeclared_owning_entity_name: " + before_name);
          	pw.println("\t //redeclared_owning_entity_name, if is_original: " + after_name);
          	pw.println("\t //current_name: " + tattr.consolidated_explicit_to_derived.attr.getName(null));
          	pw.println("\t //current_name, if is_original: " + tattr.attr.getName(null));
          }
          generateJavaExplicit2DerivedAttributeSimpleTypeMethods(attr, redeclared_attr,(ESimple_type) bt, pw, entity_name, 
                                                            attr_name, method_suffix, 
                                                            redeclared_owning_entity_name, attr_internal_name, expression_java);
        } else if (bt instanceof EAggregation_type) {
//          generateLaterRedeclaredAttributeAggregationTypeMethods((EAggregation_type) bt, pw, 
//                                                                 entity_name, attr_name, 
//                                                                 method_suffix, owning_entity_name, 
//                                                                 attr_internal_name);

          generateJavaExplicit2DerivedAttributeAggregationTypeMethods(attr, redeclared_attr,(EAggregation_type) bt, pw, entity_name, 
                                                            attr_name, method_suffix, 
                                                            redeclared_owning_entity_name, attr_internal_name, expression_java);

        } else if (bt instanceof EDefined_type) {
//          generateLaterRedeclaredAttributeDefinedTypeMethods((EDefined_type) bt, pw, entity_name, 
//                                                             attr_name, method_suffix, 
//                                                             owning_entity_name, attr_internal_name);

          generateJavaExplicit2DerivedAttributeDefinedTypeMethods(attr, redeclared_attr, (EDefined_type) bt, pw, entity_name, 
                                                             attr_name, method_suffix, 
                                                             redeclared_owning_entity_name, attr_internal_name, expression_java);
        } else if (bt instanceof EEntity_definition) {
// old
/*
          String base_entity_name = ((EEntity_definition) bt).getName(null);
          String base_name = getEntityPackage((EEntity_definition) bt) + "E" + 
                             base_entity_name.substring(0, 1).toUpperCase() + 
                             base_entity_name.substring(1).toLowerCase();
          pw.println("\t// explicit redeclared as derived attribute: " + attr_name + 
                     ", base type: entity " + base_entity_name);
          pw.println("\tpublic boolean test" + method_suffix + "(" + owning_entity_name + 
                     " type) throws " + "SdaiException {");
          pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
          pw.println("\t}");


          // base_name get Method
          pw.println("\tpublic " + base_name + " get" + method_suffix + "(" + owning_entity_name + 
                     " type) throws " + "SdaiException {");
          pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
          pw.println("\t}");
          pw.println("\tpublic void set" + method_suffix + "(" + owning_entity_name + " type, " + 
                     base_name + " value) throws SdaiException {");
          pw.println("\t\t\tthrow new SdaiException(SdaiException.AT_NVLD);");
          pw.println("\t}");
          pw.println("\tpublic void unset" + method_suffix + "(" + owning_entity_name + 
                     " type) throws SdaiException {");
          pw.println("\t\t\tthrow new SdaiException(SdaiException.AT_NVLD);");
          pw.println("\t}");
*/
// old end

// new        



          String base_entity_name = ((EEntity_definition) bt).getName(null);
          String base_name = getEntityPackage((EEntity_definition) bt) + "E" + 
                             base_entity_name.substring(0, 1).toUpperCase() + 
                             base_entity_name.substring(1).toLowerCase();
// System.out.println("<<<>>> entity: " + ed.getName(null) + ", derived attribute: " + attr_name + ", base type: entity " + base_entity_name);
          pw.println("\t// -15S- explicit redeclared as derived attribute: " + attr_name + ", base type: entity " + 
                     base_entity_name);


					
          pw.println("\tpublic static int usedin" + method_suffix + "(" + redeclared_owning_entity_name + 
                     " type, " + base_name + 
                     " instance, ASdaiModel domain, AEntity result) throws SdaiException {");
          pw.println("\t\t\t// FN_NAVL - 26 - USEDIN");
          pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
//          pw.println("\t\treturn ((CEntity)instance).makeUsedin(definition, " + 
//                     attr_internal_name + "$, domain, result);");
          pw.println("\t}");



          pw.println("\tpublic boolean test" + method_suffix + "(" + redeclared_owning_entity_name + 
                     " type) throws " + "SdaiException {");
          pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
          pw.println("\t}");

  
          pw.println("\tpublic " + "Value" + " get" + method_suffix + "(" + redeclared_owning_entity_name + 
                     " type, SdaiContext _context) throws " + "SdaiException {");

          //               if ((flag_expressions) & (expression_java != null)) {
          if (flag_expressions) {

pw.println("//HOHO invoking expression generation, attr: " + attr + ", sd: " + sd + ", _ed: " + _ed + ", model: " + model);
		        generateJavaExpressionForDeriveMethodsInc(pw, attr, sd, _ed, model);

          } else {
            pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
          }

          pw.println("\t}");



          pw.println("\tpublic " + base_name + " get" + method_suffix + "(" + redeclared_owning_entity_name + 
                     " type) throws " + "SdaiException {");


          //               if ((flag_expressions) & (expression_java != null)) {

//RR-SdaiContext-temp
//          pw.println("\t\tSdaiContext _context = SdaiSession.getSdaiContext();");
          pw.println("\t\tSdaiContext _context = this.findEntityInstanceSdaiModel().getRepository().getSession().getSdaiContext();");

          if (flag_expressions) {
            //						pw.println("\t\t\tSdaiContext _context = this.findEntityInstanceSdaiModel().getRepository().getSession().getSdaiContext();");
//            pw.println("\t\t\treturn (" + base_name + ") get" + method_suffix + "(null, _context).getActualType();");
            pw.println("\t\t\treturn (" + base_name + ") get" + method_suffix + "(null, _context).getInstance();");
          } else {
            pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
          }

          pw.println("\t}");

// let's have  another method with sdaicontext parameter, just in case
// no - we cannot have it, because we already have Value, so only return type is different,
// we need to change the order of parameters, if we really need this method

/*
          pw.println("\tpublic " + base_name + " get" + method_suffix + "(" + redeclared_owning_entity_name + 
                     " type, SdaiContext _context) throws " + "SdaiException {");


          //               if ((flag_expressions) & (expression_java != null)) {

//RR-SdaiContext-temp
//          pw.println("\t\tSdaiContext _context = SdaiSession.getSdaiContext();");

//          pw.println("\t\tSdaiContext _context = this.findEntityInstanceSdaiModel().getRepository().getSession().getSdaiContext();");

          if (flag_expressions) {
            //						pw.println("\t\t\tSdaiContext _context = this.findEntityInstanceSdaiModel().getRepository().getSession().getSdaiContext();");
//            pw.println("\t\t\treturn (" + base_name + ") get" + method_suffix + "(null, _context).getActualType();");
            pw.println("\t\t\treturn (" + base_name + ") get" + method_suffix + "(null, _context).getInstance();");
          } else {
            pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
          }

          pw.println("\t}");

*/


        
          pw.println("\tpublic void set" + method_suffix + "(" + redeclared_owning_entity_name + " type, " + 
                     base_name + " value) throws SdaiException {");
          pw.println("\t\t\tthrow new SdaiException(SdaiException.AT_NVLD);");
          pw.println("\t}");
          pw.println("\tpublic void unset" + method_suffix + "(" + redeclared_owning_entity_name + 
                     " type) throws SdaiException {");
          pw.println("\t\t\tthrow new SdaiException(SdaiException.AT_NVLD);");
          pw.println("\t}");
      
// new end        
        }



// consolidated_derived_index results in -1

/*

        pw.println("\tpublic static jsdai.dictionary.EAttribute attribute" + method_suffix + "(" + 
                   redeclared_owning_entity_name + " type) throws SdaiException {");
//NEW_IMPLEMENTATION
//        pw.println("\t\treturn d" + (count_derived - 1) + "$;");

       // let's better give it consolidated node, and extract explicit2derived here in the method

// should be ok for both values of is_original - because the derived field is used and not explicit
        pw.println("\t\treturn d" + tattr.consolidated_derived_index + "$;");

        // not the consolidated given here, but the derived that later redeclares it, and its consolidated fields are empty
//        pw.println("\t\treturn d" + tattr.derived_index + "$;");

        pw.println("\t}");


*/


        pw.println("");

				} else  //  above - the case when explicit redeclared as derived
				if (redeclared_attr instanceof EDerived_attribute) {
					// derived as derived
				} else {
				}
				



 }




 void generateExplicit2DerivedNonJavaMethodsX_old(EEntity_definition ed, TheAttribute tattr, PrintWriter pw, boolean is_original) throws SdaiException {

//		System.out.println("entity: " + ed);
//		System.out.println("attribute: " + tattr.attr);






    String entity_name = ed.getName(null);
    String current_name = null;

      //EAttribute attr = tattr.attr;
      EAttribute attr = null;
      if (is_original) {
      	// two possible interpretations - the whole original attribute, or only original name
      	// the interpretation with the whole attribute is not good, because it becomes explicit instead of derived,
      	// perhaps completely differnt method better be used (of the explicit later redeclared variety)
      	// or try to use the original name only
      	//attr = tattr.attr;
      	current_name = tattr.attr.getName(null);
      } else {
      	current_name = tattr.consolidated_explicit_to_derived.attr.getName(null);
	//     	attr = tattr.consolidated_explicit_to_derived.attr;
			}
     	attr = tattr.consolidated_explicit_to_derived.attr;

			// so which exactly entity is needed in the case of is_original?

      EEntity_definition owner_entity = (EEntity_definition) attr.getParent_entity(null);
      String owner_name = owner_entity.getName(null);
      String owning_entity_name = getEntityPackage(owner_entity) + "E" + 
                                  owner_name.substring(0, 1).toUpperCase() + 
                                  owner_name.substring(1).toLowerCase();
      ;

      //String attr_name = attr.getName(null);
      String attr_name = current_name;
      String attr_internal_name = "a" + tattr.consolidated_explicit_index;



        EDerived_attribute dattr = (EDerived_attribute) attr;

				EAttribute redeclared_attr = null;
				EEntity_definition redeclared_owner_entity = null;
				String redeclared_owner_name = null;
				String redeclared_owning_entity_name = null;
				
				if (dattr.testRedeclaring(null)) {
					redeclared_attr = (EAttribute)dattr.getRedeclaring(null);
				} 
				
				String redeclared_name = null;
				String redeclaring_name = attr.getName(null);
				
				if (redeclared_attr != null) {
				
					redeclared_name = redeclared_attr.getName(null);
	      	redeclared_owner_entity = (EEntity_definition) redeclared_attr.getParent_entity(null);
      		redeclared_owner_name = redeclared_owner_entity.getName(null);
      		redeclared_owning_entity_name = getEntityPackage(redeclared_owner_entity) + "E" + 
		                                  redeclared_owner_name.substring(0, 1).toUpperCase() + 
                                  redeclared_owner_name.substring(1).toLowerCase();
				}	
				
        A_string expression_java = null;
				
				if (redeclared_attr instanceof EExplicit_attribute) {

//  	      count_derived++;

//				if (attribute_flag == AA_SUPERTYPE_DERIVED_REDECLARING) {
//					internal++;
//				}
				
				
        String method_suffix = attr_name.substring(0, 1).toUpperCase() + 
                               attr_name.substring(1).toLowerCase();
//        EEntity bt = dattr.getDomain(null);

  // trying to replace with the method that calculates the type
 //       EEntity bt = ((EExplicit_attribute)redeclared_attr).getDomain(null);

//					EEntity bt_prev = xattr_prev.getDomain(null);
					EEntity bt = calculateTypeOfRedeclaredAttribute(attr);


					if (is_original) {
			      EEntity_definition owner_entity_x = (EEntity_definition) tattr.attr.getParent_entity(null);
      			String owner_name_x = owner_entity_x.getName(null);
      			String owning_entity_name_x = getEntityPackage(owner_entity_x) + "E" + 
                                  owner_name_x.substring(0, 1).toUpperCase() + 
                                  owner_name_x.substring(1).toLowerCase();


						redeclared_owning_entity_name = owning_entity_name_x;
					}


        if (bt instanceof ESimple_type) {
          if (debug_java) pw.println("\t// generateJavaExplicit2DerivedAttributeSimpleTypeMethods: 5");
          generateJavaExplicit2DerivedAttributeSimpleTypeMethods(attr, redeclared_attr,(ESimple_type) bt, pw, entity_name, 
                                                            attr_name, method_suffix, 
                                                            redeclared_owning_entity_name, attr_internal_name, expression_java);
        } else if (bt instanceof EAggregation_type) {
//          generateLaterRedeclaredAttributeAggregationTypeMethods((EAggregation_type) bt, pw, 
//                                                                 entity_name, attr_name, 
//                                                                 method_suffix, owning_entity_name, 
//                                                                 attr_internal_name);

          generateJavaExplicit2DerivedAttributeAggregationTypeMethods(attr, redeclared_attr,(EAggregation_type) bt, pw, entity_name, 
                                                            attr_name, method_suffix, 
                                                            redeclared_owning_entity_name, attr_internal_name, expression_java);

        } else if (bt instanceof EDefined_type) {
//          generateLaterRedeclaredAttributeDefinedTypeMethods((EDefined_type) bt, pw, entity_name, 
//                                                             attr_name, method_suffix, 
//                                                             owning_entity_name, attr_internal_name);

          generateJavaExplicit2DerivedAttributeDefinedTypeMethods(attr, redeclared_attr, (EDefined_type) bt, pw, entity_name, 
                                                             attr_name, method_suffix, 
                                                             redeclared_owning_entity_name, attr_internal_name, expression_java);
        } else if (bt instanceof EEntity_definition) {
// old
/*
          String base_entity_name = ((EEntity_definition) bt).getName(null);
          String base_name = getEntityPackage((EEntity_definition) bt) + "E" + 
                             base_entity_name.substring(0, 1).toUpperCase() + 
                             base_entity_name.substring(1).toLowerCase();
          pw.println("\t// explicit redeclared as derived attribute: " + attr_name + 
                     ", base type: entity " + base_entity_name);
          pw.println("\tpublic boolean test" + method_suffix + "(" + owning_entity_name + 
                     " type) throws " + "SdaiException {");
          pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
          pw.println("\t}");


          // base_name get Method
          pw.println("\tpublic " + base_name + " get" + method_suffix + "(" + owning_entity_name + 
                     " type) throws " + "SdaiException {");
          pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
          pw.println("\t}");
          pw.println("\tpublic void set" + method_suffix + "(" + owning_entity_name + " type, " + 
                     base_name + " value) throws SdaiException {");
          pw.println("\t\t\tthrow new SdaiException(SdaiException.AT_NVLD);");
          pw.println("\t}");
          pw.println("\tpublic void unset" + method_suffix + "(" + owning_entity_name + 
                     " type) throws SdaiException {");
          pw.println("\t\t\tthrow new SdaiException(SdaiException.AT_NVLD);");
          pw.println("\t}");
*/
// old end

// new        



          String base_entity_name = ((EEntity_definition) bt).getName(null);
          String base_name = getEntityPackage((EEntity_definition) bt) + "E" + 
                             base_entity_name.substring(0, 1).toUpperCase() + 
                             base_entity_name.substring(1).toLowerCase();
// System.out.println("<<<>>> entity: " + ed.getName(null) + ", derived attribute: " + attr_name + ", base type: entity " + base_entity_name);
          pw.println("\t// -15D- explicit redeclared as derived attribute: " + attr_name + ", base type: entity " + 
                     base_entity_name);


					
          pw.println("\tpublic static int usedin" + method_suffix + "(" + redeclared_owning_entity_name + 
                     " type, " + base_name + 
                     " instance, ASdaiModel domain, AEntity result) throws SdaiException {");
          pw.println("\t\t\t// FN_NAVL - 27 - USEDIN");
          pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
//          pw.println("\t\treturn ((CEntity)instance).makeUsedin(definition, " + 
//                     attr_internal_name + "$, domain, result);");
          pw.println("\t}");

          pw.println("\tpublic boolean test" + method_suffix + "(" + redeclared_owning_entity_name + 
                     " type) throws " + "SdaiException {");
          pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
          pw.println("\t}");

          pw.println("\tpublic " + "Value" + " get" + method_suffix + "(" + redeclared_owning_entity_name + 
                     " type, SdaiContext _context) throws " + "SdaiException {");

          //               if ((flag_expressions) & (expression_java != null)) {
          if (flag_expressions) {
		        generateJavaExpressionForDeriveMethodsInc(pw, attr, sd, _ed, model);

          } else {
            pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
          }

          pw.println("\t}");

          pw.println("\tpublic " + base_name + " get" + method_suffix + "(" + redeclared_owning_entity_name + 
                     " type) throws " + "SdaiException {");


          //               if ((flag_expressions) & (expression_java != null)) {

//RR-SdaiContext-temp
//          pw.println("\t\tSdaiContext _context = SdaiSession.getSdaiContext();");
          pw.println("\t\tSdaiContext _context = this.findEntityInstanceSdaiModel().getRepository().getSession().getSdaiContext();");

          if (flag_expressions) {
            //						pw.println("\t\t\tSdaiContext _context = this.findEntityInstanceSdaiModel().getRepository().getSession().getSdaiContext();");
//            pw.println("\t\t\treturn (" + base_name + ") get" + method_suffix + "(null, _context).getActualType();");
            pw.println("\t\t\treturn (" + base_name + ") get" + method_suffix + "(null, _context).getInstance();");
          } else {
            pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
          }

          pw.println("\t}");
        
          pw.println("\tpublic void set" + method_suffix + "(" + redeclared_owning_entity_name + " type, " + 
                     base_name + " value) throws SdaiException {");
          pw.println("\t\t\tthrow new SdaiException(SdaiException.AT_NVLD);");
          pw.println("\t}");
          pw.println("\tpublic void unset" + method_suffix + "(" + redeclared_owning_entity_name + 
                     " type) throws SdaiException {");
          pw.println("\t\t\tthrow new SdaiException(SdaiException.AT_NVLD);");
          pw.println("\t}");
      
// new end        
        }

        pw.println("\tpublic static jsdai.dictionary.EAttribute attribute" + method_suffix + "(" + 
                   redeclared_owning_entity_name + " type) throws SdaiException {");
//NEW_IMPLEMENTATION
//        pw.println("\t\treturn d" + (count_derived - 1) + "$;");

       // let's better give it consolidated node, and extract explicit2derived here in the method

// should be ok for both values of is_original - because the derived field is used and not explicit
        pw.println("\t\treturn d" + tattr.consolidated_derived_index + "$;");

        // not the consolidated given here, but the derived that later redeclares it, and its consolidated fields are empty
//        pw.println("\t\treturn d" + tattr.derived_index + "$;");

        pw.println("\t}");
        pw.println("");

				} else  //  above - the case when explicit redeclared as derived
				if (redeclared_attr instanceof EDerived_attribute) {
					// derived as derived
				} else {
				}
				



 }

	void generateExplicitRedeclaredRenamedCurrentEntityMethodsX(EEntity_definition ed, TheMethod tm, PrintWriter pw) throws SdaiException {
		// using this for now
		generateExplicitRedeclaredRenamedNonJavaMethodsX(ed, tm, pw);
	}

	void generateExplicitRedeclaredRenamedSupertypeNonJavaMethodsX(EEntity_definition ed, TheMethod tm, PrintWriter pw) throws SdaiException {
		// using this for now
		generateExplicitRedeclaredRenamedNonJavaMethodsX(ed, tm, pw);
	}


	void generateExplicitToDerivedRedeclaredRenamedSupertypeNonJavaMethodsX(EEntity_definition ed, TheMethod tm, PrintWriter pw) throws SdaiException {
		// using this for now
		generateExplicitToDerivedRedeclaredRenamedNonJavaMethodsX(ed, tm, pw);
	}


	void generateExplicitRedeclaredRenamedSupertypeJavaInheritedX(EEntity_definition ed, TheMethod tm, PrintWriter pw) throws SdaiException {
		// need only USEDIN methods so that they use local definition


        // methods are inherited, not generated.

			TheAttribute tattr = tm.current;
		  String entity_name = ed.getName(null);
      EAttribute attr = tattr.attr;

      EEntity_definition owner_entity = (EEntity_definition) attr.getParent_entity(null);
      String owner_name = owner_entity.getName(null);
      String owning_entity_name = getEntityPackage(owner_entity) + "E" + 
                                  owner_name.substring(0, 1).toUpperCase() + 
                                  owner_name.substring(1).toLowerCase();

      String attr_name = attr.getName(null);
      String attr_internal_name = "a" + tm.consolidated.consolidated_explicit_index;
 			
 	      EExplicit_attribute xattr = (EExplicit_attribute) attr;
        EExplicit_attribute xattr_prev = xattr.getRedeclaring(null);
      	String redeclaring_name = xattr.getName(null);
      	String redeclared_name = xattr_prev.getName(null);

					// renamed attribute, generate methods for it

  	      String method_suffix = attr_name.substring(0, 1).toUpperCase() + attr_name.substring(1).toLowerCase();
					EEntity bt_prev = xattr_prev.getDomain(null);

					EEntity bt = calculateTypeOfRedeclaredAttribute(xattr);

	
      		EEntity_definition owner_entity_prev = (EEntity_definition) xattr_prev.getParent_entity(null);
      		String owner_name_prev = owner_entity_prev.getName(null);
      		String owning_entity_name_prev = getEntityPackage(owner_entity_prev) + "E" + 
                                  owner_name_prev.substring(0, 1).toUpperCase() + 
                                  owner_name_prev.substring(1).toLowerCase();
  	      String method_suffix_prev = redeclared_name.substring(0, 1).toUpperCase() + redeclared_name.substring(1).toLowerCase();
          String package_prev = getEntityPackage(owner_entity_prev)  + "C" +
                                  owner_name_prev.substring(0, 1).toUpperCase() + 
                                  owner_name_prev.substring(1).toLowerCase() + ".";

         package_prev = "";


// experiment starts --------------------
/*

//        EDerived_attribute dattr = (EDerived_attribute) attr;
        EExplicit_attribute dattr = (EExplicit_attribute) attr;

				EEntity_definition redeclared_owner_entity = null;
				String redeclared_owner_name = null;
				String redeclared_owning_entity_name = null;

				EAttribute redeclared_attr = null;



				if (dattr.testRedeclaring(null)) {
					redeclared_attr = (EAttribute)dattr.getRedeclaring(null);
				} 

//				String redeclared_name = null;
//				String redeclaring_name = attr.getName(null);



				if (redeclared_attr != null) {
				
					redeclared_name = redeclared_attr.getName(null);
	      	redeclared_owner_entity = (EEntity_definition) redeclared_attr.getParent_entity(null);
      		redeclared_owner_name = redeclared_owner_entity.getName(null);
      		redeclared_owning_entity_name = getEntityPackage(redeclared_owner_entity) + "E" + 
                                  redeclared_owner_name.substring(0, 1).toUpperCase() + 
                                  redeclared_owner_name.substring(1).toLowerCase();
				}	

*/
// experiment ends -------------------------



        if (bt instanceof EAggregation_type) {
          generateExplicitAttributeAggregationTypeMethodsUsedinOnlyRenamed((EAggregation_type) bt, pw, 
                                                                    entity_name, attr_name, 
                                                                    method_suffix, 
                                                                    owning_entity_name, 
                                                                    attr_internal_name);
        } else if (bt instanceof EDefined_type) {
          generateExplicitAttributeDefinedTypeMethodsUsedinOnlyRenamed((EDefined_type) bt, pw, entity_name, 
                                                                attr_name, method_suffix, 
                                                                owning_entity_name, 
                                                                attr_internal_name);
        } else if (bt instanceof EEntity_definition) {
          String base_entity_name = ((EEntity_definition) bt).getName(null);
          String base_name = getEntityPackage((EEntity_definition) bt) + "E" + 
                             base_entity_name.substring(0, 1).toUpperCase() + 
                             base_entity_name.substring(1).toLowerCase();
          pw.println("\t// attribute (java explicit renamed): " + attr_name + ", base type: entity " + base_entity_name);


pw.println("// USEDIN-RENAMED-12 renamed");
          // usedin
          pw.println("\tpublic static int usedin" + method_suffix + "(" + owning_entity_name + " type, " + base_name + " instance, ASdaiModel domain, AEntity result) throws SdaiException {");
          pw.println("\t\treturn ((CEntity)instance).makeUsedin(definition, " + attr_internal_name + "$, domain, result);");
          pw.println("\t}");


//-- experiment starts
/*

          pw.println("\tpublic " + "Value" + " get" + method_suffix + "(" + redeclared_owning_entity_name + 
                     " type, SdaiContext _context) throws " + "SdaiException {");

          //               if ((flag_expressions) & (expression_java != null)) {
          if (flag_expressions) {

pw.println("//HOHO invoking expression generation, attr: " + attr + ", sd: " + sd + ", _ed: " + _ed + ", model: " + model);
		        generateJavaExpressionForDeriveMethodsInc(pw, attr, sd, _ed, model);

          } else {
            pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
          }

          pw.println("\t}");



          pw.println("\tpublic " + base_name + " get" + method_suffix + "(" + redeclared_owning_entity_name + 
                     " type) throws " + "SdaiException {");


          //               if ((flag_expressions) & (expression_java != null)) {

//RR-SdaiContext-temp
//          pw.println("\t\tSdaiContext _context = SdaiSession.getSdaiContext();");
          pw.println("\t\tSdaiContext _context = this.findEntityInstanceSdaiModel().getRepository().getSession().getSdaiContext();");

          if (flag_expressions) {
            //						pw.println("\t\t\tSdaiContext _context = this.findEntityInstanceSdaiModel().getRepository().getSession().getSdaiContext();");
//            pw.println("\t\t\treturn (" + base_name + ") get" + method_suffix + "(null, _context).getActualType();");
            pw.println("\t\t\treturn (" + base_name + ") get" + method_suffix + "(null, _context).getInstance();");
          } else {
            pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
          }

          pw.println("\t}");

*/


//-- experiment ends
        }


	}




	void generateExplicit2DerivedRedeclaredRenamedNonJavaMethodsX(EEntity_definition ed, TheMethod tm, PrintWriter pw) throws SdaiException {
	
			TheAttribute tattr = tm.current;

		  String entity_name = ed.getName(null);

      EAttribute attr = tattr.attr;

      EEntity_definition owner_entity = (EEntity_definition) attr.getParent_entity(null);
      String owner_name = owner_entity.getName(null);
      String owning_entity_name = getEntityPackage(owner_entity) + "E" + 
                                  owner_name.substring(0, 1).toUpperCase() + 
                                  owner_name.substring(1).toLowerCase();
      ;

      String attr_name = attr.getName(null);
//      String attr_internal_name = "a" + tattr.consolidated_explicit_index;
//guhusu
      String attr_internal_name = "a" + tm.consolidated.consolidated_explicit_index;
//			if (tattr.consolidated) {
//				attr_internal_name = "a" + tattr.consolidated_explicit_index;
//			}
	
	// ----------------		 
 			
 	      EExplicit_attribute xattr = (EExplicit_attribute) attr;
        EExplicit_attribute xattr_prev = xattr.getRedeclaring(null);
      	String redeclaring_name = xattr.getName(null);
      	String redeclared_name = xattr_prev.getName(null);



					// renamed attribute, generate methods for it

  	      String method_suffix = attr_name.substring(0, 1).toUpperCase() + attr_name.substring(1).toLowerCase();
//      	  EEntity bt = xattr.getDomain(null);
					EEntity bt_prev = xattr_prev.getDomain(null);

					EEntity bt = calculateTypeOfRedeclaredAttribute(xattr);


      		EEntity_definition owner_entity_prev = (EEntity_definition) xattr_prev.getParent_entity(null);
      		String owner_name_prev = owner_entity_prev.getName(null);
      		String owning_entity_name_prev = getEntityPackage(owner_entity_prev) + "E" + 
                                  owner_name_prev.substring(0, 1).toUpperCase() + 
                                  owner_name_prev.substring(1).toLowerCase();
  	      String method_suffix_prev = redeclared_name.substring(0, 1).toUpperCase() + redeclared_name.substring(1).toLowerCase();
          String package_prev = getEntityPackage(owner_entity_prev)  + "C" +
                                  owner_name_prev.substring(0, 1).toUpperCase() + 
                                  owner_name_prev.substring(1).toLowerCase() + ".";

         package_prev = "";



        if (bt instanceof ESimple_type) {
//          generateExplicitAttributeSimpleTypeMethods((ESimple_type) bt, pw, entity_name, attr_name, 
//                                                     method_suffix, owning_entity_name, 
//                                                     attr_internal_name);
          generateExplicitAttributeSimpleTypeMethodsRenamed((ESimple_type) bt, pw, entity_name, attr_name, 
                                                     method_suffix, owning_entity_name, 
                                                     attr_internal_name,
 																											xattr, method_suffix_prev, owning_entity_name_prev, package_prev);


        } else if (bt instanceof EAggregation_type) {
        	
        	// can the get the original aggregation type?
        	
        	
          generateExplicitAttributeAggregationTypeMethodsRenamed((EAggregation_type) bt, pw, entity_name, 
                                                          attr_name, method_suffix, 
                                                          owning_entity_name, attr_internal_name, xattr, method_suffix_prev, owning_entity_name_prev, package_prev);
        } else if (bt instanceof EDefined_type) {
          generateExplicitAttributeDefinedTypeMethodsRenamed((EDefined_type) bt, pw, entity_name, 
                                                      attr_name, method_suffix, owning_entity_name, 
                                                      attr_internal_name,
 																											xattr, method_suffix_prev, owning_entity_name_prev, package_prev);
        } else if (bt instanceof EEntity_definition) {

					// perhaps let's do it this way for now:
					// if both entities, then new entity (parser already ensures that it is a subtype
					// if prev entity and new is not entity - then prev entity type, at least for now, the new type is possibly select with subtypes in it

					String base_entity_name = null;
					String base_name = null;
		
          
//          if (bt instanceof EEntity_definition) {
          
	          base_entity_name = ((EEntity_definition) bt).getName(null);
  	        base_name = getEntityPackage((EEntity_definition) bt) + "E" + 
    	                         base_entity_name.substring(0, 1).toUpperCase() + 
      	                       base_entity_name.substring(1).toLowerCase();
          
          
//        	} else {
//	          base_entity_name = ((EEntity_definition) bt_prev).getName(null);
 // 	        base_name = getEntityPackage((EEntity_definition) bt_prev) + "E" + 
 //   	                         base_entity_name.substring(0, 1).toUpperCase() + 
  //    	                       base_entity_name.substring(1).toLowerCase();
  //      	}
          
          pw.println("\t//-2- attribute (current explicit redeclaring or supertype explicit redeclaring):  " + attr_name + ", base type: entity " + base_entity_name);



          // usedin
//USEDIN-RENAMED
pw.println("// USEDIN-RENAMED-11");
          pw.println("\tpublic static int usedin" + method_suffix + "(" + owning_entity_name + " type, " + base_name + " instance, ASdaiModel domain, AEntity result) throws SdaiException {");
          pw.println("\t\treturn ((CEntity)instance).makeUsedin(definition, " + attr_internal_name + "$, domain, result);");
//          pw.println("\t\treturn " + package_prev + "usedin" + method_suffix_prev + "((" + owning_entity_name_prev + ")null, instance, domain, result);");
          pw.println("\t}");
  
   
          pw.println("\tpublic boolean test" + method_suffix + "(" + owning_entity_name + 
                     " type) throws " + "SdaiException {");
//          pw.println("\t\treturn test_instance(" + attr_internal_name + ");");
          pw.println("\t\treturn " + package_prev + "test" + method_suffix_prev + "((" + owning_entity_name_prev + ")null);");

          pw.println("\t}");

          pw.println("\tpublic " + base_name + " get" + method_suffix + "(" + owning_entity_name + 
                     " type) throws " + "SdaiException {");
//          pw.println("\t\t" + attr_internal_name + " = get_instance(" + attr_internal_name + ");");
//          pw.println("\t\treturn (" + base_name + ")" + attr_internal_name + ";");
          pw.println("\t\treturn (" + base_name + ")" + package_prev + "get" + method_suffix_prev + "((" + owning_entity_name_prev + ")null);");
          pw.println("\t}");

          pw.println("\tpublic void set" + method_suffix + "(" + owning_entity_name + " type, " + 
                     base_name + " value) throws " + "SdaiException {");
//          pw.println("\t\t" + attr_internal_name + " = set_instance(" + attr_internal_name + ", value);");
          pw.println("\t\t" + package_prev + "set" + method_suffix_prev + "((" + owning_entity_name_prev + ")null, value);");
          pw.println("\t}");

          pw.println("\tpublic void unset" + method_suffix + "(" + owning_entity_name + 
                     " type) throws " + "SdaiException {");
//          pw.println("\t\t" + attr_internal_name + " = unset_instance(" + attr_internal_name + ");");
          pw.println("\t\t" + package_prev + "unset" + method_suffix_prev + "((" + owning_entity_name_prev + ")null);");
          pw.println("\t}");
        }

        pw.println("\tpublic static jsdai.dictionary.EAttribute attribute" + method_suffix + "(" + owning_entity_name + " type) throws SdaiException {");
        pw.println("\t\treturn " + package_prev + "attribute" + method_suffix_prev + "((" + owning_entity_name_prev + ")null);");
        pw.println("\t}");
        pw.println("");

	}








	void generateExplicitToDerivedRedeclaredRenamedNonJavaMethodsX(EEntity_definition ed, TheMethod tm, PrintWriter pw) throws SdaiException {
	
			TheAttribute tattr = tm.current;

		  String entity_name = ed.getName(null);

      EAttribute attr = tattr.attr;

      EEntity_definition owner_entity = (EEntity_definition) attr.getParent_entity(null);
      String owner_name = owner_entity.getName(null);
      String owning_entity_name = getEntityPackage(owner_entity) + "E" + 
                                  owner_name.substring(0, 1).toUpperCase() + 
                                  owner_name.substring(1).toLowerCase();
      ;

      String attr_name = attr.getName(null);
//      String attr_internal_name = "a" + tattr.consolidated_explicit_index;
//guhusu
      String attr_internal_name = "a" + tm.consolidated.consolidated_explicit_index;
//			if (tattr.consolidated) {
//				attr_internal_name = "a" + tattr.consolidated_explicit_index;
//			}
	
	// ----------------		 
 			
 	      EExplicit_attribute xattr = (EExplicit_attribute) attr;
        EExplicit_attribute xattr_prev = xattr.getRedeclaring(null);
      	String redeclaring_name = xattr.getName(null);
      	String redeclared_name = xattr_prev.getName(null);



					// renamed attribute, generate methods for it

  	      String method_suffix = attr_name.substring(0, 1).toUpperCase() + attr_name.substring(1).toLowerCase();
//      	  EEntity bt = xattr.getDomain(null);
					EEntity bt_prev = xattr_prev.getDomain(null);

					EEntity bt = calculateTypeOfRedeclaredAttribute(xattr);


      		EEntity_definition owner_entity_prev = (EEntity_definition) xattr_prev.getParent_entity(null);
      		String owner_name_prev = owner_entity_prev.getName(null);
      		String owning_entity_name_prev = getEntityPackage(owner_entity_prev) + "E" + 
                                  owner_name_prev.substring(0, 1).toUpperCase() + 
                                  owner_name_prev.substring(1).toLowerCase();
  	      String method_suffix_prev = redeclared_name.substring(0, 1).toUpperCase() + redeclared_name.substring(1).toLowerCase();
          String package_prev = getEntityPackage(owner_entity_prev)  + "C" +
                                  owner_name_prev.substring(0, 1).toUpperCase() + 
                                  owner_name_prev.substring(1).toLowerCase() + ".";

         package_prev = "";

//---------------- new stuff -------------------------

//    String current_name = null;


//----------------- end of new stuff -----------------------
        if (bt instanceof ESimple_type) {
//          generateExplicitAttributeSimpleTypeMethods((ESimple_type) bt, pw, entity_name, attr_name, 
//                                                     method_suffix, owning_entity_name, 
//                                                     attr_internal_name);
          generateExplicitAttributeSimpleTypeMethodsRenamed((ESimple_type) bt, pw, entity_name, attr_name, 
                                                     method_suffix, owning_entity_name, 
                                                     attr_internal_name,
 																											xattr, method_suffix_prev, owning_entity_name_prev, package_prev);


        } else if (bt instanceof EAggregation_type) {
        	
        	// can the get the original aggregation type?
        	
        	
          generateExplicitAttributeAggregationTypeMethodsRenamed((EAggregation_type) bt, pw, entity_name, 
                                                          attr_name, method_suffix, 
                                                          owning_entity_name, attr_internal_name, xattr, method_suffix_prev, owning_entity_name_prev, package_prev);
        } else if (bt instanceof EDefined_type) {


          generateExplicitAttributeDefinedTypeMethodsRenamed((EDefined_type) bt, pw, entity_name, 
                                                      attr_name, method_suffix, owning_entity_name, 
                                                      attr_internal_name,
 																											xattr, method_suffix_prev, owning_entity_name_prev, package_prev);

//          generateJavaExplicit2DerivedAttributeDefinedTypeMethods(attr, redeclared_attr, (EDefined_type) bt, pw, entity_name, 
//                                                             attr_name, method_suffix, 
//                                                             redeclared_owning_entity_name, attr_internal_name, expression_java);



        } else if (bt instanceof EEntity_definition) {

					// perhaps let's do it this way for now:
					// if both entities, then new entity (parser already ensures that it is a subtype
					// if prev entity and new is not entity - then prev entity type, at least for now, the new type is possibly select with subtypes in it

//					String base_entity_name = null;
//					String base_name = null;
		
          
//          if (bt instanceof EEntity_definition) {
          
//	          base_entity_name = ((EEntity_definition) bt).getName(null);
//  	        base_name = getEntityPackage((EEntity_definition) bt) + "E" + 
//    	                         base_entity_name.substring(0, 1).toUpperCase() + 
//      	                       base_entity_name.substring(1).toLowerCase();
          
          
//        	} else {
//	          base_entity_name = ((EEntity_definition) bt_prev).getName(null);
 // 	        base_name = getEntityPackage((EEntity_definition) bt_prev) + "E" + 
 //   	                         base_entity_name.substring(0, 1).toUpperCase() + 
  //    	                       base_entity_name.substring(1).toLowerCase();
  //      	}



          String base_entity_name = ((EEntity_definition) bt).getName(null);
          String base_name = getEntityPackage((EEntity_definition) bt) + "E" + 
                             base_entity_name.substring(0, 1).toUpperCase() + 
                             base_entity_name.substring(1).toLowerCase();



          
          pw.println("\t//-2- attribute (explicit-to-derived redeclaring renamed non-java):  " + attr_name + ", base type: entity " + base_entity_name);



          // usedin
//USEDIN-RENAMED
pw.println("// USEDIN-RENAMED-11-explicit-to-derived");


          pw.println("\tpublic static int usedin" + method_suffix + "(" + owning_entity_name + " type, " + base_name + " instance, ASdaiModel domain, AEntity result) throws SdaiException {");
//          pw.println("\t\treturn ((CEntity)instance).makeUsedin(definition, " + attr_internal_name + "$, domain, result);");
          pw.println("\t\t\t// FN_NAVL - 28 - USEDIN");
          pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
//          pw.println("\t\treturn " + package_prev + "usedin" + method_suffix_prev + "((" + owning_entity_name_prev + ")null, instance, domain, result);");
          pw.println("\t}");


/*
          pw.println("\tpublic static int usedin" + method_suffix + "(" + redeclared_owning_entity_name + 
                     " type, " + base_name + 
                     " instance, ASdaiModel domain, AEntity result) throws SdaiException {");
          pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
          pw.println("\t}");
*/

  
   
          pw.println("\tpublic boolean test" + method_suffix + "(" + owning_entity_name + 
                     " type) throws " + "SdaiException {");
//          pw.println("\t\treturn test_instance(" + attr_internal_name + ");");

//          pw.println("\t\treturn " + package_prev + "test" + method_suffix_prev + "((" + owning_entity_name_prev + ")null);");

          pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
          pw.println("\t}");

/*
          pw.println("\tpublic boolean test" + method_suffix + "(" + redeclared_owning_entity_name + 
                     " type) throws " + "SdaiException {");
          pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
          pw.println("\t}");
*/



//          pw.println("\tpublic " + "Value" + " get" + method_suffix + "(" + redeclared_owning_entity_name + " type, SdaiContext _context) throws " + "SdaiException {");
          pw.println("\tpublic " + "Value" + " get" + method_suffix + "(" + owning_entity_name + " type, SdaiContext _context) throws " + "SdaiException {");

//          if (false) {
          if (flag_expressions) {
//TODO does not work, see why

            pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL); // D");
//		        generateJavaExpressionForDeriveMethodsInc(pw, attr, sd, _ed, model);

          } else {
            pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
          }

          pw.println("\t}");




/*

          pw.println("\tpublic " + base_name + " get" + method_suffix + "(" + owning_entity_name + 
                     " type) throws " + "SdaiException {");
//          pw.println("\t\t" + attr_internal_name + " = get_instance(" + attr_internal_name + ");");
//          pw.println("\t\treturn (" + base_name + ")" + attr_internal_name + ";");
          pw.println("\t\treturn (" + base_name + ")" + package_prev + "get" + method_suffix_prev + "((" + owning_entity_name_prev + ")null);");
          pw.println("\t}");

*/


//          pw.println("\tpublic " + base_name + " get" + method_suffix + "(" + redeclared_owning_entity_name + " type) throws " + "SdaiException {");
          pw.println("\tpublic " + base_name + " get" + method_suffix + "(" + owning_entity_name + " type) throws " + "SdaiException {");


          pw.println("\t\tSdaiContext _context = this.findEntityInstanceSdaiModel().getRepository().getSession().getSdaiContext();");

          if (flag_expressions) {
//            pw.println("\t\t\treturn (" + base_name + ") get" + method_suffix + "(null, _context).getInstance();");
            pw.println("\t\t\treturn (" + base_name + ") get" + method_suffix + "((" + owning_entity_name + ")null, _context).getInstance();");
          } else {
            pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
          }

          pw.println("\t}");






          pw.println("\tpublic void set" + method_suffix + "(" + owning_entity_name + " type, " + 
                     base_name + " value) throws " + "SdaiException {");
//          pw.println("\t\t" + attr_internal_name + " = set_instance(" + attr_internal_name + ", value);");
          pw.println("\t\t\tthrow new SdaiException(SdaiException.AT_NVLD);");
//          pw.println("\t\t" + package_prev + "set" + method_suffix_prev + "((" + owning_entity_name_prev + ")null, value);");
          pw.println("\t}");

/*

          pw.println("\tpublic void set" + method_suffix + "(" + redeclared_owning_entity_name + " type, " + 
                     base_name + " value) throws SdaiException {");
          pw.println("\t\t\tthrow new SdaiException(SdaiException.AT_NVLD);");
          pw.println("\t}");
*/


          pw.println("\tpublic void unset" + method_suffix + "(" + owning_entity_name + 
                     " type) throws " + "SdaiException {");
//          pw.println("\t\t" + attr_internal_name + " = unset_instance(" + attr_internal_name + ");");
          pw.println("\t\t\tthrow new SdaiException(SdaiException.AT_NVLD);");
//          pw.println("\t\t" + package_prev + "unset" + method_suffix_prev + "((" + owning_entity_name_prev + ")null);");
          pw.println("\t}");


/*
          pw.println("\tpublic void unset" + method_suffix + "(" + redeclared_owning_entity_name + 
                     " type) throws SdaiException {");
          pw.println("\t\t\tthrow new SdaiException(SdaiException.AT_NVLD);");
          pw.println("\t}");
*/

        }

        pw.println("\tpublic static jsdai.dictionary.EAttribute attribute" + method_suffix + "(" + owning_entity_name + " type) throws SdaiException {");
        pw.println("\t\treturn " + package_prev + "attribute" + method_suffix_prev + "((" + owning_entity_name_prev + ")null);");
        pw.println("\t}");
        pw.println("");

	}








	
	void generateExplicitRedeclaredRenamedNonJavaMethodsX(EEntity_definition ed, TheMethod tm, PrintWriter pw) throws SdaiException {
	
			TheAttribute tattr = tm.current;

		  String entity_name = ed.getName(null);

      EAttribute attr = tattr.attr;

      EEntity_definition owner_entity = (EEntity_definition) attr.getParent_entity(null);
      String owner_name = owner_entity.getName(null);
      String owning_entity_name = getEntityPackage(owner_entity) + "E" + 
                                  owner_name.substring(0, 1).toUpperCase() + 
                                  owner_name.substring(1).toLowerCase();
      ;

      String attr_name = attr.getName(null);
//      String attr_internal_name = "a" + tattr.consolidated_explicit_index;
//guhusu
      String attr_internal_name = "a" + tm.consolidated.consolidated_explicit_index;
//			if (tattr.consolidated) {
//				attr_internal_name = "a" + tattr.consolidated_explicit_index;
//			}
	
	// ----------------		 
 			
 	      EExplicit_attribute xattr = (EExplicit_attribute) attr;
        EExplicit_attribute xattr_prev = xattr.getRedeclaring(null);
      	String redeclaring_name = xattr.getName(null);
      	String redeclared_name = xattr_prev.getName(null);



					// renamed attribute, generate methods for it

  	      String method_suffix = attr_name.substring(0, 1).toUpperCase() + attr_name.substring(1).toLowerCase();
//      	  EEntity bt = xattr.getDomain(null);
					EEntity bt_prev = xattr_prev.getDomain(null);

					EEntity bt = calculateTypeOfRedeclaredAttribute(xattr);


      		EEntity_definition owner_entity_prev = (EEntity_definition) xattr_prev.getParent_entity(null);
      		String owner_name_prev = owner_entity_prev.getName(null);
      		String owning_entity_name_prev = getEntityPackage(owner_entity_prev) + "E" + 
                                  owner_name_prev.substring(0, 1).toUpperCase() + 
                                  owner_name_prev.substring(1).toLowerCase();
  	      String method_suffix_prev = redeclared_name.substring(0, 1).toUpperCase() + redeclared_name.substring(1).toLowerCase();
          String package_prev = getEntityPackage(owner_entity_prev)  + "C" +
                                  owner_name_prev.substring(0, 1).toUpperCase() + 
                                  owner_name_prev.substring(1).toLowerCase() + ".";

         package_prev = "";



        if (bt instanceof ESimple_type) {
//          generateExplicitAttributeSimpleTypeMethods((ESimple_type) bt, pw, entity_name, attr_name, 
//                                                     method_suffix, owning_entity_name, 
//                                                     attr_internal_name);
          generateExplicitAttributeSimpleTypeMethodsRenamed((ESimple_type) bt, pw, entity_name, attr_name, 
                                                     method_suffix, owning_entity_name, 
                                                     attr_internal_name,
 																											xattr, method_suffix_prev, owning_entity_name_prev, package_prev);


        } else if (bt instanceof EAggregation_type) {
        	
        	// can the get the original aggregation type?
        	
        	
          generateExplicitAttributeAggregationTypeMethodsRenamed((EAggregation_type) bt, pw, entity_name, 
                                                          attr_name, method_suffix, 
                                                          owning_entity_name, attr_internal_name, xattr, method_suffix_prev, owning_entity_name_prev, package_prev);
        } else if (bt instanceof EDefined_type) {
          generateExplicitAttributeDefinedTypeMethodsRenamed((EDefined_type) bt, pw, entity_name, 
                                                      attr_name, method_suffix, owning_entity_name, 
                                                      attr_internal_name,
 																											xattr, method_suffix_prev, owning_entity_name_prev, package_prev);
        } else if (bt instanceof EEntity_definition) {

					// perhaps let's do it this way for now:
					// if both entities, then new entity (parser already ensures that it is a subtype
					// if prev entity and new is not entity - then prev entity type, at least for now, the new type is possibly select with subtypes in it

					String base_entity_name = null;
					String base_name = null;
		
          
//          if (bt instanceof EEntity_definition) {
          
	          base_entity_name = ((EEntity_definition) bt).getName(null);
  	        base_name = getEntityPackage((EEntity_definition) bt) + "E" + 
    	                         base_entity_name.substring(0, 1).toUpperCase() + 
      	                       base_entity_name.substring(1).toLowerCase();
          
          
//        	} else {
//	          base_entity_name = ((EEntity_definition) bt_prev).getName(null);
 // 	        base_name = getEntityPackage((EEntity_definition) bt_prev) + "E" + 
 //   	                         base_entity_name.substring(0, 1).toUpperCase() + 
  //    	                       base_entity_name.substring(1).toLowerCase();
  //      	}
          
          pw.println("\t//-2- attribute (current explicit redeclaring or supertype explicit redeclaring):  " + attr_name + ", base type: entity " + base_entity_name);



          // usedin
//USEDIN-RENAMED
pw.println("// USEDIN-RENAMED-11");
          pw.println("\tpublic static int usedin" + method_suffix + "(" + owning_entity_name + " type, " + base_name + " instance, ASdaiModel domain, AEntity result) throws SdaiException {");
          pw.println("\t\treturn ((CEntity)instance).makeUsedin(definition, " + attr_internal_name + "$, domain, result);");
//          pw.println("\t\treturn " + package_prev + "usedin" + method_suffix_prev + "((" + owning_entity_name_prev + ")null, instance, domain, result);");
          pw.println("\t}");
  
   
          pw.println("\tpublic boolean test" + method_suffix + "(" + owning_entity_name + 
                     " type) throws " + "SdaiException {");
//          pw.println("\t\treturn test_instance(" + attr_internal_name + ");");
          pw.println("\t\treturn " + package_prev + "test" + method_suffix_prev + "((" + owning_entity_name_prev + ")null);");

          pw.println("\t}");

          pw.println("\tpublic " + base_name + " get" + method_suffix + "(" + owning_entity_name + 
                     " type) throws " + "SdaiException {");
//          pw.println("\t\t" + attr_internal_name + " = get_instance(" + attr_internal_name + ");");
//          pw.println("\t\treturn (" + base_name + ")" + attr_internal_name + ";");
          pw.println("\t\treturn (" + base_name + ")" + package_prev + "get" + method_suffix_prev + "((" + owning_entity_name_prev + ")null);");
          pw.println("\t}");

          pw.println("\tpublic void set" + method_suffix + "(" + owning_entity_name + " type, " + 
                     base_name + " value) throws " + "SdaiException {");
//          pw.println("\t\t" + attr_internal_name + " = set_instance(" + attr_internal_name + ", value);");
          pw.println("\t\t" + package_prev + "set" + method_suffix_prev + "((" + owning_entity_name_prev + ")null, value);");
          pw.println("\t}");

          pw.println("\tpublic void unset" + method_suffix + "(" + owning_entity_name + 
                     " type) throws " + "SdaiException {");
//          pw.println("\t\t" + attr_internal_name + " = unset_instance(" + attr_internal_name + ");");
          pw.println("\t\t" + package_prev + "unset" + method_suffix_prev + "((" + owning_entity_name_prev + ")null);");
          pw.println("\t}");
        }

        pw.println("\tpublic static jsdai.dictionary.EAttribute attribute" + method_suffix + "(" + owning_entity_name + " type) throws SdaiException {");
        pw.println("\t\treturn " + package_prev + "attribute" + method_suffix_prev + "((" + owning_entity_name_prev + ")null);");
        pw.println("\t}");
        pw.println("");

	}




// ########################### generateAllMethods ######## start

	void	generateAllMethods(EEntity_definition ed, PrintWriter pw, ArrayList all_attributes_all, ArrayList all_flags_all) throws SdaiException {


// --- common -----------

    _ed = ed;

		// no longer needed, hopefully
//    int internal = 0;
//    int count_derived = 0;
//    int count_inverse = 0;


 
       


// -- common ---- end


    for (int i = 0; i < all_attributes_all.size(); i++) {
      TheAttribute tattr = (TheAttribute) all_attributes_all.get(i);

			if (debug_java) pw.println("\t//going through all the attributes: " + tattr.attr);

/*
		 if (ed.getName(null).equalsIgnoreCase("Land_with_join_terminal_xim+Probe_access_area_armx")) {
//		 if (ed.getName(null).equalsIgnoreCase("Land_with_join_terminal_xim+stratum_feature_template_component_with_stratum_feature_xim")) {


     	if (tattr.attr.getName(null).equalsIgnoreCase("resident_stratum")) {
     			System.out.println("<P1> resident_stratum tattr: " + tattr);
	     }

     	if (tattr.attr.getName(null).equalsIgnoreCase("containing_shape")) {
     			System.out.println("<P1> containing_shape tattr: " + tattr);
     	}

	     if (tattr.attr.getName(null).equalsIgnoreCase("of_shape")) {
  	   		System.out.println("<P1> of_shape tattr: " + tattr);
    	 }
     }

*/

			if (tattr.consolidated) {



      // not needed, hopefully
//      int attribute_flag = (int) ((Integer) all_flags_all.get(i)).intValue();


/*
				if ((tattr.consolidated_inheritance == 0) || (tattr.consolidated_inheritance == 2)) {
					if (tattr.consolidated_type == 0) { // explicit
		        generateExplicitNoJavaInheritanceMethodsX(ed, tattr, pw);  
					} else
					if (tattr.consolidated_type == 1) { // derived
						generateDerivedNoJavaInheritanceMethodsX(ed, tattr, pw);
					} else
					if (tattr.consolidated_type == 2) { // inverse
						generateInverseNoJavaInheritanceMethodsX(ed, tattr, pw);
					}
				} else				
				if (tattr.consolidated_inheritance == 1) {  // java inheritance
					if (tattr.consolidated_type == 0) { // explicit
			  		generateExplicitJavaInheritedMethodsX(ed, tattr, pw);
					} else
					if (tattr.consolidated_type == 1) { // derived
						generateDerivedJavaInheritedMethodsX(ed, tattr, pw);
					} else
					if (tattr.consolidated_type == 2) { // inverse
						generateInverseJavaInheritedMethodsX(ed, tattr, pw);
					}
				}	
*/

			  if (debug_java) pw.println("\t//<01> generating methods for consolidated attribute:  " + tattr.attr.getName(null));

				switch (tattr.consolidated_inheritance) {

					
					case 0: // current entity

					  if (debug_java) pw.println("\t//<01-0> current entity");

						switch (tattr.consolidated_type) {
							case 0: //explicit
							  if (debug_java) pw.println("\t//<01-0-0> explicit attribute - generateExplicitCurrentEntityMethodsX()");
				        generateExplicitCurrentEntityMethodsX(ed, tattr, pw);  
								break;
							case 1: // derived
							  if (debug_java) pw.println("\t//<01-0-1> derived attribute");
								if (tattr.consolidated_flag_explicit_to_derived) {
								  if (debug_java) pw.println("\t//<01-0-1-1> explicit-to-derived");
									//  in this case, "laterRedeclared" methods are used on explicit attribute
//System.out.println("## current: \n" + tattr.toString());									
//System.out.println("## consolidated_explicit_to_derived: \n" + tattr.consolidated_explicit_to_derived.toString());									
//									generateExplicit2DerivedCurrentEntityMethodsX(ed, tattr.consolidated_explicit_to_derived, pw);								
									//if (debug_java) pw.println("\t// generateExplicit2DerivedCurrentEntityMethodsX: 1 - e->d - 0 - current entity");
//TESTING: Shape_feature -> Shape_element, changing is_original from false to true, but will it cause problems elsewhere?
										// if renamed, hopefully
										if (!(tattr.attr.getName(null).equalsIgnoreCase(tattr.consolidated_explicit_to_derived.attr.getName(null)))) {
										  if (debug_java) pw.println("\t//<01-0-1-1-1> RENAMED: " + tattr.attr.getName(null) + " - " + tattr.consolidated_explicit_to_derived.attr.getName(null) + " - generateExplicit2DerivedCurrentEntityMethodsX(false)");
											// if renamed - is_original = false 
											generateExplicit2DerivedCurrentEntityMethodsX(ed, tattr, pw, false);								
										} else {
											// if not renamed - is_original = true;
										  if (debug_java) pw.println("\t//<01-0-1-1-2> NOT RENAMED: " + tattr.attr.getName(null) + " - " + tattr.consolidated_explicit_to_derived.attr.getName(null) + " - generateExplicit2DerivedCurrentEntityMethodsX(true)");
											generateExplicit2DerivedCurrentEntityMethodsX(ed, tattr, pw, true);								
										}
//---TEST ends ------
//disabled for TEST											generateExplicit2DerivedCurrentEntityMethodsX(ed, tattr, pw, false);								
								 	// perhaps we need here also the original name explicit methods
								 	
								 	// do we need to check the type of inheritance (for the original attribute) here? 
									if (!(tattr.attr.getName(null).equalsIgnoreCase(tattr.consolidated_explicit_to_derived.attr.getName(null)))) {
  								  if (debug_java) pw.println("\t//<01-0-1-1-3> more stuff if RENAMED: " + tattr.attr.getName(null) + " - " + tattr.consolidated_explicit_to_derived.attr.getName(null));
										switch (tattr.inheritance) {
											case 0: // current
							      	  // generateExplicitCurrentEntityMethodsX(ed, tattr, pw);  
												//generateExplicit2DerivedCurrentEntityMethodsX(ed, tattr, pw, true); // true - for original name								
		  								  if (debug_java) pw.println("\t//<01-0-1-1-3-0> current -  generateExplicit2DerivedCurrentEntityMethodsXAlt()");
												pw.println("\t// e->d - 1 - current entity");
												generateExplicit2DerivedCurrentEntityMethodsXAlt(ed, tattr, pw);
												break;
											case 1:  // java
		  								  if (debug_java) pw.println("\t//<01-0-1-1-3-1> java inheritance - NOTHING generated");
pw.println("\t// e->d - 2 - current entity");
									  		//generateExplicitSupertypeJavaInheritedMethodsX(ed, tattr, pw);
//												generateExplicit2DerivedSupertypeJavaInheritedMethodsX(ed, tattr.consolidated_explicit_to_derived, pw, true);								
												break;
											case 2:  // non-java
		  								  if (debug_java) pw.println("\t//<01-0-1-1-3-2> NON-java inheritance - generateExplicit2DerivedCurrentEntityMethodsXAlt()");
pw.println("\t// e->d - 3 - current entity");
								        //generateExplicitSupertypeNoJavaInheritanceMethodsX(ed, tattr, pw);  
//												generateExplicit2DerivedSupertypeNoJavaInheritanceMethodsX(ed, tattr, pw, true);								
												generateExplicit2DerivedCurrentEntityMethodsXAlt(ed, tattr, pw);
												break;
											default: // is it possible?
		  								  if (debug_java) pw.println("\t//<01-0-1-1-3-default> is it possible?");
pw.println("\t// e->d - 4 - current entity");
												// not sure if it is possible and what method is needed if any
//												generateExplicit2DerivedCurrentEntityMethodsX(ed, tattr, pw, true); // true - for original name								
//												generateExplicit2DerivedCurrentEntityMethodsXAlt(ed, tattr, pw);
												break;
										}
									}
								} else {
								  if (debug_java) pw.println("\t//<01-0-1-1> NOT explicit-to-derived - generateDerivedCurrentEntityMethodsX()");
									//if (debug_java) pw.println("\t// <03Consolidated type: DERIVED, NOT Explicit-to-Derived> generateDerivedCurrentEntityMethodsX: " + tattr.attr.getName(null));
									generateDerivedCurrentEntityMethodsX(ed, tattr, pw);
								}
								break;
							case 2: // inverse		
							  if (debug_java) pw.println("\t//<01-0-2> inverse attribute - generateInverseCurrentEntityMethodsX()");
								generateInverseCurrentEntityMethodsX(ed, tattr, pw);
								break;
							default: // internal error
							  if (debug_java) pw.println("\t//<01-0-default> INTERNAL ERROR");
								break;
						}
						break;
					case 1: // supertype, java inheritance

					  if (debug_java) pw.println("\t//<01-1> supertype, java inheritance");

						switch (tattr.consolidated_type) {
							case 0: //explicit
							  if (debug_java) pw.println("\t//<01-1-0> explicit - generateExplicitSupertypeJavaInheritedMethodsX()");
					  		generateExplicitSupertypeJavaInheritedMethodsX(ed, tattr, pw);
								break;
							case 1: // derived
							  if (debug_java) pw.println("\t//<01-1-1> derived");
								if (tattr.consolidated_flag_explicit_to_derived) {
								  if (debug_java) pw.println("\t//<01-1-1-1> explicit-to-derived - generateExplicit2DerivedSupertypeJavaInheritedMethodsX(false)");
pw.println("\t// e->d - 00 - supertype, java inheritance: " + tattr.consolidated_explicit_to_derived.attr.getName(null));
//									generateExplicit2DerivedSupertypeJavaInheritedMethodsX(ed, tattr.consolidated_explicit_to_derived, pw, false);								
									generateExplicit2DerivedSupertypeJavaInheritedMethodsX(ed, tattr, pw, false);								

									// experiment with additional methods for the original name								
									if (!(tattr.attr.getName(null).equalsIgnoreCase(tattr.consolidated_explicit_to_derived.attr.getName(null)))) {

									  if (debug_java) pw.println("\t//<01-1-1-1-0> experiment with additional methods for the original name: " + tattr.attr.getName(null) + " - " + tattr.consolidated_explicit_to_derived.attr.getName(null));

										switch (tattr.inheritance) {
											case 0: // current
											  if (debug_java) pw.println("\t//<01-1-1-1-0-0> current - NOTHING generated");
pw.println("\t// e->d - 5  - supertype, java inheritance");
							      	  // generateExplicitCurrentEntityMethodsX(ed, tattr, pw);  
//												generateExplicit2DerivedCurrentEntityMethodsX(ed, tattr, pw, true); // true - for original name								
//												generateExplicit2DerivedCurrentEntityMethodsXAlt(ed, tattr, pw);
												break;
											case 1:  // java
											  if (debug_java) pw.println("\t//<01-1-1-1-0-1> java inheritance - generateExplicit2DerivedSupertypeJavaInheritedMethodsXX(true)");
pw.println("\t// e->d - 6 - supertype, java inheritance: " + tattr.attr.getName(null));
									  		//generateExplicitSupertypeJavaInheritedMethodsX(ed, tattr, pw);
//2005-06-15: do we need it? no need
/*
	this case includes also an explicit attribute in a supertype redeclared as derived in the current entity

*/

//												generateExplicit2DerivedSupertypeJavaInheritedMethodsX(ed, tattr	, pw, true);								
												// basically, I think I want here explicit (as a temp fix)
												generateExplicit2DerivedSupertypeJavaInheritedMethodsXX(ed, tattr	, pw, true);								
												break;
											case 2:  // non-java
											  if (debug_java) pw.println("\t//<01-1-1-1-0-2> NON-java inheritance - NOTHING generated");
pw.println("\t// e->d - 7 - supertype, java inheritance");
								        //generateExplicitSupertypeNoJavaInheritanceMethodsX(ed, tattr, pw);  
//												generateExplicit2DerivedSupertypeNoJavaInheritanceMethodsX(ed, tattr, pw, true);								
//												generateExplicit2DerivedCurrentEntityMethodsXAlt(ed, tattr, pw);
												break;
											default: // is it possible?
											  if (debug_java) pw.println("\t//<01-1-1-1-0-2> is it possible?");
pw.println("\t// e->d - 8 - supertype, java inheritance");
												// not sure if it is possible and what method is needed if any
//												generateExplicit2DerivedCurrentEntityMethodsX(ed, tattr, pw, true); // true - for original name								
//												generateExplicit2DerivedCurrentEntityMethodsXAlt(ed, tattr, pw);
												break;
										}
									}
								} else {
								  if (debug_java) pw.println("\t//<01-1-1-2> NOT explicit-to-derived - generateDerivedSupertypeJavaInheritedMethodsX");
									generateDerivedSupertypeJavaInheritedMethodsX(ed, tattr, pw);
								}
								break;
							case 2: // inverse		
							  if (debug_java) pw.println("\t//<01-1-2> inverse - generateInverseSupertypeJavaInheritedMethodsX()");
								generateInverseSupertypeJavaInheritedMethodsX(ed, tattr, pw);
								break;
							default: // internal error
							  if (debug_java) pw.println("\t//<01-1-default> INTERNAL ERROR");
								break;
						}
						break;
					case 2: // supertype, non-java inheritance		

					  if (debug_java) pw.println("\t//<01-2> supertype, non-java inheritance");

						switch (tattr.consolidated_type) {
							case 0: //explicit
							  if (debug_java) pw.println("\t//<01-2-0> explicit - generateExplicitSupertypeNoJavaInheritanceMethodsX()");
				        generateExplicitSupertypeNoJavaInheritanceMethodsX(ed, tattr, pw);  
								break;
							case 1: // derived
							  if (debug_java) pw.println("\t//<01-2-1> derived");
								if (tattr.consolidated_flag_explicit_to_derived) {
								  if (debug_java) pw.println("\t//<01-2-1-1> explicit-to-derived - generateExplicit2DerivedSupertypeNoJavaInheritanceMethodsX(false)");
								// make this reference inside the method instead
//									generateExplicit2DerivedSupertypeNoJavaInheritanceMethodsX(ed, tattr.consolidated_explicit_to_derived, pw);								
pw.println("\t// e->d - 000 - supertype, non-java inheritance: " + tattr.consolidated_explicit_to_derived.attr.getName(null));
									generateExplicit2DerivedSupertypeNoJavaInheritanceMethodsX(ed, tattr, pw, false);								

                  // experimenting with the additonal methods for the original name

									if (!(tattr.attr.getName(null).equalsIgnoreCase(tattr.consolidated_explicit_to_derived.attr.getName(null)))) {
									  if (debug_java) pw.println("\t//<01-2-1-1-1> RENAMED: " + tattr.attr.getName(null) + " - " + tattr.consolidated_explicit_to_derived.attr.getName(null));

										switch (tattr.inheritance) {
											case 0: // current
											  if (debug_java) pw.println("\t//<01-2-1-1-1-0> current  - NOTHING");
pw.println("\t// e->d - 9");
							      	  // generateExplicitCurrentEntityMethodsX(ed, tattr, pw);  
//												generateExplicit2DerivedCurrentEntityMethodsX(ed, tattr, pw, true); // true - for original name								
//												generateExplicit2DerivedCurrentEntityMethodsXAlt(ed, tattr, pw);
												break;
											case 1:  // java
											  if (debug_java) pw.println("\t//<01-2-1-1-1-1> java inheritance  - NOTHING");
pw.println("\t// e->d - 10");
									  		//generateExplicitSupertypeJavaInheritedMethodsX(ed, tattr, pw);
//												generateExplicit2DerivedSupertypeJavaInheritedMethodsX(ed, tattr.consolidated_explicit_to_derived, pw, true);								
												break;
											case 2:  // non-java
											  if (debug_java) pw.println("\t//<01-2-1-1-1-2> non-java inheritance  - generateExplicit2DerivedCurrentEntityMethodsXAlt(ed, tattr, pw)()");
pw.println("\t// e->d - 11");
								        //generateExplicitSupertypeNoJavaInheritanceMethodsX(ed, tattr, pw);  
//												generateExplicit2DerivedSupertypeNoJavaInheritanceMethodsX(ed, tattr, pw, true);								
                        // experiment
												// generateExplicit2DerivedCurrentEntityMethodsXAlt(ed, tattr, pw);



											 	EAttribute attr0 = null;
												if (tattr != null) {
													TheAttribute tattr00 = tattr.last_redeclared_by;
													if (tattr00 != null) {
														attr0 = tattr00.attr;
													} else {
//												if (debug_java) pw.println("tattr00 is NULL: " + tattr0);
														if (debug_java) pw.println("\t// tattr00 is NULL");
													}
												} else {
//											if (debug_java) pw.println("tattr0 is NULL: " + tm);
													if (debug_java) pw.println("\t// tattr is NULL");
												}
 									 // if (debug_java) pw.println("\t// attr0: " + attr0);
									 
											 if (attr0 instanceof EDerived_attribute) {
											  if (debug_java) pw.println("\t//<01-2-1-1-1-2-EXPERIMENT-1 - overrides above> non-java inheritance  - generateExplicit2DerivedNonJavaMethodsXSX(ed, tattr, pw, true)");
												generateExplicit2DerivedNonJavaMethodsXSX(ed, tattr, pw, true);
											} else {
												generateExplicit2DerivedCurrentEntityMethodsXAlt(ed, tattr, pw);
											}
												break;
											default: // is it possible?
											  if (debug_java) pw.println("\t//<01-2-1-1-1-default> is it possible?");
pw.println("\t// e->d - 12");
												// not sure if it is possible and what method is needed if any
//												generateExplicit2DerivedCurrentEntityMethodsX(ed, tattr, pw, true); // true - for original name								
//												generateExplicit2DerivedCurrentEntityMethodsXAlt(ed, tattr, pw);
												break;
										}
									} else {
									  if (debug_java) pw.println("\t//<01-2-1-1-2> NOT RENAMED - DO NOTHING: " + tattr.attr.getName(null) + " - " + tattr.consolidated_explicit_to_derived.attr.getName(null));
									}

								} else {
								  if (debug_java) pw.println("\t//<01-2-1-2> NOT explicit-to-derived - generateDerivedSupertypeNoJavaInheritanceMethodsX()");
									generateDerivedSupertypeNoJavaInheritanceMethodsX(ed, tattr, pw);
								}
								break;
							case 2: // inverse		
							  if (debug_java) pw.println("\t//<01-2-2> inverse - generateInverseSupertypeNoJavaInheritanceMethodsX()");
								generateInverseSupertypeNoJavaInheritanceMethodsX(ed, tattr, pw);
								break;
							default: // internal error
							  if (debug_java) pw.println("\t//<01-2-default> INTERNAL ERROR");
								break;
						}
						break;
					default: // internal error
					  if (debug_java) pw.println("\t//<01-default> INTERNAL ERROR");
						break;
				}
//System.out.println("<><>RENAMED: \n" + tattr); 				
				if (tattr.consolidated_renamed_present) {

				  if (debug_java) pw.println("\t//<03> consolidated renamed present - additional stuff ");
					// generate methods for renamed attributes
					for (int j = 0; j < tattr.consolidated_renamed.size(); j++) {
						TheMethod tm = (TheMethod)tattr.consolidated_renamed.get(j);
						
					  if ((tattr.consolidated_flag_explicit_to_derived)&& (tm.current.type == 0)) {
							TheAttribute tattrx	= tattr.consolidated_explicit_to_derived;
					  	if (tattrx.attr.getName(null).equalsIgnoreCase(tm.current.attr.getName(null))) {
					  		// this explicit renamed attribute is later redeclared as derived with the new name
					  		// so only derived methods are needed 
					  		
					  		/*
					  				HOWEVER:
					  				1. all this code perhaps should be moved to the preparation stage so that these unnecessary methods not even attempted 
					  				   to be generated here
					  				2. There still might be missing methods: if the consolidated  methods are with the new name,
					  				    then no methods are generated with the original name, and they might be needed to match interface methods when
					  				    java inheritance is not used. 
					  		     
					  		    Check how consolidated methods are generated, especially explicit-to-derived,
					  		    because, if explicit-to-derived results in a different name, two things may be needed:
					  		    a) to suppress renamed method for the same name on an earlier explicit attribute (done here)
					  		    b) to generate methods for the original name, especially when there is no java inheritance.
					  		    OR DO WE REALLY NEED THEM? perhaps not.
					  		    
					  		    Probably everything is WRONG here:
					  		    if an attribute is later redeclared as derived, we cannot generate also methods for explicit with the original name,
					  		    because the internal fields an$, an, an$$ may not be even present.
					  		    But perhaps we need to generate derived methods for the original name, in adition to the methods for the new name. 
					  		
					  		
					  		*/
					  		
					  		continue;
					  	}
					  }

						
						
						switch (tm.current.inheritance) {
							case 0: // current entity
							  if (debug_java) pw.println("\t//<03-0> current entity");
								switch (tm.current.type) {
									case 0: // explicit
									  if (debug_java) pw.println("\t//<03-0-0> explicit - generateExplicitRedeclaredRenamedCurrentEntityMethodsX()");
										generateExplicitRedeclaredRenamedCurrentEntityMethodsX(ed, tm, pw);
										break;
									case 1: // derived
									  if (debug_java) pw.println("\t//<03-0-1> derived - NOTHING");
										break;
									case 2: // inverse
									  if (debug_java) pw.println("\t//<03-0-1> inverse - NOTHING");
										break;
									default:
									  if (debug_java) pw.println("\t//<03-0-default> INTERNAL ERROR");
										break;
								}
								break; 
							case 1: // supertype - java inheritance
							  if (debug_java) pw.println("\t//<03-1> supertype - java inheritance");
								switch (tm.current.type) {
									case 0: // explicit
//									  if (debug_java) pw.println("\t//<03-1-0> explicit - generateExplicitRedeclaredRenamedSupertypeJavaInheritedX()");
// original
//										generateExplicitRedeclaredRenamedSupertypeJavaInheritedX(ed, tm, pw); // experiment
// another experiment: - too many methods generated
//									 generateExplicit2DerivedNonJavaMethodsX(ed, tattr, pw, false);
// let's implement a method on the basis of the above one

//									  if (debug_java) pw.println("\t//<03-1-0> explicit - generateExplicitRedeclaredRenamedSupertypeJavaInheritedXS()");
									  if (debug_java) pw.println("\t//<03-1-0> explicit");
									 
									 	TheAttribute tattr0 = tm.current;
									 	EAttribute attr0 = null;
										if (tattr0 != null) {
											TheAttribute tattr00 = tattr0.last_redeclared_by;
											if (tattr00 != null) {
												attr0 = tattr00.attr;
											} else {
//												if (debug_java) pw.println("tattr00 is NULL: " + tattr0);
												if (debug_java) pw.println("\t// tattr00 is NULL");
											}
										} else {
//											if (debug_java) pw.println("tattr0 is NULL: " + tm);
											if (debug_java) pw.println("\t// tattr0 is NULL");
										}
 									 // if (debug_java) pw.println("\t// attr0: " + attr0);
									 
									 if (attr0 instanceof EDerived_attribute) {
									  if (debug_java) pw.println("\t//<03-1-0-1> explicit - generateExplicitRedeclaredRenamedSupertypeJavaInheritedXS(true)");
									 	generateExplicit2DerivedNonJavaMethodsXS(ed, tm, pw, true);
									 } else {
									 	// this is the original method
									  if (debug_java) pw.println("\t//<03-1-0-2> explicit - generateExplicitRedeclaredRenamedSupertypeJavaInheritedX()");
									  // if (debug_java) pw.println("\t// tm: " + tm);

									 	generateExplicitRedeclaredRenamedSupertypeJavaInheritedX(ed, tm, pw);
									 }
// does not generate correct derived get methods either
//									  if (debug_java) pw.println("\t//<03-1-0-experiment> replaced by - generateExplicit2DerivedRedeclaredRenamedNonJavaMethodsX(");
//										generateExplicit2DerivedRedeclaredRenamedNonJavaMethodsX(ed, tm, pw);
										break;
									case 1: // derived
									  if (debug_java) pw.println("\t//<03-1-1> derived - NOTHING");
										break;
									case 2: // inverse
									  if (debug_java) pw.println("\t//<03-1-2> inverse - NOTHING");
										break;
									default:
									  if (debug_java) pw.println("\t//<03-1-default> INTERNAL ERROR");
										break;
								}
								break;
							case 2: // supertype - no java inheritance
							  if (debug_java) pw.println("\t//<03-2> supertype - NON-java inheritance");
								switch (tm.current.type) {
									case 0: // explicit
									  if (debug_java) pw.println("\t//<03-2-0> explicit");
										if (tattr.consolidated_flag_explicit_to_derived) {


									 	TheAttribute tattrx0 = tm.current;
									 	EAttribute attrx0 = null;
										if (tattrx0 != null) {
											TheAttribute tattrx00 = tattrx0.last_redeclared_by;
											if (tattrx00 != null) {
												attrx0 = tattrx00.attr;
											} else {
//												if (debug_java) pw.println("tattrx00 is NULL: " + tattrx0);
												if (debug_java) pw.println("\t// tattrx00 is NULL");
											}
										} else {
//											if (debug_java) pw.println("tattrx0 is NULL: " + tm);
											if (debug_java) pw.println("\t// tattrx0 is NULL");
										}
 									 // if (debug_java) pw.println("attrx0: " + attrx0);
									 
									 if (attrx0 instanceof EDerived_attribute) {

										  	if (debug_java) pw.println("\t//<03-2-0-1-0> explicit-to-derived - generateExplicit2DerivedNonJavaMethodsXX()");
											 	generateExplicit2DerivedNonJavaMethodsXS(ed, tm, pw, true);
		//										generateExplicit2DerivedNonJavaMethodsXX(ed, tattrx0, pw, false);
										} else {


										  	if (debug_java) pw.println("\t//<03-2-0-1-1> explicit-to-derived - generateExplicitToDerivedRedeclaredRenamedSupertypeNonJavaMethodsX()");
pw.println("\t// renamed e->d - supertype no-java");
												generateExplicitToDerivedRedeclaredRenamedSupertypeNonJavaMethodsX(ed, tm, pw);
//											generateExplicit2DerivedSupertypeNoJavaInheritanceMethodsX(ed, tm.consolidated, pw, true);								
											}
										} else {
										  if (debug_java) pw.println("\t//<03-2-0-1> NOT explicit-to-derived - generateExplicitRedeclaredRenamedSupertypeNonJavaMethodsX()");
pw.println("\t// renamed explicit - supertype no-java");
											generateExplicitRedeclaredRenamedSupertypeNonJavaMethodsX(ed, tm, pw);
										}
										break;
									case 1: // derived
									  if (debug_java) pw.println("\t//<03-2-1> derived - NOTHING");
										break;
									case 2: // inverse
									  if (debug_java) pw.println("\t//<03-2-2> inverse - NOTHING");
										break;
									default:
									  if (debug_java) pw.println("\t//<03-2-default> INTERNAL ERROR");
										break;
								}
								break;
							default: // internal error
							  if (debug_java) pw.println("\t//<03-default> INTERNAL ERROR");
								break;
						}
					}
				}
	
			} else { // if consolidated			
			  // not consolidated, do not generate, we genarate all the methods for consolidated attributes only
			  if (debug_java) pw.println("\t//<02> NOT generating methods for NOT consolidated attribute:  " + tattr.attr.getName(null));
				
			}
		} // loop			
	} // method



// ########################### generateAllMethods ######### end


	void	generateAllMethods_prev(EEntity_definition ed, PrintWriter pw, ArrayList all_attributes_all, ArrayList all_flags_all) throws SdaiException {


// --- common -----------

    _ed = ed;

		// no longer needed, hopefully
//    int internal = 0;
//    int count_derived = 0;
//    int count_inverse = 0;


 
       


// -- common ---- end


    for (int i = 0; i < all_attributes_all.size(); i++) {
      TheAttribute tattr = (TheAttribute) all_attributes_all.get(i);


			if (tattr.consolidated) {



      // not needed, hopefully
//      int attribute_flag = (int) ((Integer) all_flags_all.get(i)).intValue();


/*
				if ((tattr.consolidated_inheritance == 0) || (tattr.consolidated_inheritance == 2)) {
					if (tattr.consolidated_type == 0) { // explicit
		        generateExplicitNoJavaInheritanceMethodsX(ed, tattr, pw);  
					} else
					if (tattr.consolidated_type == 1) { // derived
						generateDerivedNoJavaInheritanceMethodsX(ed, tattr, pw);
					} else
					if (tattr.consolidated_type == 2) { // inverse
						generateInverseNoJavaInheritanceMethodsX(ed, tattr, pw);
					}
				} else				
				if (tattr.consolidated_inheritance == 1) {  // java inheritance
					if (tattr.consolidated_type == 0) { // explicit
			  		generateExplicitJavaInheritedMethodsX(ed, tattr, pw);
					} else
					if (tattr.consolidated_type == 1) { // derived
						generateDerivedJavaInheritedMethodsX(ed, tattr, pw);
					} else
					if (tattr.consolidated_type == 2) { // inverse
						generateInverseJavaInheritedMethodsX(ed, tattr, pw);
					}
				}	
*/

				switch (tattr.consolidated_inheritance) {
					
					case 0: // current entity
						switch (tattr.consolidated_type) {
							case 0: //explicit
				        generateExplicitCurrentEntityMethodsX(ed, tattr, pw);  
								break;
							case 1: // derived
								if (tattr.consolidated_flag_explicit_to_derived) {
									//  in this case, "laterRedeclared" methods are used on explicit attribute
//System.out.println("## current: \n" + tattr.toString());									
//System.out.println("## consolidated_explicit_to_derived: \n" + tattr.consolidated_explicit_to_derived.toString());									
//									generateExplicit2DerivedCurrentEntityMethodsX(ed, tattr.consolidated_explicit_to_derived, pw);								
									if (debug_java) pw.println("\t// generateExplicit2DerivedCurrentEntityMethodsX: 2 - derived, consolidated_flag_explicit_to_derived = true");
									generateExplicit2DerivedCurrentEntityMethodsX(ed, tattr, pw, false);								
								 	// perhaps we need here also the original name explicit methods
								 	
								 	// do we need to check the type of inheritance (for the original attribute) here? 
									if (!(tattr.attr.getName(null).equalsIgnoreCase(tattr.consolidated_explicit_to_derived.attr.getName(null)))) {
										switch (tattr.inheritance) {
											case 0: // current
							      	  // generateExplicitCurrentEntityMethodsX(ed, tattr, pw);  
												//generateExplicit2DerivedCurrentEntityMethodsX(ed, tattr, pw, true); // true - for original name								
pw.println("\t// e->d - 1");
												generateExplicit2DerivedCurrentEntityMethodsXAlt(ed, tattr, pw);
												break;
											case 1:  // java
pw.println("\t// e->d - 2");
									  		//generateExplicitSupertypeJavaInheritedMethodsX(ed, tattr, pw);
//												generateExplicit2DerivedSupertypeJavaInheritedMethodsX(ed, tattr.consolidated_explicit_to_derived, pw, true);								
												break;
											case 2:  // non-java
pw.println("\t// e->d - 3");
								        //generateExplicitSupertypeNoJavaInheritanceMethodsX(ed, tattr, pw);  
//												generateExplicit2DerivedSupertypeNoJavaInheritanceMethodsX(ed, tattr, pw, true);								
												generateExplicit2DerivedCurrentEntityMethodsXAlt(ed, tattr, pw);
												break;
											default: // is it possible?
pw.println("\t// e->d - 4");
												// not sure if it is possible and what method is needed if any
//												generateExplicit2DerivedCurrentEntityMethodsX(ed, tattr, pw, true); // true - for original name								
//												generateExplicit2DerivedCurrentEntityMethodsXAlt(ed, tattr, pw);
												break;
										}
									}
								} else {
									generateDerivedCurrentEntityMethodsX(ed, tattr, pw);
								}
								break;
							case 2: // inverse		
								generateInverseCurrentEntityMethodsX(ed, tattr, pw);
								break;
							default: // internal error
								break;
						}
						break;
					case 1: // supertype, java inheritance
						switch (tattr.consolidated_type) {
							case 0: //explicit
					  		generateExplicitSupertypeJavaInheritedMethodsX(ed, tattr, pw);
								break;
							case 1: // derived
								if (tattr.consolidated_flag_explicit_to_derived) {
									generateExplicit2DerivedSupertypeJavaInheritedMethodsX(ed, tattr.consolidated_explicit_to_derived, pw, false);								

									// experiment with additional methods for the original name								
									if (!(tattr.attr.getName(null).equalsIgnoreCase(tattr.consolidated_explicit_to_derived.attr.getName(null)))) {
										switch (tattr.inheritance) {
											case 0: // current
pw.println("\t// e->d - 5");
							      	  // generateExplicitCurrentEntityMethodsX(ed, tattr, pw);  
//												generateExplicit2DerivedCurrentEntityMethodsX(ed, tattr, pw, true); // true - for original name								
//												generateExplicit2DerivedCurrentEntityMethodsXAlt(ed, tattr, pw);
												break;
											case 1:  // java
pw.println("\t// e->d - 6");
									  		//generateExplicitSupertypeJavaInheritedMethodsX(ed, tattr, pw);
												generateExplicit2DerivedSupertypeJavaInheritedMethodsX(ed, tattr	, pw, true);								
												break;
											case 2:  // non-java
pw.println("\t// e->d - 7");
								        //generateExplicitSupertypeNoJavaInheritanceMethodsX(ed, tattr, pw);  
//												generateExplicit2DerivedSupertypeNoJavaInheritanceMethodsX(ed, tattr, pw, true);								
//												generateExplicit2DerivedCurrentEntityMethodsXAlt(ed, tattr, pw);
												break;
											default: // is it possible?
pw.println("\t// e->d - 8");
												// not sure if it is possible and what method is needed if any
//												generateExplicit2DerivedCurrentEntityMethodsX(ed, tattr, pw, true); // true - for original name								
//												generateExplicit2DerivedCurrentEntityMethodsXAlt(ed, tattr, pw);
												break;
										}
									}
								} else {
									generateDerivedSupertypeJavaInheritedMethodsX(ed, tattr, pw);
								}
								break;
							case 2: // inverse		
								generateInverseSupertypeJavaInheritedMethodsX(ed, tattr, pw);
								break;
							default: // internal error
								break;
						}
						break;
					case 2: // supertype, non-java inheritance		
						switch (tattr.consolidated_type) {
							case 0: //explicit
				        generateExplicitSupertypeNoJavaInheritanceMethodsX(ed, tattr, pw);  
								break;
							case 1: // derived
								if (tattr.consolidated_flag_explicit_to_derived) {
								// make this reference inside the method instead
//									generateExplicit2DerivedSupertypeNoJavaInheritanceMethodsX(ed, tattr.consolidated_explicit_to_derived, pw);								
									generateExplicit2DerivedSupertypeNoJavaInheritanceMethodsX(ed, tattr, pw, false);								

                  // experimenting with the additonal methods for the original name
									if (!(tattr.attr.getName(null).equalsIgnoreCase(tattr.consolidated_explicit_to_derived.attr.getName(null)))) {
										switch (tattr.inheritance) {
											case 0: // current
pw.println("\t// e->d - 9");
							      	  // generateExplicitCurrentEntityMethodsX(ed, tattr, pw);  
//												generateExplicit2DerivedCurrentEntityMethodsX(ed, tattr, pw, true); // true - for original name								
//												generateExplicit2DerivedCurrentEntityMethodsXAlt(ed, tattr, pw);
												break;
											case 1:  // java
pw.println("\t// e->d - 10");
									  		//generateExplicitSupertypeJavaInheritedMethodsX(ed, tattr, pw);
//												generateExplicit2DerivedSupertypeJavaInheritedMethodsX(ed, tattr.consolidated_explicit_to_derived, pw, true);								
												break;
											case 2:  // non-java
pw.println("\t// e->d - 11");
								        //generateExplicitSupertypeNoJavaInheritanceMethodsX(ed, tattr, pw);  
//												generateExplicit2DerivedSupertypeNoJavaInheritanceMethodsX(ed, tattr, pw, true);								
												generateExplicit2DerivedCurrentEntityMethodsXAlt(ed, tattr, pw);
												break;
											default: // is it possible?
pw.println("\t// e->d - 12");
												// not sure if it is possible and what method is needed if any
//												generateExplicit2DerivedCurrentEntityMethodsX(ed, tattr, pw, true); // true - for original name								
//												generateExplicit2DerivedCurrentEntityMethodsXAlt(ed, tattr, pw);
												break;
										}
									}

								} else {
									generateDerivedSupertypeNoJavaInheritanceMethodsX(ed, tattr, pw);
								}
								break;
							case 2: // inverse		
								generateInverseSupertypeNoJavaInheritanceMethodsX(ed, tattr, pw);
								break;
							default: // internal error
								break;
						}
						break;
					default: // internal error
						break;
				}
//System.out.println("<><>RENAMED: \n" + tattr); 				
				if (tattr.consolidated_renamed_present) {
					// generate methods for renamed attributes
					for (int j = 0; j < tattr.consolidated_renamed.size(); j++) {
						TheMethod tm = (TheMethod)tattr.consolidated_renamed.get(j);
						
					  if ((tattr.consolidated_flag_explicit_to_derived)&& (tm.current.type == 0)) {
							TheAttribute tattrx	= tattr.consolidated_explicit_to_derived;
					  	if (tattrx.attr.getName(null).equalsIgnoreCase(tm.current.attr.getName(null))) {
					  		// this explicit renamed attribute is later redeclared as derived with the new name
					  		// so only derived methods are needed 
					  		
					  		/*
					  				HOWEVER:
					  				1. all this code perhaps should be moved to the preparation stage so that these unnecessary methods not even attempted 
					  				   to be generated here
					  				2. There still might be missing methods: if the consolidated  methods are with the new name,
					  				    then no methods are generated with the original name, and they might be needed to match interface methods when
					  				    java inheritance is not used. 
					  		     
					  		    Check how consolidated methods are generated, especially explicit-to-derived,
					  		    because, if explicit-to-derived results in a different name, two things may be needed:
					  		    a) to suppress renamed method for the same name on an earlier explicit attribute (done here)
					  		    b) to generate methods for the original name, especially when there is no java inheritance.
					  		    OR DO WE REALLY NEED THEM? perhaps not.
					  		    
					  		    Probably everything is WRONG here:
					  		    if an attribute is later redeclared as derived, we cannot generate also methods for explicit with the original name,
					  		    because the internal fields an$, an, an$$ may not be even present.
					  		    But perhaps we need to generate derived methods for the original name, in adition to the methods for the new name. 
					  		
					  		
					  		*/
					  		
					  		continue;
					  	}
					  }

						
						
						switch (tm.current.inheritance) {
							case 0: // current entity
								switch (tm.current.type) {
									case 0: // explicit
										generateExplicitRedeclaredRenamedCurrentEntityMethodsX(ed, tm, pw);
										break;
									case 1: // derived
										break;
									case 2: // inverse
										break;
									default:
										break;
								}
								break; 
							case 1: // supertype - java inheritance
								switch (tm.current.type) {
									case 0: // explicit
										generateExplicitRedeclaredRenamedSupertypeJavaInheritedX(ed, tm, pw);
										break;
									case 1: // derived
										break;
									case 2: // inverse
										break;
									default:
										break;
								}
								break;
							case 2: // supertype - no java inheritance
								switch (tm.current.type) {
									case 0: // explicit
										generateExplicitRedeclaredRenamedSupertypeNonJavaMethodsX(ed, tm, pw);
										break;
									case 1: // derived
										break;
									case 2: // inverse
										break;
									default:
										break;
								}
								break;
							default: // internal error
								break;
						}
					}
				}
	
			} // if consolidated			
		} // loop			
	} // method


  void generateAllAttributes(EEntity_definition ed, PrintWriter pw, ArrayList all_attributes, 
                          ArrayList all_flags) throws SdaiException {


    SdaiModel edmod = ed.findEntityInstanceSdaiModel();
		boolean is_xim = false;
//		if (edmod.getName().endsWith("_XIM_DICTIONARY_DATA")) {
		if ((edmod.getName().endsWith("_XIM_DICTIONARY_DATA")) || (edmod.getName().equalsIgnoreCase("MIXED_COMPLEX_TYPES_DICTIONARY_DATA"))) {
			is_xim = true;
		}



    pw.println("");
    pw.println("\t/*----------------------------- Attributes (new version) -----------*/");
    pw.println("");
		getAllAttributes(ed, all_attributes, all_flags);


/*		
		System.out.println("#### entity: " + ed.getName(null));
		for (int ji = 0; ji < all_attributes.size(); ji++) {
			TheAttribute tattr = (TheAttribute)all_attributes.get(ji);
			System.out.println("#NEW# attr: " + tattr.attr);
		}
*/

    for (int i = 0; i < all_attributes.size(); i++) {
      TheAttribute tattr = (TheAttribute) all_attributes.get(i);
			
			if (tattr.consolidated) {
				pw.println("\t" + tattr.consolidated_attribute_comment_str);
				if ((tattr.consolidated_inheritance == 0) || (tattr.consolidated_inheritance == 2)) {
					pw.println("\t" + tattr.consolidated_attribute_str);
//debug					pw.println("\t" + tattr.consolidated_attribute_str + "  // <01>");
					if (tattr.consolidated_type == 0) { // explicit
						pw.println("\t" + tattr.consolidated_attribute_value_str);
//debug					pw.println("\t" + tattr.consolidated_attribute_value_str + "  // <01-2>");
						if (tattr.consolidated_attribute_select_field_present) {
							pw.println("\t" + tattr.consolidated_attribute_select_str);
						}
					} else 
					if (tattr.consolidated_type == 1) { // derived
						if (tattr.consolidated_flag_explicit_to_derived) {  // or just test if tattr.type == 0						
						  String exp_str = "protected static final jsdai.dictionary.CExplicit_attribute a" + tattr.consolidated_explicit_index + "$ = CEntity.initExplicitAttribute(definition, " + tattr.consolidated_explicit_index + ");";
//							pw.println("\ta" + tattr.consolidated_explicit_index + "$;");
//							pw.println("\ta" + tattr.consolidated_explicit_index + ";");

							  pw.println("\t" + exp_str);
//debug-temp-out							  pw.println("\t// (experimentally removed)" + exp_str);

								// need also support for xims here:
								// so:
								// if redeclared explicit-as-derived non-java AND (boolean OR _xim)
								//XIM issue when supertype is not in XIM, let's try to generate the field for all:

//a8 issue

// we can suppres generation for current entity (and java inheritance?) only,
// if it is non-java inheritance, - do not suppress


//								if (isAttributeBoolean(tattr) || is_xim) {
//								if (isAttributeBoolean(tattr) || (!is_xim)) {

//								if (isAttributeBoolean(tattr) || (!is_xim) || (tattr.consolidated_inheritance == 2)) {
								if (isAttributeBoolean(tattr) || (!is_xim) || (tattr.inheritance == 2)) {



//								if (true) {
									String boolean_or_xim_value_str = getExplicitAttributeValueField(tattr);
								  pw.println("\t" + boolean_or_xim_value_str);
//debug								  pw.println("\t" + boolean_or_xim_value_str + " // boolean or xim only, but currently for all");
//								  pw.println("\t// (experimentally removed) " + boolean_or_xim_value_str);

									// does not work for derived
//									if (tattr.consolidated_attribute_select_field_present) {
//										pw.println("\t" + tattr.consolidated_attribute_select_str);
//									}

									boolean is_select_field_present = ifSelectFieldPresent(tattr);
									if (is_select_field_present) {
										pw.println("\tprotected int a" + tattr.consolidated_explicit_index + "$$;"); 
									}



								} else {

//									String boolean_or_xim_value_str = getExplicitAttributeValueField(tattr);
//								  pw.println("\t// HOHO " + boolean_or_xim_value_str + " con inheritance: " + tattr.consolidated_inheritance + ", inheritance: " + tattr.inheritance);
									
								}
						}
					}
				} else 
				if (tattr.consolidated_inheritance == 1) {  // java inheritance
					pw.println("\t// " + tattr.consolidated_attribute_str);
//debug					pw.println("\t// " + tattr.consolidated_attribute_str + "// <2>");
					if (tattr.consolidated_type == 0) {
						pw.println("\t// " + tattr.consolidated_attribute_value_str);
						if (tattr.consolidated_attribute_select_field_present) {
							pw.println("\t// " + tattr.consolidated_attribute_select_str);
						}
					}
				}
			}
		}

	}


	void	getAllAttributes(EEntity_definition ed, ArrayList all_attributes_ext, ArrayList all_flags_ext) throws SdaiException {

    HashSet entities = new HashSet();
    boolean inherited_branch = true;
    boolean is_complex = ed.getComplex(null);
		Counts all_counts = new Counts();
		//int explicit_count = 0;
		//wint derived_count = 0;
		//int alt_derived_count = 0;
		//int inverse_count = 0;
		HashSet original_explicit_attributes = new HashSet();

    if (is_complex) {
      collectComplexAttributesAll(ed, all_attributes_ext, all_flags_ext, all_counts, original_explicit_attributes);
    } else {
      collectAttributesAll(ed, ed, all_attributes_ext, all_flags_ext, entities, inherited_branch, all_counts, original_explicit_attributes);
    }
    processAttributesAll(ed, all_attributes_ext, all_flags_ext);
    processAttributesAll2(ed, all_attributes_ext, all_flags_ext);
    processAttributesAll4(ed, all_attributes_ext, all_flags_ext);
    processAttributesAll5(ed, all_attributes_ext, all_flags_ext);
	
//System.out.println("entity: " + ed.getName(null) + ", ext attributes: " + all_attributes_ext);
	}



	void	getExtendedAttributes(EEntity_definition ed, Vector all_attributes_ext, Vector all_flags_ext) throws SdaiException {

    HashSet entities = new HashSet();
    boolean inherited_branch = true;
    boolean is_complex = ed.getComplex(null);

    if (is_complex) {
      collectComplexAttributesExt(ed, all_attributes_ext, all_flags_ext);
    } else {
      collectAttributesExt(ed, ed, all_attributes_ext, all_flags_ext, entities, inherited_branch);
    }
    processAttributesExt(ed, all_attributes_ext, all_flags_ext);
	
//System.out.println("entity: " + ed.getName(null) + ", ext attributes: " + all_attributes_ext);
	}

  void generateAttributes(EEntity_definition ed, PrintWriter pw, Vector all_attributes, 
                          Vector all_flags) throws SdaiException {
    /*  In the case of extending a supertype, attribute numbering must be continued.
      The supertype itself may have inherited some attributes directly, 
      and others generated for other supertypes and for the entity itself,
      they all must be taken into account. In addition to that, it is important to know,
      if an attribute is later redeclared. */
    HashSet entities = new HashSet();
    boolean inherited_branch = true;
    boolean is_complex = ed.getComplex(null);

    if (is_complex) {
      collectComplexAttributes(ed, all_attributes, all_flags);
    } else {
      collectAttributes(ed, ed, all_attributes, all_flags, entities, inherited_branch);
    }

// System.out.println("entity: " + ed.getName(null) + ", attributes: " + all_attributes);

    processAttributes(ed, all_attributes, all_flags);

    int internal = 0;
    int count_derived = 0;
    int count_inverse = 0;

    for (int sj = 0; sj < all_attributes.size(); sj++) {
      EAttribute attr0 = (EAttribute) all_attributes.elementAt(sj);
      String attr_name = attr0.getName(null);
      int attribute_flag = (int) ((Integer) all_flags.elementAt(sj)).intValue();
      String attribute_field = null;

      if (attribute_flag == AA_CURRENT_EXPLICIT) {
        attribute_field = " a" + internal++ + "; // " + attr_name + " - current entity -";

        //           pw.println("\t + attribute_object + " a" + sj + " // " + attr_name + " - current entity");
      } else if (attribute_flag == AA_JAVA_EXPLICIT) {
        attribute_field = " a" + internal++ + ";   " + attr_name + " - java inheritance -";

        //           pw.println("\t//  + attribute_object + " a" + sj + "   " + attr_name + " - java inheritance");
      } else if (attribute_flag == AA_SUPERTYPE_EXPLICIT) {
        attribute_field = " a" + internal++ + "; // " + attr_name + " - non-java inheritance -";

        //           pw.println("\t + attribute_object + " a" + sj + " // " + attr_name + " - non-java inheritance");
      } else if (attribute_flag == AA_CURRENT_EXPLICIT_TO_DERIVED) {
        //            internal++;
        attribute_field = " a" + internal++ + 
                          " - explicit redeclared as derived - current entity - ";
        count_derived++;
      } else if (attribute_flag == AA_JAVA_EXPLICIT_TO_DERIVED) {
        //            internal++;
        attribute_field = " a" + internal++ + 
  
                         " -  explicit redeclared as derived - java inheritance - ";
//RR - dulplicated derived, this one is not needed and numbering must remain unchanged
        count_derived++;
      } else if (attribute_flag == AA_SUPERTYPE_EXPLICIT_TO_DERIVED) {
        //            internal++;
// try not to increase the number for redeclared as derived non-java, which is not actually present 
// causes problems with old - new, setAll/getAll
        attribute_field = " a" + internal++ + 
//        attribute_field = " a" + internal + 
                          " - explicit redeclared as derived - non-java inheritance - ";
        count_derived++;
      } else if (attribute_flag == AA_CURRENT_EXPLICIT_REDECLARING) {
        //            System.out.println("explicit redeclaring");
        attribute_field = "  - explicit redeclaring - current - ";
      } else if (attribute_flag == AA_JAVA_EXPLICIT_REDECLARING) {
        //            System.out.println("explicit redeclaring");
        attribute_field = "  - explicit redeclaring - java inheritance - ";
      } else if (attribute_flag == AA_SUPERTYPE_EXPLICIT_REDECLARING) {
        //            System.out.println("explicit redeclaring");
        attribute_field = "  - explicit redeclaring - non-java inheritance - ";
      } else if (attribute_flag == AA_JAVA_DERIVED) {
        attribute_field = "  - derived - java inheritance - ";
        count_derived++;
      } else if (attribute_flag == AA_JAVA_DERIVED_REDECLARING) {
        attribute_field = "  - derived redeclaring - java inheritance - ";
      } else if (attribute_flag == AA_SUPERTYPE_DERIVED) {
        attribute_field = "  - derived - non-java inheritance - ";
        count_derived++;
      } else if (attribute_flag == AA_SUPERTYPE_DERIVED_REDECLARING) {
        attribute_field = "  - derived redeclaring - non-java inheritance - ";
        if (((EDerived_attribute)attr0).getRedeclaring(null) instanceof EExplicit_attribute) {
				  int count_renamed = countAttributeRenamings(attr0);
          if (count_renamed > 0) {
 	        	count_derived++; // two d$ - explicit redeclared as derived - non-java inheritance and derived redeclaring - non-java inheritance 
					}
//					internal++; // controversial experiment RR-2005-03-27 - does not help, but obviously is wrong
				}
      } else if (attribute_flag == AA_CURRENT_DERIVED) {
        attribute_field = "  - derived - current - ";
        count_derived++;
      } else if (attribute_flag == AA_CURRENT_DERIVED_REDECLARING) {
        attribute_field = "  - derived redeclaring - current - ";
// still duplicate
        if (((EDerived_attribute)attr0).getRedeclaring(null) instanceof EExplicit_attribute) {
				  int count_renamed = countAttributeRenamings(attr0);
          if (count_renamed > 0) {
		    		count_derived++;
					}
				}
      } else if (attribute_flag == AA_JAVA_INVERSE) {
        attribute_field = "  - inverse - java inheritance - ";
        count_inverse++;
      } else if (attribute_flag == AA_JAVA_INVERSE_REDECLARING) {
        attribute_field = "  - inverse redeclaring - java inheritance - ";
      } else if (attribute_flag == AA_SUPERTYPE_INVERSE) {
        attribute_field = "  - inverse - non-java inheritance - ";
        count_inverse++;
      } else if (attribute_flag == AA_SUPERTYPE_INVERSE_REDECLARING) {
        attribute_field = "  - inverse redeclaring - non-java inheritance - ";
      } else if (attribute_flag == AA_CURRENT_INVERSE) {
        attribute_field = "  - inverse - current - ";
        count_inverse++;
      } else if (attribute_flag == AA_CURRENT_INVERSE_REDECLARING) {
        attribute_field = "  - inverse redeclaring - current - ";
      } else {
        attribute_field = "// " + attr_name + " - unknown";
      }

      select_two_dollars = null;

      String attribute_object = getAttributeObjectString(attr0, attribute_field, sj, internal - 1, 
                                                         pw);

      if (attribute_flag == AA_JAVA_EXPLICIT) {
        pw.println("\t// " + attr_name + ": " + attribute_object);

        if (select_two_dollars != null) {
          pw.println("\t// " + select_two_dollars);
        }
      } else if ((attribute_flag == AA_SUPERTYPE_EXPLICIT) || 
                     (attribute_flag == AA_CURRENT_EXPLICIT)) {
        pw.println("\t" + attribute_object);
        internal--;
        pw.println("\tprotected static final jsdai.dictionary.CExplicit_attribute a" + internal + 
                   "$ = CEntity.initExplicitAttribute(definition, " + internal + ");");
        internal++;

        if (select_two_dollars != null) {
          pw.println("\t" + select_two_dollars);
        }
      } else if (attribute_flag == AA_CURRENT_EXPLICIT_TO_DERIVED) {
        pw.println("\t// " + attr_name + ": " + attribute_object);
        count_derived--;
        pw.println("\tprotected static final jsdai.dictionary.CDerived_attribute d" + 
                   count_derived + "$ = CEntity.initDerivedAttribute(definition, " + 
                   count_derived + ");");
        count_derived++;

        if (select_two_dollars != null) {
          pw.println("\t// " + select_two_dollars);
        }
      } else if (attribute_flag == AA_JAVA_EXPLICIT_TO_DERIVED) {
        pw.println("\t// " + attr_name + ": " + attribute_object);

// not needed, duplicated - but what if not always not needed?

        count_derived--;
        pw.println("\tprotected static final jsdai.dictionary.CDerived_attribute d" + 
                   count_derived + "$ = CEntity.initDerivedAttribute(definition, " + 
                   count_derived + ");");
        count_derived++;

        if (select_two_dollars != null) {
          pw.println("\t// " + select_two_dollars);
        }
      } else if (attribute_flag == AA_SUPERTYPE_EXPLICIT_TO_DERIVED) {
        pw.println("\t// " + attr_name + ": " + attribute_object);
        count_derived--;
        pw.println("\tprotected static final jsdai.dictionary.CDerived_attribute d" + 
                   count_derived + "$ = CEntity.initDerivedAttribute(definition, " + 
                   count_derived + ");");
        count_derived++;

        if (select_two_dollars != null) {
          pw.println("\t// " + select_two_dollars);
        }
      } else if (attribute_flag == AA_CURRENT_EXPLICIT_REDECLARING) {
        //            System.out.println("explicit redeclaring 2");
        pw.println("\t// " + attr_name + ": " + attribute_object);

        if (select_two_dollars != null) {
          pw.println("\t// " + select_two_dollars);
        }
      } else if (attribute_flag == AA_JAVA_EXPLICIT_REDECLARING) {
        //            System.out.println("explicit redeclaring 2");
        pw.println("\t// " + attr_name + ": " + attribute_object);

        if (select_two_dollars != null) {
          pw.println("\t// " + select_two_dollars);
        }
      } else if (attribute_flag == AA_SUPERTYPE_EXPLICIT_REDECLARING) {
        //            System.out.println("explicit redeclaring 2");
        pw.println("\t// " + attr_name + ": " + attribute_object);

        if (select_two_dollars != null) {
          pw.println("\t// " + select_two_dollars);
        }
      } else if (attribute_flag == AA_JAVA_DERIVED) {
        pw.println("\t// " + attr_name + ": " + attribute_object);
        count_derived--;
        pw.println("\tprotected static final jsdai.dictionary.CDerived_attribute d" + 
                   count_derived + "$ = CEntity.initDerivedAttribute(definition, " + 
                   count_derived + ");");
        count_derived++;

        if (select_two_dollars != null) {
          pw.println("\t// " + select_two_dollars);
        }
      } else if (attribute_flag == AA_JAVA_DERIVED_REDECLARING) {
        pw.println("\t// " + attr_name + ": " + attribute_object);

        if (select_two_dollars != null) {
          pw.println("\t// " + select_two_dollars);
        }
      } else if (attribute_flag == AA_SUPERTYPE_DERIVED) {
        pw.println("\t// " + attr_name + ": " + attribute_object);
        count_derived--;
        pw.println("\tprotected static final jsdai.dictionary.CDerived_attribute d" + 
                   count_derived + "$ = CEntity.initDerivedAttribute(definition, " + 
                   count_derived + ");");
        count_derived++;

        if (select_two_dollars != null) {
          pw.println("\t// " + select_two_dollars);
        }
      } else if (attribute_flag == AA_SUPERTYPE_DERIVED_REDECLARING) {
        pw.println("\t// " + attr_name + ": " + attribute_object);
        if (((EDerived_attribute)attr0).getRedeclaring(null) instanceof EExplicit_attribute) {
        	// in this case we need to generated dx$ field and initialization? - if explicit -> derived do we have also dx$?


				  int count_renamed = countAttributeRenamings(attr0);
          if (count_renamed > 0) {

        	count_derived--;
      	  pw.println("\tprotected static final jsdai.dictionary.CDerived_attribute d" + 
    	               count_derived + "$ = CEntity.initDerivedAttribute(definition, " + 
  	                 count_derived + ");");
	        count_derived++;
				}

				}

        if (select_two_dollars != null) {
          pw.println("\t// " + select_two_dollars);
        }
      } else if (attribute_flag == AA_CURRENT_DERIVED) {
        pw.println("\t// " + attr_name + ": " + attribute_object);
        count_derived--;
        pw.println("\tprotected static final jsdai.dictionary.CDerived_attribute d" + 
                   count_derived + "$ = CEntity.initDerivedAttribute(definition, " + 
                   count_derived + ");");
        count_derived++;

        if (select_two_dollars != null) {
          pw.println("\t// " + select_two_dollars);
        }
      } else if (attribute_flag == AA_CURRENT_DERIVED_REDECLARING) {
        pw.println("\t// " + attr_name + ": " + attribute_object);
        if (((EDerived_attribute)attr0).getRedeclaring(null) instanceof EExplicit_attribute) {
        	// in this case we need to generated dx$ field and initialization? - if explicit -> derived do we have also dx$?
				  int count_renamed = countAttributeRenamings(attr0);
          if (count_renamed > 0) {

		        count_derived--;
  		      pw.println("\tprotected static final jsdai.dictionary.CDerived_attribute d" + 
    		               count_derived + "$ = CEntity.initDerivedAttribute(definition, " + 
      		             count_derived + ");");
        		count_derived++;
        	}
        }

        if (select_two_dollars != null) {
          pw.println("\t// " + select_two_dollars);
        }
      } else if (attribute_flag == AA_JAVA_INVERSE) {
        pw.println("\t// " + attr_name + ": " + attribute_object);

        if (select_two_dollars != null) {
          pw.println("\t// " + select_two_dollars);
        }
      } else if (attribute_flag == AA_JAVA_INVERSE_REDECLARING) {
        pw.println("\t// " + attr_name + ": " + attribute_object);

        if (select_two_dollars != null) {
          pw.println("\t// " + select_two_dollars);
        }
      } else if (attribute_flag == AA_SUPERTYPE_INVERSE) {
        pw.println("\t// " + attr_name + ": " + attribute_object);
        count_inverse--;
        pw.println("\tprotected static final jsdai.dictionary.CInverse_attribute i" + 
                   count_inverse + "$ = CEntity.initInverseAttribute(definition, " + 
                   count_inverse + ");");
        count_inverse++;

        if (select_two_dollars != null) {
          pw.println("\t// " + select_two_dollars);
        }
      } else if (attribute_flag == AA_SUPERTYPE_INVERSE_REDECLARING) {
        pw.println("\t// " + attr_name + ": " + attribute_object);
        count_inverse--;
        pw.println("\tprotected static final jsdai.dictionary.CInverse_attribute i" + 
                   count_inverse + "$ = CEntity.initInverseAttribute(definition, " + 
                   count_inverse + ");");
        count_inverse++;

        if (select_two_dollars != null) {
          pw.println("\t// " + select_two_dollars);
        }
      } else if (attribute_flag == AA_CURRENT_INVERSE) {
        pw.println("\t// " + attr_name + ": " + attribute_object);
        count_inverse--;
        pw.println("\tprotected static final jsdai.dictionary.CInverse_attribute i" + 
                   count_inverse + "$ = CEntity.initInverseAttribute(definition, " + 
                   count_inverse + ");");
        count_inverse++;

        if (select_two_dollars != null) {
          pw.println("\t// " + select_two_dollars);
        }
      } else if (attribute_flag == AA_CURRENT_INVERSE_REDECLARING) {
        pw.println("\t// " + attr_name + ": " + attribute_object);

        if (select_two_dollars != null) {
          pw.println("\t// " + select_two_dollars);
        }
      } else {
        pw.println("\t// " + attribute_object);

        if (select_two_dollars != null) {
          pw.println("\t// " + attr_name + ": " + select_two_dollars);
        }
      }
    }
  }


/*
ROCOFOCO-01 attribute flag: 1, index: 0, attribute: #1079=EXPLICIT_ATTRIBUTE('attr1',#1077,#1077,0,#1075,$,.F.);
ROCOFOCO-02 attribute flag: 5, index: 1
ROCOFOCO-01 attribute flag: 5, index: 1, attribute: #1082=EXPLICIT_ATTRIBUTE('attr2',#1080,#1080,0,#2,$,.F.);
ROCOFOCO-02 attribute flag: 1, index: 0
ROCOFOCO attribute flag: 1, index: 0
ROCOFOCO attribute flag: 5, index: 1
*/

  void processAttributes(EEntity_definition ed, Vector all_attributes, Vector all_flags)
                  throws SdaiException {
    // check each attribute if it is redeclared later.
    // Especially important cases when explicit is redeclared as derived. 
    // Although the internal number remains reserved, the field is not present.
    // However, in the case of java inheritance, we can do nothing. 
    // Let's have the field as well, but need to know if the attribute is later redeclared as derived


    for (int sj = 0; sj < all_attributes.size(); sj++) {
      EAttribute a1 = (EAttribute) all_attributes.elementAt(sj);
      int attribute_flag = (int) ((Integer) all_flags.elementAt(sj)).intValue();
// System.out.println("ROCOFOCO-01 attribute flag: " + attribute_flag + ", index: " + sj + ", attribute: " + a1);

      if ((attribute_flag == AA_JAVA_EXPLICIT) || (attribute_flag == AA_SUPERTYPE_EXPLICIT) || 
              (attribute_flag == AA_CURRENT_EXPLICIT)) {
        for (int sjj = 0; sjj < all_attributes.size(); sjj++) {
          if (sj == sjj) {
            continue;
          }

          int attribute_flag2 = (int) ((Integer) all_flags.elementAt(sjj)).intValue();
// System.out.println("ROCOFOCO-02 attribute flag: " + attribute_flag2 + ", index: " + sjj);

          if ((attribute_flag2 == AA_JAVA_DERIVED_REDECLARING) || 
                  (attribute_flag2 == AA_CURRENT_DERIVED_REDECLARING) || 
                  (attribute_flag2 == AA_SUPERTYPE_DERIVED_REDECLARING)) {
            EAttribute a2 = (EAttribute) all_attributes.elementAt(sjj);
            EEntity a3 = ((EDerived_attribute) a2).getRedeclaring(null);
// System.out.println("ROCOFOCO-03 derived attribute: " + a2 + ", redeclaring: " + a3);

            if (a1 == a3) {
              printDebug("CHANGING FLAG: " + a1.getName(null));

              // changing flag for a1 - explicit later redeclared as derived
              if (attribute_flag == AA_JAVA_EXPLICIT) {
                attribute_flag = AA_JAVA_EXPLICIT_TO_DERIVED;
              } else if (attribute_flag == AA_SUPERTYPE_EXPLICIT) {
                attribute_flag = AA_SUPERTYPE_EXPLICIT_TO_DERIVED;
              } else if (attribute_flag == AA_CURRENT_EXPLICIT) {
                attribute_flag = AA_CURRENT_EXPLICIT_TO_DERIVED;
              }

              all_flags.set(sj, new Integer(attribute_flag));
            }
          }
        } // for sjj
      } // if explicit
    } // for sj
  } // method


  void processAttributesExt(EEntity_definition ed, Vector all_attributes, Vector all_flags)
                  throws SdaiException {
    // check each attribute if it is redeclared later.
    // Especially important cases when explicit is redeclared as derived. 
    // Although the internal number remains reserved, the field is not present.
    // However, in the case of java inheritance, we can do nothing. 
    // Let's have the field as well, but need to know if the attribute is later redeclared as derived

// System.out.println("ROCOFOCO-00 ########################## ENTITY: " + ed);

    for (int sj = 0; sj < all_attributes.size(); sj++) {
      EAttribute a1 = (EAttribute) all_attributes.elementAt(sj);
      int attribute_flag = (int) ((Integer) all_flags.elementAt(sj)).intValue();
// System.out.println("ROCOFOCO-01 attribute flag: " + attribute_flag + ", index: " + sj + ", attribute: " + a1);

      if ((attribute_flag == AA_JAVA_EXPLICIT) || (attribute_flag == AA_SUPERTYPE_EXPLICIT) || 
              (attribute_flag == AA_CURRENT_EXPLICIT) ||
							(attribute_flag == AA_SUPERTYPE_EXPLICIT_REDECLARING) ||              
							(attribute_flag == AA_CURRENT_EXPLICIT_REDECLARING)             
      ) {
        for (int sjj = 0; sjj < all_attributes.size(); sjj++) {
          if (sj == sjj) {
            continue;
          }

          int attribute_flag2 = (int) ((Integer) all_flags.elementAt(sjj)).intValue();
// System.out.println("ROCOFOCO-02 attribute flag: " + attribute_flag2 + ", index: " + sjj);

          if ((attribute_flag2 == AA_JAVA_DERIVED_REDECLARING) || 
                  (attribute_flag2 == AA_CURRENT_DERIVED_REDECLARING) || 
                  (attribute_flag2 == AA_SUPERTYPE_DERIVED_REDECLARING)) {
            EAttribute a2 = (EAttribute) all_attributes.elementAt(sjj);
            EEntity a3 = ((EDerived_attribute) a2).getRedeclaring(null);

// System.out.println("ROCOFOCO-03 derived attribute: " + a2 + ", redeclaring: " + a3);

            if (a1 == a3) {
              printDebug("CHANGING FLAG: " + a1.getName(null));
// System.out.println("ROCOFOCO-04 changing FLAG: " + a1 + ", flag: " + attribute_flag);

              // changing flag for a1 - explicit later redeclared as derived
              if (attribute_flag == AA_JAVA_EXPLICIT) {
                attribute_flag = AA_JAVA_EXPLICIT_TO_DERIVED;
// System.out.println("ROCOFOCO-05 changing FLAG: AA_JAVA_EXPLICIT > AA_JAVA_EXPLICIT_TO_DERIVED");
              } else if (attribute_flag == AA_SUPERTYPE_EXPLICIT) {
								if (a1.getName(null).equalsIgnoreCase(a2.getName(null))) {
	                attribute_flag = AA_SUPERTYPE_EXPLICIT_TO_DERIVED;
// System.out.println("ROCOFOCO-05 changing FLAG: AA_SUPERTYPE_EXPLICIT > AA_SUPERTYPE_EXPLICIT_TO_DERIVED");
								} else {
	                attribute_flag = AA_SUPERTYPE_EXPLICIT_TO_DERIVED_RENAMED;
// System.out.println("ROCOFOCO-05 changing FLAG: AA_SUPERTYPE_EXPLICIT > AA_SUPERTYPE_EXPLICIT_TO_DERIVED_RENAMED");
								}
					
								// experiment - probably will not work, besides we probably need derived methods not explicit, so need to implement supertype_explicit_to_derived case
                // however, some new cases below use supertype_explicit_to_derived to suppress generation of any methods
                // so supertype_explicit_to_derived should generate methods if the renaming occurs in redclaring to derive ???
//                if (attribute_flag2 == AA_CURRENT_DERIVED_REDECLARING)  {
//								} else {
//	                attribute_flag = AA_SUPERTYPE_EXPLICIT_TO_DERIVED;
//								}				

/*
                if (attribute_flag2 == AA_CURRENT_DERIVED_REDECLARING) 
	                attribute_flag = AA_SUPERTYPE_EXPLICIT_TO_DERIVED;
  							} else 
                if (attribute_flag2 == AA_SUPERTYPE_DERIVED_REDECLARING) {
	                attribute_flag = AA_SUPERTYPE_EXPLICIT_TO_DERIVED;
  							} else 
                if (attribute_flag2 == AA_JAVA_DERIVED_REDECLARING) {
	                attribute_flag = AA_SUPERTYPE_EXPLICIT_TO_DERIVED;
  							} 
*/
              } else if (attribute_flag == AA_CURRENT_EXPLICIT) {
                attribute_flag = AA_CURRENT_EXPLICIT_TO_DERIVED;
// System.out.println("ROCOFOCO-05 changing FLAG: AA_CURRENT_EXPLICIT > AA_CURRENT_EXPLICIT_TO_DERIVED");
              } else if (attribute_flag == AA_SUPERTYPE_EXPLICIT_REDECLARING) {
								// added for renamed
								// not for all
                if (attribute_flag2 == AA_CURRENT_DERIVED_REDECLARING) {
										// here we may need to change to something else
									if (a1.getName(null).equalsIgnoreCase(a2.getName(null))) {
		                attribute_flag = AA_SUPERTYPE_EXPLICIT_TO_DERIVED;
// System.out.println("ROCOFOCO-05 changing FLAG: AA_SUPERTYPE_EXPLICIT_REDECLARING > AA_SUPERTYPE_EXPLICIT_TO_DERIVED (2 = AA_CURRENT_DERIVED_REDECLARING)");
									} else {
		                attribute_flag = AA_SUPERTYPE_EXPLICIT_TO_DERIVED_RENAMED;
// System.out.println("ROCOFOCO-05 changing FLAG: AA_SUPERTYPE_EXPLICIT_REDECLARING > AA_SUPERTYPE_EXPLICIT_TO_DERIVED_RENAMED (2 = AA_CURRENT_DERIVED_REDECLARING)");
									}

//	                attribute_flag = AA_SUPERTYPE_EXPLICIT_TO_DERIVED;
// System.out.println("ROCOFOCO-05 changing FLAG: AA_SUPERTYPE_EXPLICIT_REDECLARING > AA_SUPERTYPE_EXPLICIT_TO_DERIVED (2 = AA_CURRENT_DERIVED_REDECLARING)");
              	} else 
              	if (attribute_flag2 == AA_SUPERTYPE_DERIVED_REDECLARING) {
									if (a1.getName(null).equalsIgnoreCase(a2.getName(null))) {
		                attribute_flag = AA_SUPERTYPE_EXPLICIT_TO_DERIVED;
// System.out.println("ROCOFOCO-05 EXPERIMENT changing FLAG: AA_SUPERTYPE_EXPLICIT_REDECLARING > AA_SUPERTYPE_EXPLICIT_TO_DERIVED (2 = AA_SUPERTYPE_DERIVED_REDECLARING)");
									} else {
		                attribute_flag = AA_SUPERTYPE_EXPLICIT_TO_DERIVED_RENAMED;
// System.out.println("ROCOFOCO-05 EXPERIMENT changing FLAG: AA_SUPERTYPE_EXPLICIT_REDECLARING > AA_SUPERTYPE_EXPLICIT_TO_DERIVED_RENAMED (2 = AA_SUPERTYPE_DERIVED_REDECLARING)");
									}

//	                attribute_flag = AA_SUPERTYPE_EXPLICIT_TO_DERIVED;
// System.out.println("ROCOFOCO-05 EXPERIMENT changing FLAG: AA_SUPERTYPE_EXPLICIT_REDECLARING > AA_SUPERTYPE_EXPLICIT_TO_DERIVED (2 = AA_SUPERTYPE_DERIVED_REDECLARING)");
                } else {
// System.out.println("ROCOFOCO-05 NOT changing FLAG: AA_SUPERTYPE_EXPLICIT_REDECLARING > AA_SUPERTYPE_EXPLICIT_TO_DERIVED (2 NOT = AA_CURRENT_DERIVED_REDECLARING), 2 = " + attribute_flag2);
                }
                // experiment
              } else if (attribute_flag == AA_CURRENT_EXPLICIT_REDECLARING) {
								// added for renamed
//                if (attribute_flag2 == AA_CURRENT_DERIVED_REDECLARING) {
	                attribute_flag = AA_CURRENT_EXPLICIT_TO_DERIVED;
// System.out.println("ROCOFOCO-05 changing FLAG: AA_CURRENT_EXPLICIT_REDECLARING > AA_CURRENT_EXPLICIT_TO_DERIVED, never mind if 2 = AA_CURRENT_EXPLICIT_TO_DERIVED or not, actully, flag2: " + attribute_flag2);
//								} else {
//								}
              }
		           
		

              all_flags.set(sj, new Integer(attribute_flag));
            }
          }
        } // for sjj
      } // if explicit
    } // for sj
  } // method


  /*
  void generateAttributes_old(EEntity_definition ed, PrintWriter pw, Vector all_attributes, Vector all_flags) throws SdaiException {
     // in the case of extending a supertype, attribute numbering must be continued. 
     // the supertype itself may have inherited some attributes directly, and others generated for other supertypes and for the entity itself,
     // they all must be taken into account.
     // in addition to that, it is important to know, if an attribute is later redeclared.
     HashSet entities = new HashSet();
     boolean inherited_branch = true;
     collectAttributes(ed, ed, all_attributes, all_flags, entities, inherited_branch);
     for (int sj = 0; sj < all_attributes.size(); sj++) {
      EExplicit_attribute xa = (EExplicit_attribute)all_attributes.elementAt(sj);
        String attr_name = xa.getName(null);
        int attribute_flag = (int)((Integer) all_flags.elementAt(sj)).intValue();
        String attribute_field;
        if (attribute_flag == AA_CURRENT_EXPLICIT) {
           attribute_field = " a" + sj + "; // " + attr_name + " - current entity -";
  //           pw.println("\t + attribute_object + " a" + sj + " // " + attr_name + " - current entity");
           }   else
           if (attribute_flag == AA_JAVA_EXPLICIT) {
              attribute_field = " a" + sj + ";   " + attr_name + " - java inheritance -";
  //           pw.println("\t//  + attribute_object + " a" + sj + "   " + attr_name + " - java inheritance");
           }   else
           if (attribute_flag == AA_SUPERTYPE_EXPLICIT) {
              attribute_field = " a" + sj + "; // " + attr_name + " - non-java inheritance -";
  //           pw.println("\t + attribute_object + " a" + sj + " // " + attr_name + " - non-java inheritance");
           }
           else {
              attribute_field = " a" + sj + "; // " + attr_name + " - internal error -";
  //           pw.println("\t + attribute_object + " a" + sj + " // " + attr_name + " - internal error");
           }
           String attribute_object = getAttributeObjectString(xa, attribute_field, sj, pw);
           if (attribute_flag == AA_JAVA_EXPLICIT) {
                pw.println("\t// " + attribute_object);
           } else {
                pw.println("\t" + attribute_object);
                 pw.println("\tprotected static final jsdai.dictionary.CExplicit_attribute a" + sj + "$ = CEntity.initExplicitAttribute(definition, " + sj + ");");
           }
        }      
     }
   */
  String getAttributeObjectString(EAttribute attr, String attribute_field, int attr_index, 
                                  int internal, PrintWriter pw)
                           throws SdaiException {
    String return_object = "";
    String attr_name = attr.getName(null);
    String method_suffix = attr_name.substring(0, 1).toUpperCase() + 
                           attr_name.substring(1).toLowerCase();

    if (attr instanceof EExplicit_attribute) {
      EEntity bt = ((EExplicit_attribute) attr).getDomain(null);

//System.out.println("attribute base type: " + bt);

      if (bt instanceof ESimple_type) {
        ESimple_type st = (ESimple_type) bt;
        return_object = getSimpleTypeAttributeString(st, attribute_field);
      } else if (bt instanceof EAggregation_type) {
        EAggregation_type at = (EAggregation_type) bt;
        return_object = getAggregateAttributeString(at, attribute_field);
      } else if (bt instanceof EDefined_type) {
        EDefined_type dt = (EDefined_type) bt;
        return_object = getDefinedTypeAttributeString(dt, attribute_field, attr_index, internal, pw);
      } else if (bt instanceof EEntity_definition) {
        EEntity_definition ed1 = (EEntity_definition) bt;
        String entity_name = ed1.getName(null);
        return_object = "protected Object" + attribute_field + " ENTITY " + entity_name;
      } else 
      if (bt instanceof EParameter) {	 // generalized attribute type - ammendment
        return_object = "protected Object" + attribute_field + " GENERALIZED";
//System.out.println("attribute base type is PARAMETER, returning: " + return_object);
      } else {
					System.out.println("<ExpressCompiler> UNSUPPORTED ATTRIBUTE BASE TYPE: " + bt);
      }
    } else if (attr instanceof EDerived_attribute) {
    	// can derived be generalized - if later redeclared - here, only fox explicit support for generalized was added ??? - to check
      EEntity bt = null;
	    if (((EDerived_attribute)attr).testDomain(null)) {
	      bt = ((EDerived_attribute) attr).getDomain(null);
			} else {
				pw.println("WARNING! Attribute object string not generated - attribute domain is NULL: " + attr);
				System.out.println("WARNING! Attribute object string not generated - attribute domain is NULL: " + attr);
				return "_NOT_GENERATED_ATTRIBUTE_DOMAIN_IS_NULL_";
			}


      if (bt instanceof ESimple_type) {
        ESimple_type st = (ESimple_type) bt;
        return_object = getSimpleTypeAttributeString(st, attribute_field);
      } else if (bt instanceof EAggregation_type) {
        EAggregation_type at = (EAggregation_type) bt;
        return_object = getAggregateAttributeString(at, attribute_field);
      } else if (bt instanceof EDefined_type) {
        EDefined_type dt = (EDefined_type) bt;
        return_object = getDefinedTypeAttributeString(dt, attribute_field, attr_index, internal, pw);
      } else if (bt instanceof EEntity_definition) {
        EEntity_definition ed1 = (EEntity_definition) bt;
        String entity_name = ed1.getName(null);
        return_object = "protected Object" + attribute_field + " ENTITY " + entity_name;
      }
    } else if (attr instanceof EInverse_attribute) {
      EEntity_definition bet = null;
      
	    if (((EInverse_attribute)attr).testDomain(null)) {
	      bet = ((EInverse_attribute) attr).getDomain(null);
			} else {
				pw.println("WARNING! Attribute object string not generated - inverse attribute domain is NULL: " + attr);
				System.out.println("WARNING! Attribute object string not generated - inverse attribute domain is NULL: " + attr);
				return "_ATTRIBUTE_OBJECT_STRING_NOT_GENERATED__INVERSE_ATTRIBUTE_DOMAIN_IS_NULL_";
			}
      
      
      String entity_name = bet.getName(null);
      return_object = "protected Object" + attribute_field + " ENTITY " + entity_name;
    }

//System.out.println("finally returning: " + return_object);

    return return_object;
  }



  String getDefinedTypeAttributeStringX(EDefined_type dt) throws SdaiException {


  // no longer used parameters - String attribute_field, int attr_index,  int internal, PrintWriter pw)

    String return_object = "";
    EEntity ut = dt.getDomain(null);

    if (ut instanceof ESimple_type) {
      return_object = getSimpleTypeAttributeStringX((ESimple_type) ut);
    } else if (ut instanceof EAggregation_type) {
      return_object = getAggregateAttributeStringX((EAggregation_type) ut);
    } else if (ut instanceof EDefined_type) {
      return_object = getDefinedTypeAttributeStringX((EDefined_type) ut);
    } else if (ut instanceof EEnumeration_type) {
      return_object = "protected int";
    } else if (ut instanceof ESelect_type) {
      return_object = "protected Object";

			// all this parts with select may not be needed

      ANamed_type ant1 = getSelections((ESelect_type) ut);
      SelectPaths paths1 = null;
      int select_type = Integer.MIN_VALUE;
      Object temp_object = ut.getTemp();

      if (temp_object instanceof SelectPaths) {
        if (((SelectPaths) temp_object).owner == ut) {
          paths1 = (SelectPaths) temp_object;
          select_type = paths1.select_type;
        }
      }

      if (paths1 == null) {
        int count = 1;
        int[] indeces = new int[500];
        int depth = 0;
        int depth_count = 0;
        boolean with_type = false;
        Vector current_nodes = new Vector();
        Vector current_node_strings = new Vector();
        paths1 = new SelectPaths();
        paths1.owner = (ESelect_type) ut;
        select_type = calculateSelectPaths(count, current_nodes, current_node_strings, indeces, 
                                           depth, depth_count, paths1, (ESelect_type) ut, with_type);
        paths1.removeIdentical();
        paths1.select_type = select_type;
        ut.setTemp(paths1);
      }

      if (select_type > 0) { // includes defined_types

        //               pw.println("\tprotected int a" + internal + "$$; // current SELECT path indicator");
//        select_two_dollars = "protected int a" + internal + 
//                            "$$; // current SELECT path indicator";
      }
    }

    return return_object;
  }






  String getDefinedTypeAttributeStringX(EDefined_type dt, String attribute_field, int attr_index, 
                                       int internal, PrintWriter pw)
                                throws SdaiException {
    String return_object = "";
    EEntity ut = dt.getDomain(null);

    if (ut instanceof ESimple_type) {
      return_object = getSimpleTypeAttributeString((ESimple_type) ut, attribute_field);
    } else if (ut instanceof EAggregation_type) {
      return_object = getAggregateAttributeString((EAggregation_type) ut, attribute_field);
    } else if (ut instanceof EDefined_type) {
      return_object = getDefinedTypeAttributeString((EDefined_type) ut, attribute_field, attr_index, 
                                                    internal, pw);
    } else if (ut instanceof EEnumeration_type) {
      return_object = "protected int" + attribute_field + " ENUMERATION " + dt.getName(null);
    } else if (ut instanceof ESelect_type) {
      return_object = "protected Object" + attribute_field + " SELECT " + dt.getName(null);

//      ANamed_type ant1 = ((ESelect_type) ut).getSelections(null);
//      ANamed_type ant1 = ((ESelect_type) ut).getLocal_selections(null);
      ANamed_type ant1 = getSelections((ESelect_type) ut);
      SelectPaths paths1 = null;
      int select_type = Integer.MIN_VALUE;
      Object temp_object = ut.getTemp();

      if (temp_object instanceof SelectPaths) {
        if (((SelectPaths) temp_object).owner == ut) {
          paths1 = (SelectPaths) temp_object;
          select_type = paths1.select_type;
        }
      }

      if (paths1 == null) {
        int count = 1;
        int[] indeces = new int[500];
        int depth = 0;
        int depth_count = 0;
        boolean with_type = false;
        Vector current_nodes = new Vector();
        Vector current_node_strings = new Vector();
        paths1 = new SelectPaths();
        paths1.owner = (ESelect_type) ut;
        select_type = calculateSelectPaths(count, current_nodes, current_node_strings, indeces, 
                                           depth, depth_count, paths1, (ESelect_type) ut, with_type);
        paths1.removeIdentical();
        paths1.select_type = select_type;
        ut.setTemp(paths1);
      }

      if (select_type > 0) { // includes defined_types

        //               pw.println("\tprotected int a" + internal + "$$; // current SELECT path indicator");
        select_two_dollars = "protected int a" + internal + 
                             "$$; // current SELECT path indicator";
      }
    }

    return return_object;
  }



  String getDefinedTypeAttributeString(EDefined_type dt, String attribute_field, int attr_index, 
                                       int internal, PrintWriter pw)
                                throws SdaiException {
    String return_object = "";
    EEntity ut = dt.getDomain(null);

    if (ut instanceof ESimple_type) {
      return_object = getSimpleTypeAttributeString((ESimple_type) ut, attribute_field);
    } else if (ut instanceof EAggregation_type) {
      return_object = getAggregateAttributeString((EAggregation_type) ut, attribute_field);
    } else if (ut instanceof EDefined_type) {
      return_object = getDefinedTypeAttributeString((EDefined_type) ut, attribute_field, attr_index, 
                                                    internal, pw);
    } else if (ut instanceof EEnumeration_type) {
      return_object = "protected int" + attribute_field + " ENUMERATION " + dt.getName(null);
    } else if (ut instanceof ESelect_type) {
      return_object = "protected Object" + attribute_field + " SELECT " + dt.getName(null);

//      ANamed_type ant1 = ((ESelect_type) ut).getSelections(null);
//      ANamed_type ant1 = ((ESelect_type) ut).getLocal_selections(null);
      ANamed_type ant1 = getSelections((ESelect_type) ut);
      SelectPaths paths1 = null;
      int select_type = Integer.MIN_VALUE;
      Object temp_object = ut.getTemp();

      if (temp_object instanceof SelectPaths) {
        if (((SelectPaths) temp_object).owner == ut) {
          paths1 = (SelectPaths) temp_object;
          select_type = paths1.select_type;
        }
      }

      if (paths1 == null) {
        int count = 1;
        int[] indeces = new int[500];
        int depth = 0;
        int depth_count = 0;
        boolean with_type = false;
        Vector current_nodes = new Vector();
        Vector current_node_strings = new Vector();
        paths1 = new SelectPaths();
        paths1.owner = (ESelect_type) ut;
        select_type = calculateSelectPaths(count, current_nodes, current_node_strings, indeces, 
                                           depth, depth_count, paths1, (ESelect_type) ut, with_type);
        paths1.removeIdentical();
        paths1.select_type = select_type;
        ut.setTemp(paths1);
      }

      if (select_type > 0) { // includes defined_types

        //               pw.println("\tprotected int a" + internal + "$$; // current SELECT path indicator");
        select_two_dollars = "protected int a" + internal + 
                             "$$; // current SELECT path indicator";
      }
    }

    return return_object;
  }

  String getSimpleTypeAttributeStringX(ESimple_type st, String attribute_field)throws SdaiException {
    String return_object = "";

    if (st instanceof EInteger_type) {
      return_object = "protected int" + attribute_field + " INTEGER";
    } else if (st instanceof ENumber_type) {
      return_object = "protected double" + attribute_field + " NUMBER";
    } else if (st instanceof EReal_type) {
      return_object = "protected double" + attribute_field + " REAL";
    } else if (st instanceof EBoolean_type) {
      return_object = "protected int" + attribute_field + " BOOLEAN";
    } else if (st instanceof ELogical_type) {
      return_object = "protected int" + attribute_field + " LOGICAL";
    } else if (st instanceof EBinary_type) {
      return_object = "protected Binary" + attribute_field + " BINARY";
    } else if (st instanceof EString_type) {
      return_object = "protected String" + attribute_field + " STRING";
    }

    return return_object;
  }

  String getSimpleTypeAttributeStringX(ESimple_type st)throws SdaiException {
    String return_object = "";

    if (st instanceof EInteger_type) {
      return_object = "protected int";
    } else if (st instanceof ENumber_type) {
      return_object = "protected double";
    } else if (st instanceof EReal_type) {
      return_object = "protected double";
    } else if (st instanceof EBoolean_type) {
      return_object = "protected int";
    } else if (st instanceof ELogical_type) {
      return_object = "protected int";
    } else if (st instanceof EBinary_type) {
      return_object = "protected Binary";
    } else if (st instanceof EString_type) {
      return_object = "protected String";
    }

    return return_object;
  }



  String getSimpleTypeAttributeString(ESimple_type st, String attribute_field)
                               throws SdaiException {
    String return_object = "";

    if (st instanceof EInteger_type) {
      return_object = "protected int" + attribute_field + " INTEGER";
    } else if (st instanceof ENumber_type) {
      return_object = "protected double" + attribute_field + " NUMBER";
    } else if (st instanceof EReal_type) {
      return_object = "protected double" + attribute_field + " REAL";
    } else if (st instanceof EBoolean_type) {
      return_object = "protected int" + attribute_field + " BOOLEAN";
    } else if (st instanceof ELogical_type) {
      return_object = "protected int" + attribute_field + " LOGICAL";
    } else if (st instanceof EBinary_type) {
      return_object = "protected Binary" + attribute_field + " BINARY";
    } else if (st instanceof EString_type) {
      return_object = "protected String" + attribute_field + " STRING";
    }

    return return_object;
  }



  String getAggregateAttributeStringX(EAggregation_type at) throws SdaiException {
    String return_object = "";
    String comment = "";

    if (at instanceof EArray_type) {
      comment += " ARRAY OF ";
    } else if (at instanceof EBag_type) {
      comment += " BAG OF ";
    } else if (at instanceof ESet_type) {
      comment += " SET OF ";
    } else if (at instanceof EList_type) {
      comment += " LIST OF ";
    }

    int aggregate_depth = 1;
    EEntity an_ss;
    EEntity ass = at;
    String aggr_prefices = "";
    an_ss = at.getElement_type(null);

    for (;;) {
      boolean done_something = false;

      if (an_ss instanceof EDefined_type) {
        ass = an_ss;
        an_ss = ((EDefined_type) an_ss).getDomain(null);
        done_something = true;
      } else if (an_ss instanceof EAggregation_type) {
        aggr_prefices += "a";
        aggregate_depth++;
        ass = an_ss;

        if (ass instanceof EArray_type) {
          comment += "ARRAY OF ";
        } else if (ass instanceof EBag_type) {
          comment += "BAG OF ";
        } else if (ass instanceof ESet_type) {
          comment += "SET OF ";
        } else if (ass instanceof EList_type) {
          comment += "LIST OF ";
        }

        an_ss = ((EAggregation_type) an_ss).getElement_type(null);
        done_something = true;
      }

      if (!done_something) {
        break;
      }
    }

    String aggr_prefix = "A" + aggr_prefices;

    if (an_ss instanceof ESelect_type) {
      return_object = "protected " + getAggregatePackage(aggr_prefix, ass);
    } else if (an_ss instanceof EEntity_definition) {
      return_object = "protected " + getAggregatePackage(aggr_prefix, an_ss);
    } else if (an_ss instanceof EEnumeration_type) {
      return_object = "protected " + aggr_prefix + "_enumeration";
    } else if (an_ss instanceof EInteger_type) {
      return_object = "protected " + aggr_prefix + "_integer";
    } else if (an_ss instanceof ENumber_type) {
      return_object = "protected " + aggr_prefix + "_double";
    } else if (an_ss instanceof EReal_type) {
      return_object = "protected " + aggr_prefix + "_double";
    } else if (an_ss instanceof EString_type) {
      return_object = "protected " + aggr_prefix + "_string";
    } else if (an_ss instanceof ELogical_type) {
      return_object = "protected " + aggr_prefix + "_enumeration";
    } else if (an_ss instanceof EBoolean_type) {
      return_object = "protected " + aggr_prefix + "_boolean";
    } else if (an_ss instanceof EBinary_type) {
      return_object = "protected " + aggr_prefix + "_binary";
    } else if (an_ss instanceof EData_type) {
      if (((EData_type)an_ss).getName(null).equalsIgnoreCase("_GENERIC")) { 
      	return_object = "protected CAggregate";
    	} else
      if (((EData_type)an_ss).getName(null).equalsIgnoreCase("_ENTITY")) { 
//      	return_object = "protected AEntity" + attribute_field + comment + "GENERIC_ENTITY";
      	return_object = "protected AEntity";
			}
    }

    return return_object;
  }


  String getAggregateAttributeStringX(EAggregation_type at, String attribute_field)
                              throws SdaiException {
    String return_object = "";
    String comment = "";

    if (at instanceof EArray_type) {
      comment += " ARRAY OF ";
    } else if (at instanceof EBag_type) {
      comment += " BAG OF ";
    } else if (at instanceof ESet_type) {
      comment += " SET OF ";
    } else if (at instanceof EList_type) {
      comment += " LIST OF ";
    }

    int aggregate_depth = 1;
    EEntity an_ss;
    EEntity ass = at;
    String aggr_prefices = "";
    an_ss = at.getElement_type(null);

    for (;;) {
      boolean done_something = false;

      if (an_ss instanceof EDefined_type) {
        ass = an_ss;
        an_ss = ((EDefined_type) an_ss).getDomain(null);
        done_something = true;
      } else if (an_ss instanceof EAggregation_type) {
        aggr_prefices += "a";
        aggregate_depth++;
        ass = an_ss;

        if (ass instanceof EArray_type) {
          comment += "ARRAY OF ";
        } else if (ass instanceof EBag_type) {
          comment += "BAG OF ";
        } else if (ass instanceof ESet_type) {
          comment += "SET OF ";
        } else if (ass instanceof EList_type) {
          comment += "LIST OF ";
        }

        an_ss = ((EAggregation_type) an_ss).getElement_type(null);
        done_something = true;
      }

      if (!done_something) {
        break;
      }
    }

    String aggr_prefix = "A" + aggr_prefices;

    if (an_ss instanceof ESelect_type) {
      return_object = "protected " + getAggregatePackage(aggr_prefix, ass) + attribute_field + 
                      comment + "SELECT";
    } else if (an_ss instanceof EEntity_definition) {
      return_object = "protected " + getAggregatePackage(aggr_prefix, an_ss) + attribute_field + 
                      comment + "ENTITY";
    } else if (an_ss instanceof EEnumeration_type) {
      return_object = "protected " + aggr_prefix + "_enumeration" + attribute_field + comment + 
                      "ENUMERATION";
    } else if (an_ss instanceof EInteger_type) {
      return_object = "protected " + aggr_prefix + "_integer" + attribute_field + comment + 
                      "INTEGER";
    } else if (an_ss instanceof ENumber_type) {
      return_object = "protected " + aggr_prefix + "_double" + attribute_field + comment + 
                      "NUMBER";
    } else if (an_ss instanceof EReal_type) {
      return_object = "protected " + aggr_prefix + "_double" + attribute_field + comment + 
                      "REAL";
    } else if (an_ss instanceof EString_type) {
      return_object = "protected " + aggr_prefix + "_string" + attribute_field + comment + 
                      "STRING";
    } else if (an_ss instanceof ELogical_type) {
      return_object = "protected " + aggr_prefix + "_enumeration" + attribute_field + comment + 
                      "LOGICAL";
    } else if (an_ss instanceof EBoolean_type) {
      return_object = "protected " + aggr_prefix + "_boolean" + attribute_field + comment + 
                      "BOOLEAN";
    } else if (an_ss instanceof EBinary_type) {
      return_object = "protected " + aggr_prefix + "_binary" + attribute_field + comment + 
                      "BINARY";
    } else if (an_ss instanceof EData_type) {
      if (((EData_type)an_ss).getName(null).equalsIgnoreCase("_GENERIC")) { 
      	return_object = "protected CAggregate" + attribute_field + comment + "GENERIC";
    	} else
      if (((EData_type)an_ss).getName(null).equalsIgnoreCase("_ENTITY")) { 
//      	return_object = "protected AEntity" + attribute_field + comment + "GENERIC_ENTITY";
      	return_object = "protected AEntity" + attribute_field + comment + "_ENTITY";
			}
    }

    return return_object;
  }


  String getAggregateAttributeString(EAggregation_type at, String attribute_field)
                              throws SdaiException {
    String return_object = "";
    String comment = "";

    if (at instanceof EArray_type) {
      comment += " ARRAY OF ";
    } else if (at instanceof EBag_type) {
      comment += " BAG OF ";
    } else if (at instanceof ESet_type) {
      comment += " SET OF ";
    } else if (at instanceof EList_type) {
      comment += " LIST OF ";
    }

    int aggregate_depth = 1;
    EEntity an_ss;
    EEntity ass = at;
    String aggr_prefices = "";
    an_ss = at.getElement_type(null);

    for (;;) {
      boolean done_something = false;

      if (an_ss instanceof EDefined_type) {
        ass = an_ss;
        an_ss = ((EDefined_type) an_ss).getDomain(null);
        done_something = true;
      } else if (an_ss instanceof EAggregation_type) {
        aggr_prefices += "a";
        aggregate_depth++;
        ass = an_ss;

        if (ass instanceof EArray_type) {
          comment += "ARRAY OF ";
        } else if (ass instanceof EBag_type) {
          comment += "BAG OF ";
        } else if (ass instanceof ESet_type) {
          comment += "SET OF ";
        } else if (ass instanceof EList_type) {
          comment += "LIST OF ";
        }

        an_ss = ((EAggregation_type) an_ss).getElement_type(null);
        done_something = true;
      }

      if (!done_something) {
        break;
      }
    }

    String aggr_prefix = "A" + aggr_prefices;

    if (an_ss instanceof ESelect_type) {
      return_object = "protected " + getAggregatePackage(aggr_prefix, ass) + attribute_field + 
                      comment + "SELECT";
    } else if (an_ss instanceof EEntity_definition) {
      return_object = "protected " + getAggregatePackage(aggr_prefix, an_ss) + attribute_field + 
                      comment + "ENTITY";
    } else if (an_ss instanceof EEnumeration_type) {
      return_object = "protected " + aggr_prefix + "_enumeration" + attribute_field + comment + 
                      "ENUMERATION";
    } else if (an_ss instanceof EInteger_type) {
      return_object = "protected " + aggr_prefix + "_integer" + attribute_field + comment + 
                      "INTEGER";
    } else if (an_ss instanceof ENumber_type) {
      return_object = "protected " + aggr_prefix + "_double" + attribute_field + comment + 
                      "NUMBER";
    } else if (an_ss instanceof EReal_type) {
      return_object = "protected " + aggr_prefix + "_double" + attribute_field + comment + 
                      "REAL";
    } else if (an_ss instanceof EString_type) {
      return_object = "protected " + aggr_prefix + "_string" + attribute_field + comment + 
                      "STRING";
    } else if (an_ss instanceof ELogical_type) {
      return_object = "protected " + aggr_prefix + "_enumeration" + attribute_field + comment + 
                      "LOGICAL";
    } else if (an_ss instanceof EBoolean_type) {
      return_object = "protected " + aggr_prefix + "_boolean" + attribute_field + comment + 
                      "BOOLEAN";
    } else if (an_ss instanceof EBinary_type) {
      return_object = "protected " + aggr_prefix + "_binary" + attribute_field + comment + 
                      "BINARY";
    } else if (an_ss instanceof EData_type) {
      if (((EData_type)an_ss).getName(null).equalsIgnoreCase("_GENERIC")) { 
      	return_object = "protected CAggregate" + attribute_field + comment + "GENERIC";
    	} else
      if (((EData_type)an_ss).getName(null).equalsIgnoreCase("_ENTITY")) { 
//      	return_object = "protected AEntity" + attribute_field + comment + "GENERIC_ENTITY";
      	return_object = "protected AEntity" + attribute_field + comment + "_ENTITY";
			}
    }

    return return_object;
  }

  void collectAttributes(EEntity_definition current, EEntity_definition start, 
                         Vector all_attributes, Vector all_flags, HashSet entities, 
                         boolean inherited_branch) throws SdaiException {
    if (!entities.add(current)) {
      // repeated inheritance
      return;
    }

    // get supertypes
    boolean is_complex = start.getComplex(null);

    if ((!is_complex) || (is_complex && (current == start))) {
      // pre-x      AEntity_definition asuper = current.getSupertypes(null);
//      AEntity_or_view_definition asuper = current.getSupertypes(null);
      AEntity_or_view_definition asuper = current.getGeneric_supertypes(null);
      int count = asuper.getMemberCount();
      SdaiIterator isuper = asuper.createIterator();

      while (isuper.next()) {
        EEntity_definition eds = (EEntity_definition) asuper.getCurrentMemberObject(isuper);
        collectAttributes(eds, start, all_attributes, all_flags, entities, inherited_branch);

        if (inherited_branch && (current == start)) {
          inherited_branch = false;
        }
      }
    }

    // explicit attributes
    AExplicit_attribute xa = getExplicit_attributes(current);
    SdaiIterator ia = null;
    ia = xa.createIterator();

    while (ia.next()) {
      EExplicit_attribute xattr = (EExplicit_attribute) xa.getCurrentMemberObject(ia);

      //       Can also be later redeclared or redeclaring another explicit
      //       attribute itself, not interesting cases for interfaces?
      //       boolean is_later_redeclared; // does not make sense for
      //       interfaces (although used in EC1?)
      boolean is_redeclaring = xattr.testRedeclaring(null);
      all_attributes.add(xattr);

      if (current == start) {
        if (is_redeclaring) {
          printDDebug("explicit redeclaring");
          all_flags.add(new Integer(AA_CURRENT_EXPLICIT_REDECLARING));
        } else {
          all_flags.add(new Integer(AA_CURRENT_EXPLICIT));
        }
      } else if (inherited_branch) {
        if (is_redeclaring) {
          printDDebug("explicit redeclaring inherited");

          if (java_inheritance_enabled) {
            all_flags.add(new Integer(AA_JAVA_EXPLICIT_REDECLARING));
          } else {
            all_flags.add(new Integer(AA_SUPERTYPE_EXPLICIT_REDECLARING));
          }
        } else {
          if (java_inheritance_enabled) {
            all_flags.add(new Integer(AA_JAVA_EXPLICIT));
          } else {
            all_flags.add(new Integer(AA_SUPERTYPE_EXPLICIT));
          }
        }
      } else {
        if (is_redeclaring) {
          printDDebug("explicit redeclaring else?");
          all_flags.add(new Integer(AA_SUPERTYPE_EXPLICIT_REDECLARING));
        } else {
          all_flags.add(new Integer(AA_SUPERTYPE_EXPLICIT));
        }
      }
    	
    }

    ADerived_attribute da = getDerived_attributes(current);
    ia = da.createIterator();

    while (ia.next()) {
      EDerived_attribute dattr = (EDerived_attribute) da.getCurrentMemberObject(ia);
      boolean is_redeclaring = dattr.testRedeclaring(null);
      all_attributes.add(dattr);

      if (current == start) {
        if (is_redeclaring) {
          all_flags.add(new Integer(AA_CURRENT_DERIVED_REDECLARING));
        } else {
          all_flags.add(new Integer(AA_CURRENT_DERIVED));
        }
      } else if (inherited_branch) {
        if (is_redeclaring) {
          if (java_inheritance_enabled) {
            all_flags.add(new Integer(AA_JAVA_DERIVED_REDECLARING));
          } else {
            all_flags.add(new Integer(AA_SUPERTYPE_DERIVED_REDECLARING));
          }
        } else {
          if (java_inheritance_enabled) {
            all_flags.add(new Integer(AA_JAVA_DERIVED));
          } else {
            all_flags.add(new Integer(AA_SUPERTYPE_DERIVED));
          }
        }
      } else {
        if (is_redeclaring) {
          all_flags.add(new Integer(AA_SUPERTYPE_DERIVED_REDECLARING));
        } else {
          all_flags.add(new Integer(AA_SUPERTYPE_DERIVED));
        }
      }
    } // while

//System.out.println("><>< getInverse_attributes() in  collectAttributes for entity: " + current.getName(null));
    AInverse_attribute ina = getInverse_attributes(current);
    ia = ina.createIterator();

    while (ia.next()) {
      EInverse_attribute nattr = (EInverse_attribute) ina.getCurrentMemberObject(ia);
      boolean is_redeclaring = nattr.testRedeclaring(null);
      all_attributes.add(nattr);

      if (current == start) {
        if (is_redeclaring) {
          all_flags.add(new Integer(AA_CURRENT_INVERSE_REDECLARING));
        } else {
          all_flags.add(new Integer(AA_CURRENT_INVERSE));
        }
      } else if (inherited_branch) {
        if (is_redeclaring) {
          if (java_inheritance_enabled) {
            all_flags.add(new Integer(AA_JAVA_INVERSE_REDECLARING));
          } else {
            all_flags.add(new Integer(AA_SUPERTYPE_INVERSE_REDECLARING));
          }
        } else {
          if (java_inheritance_enabled) {
            all_flags.add(new Integer(AA_JAVA_INVERSE));
          } else {
            all_flags.add(new Integer(AA_SUPERTYPE_INVERSE));
          }
        }
      } else {
        if (is_redeclaring) {
          all_flags.add(new Integer(AA_SUPERTYPE_INVERSE_REDECLARING));
        } else {
          all_flags.add(new Integer(AA_SUPERTYPE_INVERSE));
        }
      }
    }

    //      return all_attributes;
/*
   	Iterator iterator1 = all_attributes.iterator();
   	while (iterator1.hasNext()) {
   		EAttribute print_attribute = (EAttribute)iterator1.next();
			System.out.println("XOXO attribute: " + print_attribute);
   	}
   	Iterator iterator2 = all_flags.iterator();
   	while (iterator2.hasNext()) {
   		Integer flag = (Integer)iterator2.next();
			System.out.println("XOXO flag: " + flag.intValue());
   	}
*/
 }



  void collectAttributesAll(EEntity_definition current, EEntity_definition start, 
                         ArrayList all_attributes, ArrayList all_flags, HashSet entities, 
                         boolean inherited_branch, Counts all_counts, HashSet original_explicit_attributes) throws SdaiException {

//System.out.println("collecting attributes - recursive, current entity: " + current);

    if (!entities.add(current)) {
      // repeated inheritance
//System.out.println("><>< in collectAttributesAll, repeated inheritance");
      return;
    }

    // get supertypes
    boolean is_complex = start.getComplex(null);

    if ((!is_complex) || (is_complex && (current == start))) {
      // pre-x      AEntity_definition asuper = current.getSupertypes(null);
//      AEntity_or_view_definition asuper = current.getSupertypes(null);
      AEntity_or_view_definition asuper = current.getGeneric_supertypes(null);
      int count = asuper.getMemberCount();
      SdaiIterator isuper = asuper.createIterator();

      while (isuper.next()) {
        EEntity_definition eds = (EEntity_definition) asuper.getCurrentMemberObject(isuper);
        collectAttributesAll(eds, start, all_attributes, all_flags, entities, inherited_branch, all_counts, original_explicit_attributes);

        if (inherited_branch && (current == start)) {
          inherited_branch = false;
        }
      }
    }

    // explicit attributes
    AExplicit_attribute xa = getExplicit_attributes3(current);
    SdaiIterator ia = null;
    ia = xa.createIterator();

    while (ia.next()) {
      EExplicit_attribute xattr = (EExplicit_attribute) xa.getCurrentMemberObject(ia);


      //       Can also be later redeclared or redeclaring another explicit
      //       attribute itself, not interesting cases for interfaces?
      //       boolean is_later_redeclared; // does not make sense for
      //       interfaces (although used in EC1?)
      boolean is_redeclaring = xattr.testRedeclaring(null);
			
			TheAttribute tattr = new TheAttribute();
			tattr.attr = xattr;
			tattr.type = 0; // explicit
     	tattr.flag_redeclaring = is_redeclaring;


      if (current == start) {
        if (is_redeclaring) {
          printDDebug("explicit redeclaring");
          all_flags.add(new Integer(AA_CURRENT_EXPLICIT_REDECLARING));
       		tattr.inheritance = 0; // current
       		tattr.field = false;
					tattr.flag = AA_CURRENT_EXPLICIT_REDECLARING;
        } else {
          all_flags.add(new Integer(AA_CURRENT_EXPLICIT));
        	tattr.inheritance = 0; // current
        	tattr.field = true;
        	tattr.flag = AA_CURRENT_EXPLICIT;
        	tattr.explicit_index = all_counts.explicit_count++;
        }
      } else if (inherited_branch) {
        if (is_redeclaring) {
          printDDebug("explicit redeclaring inherited");

          if (java_inheritance_enabled) {
            all_flags.add(new Integer(AA_JAVA_EXPLICIT_REDECLARING));
          	tattr.inheritance = 1; // java
          	tattr.field = false;
          	tattr.flag = AA_JAVA_EXPLICIT_REDECLARING;
          } else {
            all_flags.add(new Integer(AA_SUPERTYPE_EXPLICIT_REDECLARING));
          	tattr.inheritance = 2; // non-java
          	tattr.field = false;
          	tattr.flag = AA_SUPERTYPE_EXPLICIT_REDECLARING;
          }
        } else {
          if (java_inheritance_enabled) {
            all_flags.add(new Integer(AA_JAVA_EXPLICIT));
          	tattr.inheritance = 1; // java
          	tattr.field = false;
          	tattr.flag = AA_JAVA_EXPLICIT;
          	tattr.explicit_index = all_counts.explicit_count++;
          } else {
            all_flags.add(new Integer(AA_SUPERTYPE_EXPLICIT));
          	tattr.inheritance = 2; // non-java
          	tattr.field = true;
          	tattr.flag = AA_SUPERTYPE_EXPLICIT;
          	tattr.explicit_index = all_counts.explicit_count++;
          }
        }
      } else {
        if (is_redeclaring) {
          printDDebug("explicit redeclaring else?");
          all_flags.add(new Integer(AA_SUPERTYPE_EXPLICIT_REDECLARING));
         	tattr.inheritance = 2; // non-java
        	tattr.field = false;
					tattr.flag = AA_SUPERTYPE_EXPLICIT_REDECLARING;
        } else {
          all_flags.add(new Integer(AA_SUPERTYPE_EXPLICIT));
         	tattr.inheritance = 2; // non-java
        	tattr.field = true;
        	tattr.flag = AA_SUPERTYPE_EXPLICIT;
         	tattr.explicit_index = all_counts.explicit_count++;
        }
      }

      all_attributes.add(tattr);
    	
    }

    ADerived_attribute da = getDerived_attributes(current);
    ia = da.createIterator();
		EExplicit_attribute xatrr0 = null;


    while (ia.next()) {
      EDerived_attribute dattr = (EDerived_attribute) da.getCurrentMemberObject(ia);
      boolean is_redeclaring = dattr.testRedeclaring(null);

			TheAttribute tattr = new TheAttribute();
			tattr.attr = dattr;
			tattr.type = 1; // derived
     	tattr.flag_redeclaring = is_redeclaring;

      EExplicit_attribute xattr0;


      if (current == start) {
        if (is_redeclaring) {
          all_flags.add(new Integer(AA_CURRENT_DERIVED_REDECLARING));
         	tattr.inheritance = 0; // current
        	if (dattr.getRedeclaring(null) instanceof EExplicit_attribute) {
	        	// check if it is the first attribute redeclaring that explicit, or, perhaps, not the first one
	        	// find the explicit attribute (the first one, not re-redeclared as explicit), see if it is already encountered
	        	xattr0 = findOriginalExplicit(dattr);
	        	if(original_explicit_attributes.add(xattr0)) { // first time
		        	tattr.field = true; 
		        	tattr.alt_field = true; 
  	        	tattr.derived_index = all_counts.derived_count++;
  	        	tattr.alt_derived_index = all_counts.alt_derived_count++;
	        		tattr.not_first_derived = false;
	        		tattr.original_explicit = xattr0;
	        	} else { // already some other derived attribute is redeclaring it
		        	tattr.field = false; 
		        	tattr.alt_field = true; 
  	        	tattr.alt_derived_index = all_counts.alt_derived_count++;
	        		tattr.not_first_derived = true;
	        		tattr.original_explicit = xattr0;
	        	}
        	} else {
  	      	tattr.field = false; 
	        	tattr.alt_field = false; 
        	}
        	tattr.flag = AA_CURRENT_DERIVED_REDECLARING;
        } else {
          all_flags.add(new Integer(AA_CURRENT_DERIVED));
         	tattr.inheritance = 0; // current
        	tattr.alt_field = true; 
        	tattr.field = true; 
        	tattr.flag = AA_CURRENT_DERIVED;
         	tattr.derived_index = all_counts.derived_count++;
        	tattr.alt_derived_index = all_counts.alt_derived_count++;
        }
      } else if (inherited_branch) {
        if (is_redeclaring) {
          if (java_inheritance_enabled) {
            all_flags.add(new Integer(AA_JAVA_DERIVED_REDECLARING));
	         	tattr.inheritance = 1; // java
 		       	tattr.alt_field = false; 
  	      	tattr.field = false; 
  	      	tattr.flag = AA_JAVA_DERIVED_REDECLARING;
	        	if (dattr.getRedeclaring(null) instanceof EExplicit_attribute) {
		        	xattr0 = findOriginalExplicit(dattr);
		        	if(original_explicit_attributes.add(xattr0)) { // first time
	  	        	tattr.alt_derived_index = all_counts.alt_derived_count++;
		          	tattr.derived_index = all_counts.derived_count++;
	          		tattr.original_explicit = xattr0;
		        		tattr.not_first_derived = false;
	          	} else {
		        		tattr.not_first_derived = true;
	          		tattr.original_explicit = xattr0;
	  	        	tattr.alt_derived_index = all_counts.alt_derived_count++;
	          	}
						}
          } else {
            all_flags.add(new Integer(AA_SUPERTYPE_DERIVED_REDECLARING));
	         	tattr.inheritance = 2; // non-java
	        	if (dattr.getRedeclaring(null) instanceof EExplicit_attribute) {
		        	xattr0 = findOriginalExplicit(dattr);
		        	if(original_explicit_attributes.add(xattr0)) { // first time
			        	tattr.field = true; 
			        	tattr.alt_field = true; 
		          	tattr.derived_index = all_counts.derived_count++;
		          	tattr.alt_derived_index = all_counts.alt_derived_count++;
		        		tattr.not_first_derived = false;
	          		tattr.original_explicit = xattr0;
							} else {
		        		tattr.not_first_derived = true;
			        	tattr.field = false; 
			        	tattr.alt_field = true; 
		          	tattr.alt_derived_index = all_counts.alt_derived_count++;
	          		tattr.original_explicit = xattr0;
							}
    	    	} else {
  	  	    	tattr.field = false; 
  	  	    	tattr.alt_field = false; 
        		}
        		tattr.flag = AA_SUPERTYPE_DERIVED_REDECLARING;
          }
        } else {
          if (java_inheritance_enabled) {
            all_flags.add(new Integer(AA_JAVA_DERIVED));
	         	tattr.inheritance = 1; // java
  	      	tattr.field = false; 
  	      	tattr.alt_field = false; 
  	      	tattr.flag = AA_JAVA_DERIVED;
          	tattr.derived_index = all_counts.derived_count++;
          	tattr.alt_derived_index = all_counts.alt_derived_count++;
          } else {
            all_flags.add(new Integer(AA_SUPERTYPE_DERIVED));
	         	tattr.inheritance = 2; // non-java
  	      	tattr.field = true; 
  	      	tattr.alt_field = true; 
  	      	tattr.flag = AA_SUPERTYPE_DERIVED;
	         	tattr.alt_derived_index = all_counts.alt_derived_count++;
          	tattr.derived_index = all_counts.derived_count++;
          }
        }
      } else {
        if (is_redeclaring) {
          all_flags.add(new Integer(AA_SUPERTYPE_DERIVED_REDECLARING));
         	tattr.inheritance = 2; // non-java
        	if (dattr.getRedeclaring(null) instanceof EExplicit_attribute) {
	        	xattr0 = findOriginalExplicit(dattr);
	        	if(original_explicit_attributes.add(xattr0)) { // first time
	        		tattr.not_first_derived = false;
		        	tattr.field = true; 
		        	tattr.alt_field = true; 
  	        	tattr.derived_index = all_counts.derived_count++;
  	        	tattr.alt_derived_index = all_counts.alt_derived_count++;
          		tattr.original_explicit = xattr0;
						} else {
	        		tattr.not_first_derived = true;
		        	tattr.field = false; 
		        	tattr.alt_field = true; 
  	        	tattr.alt_derived_index = all_counts.alt_derived_count++;
          		tattr.original_explicit = xattr0;
						}
   	    	} else {
 	  	    	tattr.field = false; 
       		}
       		tattr.flag = AA_SUPERTYPE_DERIVED_REDECLARING;
        } else {
          all_flags.add(new Integer(AA_SUPERTYPE_DERIVED));
         	tattr.inheritance = 2; // non-java
 	      	tattr.field = true; 
 	      	tattr.alt_field = true; 
 	      	tattr.flag = AA_SUPERTYPE_DERIVED;
         	tattr.derived_index = all_counts.derived_count++;
         	tattr.alt_derived_index = all_counts.alt_derived_count++;
        }
      }
      all_attributes.add(tattr);
    } // while

//System.out.println("><>< getInverse_attributes() in  collectAttributesAll for entity: " + current.getName(null));
    AInverse_attribute ina = getInverse_attributes(current);
    ia = ina.createIterator();

    while (ia.next()) {
      EInverse_attribute nattr = (EInverse_attribute) ina.getCurrentMemberObject(ia);

//System.out.println("><><  ### inverse attribute: " + nattr);
      boolean is_redeclaring = nattr.testRedeclaring(null);

			TheAttribute tattr = new TheAttribute();
			tattr.attr = nattr;
			tattr.type = 2; // inverse
     	tattr.flag_redeclaring = is_redeclaring;



      if (current == start) {
        if (is_redeclaring) {
          all_flags.add(new Integer(AA_CURRENT_INVERSE_REDECLARING));
         	tattr.inheritance = 0; // current
 	      	tattr.field = false; 
 	      	tattr.flag = AA_CURRENT_INVERSE_REDECLARING;
        } else {
          all_flags.add(new Integer(AA_CURRENT_INVERSE));
         	tattr.inheritance = 0; // current
 	      	tattr.field = true; 
 	      	tattr.flag = AA_CURRENT_INVERSE;
         	tattr.inverse_index = all_counts.inverse_count++;
        }
      } else if (inherited_branch) {
        if (is_redeclaring) {
          if (java_inheritance_enabled) {
            all_flags.add(new Integer(AA_JAVA_INVERSE_REDECLARING));
	         	tattr.inheritance = 1; // java
 		      	tattr.field = false; 
          	tattr.flag = AA_JAVA_INVERSE_REDECLARING;
          } else {
            all_flags.add(new Integer(AA_SUPERTYPE_INVERSE_REDECLARING));
	         	tattr.inheritance = 2; // non-java
 		      	tattr.field = false; 
          	tattr.flag = AA_SUPERTYPE_INVERSE_REDECLARING;
          }
        } else {
          if (java_inheritance_enabled) {
            all_flags.add(new Integer(AA_JAVA_INVERSE));
	         	tattr.inheritance = 1; // java
 		      	tattr.field = false; 
          	tattr.flag = AA_JAVA_INVERSE;
	         	tattr.inverse_index = all_counts.inverse_count++;
          } else {
            all_flags.add(new Integer(AA_SUPERTYPE_INVERSE));
	         	tattr.inheritance = 2; // non-java
 		      	tattr.field = true; 
          	tattr.flag = AA_SUPERTYPE_INVERSE;
	         	tattr.inverse_index = all_counts.inverse_count++;
          }
        }
      } else {
        if (is_redeclaring) {
          all_flags.add(new Integer(AA_SUPERTYPE_INVERSE_REDECLARING));
         	tattr.inheritance = 2; // non-java
 	      	tattr.field = false; 
         	tattr.flag = AA_SUPERTYPE_INVERSE_REDECLARING;
        } else {
          all_flags.add(new Integer(AA_SUPERTYPE_INVERSE));
         	tattr.inheritance = 2; // non-java
	      	tattr.field = true; 
         	tattr.flag = AA_SUPERTYPE_INVERSE;
         	tattr.inverse_index = all_counts.inverse_count++;
        }
      }

      all_attributes.add(tattr);

    }

    //      return all_attributes;
/*
   	Iterator iterator1 = all_attributes.iterator();
   	while (iterator1.hasNext()) {
   		EAttribute print_attribute = (EAttribute)iterator1.next();
			System.out.println("XOXO attribute: " + print_attribute);
   	}
   	Iterator iterator2 = all_flags.iterator();
   	while (iterator2.hasNext()) {
   		Integer flag = (Integer)iterator2.next();
			System.out.println("XOXO flag: " + flag.intValue());
   	}
*/
 }


	EExplicit_attribute findOriginalExplicit(EDerived_attribute dattr) throws SdaiException {
      EExplicit_attribute xattr = (EExplicit_attribute)dattr.getRedeclaring(null);
//      EExplicit xattr2;
      for (;;) {
      	if (xattr.testRedeclaring(null)) {
      		xattr = xattr.getRedeclaring(null);
      	} else {
      		break;
      	} 
      }
		  return xattr;
	}

	EAttribute findOriginalAttribute(EAttribute attr) throws SdaiException {
	
			EAttribute redeclared = null;
			if (attr instanceof EExplicit_attribute) {
				redeclared = (EAttribute)((EExplicit_attribute)attr).getRedeclaring(null);
			} else
			if (attr instanceof EDerived_attribute) {
				redeclared = (EAttribute)((EDerived_attribute)attr).getRedeclaring(null);
			} else 
			if (attr instanceof EInverse_attribute) {
				redeclared = (EAttribute)((EInverse_attribute)attr).getRedeclaring(null);
			} else {
				// must be an internal error
				return null;
			}

			for (;;) {
				if (redeclared instanceof EExplicit_attribute) {
	      	if (((EExplicit_attribute)redeclared).testRedeclaring(null)) {
	      		redeclared = (EAttribute)((EExplicit_attribute)redeclared).getRedeclaring(null);
					} else {
						break;
					}
				} else 	
				if (redeclared instanceof EDerived_attribute) {
	      	if (((EDerived_attribute)redeclared).testRedeclaring(null)) {
	      		redeclared = (EAttribute)((EDerived_attribute)redeclared).getRedeclaring(null);
					} else {
						break;
					}
				} else 	
				if (redeclared instanceof EInverse_attribute) {
	      	if (((EInverse_attribute)redeclared).testRedeclaring(null)) {
	      		redeclared = (EAttribute)((EInverse_attribute)redeclared).getRedeclaring(null);
					} else {
						break;
					}
				} else {
					// internal error
					return null;
				}
			}


		  return redeclared;
	}


  void collectComplexAttributesAll(EEntity_definition current, ArrayList all_attributes, ArrayList all_flags, Counts all_counts, HashSet original_explicit_attributes)
                         throws SdaiException {
  
    
    CompareUppercaseEntities ce = new CompareUppercaseEntities();
    TreeSet asuper = new TreeSet(ce);
    getExternalMappingParts(current, asuper);

    Iterator isuper = asuper.iterator();

    while (isuper.hasNext()) {
      EEntity_definition eds = (EEntity_definition) isuper.next();
//      AExplicit_attribute xa = getExplicit_attributes(eds);
      AExplicit_attribute xa = getExplicit_attributes3(eds);
      SdaiIterator ia = null;


      // explicit attributes
      ia = xa.createIterator();

      while (ia.next()) {
        EExplicit_attribute xattr = (EExplicit_attribute) xa.getCurrentMemberObject(ia);

        // can also be later redeclared or redeclaring another explicit attribute itself, not interesting cases for interfaces?
        boolean is_redeclaring = xattr.testRedeclaring(null);

				TheAttribute tattr = new TheAttribute();
				tattr.attr = xattr;
				tattr.type = 0; // explicit
     		tattr.flag_redeclaring = is_redeclaring;
        tattr.inheritance = 2; // non-java




        if (is_redeclaring) {
          all_flags.add(new Integer(AA_SUPERTYPE_EXPLICIT_REDECLARING));
 	      	tattr.field = false; 
 	      	tattr.flag = AA_SUPERTYPE_EXPLICIT_REDECLARING;
        } else {
          all_flags.add(new Integer(AA_SUPERTYPE_EXPLICIT));
 	      	tattr.field = true; 
					tattr.explicit_index = all_counts.explicit_count++;
 	      	tattr.flag = AA_SUPERTYPE_EXPLICIT;
        }

        all_attributes.add(tattr);

      }

      ADerived_attribute da = getDerived_attributes(eds);
      ia = da.createIterator();
			EExplicit_attribute xattr0 = null;
		
      while (ia.next()) {
        EDerived_attribute dattr = (EDerived_attribute) da.getCurrentMemberObject(ia);
        boolean is_redeclaring = dattr.testRedeclaring(null);

				TheAttribute tattr = new TheAttribute();
				tattr.attr = dattr;
				tattr.type = 1; // derived
     		tattr.flag_redeclaring = is_redeclaring;
        tattr.inheritance = 2; // non-java


        if (is_redeclaring) {
          all_flags.add(new Integer(AA_SUPERTYPE_DERIVED_REDECLARING));
        	if (dattr.getRedeclaring(null) instanceof EExplicit_attribute) {
	        	xattr0 = findOriginalExplicit(dattr);
	        	if(original_explicit_attributes.add(xattr0)) { // first time
		        	tattr.field = true; 
		        	tattr.alt_field = true; 
  	        	tattr.derived_index = all_counts.derived_count++;
  	        	tattr.alt_derived_index = all_counts.alt_derived_count++;
	        		tattr.not_first_derived = false;
	        		tattr.original_explicit = xattr0;
	        	} else { // already some other derived attribute is redeclaring it
		        	tattr.field = false; 
		        	tattr.alt_field = true; 
  	        	tattr.alt_derived_index = all_counts.alt_derived_count++;
	        		tattr.not_first_derived = true;
	        		tattr.original_explicit = xattr0;
	        	}

   	    	} else {
 	  	    	tattr.field = false; 
						tattr.alt_field = false;
       		}
       		tattr.flag = AA_SUPERTYPE_DERIVED_REDECLARING;
        } else {
          all_flags.add(new Integer(AA_SUPERTYPE_DERIVED));
        	tattr.field = true; 
        	tattr.alt_field = true; 
        	tattr.derived_index = all_counts.derived_count++;
        	tattr.alt_derived_index = all_counts.alt_derived_count++;
					tattr.flag = AA_SUPERTYPE_DERIVED;
        }
        all_attributes.add(tattr);
      }

//System.out.println("><>< getInverse_attributes() in collectComplexAttributesAll for entity: " + eds.getName(null));
      AInverse_attribute ina = getInverse_attributes(eds);
      ia = ina.createIterator();

      while (ia.next()) {
        EInverse_attribute nattr = (EInverse_attribute) ina.getCurrentMemberObject(ia);
        boolean is_redeclaring = nattr.testRedeclaring(null);

				TheAttribute tattr = new TheAttribute();
				tattr.attr = nattr;
				tattr.type = 2; // inverse
     		tattr.flag_redeclaring = is_redeclaring;
        tattr.inheritance = 2; // non-java


        if (is_redeclaring) {
          all_flags.add(new Integer(AA_SUPERTYPE_INVERSE_REDECLARING));
        	tattr.field = false; 
					tattr.flag = AA_SUPERTYPE_INVERSE_REDECLARING;
        } else {
          all_flags.add(new Integer(AA_SUPERTYPE_INVERSE));
        	tattr.field = true; 
        	tattr.inverse_index = all_counts.inverse_count++;
					tattr.flag = AA_SUPERTYPE_INVERSE;
        }
        all_attributes.add(tattr);
      }
    }

    //      return all_attributes;
  }



  void processAttributesAll(EEntity_definition ed, ArrayList all_attributes, ArrayList all_flags)
                  throws SdaiException {
    // check each attribute if it is redeclared later.
    // Especially important cases when explicit is redeclared as derived. 
    // Although the internal number remains reserved, the field is not present.
    // However, in the case of java inheritance, we can do nothing. 
    // Let's have the field as well, but need to know if the attribute is later redeclared as derived

// System.out.println("ROCOFOCO-00 ########################## ENTITY: " + ed);

    for (int sj = 0; sj < all_attributes.size(); sj++) {
      TheAttribute tattr = (TheAttribute) all_attributes.get(sj);
      
      EAttribute a1 = tattr.attr;
      int attribute_flag = tattr.flag;
// System.out.println("ROCOFOCO-01 attribute flag: " + attribute_flag + ", index: " + sj + ", attribute: " + a1);

      if ((attribute_flag == AA_JAVA_EXPLICIT) || (attribute_flag == AA_SUPERTYPE_EXPLICIT) || 
              (attribute_flag == AA_CURRENT_EXPLICIT) ||
							(attribute_flag == AA_SUPERTYPE_EXPLICIT_REDECLARING) ||              
							(attribute_flag == AA_CURRENT_EXPLICIT_REDECLARING)             
      ) {
        for (int sjj = 0; sjj < all_attributes.size(); sjj++) {
          if (sj == sjj) {
            continue;
          }
					
          TheAttribute tattr2 = (TheAttribute)all_attributes.get(sjj);
          int attribute_flag2 = tattr2.flag;
//          int attribute_flag2 = (int) ((Integer) all_flags.elementAt(sjj)).intValue();
// System.out.println("ROCOFOCO-02 attribute flag: " + attribute_flag2 + ", index: " + sjj);

          if ((attribute_flag2 == AA_JAVA_DERIVED_REDECLARING) || 
                  (attribute_flag2 == AA_CURRENT_DERIVED_REDECLARING) || 
                  (attribute_flag2 == AA_SUPERTYPE_DERIVED_REDECLARING)) {
//            EAttribute a2 = (EAttribute) all_attributes.elementAt(sjj);
            EAttribute a2 = tattr2.attr;
            EEntity a3 = ((EDerived_attribute) a2).getRedeclaring(null);

// System.out.println("ROCOFOCO-03 derived attribute: " + a2 + ", redeclaring: " + a3);

            if (a1 == a3) {
              printDebug("CHANGING FLAG: " + a1.getName(null));
// System.out.println("ROCOFOCO-04 changing FLAG: " + a1 + ", flag: " + attribute_flag);

              // changing flag for a1 - explicit later redeclared as derived
              if (attribute_flag == AA_JAVA_EXPLICIT) {
                attribute_flag = AA_JAVA_EXPLICIT_TO_DERIVED;
								tattr.flag2 = AA_JAVA_EXPLICIT_TO_DERIVED;
								tattr.explicit_to_derived = true;
// System.out.println("ROCOFOCO-05 changing FLAG: AA_JAVA_EXPLICIT > AA_JAVA_EXPLICIT_TO_DERIVED");
              } else if (attribute_flag == AA_SUPERTYPE_EXPLICIT) {
								tattr.explicit_to_derived = true;
								if (a1.getName(null).equalsIgnoreCase(a2.getName(null))) {
	                attribute_flag = AA_SUPERTYPE_EXPLICIT_TO_DERIVED;
									tattr.flag2 = AA_SUPERTYPE_EXPLICIT_TO_DERIVED;
// System.out.println("ROCOFOCO-05 changing FLAG: AA_SUPERTYPE_EXPLICIT > AA_SUPERTYPE_EXPLICIT_TO_DERIVED");
								} else {
	                attribute_flag = AA_SUPERTYPE_EXPLICIT_TO_DERIVED_RENAMED;
									tattr.flag2 = AA_SUPERTYPE_EXPLICIT_TO_DERIVED_RENAMED;
// System.out.println("ROCOFOCO-05 changing FLAG: AA_SUPERTYPE_EXPLICIT > AA_SUPERTYPE_EXPLICIT_TO_DERIVED_RENAMED");
								}
					
								// experiment - probably will not work, besides we probably need derived methods not explicit, so need to implement supertype_explicit_to_derived case
                // however, some new cases below use supertype_explicit_to_derived to suppress generation of any methods
                // so supertype_explicit_to_derived should generate methods if the renaming occurs in redclaring to derive ???
//                if (attribute_flag2 == AA_CURRENT_DERIVED_REDECLARING)  {
//								} else {
//	                attribute_flag = AA_SUPERTYPE_EXPLICIT_TO_DERIVED;
//								}				

/*
                if (attribute_flag2 == AA_CURRENT_DERIVED_REDECLARING) 
	                attribute_flag = AA_SUPERTYPE_EXPLICIT_TO_DERIVED;
  							} else 
                if (attribute_flag2 == AA_SUPERTYPE_DERIVED_REDECLARING) {
	                attribute_flag = AA_SUPERTYPE_EXPLICIT_TO_DERIVED;
  							} else 
                if (attribute_flag2 == AA_JAVA_DERIVED_REDECLARING) {
	                attribute_flag = AA_SUPERTYPE_EXPLICIT_TO_DERIVED;
  							} 
*/
              } else if (attribute_flag == AA_CURRENT_EXPLICIT) {
               attribute_flag = AA_CURRENT_EXPLICIT_TO_DERIVED;
								tattr.flag2 = AA_CURRENT_EXPLICIT_TO_DERIVED;
								tattr.explicit_to_derived = true;
// System.out.println("ROCOFOCO-05 changing FLAG: AA_CURRENT_EXPLICIT > AA_CURRENT_EXPLICIT_TO_DERIVED");
              } else if (attribute_flag == AA_SUPERTYPE_EXPLICIT_REDECLARING) {
								// added for renamed
								// not for all
                if (attribute_flag2 == AA_CURRENT_DERIVED_REDECLARING) {
										// here we may need to change to something else
									tattr.explicit_to_derived = true;
									if (a1.getName(null).equalsIgnoreCase(a2.getName(null))) {
		                attribute_flag = AA_SUPERTYPE_EXPLICIT_TO_DERIVED;
										tattr.flag2 = AA_SUPERTYPE_EXPLICIT_TO_DERIVED;
// System.out.println("ROCOFOCO-05 changing FLAG: AA_SUPERTYPE_EXPLICIT_REDECLARING > AA_SUPERTYPE_EXPLICIT_TO_DERIVED (2 = AA_CURRENT_DERIVED_REDECLARING)");
									} else {
		                attribute_flag = AA_SUPERTYPE_EXPLICIT_TO_DERIVED_RENAMED;
										tattr.flag2 = AA_SUPERTYPE_EXPLICIT_TO_DERIVED;
// System.out.println("ROCOFOCO-05 changing FLAG: AA_SUPERTYPE_EXPLICIT_REDECLARING > AA_SUPERTYPE_EXPLICIT_TO_DERIVED_RENAMED (2 = AA_CURRENT_DERIVED_REDECLARING)");
									}

//	                attribute_flag = AA_SUPERTYPE_EXPLICIT_TO_DERIVED;
// System.out.println("ROCOFOCO-05 changing FLAG: AA_SUPERTYPE_EXPLICIT_REDECLARING > AA_SUPERTYPE_EXPLICIT_TO_DERIVED (2 = AA_CURRENT_DERIVED_REDECLARING)");
              	} else 
              	if (attribute_flag2 == AA_SUPERTYPE_DERIVED_REDECLARING) {
									tattr.explicit_to_derived = true;
									if (a1.getName(null).equalsIgnoreCase(a2.getName(null))) {
		                attribute_flag = AA_SUPERTYPE_EXPLICIT_TO_DERIVED;
										tattr.flag2 = AA_SUPERTYPE_EXPLICIT_TO_DERIVED;
// System.out.println("ROCOFOCO-05 EXPERIMENT changing FLAG: AA_SUPERTYPE_EXPLICIT_REDECLARING > AA_SUPERTYPE_EXPLICIT_TO_DERIVED (2 = AA_SUPERTYPE_DERIVED_REDECLARING)");
									} else {
		                attribute_flag = AA_SUPERTYPE_EXPLICIT_TO_DERIVED_RENAMED;
										tattr.flag2 = AA_SUPERTYPE_EXPLICIT_TO_DERIVED_RENAMED;
// System.out.println("ROCOFOCO-05 EXPERIMENT changing FLAG: AA_SUPERTYPE_EXPLICIT_REDECLARING > AA_SUPERTYPE_EXPLICIT_TO_DERIVED_RENAMED (2 = AA_SUPERTYPE_DERIVED_REDECLARING)");
									}

//	                attribute_flag = AA_SUPERTYPE_EXPLICIT_TO_DERIVED;
// System.out.println("ROCOFOCO-05 EXPERIMENT changing FLAG: AA_SUPERTYPE_EXPLICIT_REDECLARING > AA_SUPERTYPE_EXPLICIT_TO_DERIVED (2 = AA_SUPERTYPE_DERIVED_REDECLARING)");
                } else {
// System.out.println("ROCOFOCO-05 NOT changing FLAG: AA_SUPERTYPE_EXPLICIT_REDECLARING > AA_SUPERTYPE_EXPLICIT_TO_DERIVED (2 NOT = AA_CURRENT_DERIVED_REDECLARING), 2 = " + attribute_flag2);
                }
                // experiment
              } else if (attribute_flag == AA_CURRENT_EXPLICIT_REDECLARING) {
								// added for renamed
//                if (attribute_flag2 == AA_CURRENT_DERIVED_REDECLARING) {
									tattr.explicit_to_derived = true;
	                attribute_flag = AA_CURRENT_EXPLICIT_TO_DERIVED;
									tattr.flag2 = AA_CURRENT_EXPLICIT_TO_DERIVED;
// System.out.println("ROCOFOCO-05 changing FLAG: AA_CURRENT_EXPLICIT_REDECLARING > AA_CURRENT_EXPLICIT_TO_DERIVED, never mind if 2 = AA_CURRENT_EXPLICIT_TO_DERIVED or not, actully, flag2: " + attribute_flag2);
//								} else {
//								}
              }
		           
		         
              // can it cause changes in the results of this algorithm?
              all_flags.set(sj, new Integer(attribute_flag));
            }
          }
        } // for sjj
      } // if explicit
    } // for sj
  } // method



  void processAttributesAll2(EEntity_definition ed, ArrayList all_attributes, ArrayList all_flags)
                  throws SdaiException {

//System.out.println("IN processAttributesAll2 -------------------------: " + ed.getName(null));
	/*
	
		1.  numbering of the ax$, dx$ fields:
		    if explicit non-redecalring - ax$ is reserved, does not matter if java or non-java inheritance
		    if derived  non-redeclanig - dx$ is reserved
		    if derived redeclaring explicit - dx$ is reserved
		    if inverse non-redeclaring - ix$ is reserved
		    ---- already done
		    
		2.  if attribute is not redeclared later, the ax$ field is generated if current or non-java, if java - not generated,
		       methods - generated if current and if non-java, not generated if java  
		    if attribute is redeclared later:
		    if an explicit attribute is redeclared later as explicit (but never as derived):
		       the field ax$ generades if non-java, not generated if java,  new methods are generated if/when renamed only,
		       if current or non-java, if java - methods are inherited, if no renamed - original methods generated if non-java
		    if a derived attribute is not redeclared later - the dx$ field is generated if current or non-java, if java - not generated
		    	 methods - generated if current and if non-java, if java - not generated
		    if a derived attribute is redeclared - the field dx$ generated if non-java, not generated if java,
		       new methods - generated if/when renamed only, if current or non-java, if java - inherited, 
		       the original methods generated if non-java, if java -not generated, if renamed or not
		    if an explicit attribute is redeclared as derived  - dx$ field is generated with the number of the posittion of the redeclaration as derived,
		    	not possition of the original declaration, generated if non-java or current, not generated if java.
		      methods: new methods generated for each renaming as explict and as derived, methods generated for current and non-java, not generated for java,
		      the original methods generated if non-java, if java - not generated, if renamed present or not

					 ......
					 
					 perhaps, let's do this:
					 1) make a loop, find for each attribute if it is later redeclared (not redeclaring), 
					 		if so, set the pointer to TheAttribute object which holds that redeclaring attribute.
					  -- probably no need to search for each attribute if it is redeclared and by which attribute,
					     enought to set for each attribute redeclared field one step away if it is redeclaring,
					     because, if attribute is redeclaring another attribute, the redeclared attribute has to be in a supertype and has to be included in this Vector
							 however, this step still requires another inner loop.
		       
		       NOTE - wrong, an attribute may be redeclared by more than one attribute, so one redeclared field may not be enough 
		              one redeclaring field, multiple redeclared fields. Let's have redeclared count and Vector or ArrayList, etc.  
		       2) further make single loops and do whatever we need to be done.
	
	*/



    for (int i = 0; i < all_attributes.size(); i++) {
      TheAttribute tattr = (TheAttribute) all_attributes.get(i);

//System.out.println("######################### tattr: "  + tattr);
      
      // EAttribute a1 = tattr.attr;
      EAttribute attr = null;
			TheAttribute tattr2 = null;
			if (tattr.flag_redeclaring) {
				switch (tattr.type) {
					case 0: // explicit
						attr = ((EExplicit_attribute)tattr.attr).getRedeclaring(null);
						if (!(attr.getName(null).equalsIgnoreCase(tattr.attr.getName(null)))) {
							tattr.flag_renamed = true;
						}
						// find redeclared, we have attr, need - tattr
						for (int j = 0; j < all_attributes.size(); j++) {
							if (j == i) continue;
							tattr2 = (TheAttribute) all_attributes.get(j);
							if (tattr2.attr == attr) {
								tattr.redeclaring = tattr2;
								tattr2.last_redeclared_by = tattr;
								tattr2.redeclared_by_count++;
								tattr2.redeclared_by.add(tattr);
								break;
							} 
						}
						break;
					case 1: // derived
						attr = (EAttribute)((EDerived_attribute)tattr.attr).getRedeclaring(null);
						if (!(attr.getName(null).equalsIgnoreCase(tattr.attr.getName(null)))) {
							tattr.flag_renamed = true;
						}
						// find redeclared, we have attr, need - tattr
						for (int j = 0; j < all_attributes.size(); j++) {
							if (j == i) continue;
							tattr2 = (TheAttribute) all_attributes.get(j);
							if (tattr2.attr == attr) {
								tattr.redeclaring = tattr2;
								tattr2.last_redeclared_by = tattr;
								tattr2.redeclared_by_count++;
								tattr2.redeclared_by.add(tattr);
								break;
							} 
						}
						break;
					case 2: // inverse
//System.out.println("<<<<01>>>> inverse");
						attr = ((EInverse_attribute)tattr.attr).getRedeclaring(null);
						if (!(attr.getName(null).equalsIgnoreCase(tattr.attr.getName(null)))) {
							tattr.flag_renamed = true;
						}
						// find redeclared, we have attr, need - tattr
						for (int j = 0; j < all_attributes.size(); j++) {
							if (j == i) continue;
							tattr2 = (TheAttribute) all_attributes.get(j);
							if (tattr2.attr == attr) {
								tattr.redeclaring = tattr2;
								tattr2.last_redeclared_by = tattr;
								tattr2.redeclared_by_count++;
//System.out.println("adding redeclared_by inverse: " + tattr);
								tattr2.redeclared_by.add(tattr);
								break;
							} 
						}
						break;
					default: // -1 - unset type -internal error
						System.out.println("INTERNAL ERROR - processAttributesAll2, attribute: " + tattr.attr);
						break;		
				} // switch - type
			} // if attribute is redeclaring some other attribute
		} // for - all TheAttribute instances in the vector
    /*
    */
    for (int i = 0; i < all_attributes.size(); i++) {
      TheAttribute tattr = (TheAttribute) all_attributes.get(i);
			if (!tattr.flag_redeclaring) {
				
	
			  /*
			  
			  	because there may be more than one redeclaring attribute, including the case when one explicit is simultaneously redeclared as derived
			  	by more than one derived attribute, the natural place for consolidated attribute (if needed at all) is the root - the original attribute
			  	
			  	
			  	So, the consolidated attribute is an attribute which is not redeclaring any other attributes, but itself may be later redeclared
			  
			  */
			  
			  
			  tattr.consolidated = true;
			  switch (tattr.type) {
			  	case 0: // explicit
						// consolidated attribute may have one explicit or one derived field
			  	  // ALT: consolidated attribute may have one explicit or one or more derived fields
			  		
			  		// ArrayList with TheAttribute instances where explicit is redeclared as derived 
			  		tattr.consolidated_primary_derived = findConsolidatedExplicit2Derived(tattr); 
			  	  // if 0 - 1 explicit field, if 1 or more - derived fields
			  	  tattr.consolidated_derived_count = tattr.consolidated_primary_derived.size();
			  	  if (tattr.consolidated_derived_count < 1) {
			  	  	tattr.consolidated_type = 0;
				  		tattr.consolidated_explicit_index = tattr.explicit_index;
			  	  	tattr.consolidated_inheritance = tattr.inheritance;
			  	  } else {
			  	  	tattr.consolidated_type = 1;
				  		// no need to generate it, although may be present through java inheritance
				  		// no, it is needed for renamed before redeclaring as derived
				  		//tattr.consolidated_explicit_index = -1; 
				  		tattr.consolidated_explicit_index = tattr.explicit_index;
		  				tattr.consolidated_flag_explicit_to_derived = true;
			  			if (tattr.consolidated_derived_count == 1) {
			  				tattr.consolidated_derived_index = ((TheAttribute)tattr.consolidated_primary_derived.get(0)).derived_index;
			  				tattr.consolidated_inheritance = ((TheAttribute)tattr.consolidated_primary_derived.get(0)).inheritance;
			  				tattr.consolidated_explicit_to_derived = (TheAttribute)tattr.consolidated_primary_derived.get(0);
			  			} else {  // more than one
			  				
			  				
			  				// let's stick to one for now, as in the previous version
 			  				

/*
 			  				for (int j = 0; j < tattr.consolidated_primary_derived.size(); j++) {
			  					TheAttribute tattr3 = (TheAttribute)tattr.consolidated_primary_derived.get(j);
			  					if (!tattr3.not_first_derived) {
			  						tattr.consolidated_derived_index = tattr3.derived_index;
			  						tattr.consolidated_inheritance = tattr3.inheritance;
			  						tattr.consolidated_explicit_to_derived = tattr3;
			  						break;
			  					}
			  				}

*/
			  				
			  				// new code
			  				
			  			 /*
			  			 		perhaps not - if there is more than one explicit2derived, check if there are both renamed and non-renamed,
			  			 		take a non-renamed (first non-renamed) because renamed may be generated together will all the other renamed,
			  			 		but perhaps mark somehow, that the generated one was not renamed, so that generation of renamed one is not suppressed,
			  			 		not sure if may be needed
			  			 */

 			  				for (int j = 0; j < tattr.consolidated_primary_derived.size(); j++) {
			  					TheAttribute tattr3 = (TheAttribute)tattr.consolidated_primary_derived.get(j);
			  					String tattr_name = tattr.attr.getName(null);
			  					String tattr3_name = tattr3.attr.getName(null);
			  					if (!tattr3.not_first_derived) {
				  						tattr.consolidated_derived_index = tattr3.derived_index;
				  						tattr.consolidated_inheritance = tattr3.inheritance;
				  						tattr.consolidated_explicit_to_derived = tattr3;
				  						if (tattr_name.equalsIgnoreCase(tattr3_name)){
					  						// ok, the first one has the original name
					  						tattr.consolidated_explicit_to_derived_original_or_renamed = 0; // the 1st one has the original name
											}	 else {
					  						tattr.consolidated_explicit_to_derived_original_or_renamed = 1; // the 1st one is renamed, generate also with original name
											}
				  						break;

			  					}
			  			
			  				} // for  

			  				
			  				
			  			  
			  			  // end of new code
			  			  
			  			} // else - more than one

			  		} // else - 1 or more derived 
			  		
			  		//tattr.consolidated_attribute_value_str = ;   // a0
			  		//tattr.consolidated_attribute_str = ;         // a0$
			  		//tattr.consolidated_attribute_select_str =;   // a0$$
			  		//tattr.consolidated_attribute_comment_str = ; 
			  		break;
			  	case 1:	// derived
			  		// consolidated has one derived field
			  		tattr.consolidated_derived_index = tattr.derived_index;
			  		tattr.consolidated_type = 1;
						tattr.consolidated_inheritance = tattr.inheritance;
			  		break;
					case 2: // inverse
			  		// consolidated has one inverse field
			  		tattr.consolidated_inverse_index = tattr.inverse_index;
			  		tattr.consolidated_type = 2;
			  		tattr.consolidated_inheritance = tattr.inheritance;
			  		break;
					default: 
						System.out.println("INTERNAL ERROR - unknown attribute type in processAttributesAll2, attribute: " + tattr.attr);
						break;
			  }
			  
			
			
			} 	
		}		
	}

  void processAttributesAll4(EEntity_definition ed, ArrayList all_attributes, ArrayList all_flags) throws SdaiException {
    for (int i = 0; i < all_attributes.size(); i++) {
      TheAttribute tattr = (TheAttribute) all_attributes.get(i);
			String inheritance_str = null;
			
			if (tattr.consolidated) {

				switch (tattr.consolidated_inheritance) {
					case 0:
						inheritance_str = "current entity";
						break;
					case 1:
						inheritance_str = "java inheritance";
						break;
					case 2: 
						inheritance_str = "non-java inheritance";
						break;
					default: // internal error
						System.out.println("INTERNAL ERROR in processAttributesAll4, consolidated_inheritance not set, attribute: " + tattr.attr); 
						break;			
				}



				switch (tattr.consolidated_type) {
					case 0: // explicit
						tattr.consolidated_attribute_comment_str = "// " + tattr.attr.getName(null) + " - explicit - " + inheritance_str;
						tattr.consolidated_attribute_value_str = getExplicitAttributeValueField(tattr);
						tattr.consolidated_attribute_str = "protected static final jsdai.dictionary.CExplicit_attribute a" 
							+ tattr.consolidated_explicit_index + "$ = CEntity.initExplicitAttribute(definition, " + tattr.consolidated_explicit_index + ");";
						tattr.consolidated_attribute_select_field_present = ifSelectFieldPresent(tattr);
						if (tattr.consolidated_attribute_select_field_present) {
							tattr.consolidated_attribute_select_str = "protected int a" + tattr.consolidated_explicit_index + "$$;"; 
						}
						break;
					case 1: // derived
						if (tattr.type == 0) {
							tattr.consolidated_attribute_comment_str = "// " + tattr.attr.getName(null) + " - explicit redeclared as derived - " + inheritance_str;
						} else {
							tattr.consolidated_attribute_comment_str = "// " + tattr.attr.getName(null) + " - derived - " + inheritance_str;
						}
						tattr.consolidated_attribute_str = "protected static final jsdai.dictionary.CDerived_attribute d" + 
						tattr.consolidated_derived_index + "$ = CEntity.initDerivedAttribute(definition, " + tattr.consolidated_derived_index + ");";
						break;
					case 2: //inverse
						tattr.consolidated_attribute_comment_str = "// " + tattr.attr.getName(null) + " - inverse - " + inheritance_str;
						tattr.consolidated_attribute_str = "protected static final jsdai.dictionary.CInverse_attribute i" 
							+ tattr.consolidated_inverse_index + "$ = CEntity.initInverseAttribute(definition, " + tattr.consolidated_inverse_index + ");";
						break;
					default: // internal error
						System.out.println("INTERNAL ERROR in processAttributesAll4, attribute: " + tattr.attr);
						break;
					
				}
			}
		}
	}

  void processAttributesAll5(EEntity_definition ed, ArrayList all_attributes, ArrayList all_flags) throws SdaiException {
    for (int i = 0; i < all_attributes.size(); i++) {
      TheAttribute tattr = (TheAttribute) all_attributes.get(i);
			if (tattr.consolidated) {
				/*
				 		ok, let's generate methods for this attribute, gather all the methods
						because of the interfaces, need to generated methods with all intermediate names and types,
						so:
						- generate methods for this original attribute:
						  * - name - original
						  * - value/return type - original
						  * - attribute type explicit/derived - as indicated by consolidated_type
						  * - internal field - as indicated by consolidated
						      NOTE - a possible problem with repeated inheritance and two or more redeclarings e->d
					 - generate methods for each point of RENAMED, name - new after renamed, return/value type - subtype if entity, the same otherwise
					   attribute type explicit/derived - as in RENAMED node.		
				*/
				
				
				// I don't think I used those
				tattr.main_method = new TheMethod();
				tattr.main_method.name = tattr.attr.getName(null);
				tattr.main_method.has_previous = false;
			
	
		
				// find all renamed, starting from consolidated = root
				
				findRenamedAttributes(tattr);	
					
				 
			}
		}
	}

	/*
		tattr - consolidated attribute
		we can go to subtype entities - to attributes that are redeclaring this attribute,
		then to attributes that are redeclaring these attributes, etc - recursively
		And find all the instances of renaming
	*/



	void findRenamedAttributes(TheAttribute tattr) throws SdaiException {
		findRenamedAttributesRecursive(tattr, tattr);
	}
	

	void findRenamedAttributesRecursive(TheAttribute current, TheAttribute start) throws SdaiException {
		
		
		if (current.redeclared_by_count < 1) {
			return;
		}	
		
		for (int i = 0; i < current.redeclared_by.size(); i++) {
			TheAttribute tattr2 = (TheAttribute)current.redeclared_by.get(i);
			if (!(current.attr.getName(null).equalsIgnoreCase(tattr2.attr.getName(null)))) {
				// we found RENAMED
				TheMethod tm = new TheMethod();
				tm.current = tattr2;
				tm.previous = current;
				tm.consolidated = start; // not really needed, because it will be known when generating methods
				start.consolidated_renamed.add(tm);
				/*
						there is a situation when renamed methods are not needed:
						if the renamed explicit attribute (with the new name) is later redeclared as derived
				
						In such a case, we have an explicit 2 derived which should be consolidated exactly into the start attribute,
						so it is possible to check:
				*/
				start.consolidated_renamed_present = true;
			}
			findRenamedAttributesRecursive(tattr2, start);
		}	
	}		
		
		
		




/*


class	TheMethod {
	boolean has_previous;
	TheAttribute previous;
	String name;
	String previous_name;
	Object type; // or EEntity?
	String type_str;
	Object value; // or EEntity?
	String value_str;
	String package_str;
	String previous_package_str;
	Object previous_type;
	String previous_type_str;
	Object previous_value;
	String previous_value_str;
}


*/


//	String getExplicitAttributeValueField(TheAttribute tattr) {
//		result = "";
//	}
	
	
	boolean isAttributeBoolean(TheAttribute tattr) throws SdaiException {
		EAttribute attr = tattr.attr;
    if (attr instanceof EExplicit_attribute) {
      EEntity bt = ((EExplicit_attribute) attr).getDomain(null);
      if (bt instanceof EDefined_type) {
        EDefined_type dt = (EDefined_type) bt;
        return isTypeBoolean(dt);
      } else if (bt instanceof EBoolean_type) {
      	return true;
      } else {
      	return false;
      }
		} else {
			return false;
		}
	}

	boolean isTypeBoolean(EDefined_type dt) throws SdaiException {
    EEntity ut = dt.getDomain(null);

    if (ut instanceof EDefined_type) {
       EDefined_type dt1 = (EDefined_type) ut;
	     return isTypeBoolean(dt1);
		} else 
    if (ut instanceof EBoolean_type) {
			return true;
		}	else {
			return false;
		}
	}

  String getExplicitAttributeValueField(TheAttribute tattr) throws SdaiException {

  //  - not used parameters - attr, String attribute_field, int attr_index, int internal, PrintWriter pw)

    String return_object = "";
		EAttribute attr = tattr.attr;

    String attr_name = attr.getName(null);
    String method_suffix = attr_name.substring(0, 1).toUpperCase() + 
                           attr_name.substring(1).toLowerCase();

    if (attr instanceof EExplicit_attribute) {
      EEntity bt = null;
	    if (((EExplicit_attribute)attr).testDomain(null)) {
	      bt = ((EExplicit_attribute) attr).getDomain(null);
			} else {
//				pw.println("WARNING! Explicit attribute value field not generated - attribute domain is NULL: " + attr);
				System.out.println("WARNING! Explicit attribute value field not generated - attribute domain is NULL: " + attr);
				return "_VALUE_FIELD_NOT_GENERATED__ATTRIBUTE_DOMAIN_IS_NULL_";
			}



      // this is to generate the type wrapped inside Parameter - for generalized attribute types
      // further down there is a generic handling of Parameter type which is insufficient
      // hopefully this new implementation will not cause problems somewhere else
      if (bt instanceof EParameter) {
      	bt = ((EParameter)bt).getParameter_type(null);
        // it is probably wrong what is done here, but adding the next line to improve things
        return_object = "protected Object";
      }


      if (bt instanceof ESimple_type) {
        ESimple_type st = (ESimple_type) bt;
        return_object = getSimpleTypeAttributeStringX(st);
      } else if (bt instanceof EAggregation_type) {
        EAggregation_type at = (EAggregation_type) bt;
        return_object = getAggregateAttributeStringX(at);
      } else if (bt instanceof EDefined_type) {
        EDefined_type dt = (EDefined_type) bt;
        return_object = getDefinedTypeAttributeStringX(dt);
      } else if (bt instanceof EEntity_definition) {
        EEntity_definition ed1 = (EEntity_definition) bt;
        String entity_name = ed1.getName(null);
//        return_object = "protected Object" + attribute_field + " ENTITY " + entity_name;
        return_object = "protected Object";
      } else 
      if (bt instanceof EParameter) {	 // generalized attribute type - ammendment
//        return_object = "protected Object" + attribute_field + " GENERALIZED";
        return_object = "protected Object";
      } else {
				// System.out.println("<ExpressCompiler> UNSUPPORTED ATTRIBUTE BASE TYPE: " + bt);
      	if (bt instanceof EData_type) {
      		String data_type_name = ((EData_type)bt).getName(null);
      		if (data_type_name.equals("_GENERIC")) {
		        return_object = "protected Object";
      		} else
      		if (data_type_name.equals("_ENTITY")) {
		        return_object = "protected Object";
      		} else {
						System.out.println("<ExpressCompiler> UNSUPPORTED ATTRIBUTE BASE TYPE: " + bt);
		        return_object = "protected Object";
      		}
      	}
      }
    }
/*    
     else if (attr instanceof EDerived_attribute) {
      EEntity bt = ((EDerived_attribute) attr).getDomain(null);

      if (bt instanceof ESimple_type) {
        ESimple_type st = (ESimple_type) bt;
        return_object = getSimpleTypeAttributeString(st, attribute_field);
      } else if (bt instanceof EAggregation_type) {
        EAggregation_type at = (EAggregation_type) bt;
        return_object = getAggregateAttributeString(at, attribute_field);
      } else if (bt instanceof EDefined_type) {
        EDefined_type dt = (EDefined_type) bt;
        return_object = getDefinedTypeAttributeString(dt, attribute_field, attr_index, internal, pw);
      } else if (bt instanceof EEntity_definition) {
        EEntity_definition ed1 = (EEntity_definition) bt;
        String entity_name = ed1.getName(null);
        return_object = "protected Object" + attribute_field + " ENTITY " + entity_name;
      }
    } else if (attr instanceof EInverse_attribute) {
      EEntity_definition bet = ((EInverse_attribute) attr).getDomain(null);
      String entity_name = bet.getName(null);
      return_object = "protected Object" + attribute_field + " ENTITY " + entity_name;
    }

*/
    return_object += " a" + tattr.consolidated_explicit_index + ";";
    
    return return_object;
  }



	
	
	
	boolean ifSelectFieldPresent(TheAttribute tattr) throws SdaiException {
		boolean result = false;
		
		EAttribute attr = tattr.attr;
		
    if (attr instanceof EExplicit_attribute) {
      EEntity bt = null;

	    if (((EExplicit_attribute)attr).testDomain(null)) {
	      bt = ((EExplicit_attribute) attr).getDomain(null);
			} else {
//				pw.println("WARNING! Explicit attribute value field not generated - attribute domain is NULL: " + attr);
				System.out.println("WARNING! Select field present-or-not for an explicit attribute - attribute domain is NULL: " + attr);
				return false;
			}


      if (bt instanceof EDefined_type) {
        EDefined_type dt = (EDefined_type) bt;
		    
		    for (;;) {
		    	EEntity ut = dt.getDomain(null);
					if (ut instanceof EDefined_type) {
						dt = (EDefined_type)ut;
					} else {
						if (ut instanceof ESelect_type) {

				      ANamed_type ant1 = getSelections((ESelect_type) ut);
  	    			SelectPaths paths1 = null;
    	  			int select_type = Integer.MIN_VALUE;
      				Object temp_object = ut.getTemp();
	
  	    			if (temp_object instanceof SelectPaths) {
    	    			if (((SelectPaths) temp_object).owner == ut) {
      	    			paths1 = (SelectPaths) temp_object;
        	  			select_type = paths1.select_type;
        				}
      				}

	      			if (paths1 == null) {
  	      			int count = 1;
    	    			int[] indeces = new int[500];
      	  			int depth = 0;
        				int depth_count = 0;
        				boolean with_type = false;
        				Vector current_nodes = new Vector();
        				Vector current_node_strings = new Vector();
	        			paths1 = new SelectPaths();
  	      			paths1.owner = (ESelect_type) ut;
    	    			select_type = calculateSelectPaths(count, current_nodes, current_node_strings, indeces, 
      	                                     			depth, depth_count, paths1, (ESelect_type) ut, with_type);
        				paths1.removeIdentical();
        				paths1.select_type = select_type;
        				ut.setTemp(paths1);
	      			}
			
    				  if (select_type > 0) { // includes defined_types
								 return true;
      				} else {
      					return false;
      				}


						} else {  // not select type
							return false;
						}
					} // not defined type
				} // loop
			} else { // attribute domain - not defined type
				return false;
			}
		} else { // not explicit attribute
			// not possible, internal error
			return false;
		}
		//return false;
	}


	/*
			may be explicit or one or more derived, therefore, 
			returns 0 instances in ArrayList for explicit, 1 - for one derived, > 1 for more than one derived;
	*/
	ArrayList findConsolidatedExplicit2Derived(TheAttribute tattr) {
		 ArrayList result = new ArrayList();	
		 /*
		 		we need to 	go to each redeclared_by attribute and see if it is derived: 
		 			if derived, add it and do not proceed further from it by its redeclared_by
		 	    if explicit - proceed further to each attribute on its redeclared_by list.
		 	    It is a recursion
		 */
		 recursiveSearchForExplicit2Derived(tattr, result);
		 return result;
	}

	void recursiveSearchForExplicit2Derived(TheAttribute tattr, ArrayList result) {
		ArrayList redeclared_by = tattr.redeclared_by;
		if (redeclared_by == null) return;
		if (redeclared_by.size() < 1) return; // are both these cases possible?
		for (int i = 0; i < redeclared_by.size(); i++) {
			TheAttribute tattr2 = (TheAttribute)redeclared_by.get(i);
			if (tattr2.type == 1) { // derived
				result.add(tattr2);
			} else
			if (tattr2.type == 0) { // explicit
				recursiveSearchForExplicit2Derived(tattr2, result);
			} else { // must be an internal error
			  System.out.println("INTERNAL ERROR in recursiveSearchForExplicit2Derived, atttribute: " + tattr2.attr);
			}
		}
	}


	int getFirstExplicitInProcessingAttributes(TheAttribute tattr) {
		TheAttribute first = tattr;
		for (;;) {
			if (first.redeclaring != null) {
				first = first.redeclaring;
			} else {
				break;
			}
		}
		return first.explicit_index;
	}

	int getFirstDerivedInProcessingAttributes(TheAttribute tattr) {
		TheAttribute first = tattr;
		for (;;) {
			if (first.redeclaring != null) {
				first = first.redeclaring;
			} else {
				break;
			}
		}
		return first.derived_index;
	}

	int getFirstInverseInProcessingAttributes(TheAttribute tattr) {
		TheAttribute first = tattr;
		for (;;) {
			if (first.redeclaring != null) {
				first = first.redeclaring;
			} else {
				break;
			}
		}
		return first.inverse_index;
	}


  void processAttributesAll3(EEntity_definition ed, ArrayList all_attributes, ArrayList all_flags)
                  throws SdaiException {

    int internal = 0;
    int count_derived = 0;
    int count_inverse = 0;

    for (int sj = 0; sj < all_attributes.size(); sj++) {
      EAttribute attr0 = (EAttribute) all_attributes.get(sj);
      String attr_name = attr0.getName(null);
      int attribute_flag = (int) ((Integer) all_flags.get(sj)).intValue();
      String attribute_field = null;

      if (attribute_flag == AA_CURRENT_EXPLICIT) {
        attribute_field = " a" + internal++ + "; // " + attr_name + " - current entity -";

        //           pw.println("\t + attribute_object + " a" + sj + " // " + attr_name + " - current entity");
      } else if (attribute_flag == AA_JAVA_EXPLICIT) {
        attribute_field = " a" + internal++ + ";   " + attr_name + " - java inheritance -";

        //           pw.println("\t//  + attribute_object + " a" + sj + "   " + attr_name + " - java inheritance");
      } else if (attribute_flag == AA_SUPERTYPE_EXPLICIT) {
        attribute_field = " a" + internal++ + "; // " + attr_name + " - non-java inheritance -";

        //           pw.println("\t + attribute_object + " a" + sj + " // " + attr_name + " - non-java inheritance");
      } else if (attribute_flag == AA_CURRENT_EXPLICIT_TO_DERIVED) {
        //            internal++;
        attribute_field = " a" + internal++ + 
                          " - explicit redeclared as derived - current entity - ";
        count_derived++;
      } else if (attribute_flag == AA_JAVA_EXPLICIT_TO_DERIVED) {
        //            internal++;
        attribute_field = " a" + internal++ + 
  
                         " -  explicit redeclared as derived - java inheritance - ";
//RR - dulplicated derived, this one is not needed and numbering must remain unchanged
        count_derived++;
      } else if (attribute_flag == AA_SUPERTYPE_EXPLICIT_TO_DERIVED) {
        //            internal++;
// try not to increase the number for redeclared as derived non-java, which is not actually present 
// causes problems with old - new, setAll/getAll
        attribute_field = " a" + internal++ + 
//        attribute_field = " a" + internal + 
                          " - explicit redeclared as derived - non-java inheritance - ";
        count_derived++;
      } else if (attribute_flag == AA_CURRENT_EXPLICIT_REDECLARING) {
        //            System.out.println("explicit redeclaring");
        attribute_field = "  - explicit redeclaring - current - ";
      } else if (attribute_flag == AA_JAVA_EXPLICIT_REDECLARING) {
        //            System.out.println("explicit redeclaring");
        attribute_field = "  - explicit redeclaring - java inheritance - ";
      } else if (attribute_flag == AA_SUPERTYPE_EXPLICIT_REDECLARING) {
        //            System.out.println("explicit redeclaring");
        attribute_field = "  - explicit redeclaring - non-java inheritance - ";
      } else if (attribute_flag == AA_JAVA_DERIVED) {
        attribute_field = "  - derived - java inheritance - ";
        count_derived++;
      } else if (attribute_flag == AA_JAVA_DERIVED_REDECLARING) {
        attribute_field = "  - derived redeclaring - java inheritance - ";
      } else if (attribute_flag == AA_SUPERTYPE_DERIVED) {
        attribute_field = "  - derived - non-java inheritance - ";
        count_derived++;
      } else if (attribute_flag == AA_SUPERTYPE_DERIVED_REDECLARING) {
        attribute_field = "  - derived redeclaring - non-java inheritance - ";
        if (((EDerived_attribute)attr0).getRedeclaring(null) instanceof EExplicit_attribute) {
				  int count_renamed = countAttributeRenamings(attr0);
          if (count_renamed > 0) {
 	        	count_derived++; // two d$ - explicit redeclared as derived - non-java inheritance and derived redeclaring - non-java inheritance 
					}
//					internal++; // controversial experiment RR-2005-03-27 - does not help, but obviously is wrong
				}
      } else if (attribute_flag == AA_CURRENT_DERIVED) {
        attribute_field = "  - derived - current - ";
        count_derived++;
      } else if (attribute_flag == AA_CURRENT_DERIVED_REDECLARING) {
        attribute_field = "  - derived redeclaring - current - ";
// still duplicate
        if (((EDerived_attribute)attr0).getRedeclaring(null) instanceof EExplicit_attribute) {
				  int count_renamed = countAttributeRenamings(attr0);
          if (count_renamed > 0) {
		    		count_derived++;
					}
				}
      } else if (attribute_flag == AA_JAVA_INVERSE) {
        attribute_field = "  - inverse - java inheritance - ";
        count_inverse++;
      } else if (attribute_flag == AA_JAVA_INVERSE_REDECLARING) {
        attribute_field = "  - inverse redeclaring - java inheritance - ";
      } else if (attribute_flag == AA_SUPERTYPE_INVERSE) {
        attribute_field = "  - inverse - non-java inheritance - ";
        count_inverse++;
      } else if (attribute_flag == AA_SUPERTYPE_INVERSE_REDECLARING) {
        attribute_field = "  - inverse redeclaring - non-java inheritance - ";
      } else if (attribute_flag == AA_CURRENT_INVERSE) {
        attribute_field = "  - inverse - current - ";
        count_inverse++;
      } else if (attribute_flag == AA_CURRENT_INVERSE_REDECLARING) {
        attribute_field = "  - inverse redeclaring - current - ";
      } else {
        attribute_field = "// " + attr_name + " - unknown";
      }
	} // for 
}





  void collectAttributesExt(EEntity_definition current, EEntity_definition start, 
                         Vector all_attributes, Vector all_flags, HashSet entities, 
                         boolean inherited_branch) throws SdaiException {
    if (!entities.add(current)) {
      // repeated inheritance
      return;
    }

    // get supertypes
    boolean is_complex = start.getComplex(null);

    if ((!is_complex) || (is_complex && (current == start))) {
      // pre-x      AEntity_definition asuper = current.getSupertypes(null);
//      AEntity_or_view_definition asuper = current.getSupertypes(null);
      AEntity_or_view_definition asuper = current.getGeneric_supertypes(null);
      int count = asuper.getMemberCount();
      SdaiIterator isuper = asuper.createIterator();

      while (isuper.next()) {
        EEntity_definition eds = (EEntity_definition) asuper.getCurrentMemberObject(isuper);
        collectAttributesExt(eds, start, all_attributes, all_flags, entities, inherited_branch);

        if (inherited_branch && (current == start)) {
          inherited_branch = false;
        }
      }
    }

    // explicit attributes
    AExplicit_attribute xa = getExplicit_attributes2(current);
    SdaiIterator ia = null;
    ia = xa.createIterator();

    while (ia.next()) {
      EExplicit_attribute xattr = (EExplicit_attribute) xa.getCurrentMemberObject(ia);

      //       Can also be later redeclared or redeclaring another explicit
      //       attribute itself, not interesting cases for interfaces?
      //       boolean is_later_redeclared; // does not make sense for
      //       interfaces (although used in EC1?)
      boolean is_redeclaring = xattr.testRedeclaring(null);
      all_attributes.add(xattr);

      if (current == start) {
        if (is_redeclaring) {
          printDDebug("explicit redeclaring");
          all_flags.add(new Integer(AA_CURRENT_EXPLICIT_REDECLARING));
        } else {
          all_flags.add(new Integer(AA_CURRENT_EXPLICIT));
        }
      } else if (inherited_branch) {
        if (is_redeclaring) {
          printDDebug("explicit redeclaring inherited");

          if (java_inheritance_enabled) {
            all_flags.add(new Integer(AA_JAVA_EXPLICIT_REDECLARING));
          } else {
            all_flags.add(new Integer(AA_SUPERTYPE_EXPLICIT_REDECLARING));
          }
        } else {
          if (java_inheritance_enabled) {
            all_flags.add(new Integer(AA_JAVA_EXPLICIT));
          } else {
            all_flags.add(new Integer(AA_SUPERTYPE_EXPLICIT));
          }
        }
      } else {
        if (is_redeclaring) {
          printDDebug("explicit redeclaring else?");
          all_flags.add(new Integer(AA_SUPERTYPE_EXPLICIT_REDECLARING));
        } else {
          all_flags.add(new Integer(AA_SUPERTYPE_EXPLICIT));
        }
      }
    	
    }

    ADerived_attribute da = getDerived_attributes(current);
    ia = da.createIterator();

    while (ia.next()) {
      EDerived_attribute dattr = (EDerived_attribute) da.getCurrentMemberObject(ia);
      boolean is_redeclaring = dattr.testRedeclaring(null);
      all_attributes.add(dattr);

      if (current == start) {
        if (is_redeclaring) {
          all_flags.add(new Integer(AA_CURRENT_DERIVED_REDECLARING));
        } else {
          all_flags.add(new Integer(AA_CURRENT_DERIVED));
        }
      } else if (inherited_branch) {
        if (is_redeclaring) {
          if (java_inheritance_enabled) {
            all_flags.add(new Integer(AA_JAVA_DERIVED_REDECLARING));
          } else {
            all_flags.add(new Integer(AA_SUPERTYPE_DERIVED_REDECLARING));
          }
        } else {
          if (java_inheritance_enabled) {
            all_flags.add(new Integer(AA_JAVA_DERIVED));
          } else {
            all_flags.add(new Integer(AA_SUPERTYPE_DERIVED));
          }
        }
      } else {
        if (is_redeclaring) {
          all_flags.add(new Integer(AA_SUPERTYPE_DERIVED_REDECLARING));
        } else {
          all_flags.add(new Integer(AA_SUPERTYPE_DERIVED));
        }
      }
    } // while

//System.out.println("><>< getInverse_attributes() in collectAttributesExt for entity: " + current.getName(null));
    AInverse_attribute ina = getInverse_attributes(current);
    ia = ina.createIterator();

    while (ia.next()) {
      EInverse_attribute nattr = (EInverse_attribute) ina.getCurrentMemberObject(ia);
      boolean is_redeclaring = nattr.testRedeclaring(null);
      all_attributes.add(nattr);

      if (current == start) {
        if (is_redeclaring) {
          all_flags.add(new Integer(AA_CURRENT_INVERSE_REDECLARING));
        } else {
          all_flags.add(new Integer(AA_CURRENT_INVERSE));
        }
      } else if (inherited_branch) {
        if (is_redeclaring) {
          if (java_inheritance_enabled) {
            all_flags.add(new Integer(AA_JAVA_INVERSE_REDECLARING));
          } else {
            all_flags.add(new Integer(AA_SUPERTYPE_INVERSE_REDECLARING));
          }
        } else {
          if (java_inheritance_enabled) {
            all_flags.add(new Integer(AA_JAVA_INVERSE));
          } else {
            all_flags.add(new Integer(AA_SUPERTYPE_INVERSE));
          }
        }
      } else {
        if (is_redeclaring) {
          all_flags.add(new Integer(AA_SUPERTYPE_INVERSE_REDECLARING));
        } else {
          all_flags.add(new Integer(AA_SUPERTYPE_INVERSE));
        }
      }
    }

    //      return all_attributes;
/*
   	Iterator iterator1 = all_attributes.iterator();
   	while (iterator1.hasNext()) {
   		EAttribute print_attribute = (EAttribute)iterator1.next();
			System.out.println("XOXO attribute: " + print_attribute);
   	}
   	Iterator iterator2 = all_flags.iterator();
   	while (iterator2.hasNext()) {
   		Integer flag = (Integer)iterator2.next();
			System.out.println("XOXO flag: " + flag.intValue());
   	}
*/
 }


  void collectAttributes_old(EEntity_definition current, EEntity_definition start, 
                             Vector all_attributes, Vector all_flags, HashSet entities, 
                             boolean inherited_branch)
                      throws SdaiException {
    if (!entities.add(current)) {
      // repeated inheritance
      return;
    }

    // get supertypes
    boolean is_complex = start.getComplex(null);

    if ((!is_complex) || (is_complex && (current == start))) {
      // pre-x      AEntity_definition asuper = current.getSupertypes(null);
//      AEntity_or_view_definition asuper = current.getSupertypes(null);
      AEntity_or_view_definition asuper = current.getGeneric_supertypes(null);
      int count = asuper.getMemberCount();
      SdaiIterator isuper = asuper.createIterator();

      while (isuper.next()) {
        EEntity_definition eds = (EEntity_definition) asuper.getCurrentMemberObject(isuper);
        collectAttributes(eds, start, all_attributes, all_flags, entities, inherited_branch);

        if (inherited_branch && (current == start)) {
          inherited_branch = false;
        }
      }
    }

    // have to go through attributes, but the order is not guaranteed.
    // let's use explicit_attribute for explicit attributes at least.
    //RR- explicit_attributes removed-      AExplicit_attribute xa = current.getExplicit_attributes(null);
    AExplicit_attribute xa = getExplicit_attributes(current);
    SdaiIterator ia = null;
    EAttribute attr = null;


    // explicit attributes
    ia = xa.createIterator();

    while (ia.next()) {
      EExplicit_attribute xattr = (EExplicit_attribute) xa.getCurrentMemberObject(ia);

      // can also be later redeclared or redeclaring another explicit attribute itself, not interesting cases for interfaces?
      // boolean is_later_redeclared; // does not make sense for interfaces (although used in EC1?)
      boolean is_redeclaring = xattr.testRedeclaring(null);
      all_attributes.add(xattr);

      if (current == start) {
        if (is_redeclaring) {
          //            printDDebug("explicit redeclaring 3");
          all_flags.add(new Integer(AA_CURRENT_EXPLICIT_REDECLARING));
        } else {
          all_flags.add(new Integer(AA_CURRENT_EXPLICIT));
        }
      } else if (inherited_branch) {
        if (is_redeclaring) {
          //            printDDebug("explicit redeclaring 3");
          if (java_inheritance_enabled) {
            all_flags.add(new Integer(AA_JAVA_EXPLICIT_REDECLARING));
          } else {
            all_flags.add(new Integer(AA_SUPERTYPE_EXPLICIT_REDECLARING));
          }
        } else {
          if (java_inheritance_enabled) {
            all_flags.add(new Integer(AA_JAVA_EXPLICIT));
          } else {
            all_flags.add(new Integer(AA_SUPERTYPE_EXPLICIT));
          }
        }
      } else {
        if (is_redeclaring) {
          //            printDDebug("explicit redeclaring 3");
          all_flags.add(new Integer(AA_SUPERTYPE_EXPLICIT_REDECLARING));
        } else {
          all_flags.add(new Integer(AA_SUPERTYPE_EXPLICIT));
        }
      }
    }

    AAttribute aattr = current.getAttributes(null, null);
    ia = aattr.createIterator();

    while (ia.next()) {
      attr = (EAttribute) aattr.getCurrentMemberObject(ia);

      if (attr instanceof EDerived_attribute) {
        boolean is_redeclaring = ((EDerived_attribute) attr).testRedeclaring(null);
        all_attributes.add(attr);

        if (current == start) {
          if (is_redeclaring) {
            all_flags.add(new Integer(AA_CURRENT_DERIVED_REDECLARING));
          } else {
            all_flags.add(new Integer(AA_CURRENT_DERIVED));
          }
        } else if (inherited_branch) {
          if (is_redeclaring) {
            if (java_inheritance_enabled) {
              all_flags.add(new Integer(AA_JAVA_DERIVED_REDECLARING));
            } else {
              all_flags.add(new Integer(AA_SUPERTYPE_DERIVED_REDECLARING));
            }
          } else {
            if (java_inheritance_enabled) {
              all_flags.add(new Integer(AA_JAVA_DERIVED));
            } else {
              all_flags.add(new Integer(AA_SUPERTYPE_DERIVED));
            }
          }
        } else {
          if (is_redeclaring) {
            all_flags.add(new Integer(AA_SUPERTYPE_DERIVED_REDECLARING));
          } else {
            all_flags.add(new Integer(AA_SUPERTYPE_DERIVED));
          }
        }
      } else if (attr instanceof EInverse_attribute) {
        boolean is_redeclaring = ((EInverse_attribute) attr).testRedeclaring(null);
        all_attributes.add(attr);

        if (current == start) {
          if (is_redeclaring) {
            all_flags.add(new Integer(AA_CURRENT_INVERSE_REDECLARING));
          } else {
            all_flags.add(new Integer(AA_CURRENT_INVERSE));
          }
        } else if (inherited_branch) {
          if (is_redeclaring) {
            if (java_inheritance_enabled) {
              all_flags.add(new Integer(AA_JAVA_INVERSE_REDECLARING));
            } else {
              all_flags.add(new Integer(AA_SUPERTYPE_INVERSE_REDECLARING));
            }
          } else {
            if (java_inheritance_enabled) {
              all_flags.add(new Integer(AA_JAVA_INVERSE));
            } else {
              all_flags.add(new Integer(AA_SUPERTYPE_INVERSE));
            }
          }
        } else {
          if (is_redeclaring) {
            all_flags.add(new Integer(AA_SUPERTYPE_INVERSE_REDECLARING));
          } else {
            all_flags.add(new Integer(AA_SUPERTYPE_INVERSE));
          }
        }
      }
    }

    //      return all_attributes;
  }

  void collectComplexAttributes(EEntity_definition current, Vector all_attributes, Vector all_flags)
                         throws SdaiException {
    CompareUppercaseEntities ce = new CompareUppercaseEntities();
    TreeSet asuper = new TreeSet(ce);
    getExternalMappingParts(current, asuper);

    Iterator isuper = asuper.iterator();

    while (isuper.hasNext()) {
      EEntity_definition eds = (EEntity_definition) isuper.next();
      AExplicit_attribute xa = getExplicit_attributes(eds);
      SdaiIterator ia = null;


      // explicit attributes
      ia = xa.createIterator();

      while (ia.next()) {
        EExplicit_attribute xattr = (EExplicit_attribute) xa.getCurrentMemberObject(ia);

        // can also be later redeclared or redeclaring another explicit attribute itself, not interesting cases for interfaces?
        boolean is_redeclaring = xattr.testRedeclaring(null);
        all_attributes.add(xattr);

        if (is_redeclaring) {
          all_flags.add(new Integer(AA_SUPERTYPE_EXPLICIT_REDECLARING));
        } else {
          all_flags.add(new Integer(AA_SUPERTYPE_EXPLICIT));
        }
      }

      ADerived_attribute da = getDerived_attributes(eds);
      ia = da.createIterator();

      while (ia.next()) {
        EDerived_attribute dattr = (EDerived_attribute) da.getCurrentMemberObject(ia);
        boolean is_redeclaring = dattr.testRedeclaring(null);
        all_attributes.add(dattr);

        if (is_redeclaring) {
          all_flags.add(new Integer(AA_SUPERTYPE_DERIVED_REDECLARING));
        } else {
          all_flags.add(new Integer(AA_SUPERTYPE_DERIVED));
        }
      }

//System.out.println("><>< getInverse_attributes() in collectComplexAttributes for entity: " + eds.getName(null));
      AInverse_attribute ina = getInverse_attributes(eds);
      ia = ina.createIterator();

      while (ia.next()) {
        EInverse_attribute nattr = (EInverse_attribute) ina.getCurrentMemberObject(ia);
        boolean is_redeclaring = nattr.testRedeclaring(null);
        all_attributes.add(nattr);

        if (is_redeclaring) {
          all_flags.add(new Integer(AA_SUPERTYPE_INVERSE_REDECLARING));
        } else {
          all_flags.add(new Integer(AA_SUPERTYPE_INVERSE));
        }
      }
    }

    //      return all_attributes;
  }

  void collectComplexAttributesExt(EEntity_definition current, Vector all_attributes, Vector all_flags)
                         throws SdaiException {
    CompareUppercaseEntities ce = new CompareUppercaseEntities();
    TreeSet asuper = new TreeSet(ce);
    getExternalMappingParts(current, asuper);

    Iterator isuper = asuper.iterator();

    while (isuper.hasNext()) {
      EEntity_definition eds = (EEntity_definition) isuper.next();
//      AExplicit_attribute xa = getExplicit_attributes(eds);
      AExplicit_attribute xa = getExplicit_attributes2(eds);
      SdaiIterator ia = null;


      // explicit attributes
      ia = xa.createIterator();

      while (ia.next()) {
        EExplicit_attribute xattr = (EExplicit_attribute) xa.getCurrentMemberObject(ia);

        // can also be later redeclared or redeclaring another explicit attribute itself, not interesting cases for interfaces?
        boolean is_redeclaring = xattr.testRedeclaring(null);
        all_attributes.add(xattr);

        if (is_redeclaring) {
          all_flags.add(new Integer(AA_SUPERTYPE_EXPLICIT_REDECLARING));
        } else {
          all_flags.add(new Integer(AA_SUPERTYPE_EXPLICIT));
        }
      }

      ADerived_attribute da = getDerived_attributes(eds);
      ia = da.createIterator();

      while (ia.next()) {
        EDerived_attribute dattr = (EDerived_attribute) da.getCurrentMemberObject(ia);
        boolean is_redeclaring = dattr.testRedeclaring(null);
        all_attributes.add(dattr);

        if (is_redeclaring) {
          all_flags.add(new Integer(AA_SUPERTYPE_DERIVED_REDECLARING));
        } else {
          all_flags.add(new Integer(AA_SUPERTYPE_DERIVED));
        }
      }

//System.out.println("><>< getInverse_attributes() in collectComplexAttributesExt for entity: " + eds.getName(null));
      AInverse_attribute ina = getInverse_attributes(eds);
      ia = ina.createIterator();

      while (ia.next()) {
        EInverse_attribute nattr = (EInverse_attribute) ina.getCurrentMemberObject(ia);
        boolean is_redeclaring = nattr.testRedeclaring(null);
        all_attributes.add(nattr);

        if (is_redeclaring) {
          all_flags.add(new Integer(AA_SUPERTYPE_INVERSE_REDECLARING));
        } else {
          all_flags.add(new Integer(AA_SUPERTYPE_INVERSE));
        }
      }
    }

    //      return all_attributes;
  }


  void collectComplexAttributes_old(EEntity_definition current, Vector all_attributes, 
                                    Vector all_flags) throws SdaiException {
    // get supertypes
    //      AEntity_definition asuper = getComplexSupertypes(current);
    CompareUppercaseEntities ce = new CompareUppercaseEntities();
    TreeSet asuper = new TreeSet(ce);
    getExternalMappingParts(current, asuper);

    //      int count = asuper.getMemberCount();
    //      SdaiIterator isuper = asuper.createIterator();
    Iterator isuper = asuper.iterator();

    //      while (isuper.next()) {
    while (isuper.hasNext()) {
      //         EEntity_definition eds = (EEntity_definition)asuper.getCurrentMemberObject(isuper);
      EEntity_definition eds = (EEntity_definition) isuper.next();

      //RR- explicit_attributes removed-         AExplicit_attribute xa = eds.getExplicit_attributes(null);
      AExplicit_attribute xa = getExplicit_attributes(eds);
      SdaiIterator ia = null;
      EAttribute attr = null;


      // explicit attributes
      ia = xa.createIterator();

      while (ia.next()) {
        EExplicit_attribute xattr = (EExplicit_attribute) xa.getCurrentMemberObject(ia);

        // can also be later redeclared or redeclaring another explicit attribute itself, not interesting cases for interfaces?
        boolean is_redeclaring = xattr.testRedeclaring(null);
        all_attributes.add(xattr);

        if (is_redeclaring) {
          all_flags.add(new Integer(AA_SUPERTYPE_EXPLICIT_REDECLARING));
        } else {
          all_flags.add(new Integer(AA_SUPERTYPE_EXPLICIT));
        }
      }

      AAttribute aattr = eds.getAttributes(null, null);
      ia = aattr.createIterator();

      while (ia.next()) {
        attr = (EAttribute) aattr.getCurrentMemberObject(ia);

        if (attr instanceof EDerived_attribute) {
          boolean is_redeclaring = ((EDerived_attribute) attr).testRedeclaring(null);
          all_attributes.add(attr);

          if (is_redeclaring) {
            all_flags.add(new Integer(AA_SUPERTYPE_DERIVED_REDECLARING));

            // printDDebug("complex derived redeclaring: " + attr.getName(null) + " in entity " + current.getName(null));
          } else {
            all_flags.add(new Integer(AA_SUPERTYPE_DERIVED));
          }
        } else if (attr instanceof EInverse_attribute) {
          boolean is_redeclaring = ((EInverse_attribute) attr).testRedeclaring(null);
          all_attributes.add(attr);

          if (is_redeclaring) {
            all_flags.add(new Integer(AA_SUPERTYPE_INVERSE_REDECLARING));
          } else {
            all_flags.add(new Integer(AA_SUPERTYPE_INVERSE));
          }
        }
      }
    }

    //      return all_attributes;
  }

  void collectAttributes_old_old(EEntity_definition current, EEntity_definition start, 
                                 Vector all_attributes, Vector all_flags, HashSet entities, 
                                 boolean inherited_branch)
                          throws SdaiException {
    if (!entities.add(current)) {
      // repeated inheritance
      return;
    }

    // get supertypes
    boolean is_complex = start.getComplex(null);

    if ((!is_complex) || (is_complex && (current == start))) {
      // pre-X AEntity_definition asuper = current.getSupertypes(null);
//      AEntity_or_view_definition asuper = current.getSupertypes(null);
      AEntity_or_view_definition asuper = current.getGeneric_supertypes(null);
      int count = asuper.getMemberCount();
      SdaiIterator isuper = asuper.createIterator();

      while (isuper.next()) {
        EEntity_definition eds = (EEntity_definition) asuper.getCurrentMemberObject(isuper);
        collectAttributes(eds, start, all_attributes, all_flags, entities, inherited_branch);

        if (inherited_branch && (current == start)) {
          inherited_branch = false;
        }
      }
    }

    // have to go through attributes, but the order is not guaranteed.
    // let's use explicit_attribute for explicit attributes at least.
    //RR- explicit_attributes removed-      AExplicit_attribute xa = current.getExplicit_attributes(null);
    AExplicit_attribute xa = getExplicit_attributes(current);
    SdaiIterator ia = null;
    EAttribute attr = null;


    // explicit attributes
    ia = xa.createIterator();

    while (ia.next()) {
      EExplicit_attribute xattr = (EExplicit_attribute) xa.getCurrentMemberObject(ia);

      // can also be later redeclared or redeclaring another explicit attribute itself, not interesting cases for interfaces?
      // boolean is_later_redeclared; // does not make sense for interfaces (although used in EC1?)
      boolean is_redeclaring = xattr.testRedeclaring(null);
      all_attributes.add(xattr);

      if (current == start) {
        all_flags.add(new Integer(AA_CURRENT_EXPLICIT));
      } else if (inherited_branch) {
        all_flags.add(new Integer(AA_JAVA_EXPLICIT));
      } else {
        all_flags.add(new Integer(AA_SUPERTYPE_EXPLICIT));
      }
    }

    //      return all_attributes;
  }

  PrintWriter getPrintWriter(String file_name) throws IOException {
		if (output_directory != null) {
			file_name = output_directory + File.separator + file_name;
		}
    FileOutputStream fos = new FileOutputStream(file_name);
    OutputStreamWriter osw = new OutputStreamWriter(fos);
    PrintWriter pw = new PrintWriter(osw);

    return pw;
  }


  /*
  	if the file already exists, return null
  */
  PrintWriter getPrintWriterIfNew(String file_name) throws IOException {
		if (output_directory != null) {
			file_name = output_directory + File.separator + file_name;
		}
		File fl = new File(file_name);
		if (fl.exists()) {
			return null;
		}
//    FileOutputStream fos = new FileOutputStream(file_name);
    FileOutputStream fos = new FileOutputStream(fl);
    OutputStreamWriter osw = new OutputStreamWriter(fos);
    PrintWriter pw = new PrintWriter(osw);

    return pw;
  }

  void printDebug2(String str) {
    if (debug_mode) {
      System.out.println("Java Backend Debug> " + str);
    }
  }

  void printVerbose2(String str) {
    if (verbose_mode) {
      System.out.println("Java Backend Verbose> " + str);
    }
  }

  void printError(String str) {
    System.out.println("Java Backend Error> " + str);
  }

  void printOk(String str) {
    System.out.println("Java Backend> " + str);
  }

  //============================================================ start =================================================
  // checks if a select contains no entities, one entity or more than one entity, used mainly to determine if usedin is needed and what parameter type
  // to generate - a specific entity or a generic one.

	// UPDATE - if select contains as its elements at any depth of nestedness one or more EXTENSIBLE selects,
	// to be safe, we have to assume that more than one entity is possible



  Object entitiesInSelect(ESelect_type st, EEntity_definition ed)
                   throws SdaiException {

	 if (!select_loops.add(st)) {
      System.out.println("WARNING (03): select type loop detected" + st);
     	// what to return - returning a safe option at the current time - more than one entity is possible
     	// because previous state is not available here
     	return (new Integer(2)); 
   }

    HashSet all_selects = new HashSet();
    EEntity an_ss;
    EEntity an_ss_super;
//    ANamed_type ant = st.getSelections(null);
//    ANamed_type ant = st.getLocal_selections(null);
    ANamed_type ant = getSelections(st);
    SdaiIterator iant = ant.createIterator();
    all_selects.add(st);

    while (iant.next()) {
      an_ss = (ENamed_type) ant.getCurrentMemberObject(iant);

      while (an_ss instanceof EDefined_type) {
        EEntity domain = ((EDefined_type) an_ss).getDomain(null);
        an_ss_super = an_ss;
        an_ss = domain;
      }

      if (an_ss instanceof ESelect_type) {
        if (an_ss instanceof EExtensible_select_type) {
        	return (new Integer(2));
				}
        if (all_selects.add(an_ss)) {
          Object result = entitiesInSelect((ESelect_type) an_ss, ed);

          if (result instanceof Integer) {
            return result;
          }

          ed = (EEntity_definition) result;
        }
      } else if (an_ss instanceof EEntity_definition) {
        // if no entities so far, this is the first one
        // if we already have an entity - check if the same. If not the same, multiple entities, exit, if the same - do nothing.
        if (ed == null) {
          ed = (EEntity_definition) an_ss;
        } else if (ed != an_ss) {
          return (new Integer(2));
        }
      } else if (an_ss instanceof EAggregation_type) {
        EEntity ass = an_ss;
        EAggregation_type aas = (EAggregation_type) an_ss;
        an_ss = aas.getElement_type(null);

        for (;;) {
          boolean done_something = false;

          if (an_ss instanceof EDefined_type) {
            ass = an_ss;
            an_ss = ((EDefined_type) an_ss).getDomain(null);
            done_something = true;
          } else if (an_ss instanceof EAggregation_type) {
            ass = an_ss;
            an_ss = ((EAggregation_type) an_ss).getElement_type(null);
            done_something = true;
          }

          if (!done_something) {
            break;
          }
        }

        if (an_ss instanceof ESelect_type) {
	        if (an_ss instanceof EExtensible_select_type) {
  	      	return (new Integer(2));
					}
          if (all_selects.add(an_ss)) {
            Object result = entitiesInSelect((ESelect_type) an_ss, ed);

            if (result instanceof Integer) {
              return result;
            }

            ed = (EEntity_definition) result;
          }
        } else if (an_ss instanceof EEntity_definition) {
          // if no entities so far, this is the first one
          // if we already have an entity - check if the same. If not the same, multiple entities, exit, if the same - do nothing.
          if (ed == null) {
            ed = (EEntity_definition) an_ss;
          } else if (ed != an_ss) {
            return (new Integer(2));
          }
        } else {
          // not interesting, can not hold entities
        }
      } else {
        // not interesting, can not hold entities
      }
    }

    return ed;
  }



  Object entitiesInSelect_old(ESelect_type st, EEntity_definition ed)
                   throws SdaiException {
    HashSet all_selects = new HashSet();
    EEntity an_ss;
    EEntity an_ss_super;
//    ANamed_type ant = st.getSelections(null);
//    ANamed_type ant = st.getLocal_selections(null);
    ANamed_type ant = getSelections(st);
    SdaiIterator iant = ant.createIterator();
    all_selects.add(st);

    while (iant.next()) {
      an_ss = (ENamed_type) ant.getCurrentMemberObject(iant);

      while (an_ss instanceof EDefined_type) {
        EEntity domain = ((EDefined_type) an_ss).getDomain(null);
        an_ss_super = an_ss;
        an_ss = domain;
      }

      if (an_ss instanceof ESelect_type) {
        if (an_ss instanceof EExtensible_select_type) {
        	return (new Integer(2));
				}
        if (all_selects.add(an_ss)) {
          Object result = entitiesInSelect((ESelect_type) an_ss, ed);

          if (result instanceof Integer) {
            return result;
          }

          ed = (EEntity_definition) result;
        }
      } else if (an_ss instanceof EEntity_definition) {
        // if no entities so far, this is the first one
        // if we already have an entity - check if the same. If not the same, multiple entities, exit, if the same - do nothing.
        if (ed == null) {
          ed = (EEntity_definition) an_ss;
        } else if (ed != an_ss) {
          return (new Integer(2));
        }
      } else if (an_ss instanceof EAggregation_type) {
        EEntity ass = an_ss;
        EAggregation_type aas = (EAggregation_type) an_ss;
        an_ss = aas.getElement_type(null);

        for (;;) {
          boolean done_something = false;

          if (an_ss instanceof EDefined_type) {
            ass = an_ss;
            an_ss = ((EDefined_type) an_ss).getDomain(null);
            done_something = true;
          } else if (an_ss instanceof EAggregation_type) {
            ass = an_ss;
            an_ss = ((EAggregation_type) an_ss).getElement_type(null);
            done_something = true;
          }

          if (!done_something) {
            break;
          }
        }

        if (an_ss instanceof ESelect_type) {
	        if (an_ss instanceof EExtensible_select_type) {
  	      	return (new Integer(2));
					}
          if (all_selects.add(an_ss)) {
            Object result = entitiesInSelect((ESelect_type) an_ss, ed);

            if (result instanceof Integer) {
              return result;
            }

            ed = (EEntity_definition) result;
          }
        } else if (an_ss instanceof EEntity_definition) {
          // if no entities so far, this is the first one
          // if we already have an entity - check if the same. If not the same, multiple entities, exit, if the same - do nothing.
          if (ed == null) {
            ed = (EEntity_definition) an_ss;
          } else if (ed != an_ss) {
            return (new Integer(2));
          }
        } else {
          // not interesting, can not hold entities
        }
      } else {
        // not interesting, can not hold entities
      }
    }

    return ed;
  }





  //---- references in select ------ for changeReferences() --------------------------------------------------------
  // checks if select contains entities, entities in aggregates or entities + entities in aggregates
  int referencesInSelect(ESelect_type st, int status) throws SdaiException {

    HashSet all_selects = new HashSet();
    EEntity an_ss;
    EEntity an_ss_super;


	 if (!select_loops.add(st)) {
      System.out.println("WARNING (01): select type loop detected" + st);
   		return status;  
   }


//    ANamed_type ant = st.getSelections(null);
//    ANamed_type ant = st.getLocal_selections(null);
      ANamed_type ant = getSelections(st);
    SdaiIterator iant = ant.createIterator();
    all_selects.add(st);

    while (iant.next()) {
      an_ss = (ENamed_type) ant.getCurrentMemberObject(iant);

      // printDDebug("##### " +((ENamed_type)an_ss).getName(null));
      while (an_ss instanceof EDefined_type) {
        EEntity domain = ((EDefined_type) an_ss).getDomain(null);
        an_ss_super = an_ss;
        an_ss = domain;
      }

      if (an_ss instanceof ESelect_type) {
        if (all_selects.add(an_ss)) {
          status = referencesInSelect((ESelect_type) an_ss, status);

          if (status == 11) {
            return status;
          }
        }
      } else if (an_ss instanceof EEntity_definition) {
        if (status == 0) {
          status = 1;
        } else if (status == 10) {
          status = 11;
        } else if (status == 1) {
          // nothing
        } else if (status == 11) {
          // nothing
        }

        //            return status;
      } else if (an_ss instanceof EAggregation_type) {
        EEntity ass = an_ss;
        EAggregation_type aas = (EAggregation_type) an_ss;
        an_ss = aas.getElement_type(null);

        for (;;) {
          boolean done_something = false;

          if (an_ss instanceof EDefined_type) {
            ass = an_ss;
            an_ss = ((EDefined_type) an_ss).getDomain(null);
            done_something = true;
          } else if (an_ss instanceof EAggregation_type) {
            ass = an_ss;
            an_ss = ((EAggregation_type) an_ss).getElement_type(null);
            done_something = true;
          }

          if (!done_something) {
            break;
          }
        }

        if (an_ss instanceof ESelect_type) {
          if (all_selects.add(an_ss)) {
            status = referencesInSelect((ESelect_type) an_ss, status);

            if (status == 11) {
              return status;
            }
          }
        } else if (an_ss instanceof EEntity_definition) {
          if (status == 0) {
            status = 10;
          } else if (status == 1) {
            status = 11;
          } else if (status == 10) {
            // nothing
          } else if (status == 11) {
            // nothing
          }

          //            return status;
        } else {
          // not interesting, can not hold entities
        }
      } else {
        // not interesting, can not hold entities
      }
    }

    return status;
  }




  //---- references in select ------ for changeReferences() --------------------------------------------------------
  // checks if select contains entities, entities in aggregates or entities + entities in aggregates
  int referencesInSelect_old(ESelect_type st, int status) throws SdaiException {
    HashSet all_selects = new HashSet();
    EEntity an_ss;
    EEntity an_ss_super;
//    ANamed_type ant = st.getSelections(null);
//    ANamed_type ant = st.getLocal_selections(null);
      ANamed_type ant = getSelections(st);
    SdaiIterator iant = ant.createIterator();
    all_selects.add(st);

    while (iant.next()) {
      an_ss = (ENamed_type) ant.getCurrentMemberObject(iant);

      // printDDebug("##### " +((ENamed_type)an_ss).getName(null));
      while (an_ss instanceof EDefined_type) {
        EEntity domain = ((EDefined_type) an_ss).getDomain(null);
        an_ss_super = an_ss;
        an_ss = domain;
      }

      if (an_ss instanceof ESelect_type) {
        if (all_selects.add(an_ss)) {
          status = referencesInSelect((ESelect_type) an_ss, status);

          if (status == 11) {
            return status;
          }
        }
      } else if (an_ss instanceof EEntity_definition) {
        if (status == 0) {
          status = 1;
        } else if (status == 10) {
          status = 11;
        } else if (status == 1) {
          // nothing
        } else if (status == 11) {
          // nothing
        }

        //            return status;
      } else if (an_ss instanceof EAggregation_type) {
        EEntity ass = an_ss;
        EAggregation_type aas = (EAggregation_type) an_ss;
        an_ss = aas.getElement_type(null);

        for (;;) {
          boolean done_something = false;

          if (an_ss instanceof EDefined_type) {
            ass = an_ss;
            an_ss = ((EDefined_type) an_ss).getDomain(null);
            done_something = true;
          } else if (an_ss instanceof EAggregation_type) {
            ass = an_ss;
            an_ss = ((EAggregation_type) an_ss).getElement_type(null);
            done_something = true;
          }

          if (!done_something) {
            break;
          }
        }

        if (an_ss instanceof ESelect_type) {
          if (all_selects.add(an_ss)) {
            status = referencesInSelect((ESelect_type) an_ss, status);

            if (status == 11) {
              return status;
            }
          }
        } else if (an_ss instanceof EEntity_definition) {
          if (status == 0) {
            status = 10;
          } else if (status == 1) {
            status = 11;
          } else if (status == 10) {
            // nothing
          } else if (status == 11) {
            // nothing
          }

          //            return status;
        } else {
          // not interesting, can not hold entities
        }
      } else {
        // not interesting, can not hold entities
      }
    }

    return status;
  }

  //------ end of references in select -----------------------------------------------------------------------------


/* before invoking for the 1st time:
        int count = 1;
        int[] indeces = new int[500];
        int depth = 0;
        int depth_count = 0;
        boolean with_type = false;
        Vector current_nodes = new Vector();
        Vector current_node_strings = new Vector();
        paths1 = new SelectPaths();
        paths1.owner = (ESelect_type) an_ss;
*/


  int calculateSelectPaths(int count, Vector current_nodes, Vector current_node_strings, 
                           int[] indeces, int depth, int depth_count, SelectPaths paths1, 
                           ESelect_type st, boolean with_type)
                    throws SdaiException {

// System.out.println("<calculateSelectPaths>: select_type: " + st  + ", depth: " + depth);
// System.out.println("<calculateSelectPaths>: current nodes: " + current_node_strings);


	 if (count == 1) { // let's say that this is 1st time (count seems to be not used for anything - until now)
	    select_loops = new HashSet();	  
	 } 
   count++;
	 if (!select_loops.add(st)) {
			// we already were in this select type
      System.out.println("WARNING (02): select type loop detected" + st);
//      System.out.println("<!!!> A loop: the same select type detected: " + st);
   		// not sure what to return: 0-entity, 1-type, 2-mixed, if there is a loop, still any of these may be true
   		// but a non-entity perhaps was detected in the 1st iteration through that type, so will not add a worse case that may not be there
   		return 0;  
   }


    boolean type_present = false;
    int is_pure = -1;
    int returned_pure = -1;
    boolean purity_type_present = false;
    boolean purity_entity_present = false;
    indeces[depth] = depth_count; //  indeces not used, it seems.
    depth++;
    depth_count = 0;


if (st instanceof EExtensible_select_type) {
	purity_entity_present = true;
}


    // here goes actions on the way inside if any
    EEntity an_ss;
    EEntity an_ss_super;
    an_ss_super = null;

//    ANamed_type ant = st.getSelections(null);
//    ANamed_type ant = st.getLocal_selections(null);
      ANamed_type ant = getSelections(st);
    SdaiIterator iant = ant.createIterator();

    while (iant.next()) {
      for (int k = depth_count; k > 0; k--) {
        current_nodes.removeElementAt(current_nodes.size() - 1);
        current_node_strings.removeElementAt(current_node_strings.size() - 1);
      }

      depth_count = 0;
      an_ss = (ENamed_type) ant.getCurrentMemberObject(iant);

      while (an_ss instanceof EDefined_type) {
        EEntity domain = ((EDefined_type) an_ss).getDomain(null);

        if (!(domain instanceof ESelect_type)) {
          if (!type_present) {
            current_nodes.addElement(an_ss);
            current_node_strings.addElement(getEEntityPackage(an_ss));
            depth_count++;
            depth++;
            type_present = true;
            with_type = true;
          } else {
            // guess nothing here.
          }
        }

        an_ss_super = an_ss;
        an_ss = domain;
      }

      Vector path;
      Vector path_strings;
      type_present = false;

      if (an_ss instanceof ESelect_type) {
        int ret_pur = calculateSelectPaths(count, current_nodes, current_node_strings, indeces, 
                                           depth, depth_count, paths1, (ESelect_type) an_ss, 
                                           with_type);

        if (returned_pure < 0) {
          returned_pure = ret_pur;
        } else if (returned_pure != ret_pur) {
          returned_pure = 2;
        }
      } else {
        if (an_ss instanceof EEntity_definition) {
          /*
          if (with_type) {
           current_nodes.addElement(an_ss);
          current_node_strings.addElement(getEEntityPackage(an_ss));
           depth_count++;
           purity_entity_present = true;
           paths1.value_strings.addElement(getEEntityPackage(an_ss)); // still, for new approach to entities in selects, it is not needed.
           paths1.express_types.addElement(new Integer(SelectPaths.XT_ENTITY));
          paths1.aggregate_bases.addElement(new Integer(SelectPaths.AB_NOT_AGGREGATE));
            } else {
           */

          //                current_nodes.addElement(an_ss);
          //              current_node_strings.addElement(getEEntityPackage(an_ss));
          //               depth_count++;
          //               paths1.value_strings.addElement(getEEntityPackage(an_ss)); // still, for new approach to entities in selects, it is not needed.
          paths1.value_strings.addElement("EEntity"); // still, for new approach to entities in selects, it is not needed.
          paths1.express_types.addElement(new Integer(SelectPaths.XT_ENTITY));
          paths1.aggregate_bases.addElement(new Integer(SelectPaths.AB_NOT_AGGREGATE));

          //            paths1.express_names.add("E" + ((EEntity_definition)an_ss).getName(null));
          //               }
          if (with_type) {
            purity_type_present = true;

            //                  with_type = false;
          } else {
            purity_entity_present = true;
          }
        } else {
          purity_type_present = true;
        }

        with_type = false;
        path = (Vector) current_nodes.clone();
        path_strings = (Vector) current_node_strings.clone();
//        count = 1; do we use it for any reason, if not, I will use it to indicated the 1st invokation


        //         paths1.return_symbols.add(an_ss);
        paths1.paths.addElement(path);
        paths1.path_strings.addElement(path_strings);

        if (an_ss instanceof EInteger_type) {
          paths1.value_strings.addElement("int");
          paths1.express_types.addElement(new Integer(SelectPaths.XT_INTEGER));
          paths1.aggregate_bases.addElement(new Integer(SelectPaths.AB_NOT_AGGREGATE));

          //            paths1.express_names.add("INTEGER");
        } else if (an_ss instanceof ENumber_type) {
          paths1.value_strings.addElement("double");
          paths1.express_types.addElement(new Integer(SelectPaths.XT_NUMBER));
          paths1.aggregate_bases.addElement(new Integer(SelectPaths.AB_NOT_AGGREGATE));

          //            paths1.express_names.add("NUMBER");
        } else if (an_ss instanceof EReal_type) {
          paths1.value_strings.addElement("double");
          paths1.express_types.addElement(new Integer(SelectPaths.XT_REAL));
          paths1.aggregate_bases.addElement(new Integer(SelectPaths.AB_NOT_AGGREGATE));

          //            paths1.express_names.add("NUMBER");
        } else if (an_ss instanceof EString_type) {
          paths1.value_strings.addElement("String");
          paths1.express_types.addElement(new Integer(SelectPaths.XT_STRING));
          paths1.aggregate_bases.addElement(new Integer(SelectPaths.AB_NOT_AGGREGATE));

          //            paths1.express_names.add("STRING");
        } else if (an_ss instanceof ELogical_type) {
          paths1.value_strings.addElement("int");
          paths1.express_types.addElement(new Integer(SelectPaths.XT_LOGICAL));
          paths1.aggregate_bases.addElement(new Integer(SelectPaths.AB_NOT_AGGREGATE));

          //            paths1.express_names.add("LOGICAL");
        } else if (an_ss instanceof EBoolean_type) {
          paths1.value_strings.addElement("boolean");
          paths1.express_types.addElement(new Integer(SelectPaths.XT_BOOLEAN));
          paths1.aggregate_bases.addElement(new Integer(SelectPaths.AB_NOT_AGGREGATE));

          //            paths1.express_names.add("BOOLEAN");
        } else if (an_ss instanceof EBinary_type) {
          paths1.value_strings.addElement("Binary");
          paths1.express_types.addElement(new Integer(SelectPaths.XT_BINARY));
          paths1.aggregate_bases.addElement(new Integer(SelectPaths.AB_NOT_AGGREGATE));

          //            paths1.express_names.add("BINARY");
        } else if (an_ss instanceof EEnumeration_type) {
          paths1.value_strings.addElement("int");
          paths1.express_types.addElement(new Integer(SelectPaths.XT_ENUMERATION));
          paths1.aggregate_bases.addElement(new Integer(SelectPaths.AB_NOT_AGGREGATE));

          //            paths1.express_names.add("E" + ((EDefined_type)an_ss_super).getName(null)); // the was .up in the original
        } else if (an_ss instanceof EAggregation_type) {
          paths1.express_types.addElement(new Integer(SelectPaths.XT_AGGREGATE));

          //         paths1.express_names.add("A" + an_ss.getName(null)); // an_ss.base.name
          EEntity ass = an_ss;
          EAggregation_type aas = (EAggregation_type) an_ss;
          String aggr_prefices = "";
          an_ss = aas.getElement_type(null);

          int aggregate_depth = 1;

          for (;;) {
            boolean done_something = false;

            if (an_ss instanceof EDefined_type) {
              ass = an_ss;
              an_ss = ((EDefined_type) an_ss).getDomain(null);
              done_something = true;
            } else if (an_ss instanceof EAggregation_type) {
              aggr_prefices += "a";
              aggregate_depth++;
              ass = an_ss;
              an_ss = ((EAggregation_type) an_ss).getElement_type(null);
              done_something = true;
            }

            if (!done_something) {
              break;
            }
          }

          String aggr_prefix = "A" + aggr_prefices;

          // these two lines used to store necessary depth - which aggregate classes need to be generated
          //           int the_aggr_depth = aggr_prefices.length() + 1;
          //           if (an_ss.aggr_depth < the_aggr_depth) an_ss.aggr_depth = the_aggr_depth;
          if (an_ss instanceof ESelect_type) {
            paths1.value_strings.addElement(getAggregatePackage(aggr_prefix, ass));
            paths1.aggregate_bases.addElement(new Integer(SelectPaths.AB_SELECT));
//System.out.println("UAD-07");
            updateAggregateDepth((ENamed_type) ass, aggregate_depth);
          } else if (an_ss instanceof EEntity_definition) {
            // in EC1 there is the same lines as in the non-aggregate entities - adding to current_nodes, depth_count, etc - probably a bug.
            paths1.value_strings.addElement(getAggregatePackage(aggr_prefix, an_ss));


            //--            paths1.value_strings.addElement("" + aggr_prefix + "Entity");
            paths1.aggregate_bases.addElement(new Integer(SelectPaths.AB_INSTANCE));
//System.out.println("UAD-08");
            updateAggregateDepth((ENamed_type) an_ss, aggregate_depth);
          } else if (an_ss instanceof EEnumeration_type) {
            paths1.value_strings.addElement("" + aggr_prefix + "_enumeration");
            paths1.aggregate_bases.addElement(new Integer(SelectPaths.AB_ENUMERATION));
          } else if (an_ss instanceof EInteger_type) {
            paths1.value_strings.addElement("" + aggr_prefix + "_integer");
            paths1.aggregate_bases.addElement(new Integer(SelectPaths.AB_INTEGER));
          } else if (an_ss instanceof ENumber_type) {
            paths1.value_strings.addElement("" + aggr_prefix + "_double");
            paths1.aggregate_bases.addElement(new Integer(SelectPaths.AB_DOUBLE));
          } else if (an_ss instanceof EReal_type) {
            paths1.value_strings.addElement("" + aggr_prefix + "_double");
            paths1.aggregate_bases.addElement(new Integer(SelectPaths.AB_DOUBLE));
          } else if (an_ss instanceof EString_type) {
            paths1.value_strings.addElement("" + aggr_prefix + "_string");
            paths1.aggregate_bases.addElement(new Integer(SelectPaths.AB_STRING));
          } else if (an_ss instanceof ELogical_type) {
            paths1.value_strings.addElement("" + aggr_prefix + "_enumeration");
            paths1.aggregate_bases.addElement(new Integer(SelectPaths.AB_ENUMERATION));
          } else if (an_ss instanceof EBoolean_type) {
            paths1.value_strings.addElement("" + aggr_prefix + "_boolean");
            paths1.aggregate_bases.addElement(new Integer(SelectPaths.AB_BOOLEAN));
          } else if (an_ss instanceof EBinary_type) {
            paths1.value_strings.addElement("" + aggr_prefix + "_binary");
            paths1.aggregate_bases.addElement(new Integer(SelectPaths.AB_BINARY));
          }
        }

        /*
        // separate aggregates may not be needed.
        if (an_ss instanceof EArray_type) {
        //         paths1.return_types.add("A" + an_ss.getName(null)); // an_ss.base.name
                    paths1.express_types.add(new Integer(SelectPaths.XT_ARRAY));
        //         paths1.express_names.add("A" + an_ss.getName(null)); // an_ss.base.name
                 //-EC1- an_ss.base.aggr_depth++; // this is a whole new problem for EC2 - to calculate needed maximal aggregate nesting
                    }   else
                    if (an_ss instanceof EBag_type) {
        //         paths1.return_types.add("A" + an_ss.getName(null)); // an_ss.base.name
                    paths1.express_types.add(new Integer(SelectPaths.XT_BAG));
        //         paths1.express_names.add("A" + an_ss.getName(null)); // an_ss.base.name
                    }   else
                    if (an_ss instanceof EList_type) {
        //         paths1.return_types.add("A" + an_ss.getName(null)); // an_ss.base.name
                    paths1.express_types.add(new Integer(SelectPaths.XT_LIST));
        //         paths1.express_names.add("A" + an_ss.getName(null)); // an_ss.base.name
                    }   else
                    if (an_ss instanceof ESet_type) {
        //         paths1.return_types.add("A" + an_ss.getName(null)); // an_ss.base.name
                    paths1.express_types.add(new Integer(SelectPaths.XT_SET));
        //         paths1.express_names.add("A" + an_ss.getName(null)); // an_ss.base.name
                    }   
         */
      } // not select
    } // while - iterates through all select elements

    if (depth_count > 0) {
      for (int k = depth_count; k > 0; k--) {
        current_nodes.removeElementAt(current_nodes.size() - 1);
        current_node_strings.removeElementAt(current_node_strings.size() - 1);
      }

      depth_count = 0;
    }

    // here goe actions from the inside out if any - returning when there are no deeper selects
    // entity = 0
    // dt     = 1
    // mixed  = 2
    if (returned_pure == 2) {
      is_pure = 2;
    } else if (returned_pure == 1) {
      if (is_pure == 1) {
        is_pure = 1;
      } else if (is_pure == 2) {
        is_pure = 2;
      } else if (is_pure == 0) {
        is_pure = 2;
      } else if (is_pure == -1) {
        is_pure = 1;
      }
    } else if (returned_pure == 0) {
      if (is_pure == 1) {
        is_pure = 2;
      } else if (is_pure == 2) {
        is_pure = 2;
      } else if (is_pure == 0) {
        is_pure = 0;
      } else if (is_pure == -1) {
        is_pure = 0;
      }
    } else {
    }

    if (is_pure == 2) {
      return 2;
    } else if (is_pure == 0) {
      if (purity_type_present) {
        return 2;
      } else {
        return 0;
      }
    } else if (is_pure == 1) {
      if (purity_entity_present) {
        return 2;
      } else {
        return 1;
      }
    } else if (is_pure == -1) {
      if (purity_entity_present) {
        if (purity_type_present) {
          return 2;
        } else {
          return 0;
        }
      } else {
        if (purity_type_present) {
          return 1;
        } else {
          return -1;
        }
      }
    } else {
      return -2;
    }
  }


  int calculateSelectPaths_old(int count, Vector current_nodes, Vector current_node_strings, 
                           int[] indeces, int depth, int depth_count, SelectPaths paths1, 
                           ESelect_type st, boolean with_type)
                    throws SdaiException {

// System.out.println("<calculateSelectPaths>: select_type: " + st  + ", depth: " + depth);
// System.out.println("<calculateSelectPaths>: current nodes: " + current_node_strings);

    boolean type_present = false;
    int is_pure = -1;
    int returned_pure = -1;
    boolean purity_type_present = false;
    boolean purity_entity_present = false;
    indeces[depth] = depth_count; //  indeces not used, it seems.
    depth++;
    depth_count = 0;


if (st instanceof EExtensible_select_type) {
	purity_entity_present = true;
}


    // here goes actions on the way inside if any
    EEntity an_ss;
    EEntity an_ss_super;
    an_ss_super = null;

//    ANamed_type ant = st.getSelections(null);
//    ANamed_type ant = st.getLocal_selections(null);
      ANamed_type ant = getSelections(st);
    SdaiIterator iant = ant.createIterator();

    while (iant.next()) {
      for (int k = depth_count; k > 0; k--) {
        current_nodes.removeElementAt(current_nodes.size() - 1);
        current_node_strings.removeElementAt(current_node_strings.size() - 1);
      }

      depth_count = 0;
      an_ss = (ENamed_type) ant.getCurrentMemberObject(iant);

      while (an_ss instanceof EDefined_type) {
        EEntity domain = ((EDefined_type) an_ss).getDomain(null);

        if (!(domain instanceof ESelect_type)) {
          if (!type_present) {
            current_nodes.addElement(an_ss);
            current_node_strings.addElement(getEEntityPackage(an_ss));
            depth_count++;
            depth++;
            type_present = true;
            with_type = true;
          } else {
            // guess nothing here.
          }
        }

        an_ss_super = an_ss;
        an_ss = domain;
      }

      Vector path;
      Vector path_strings;
      type_present = false;

      if (an_ss instanceof ESelect_type) {
        int ret_pur = calculateSelectPaths(count, current_nodes, current_node_strings, indeces, 
                                           depth, depth_count, paths1, (ESelect_type) an_ss, 
                                           with_type);

        if (returned_pure < 0) {
          returned_pure = ret_pur;
        } else if (returned_pure != ret_pur) {
          returned_pure = 2;
        }
      } else {
        if (an_ss instanceof EEntity_definition) {
          /*
          if (with_type) {
           current_nodes.addElement(an_ss);
          current_node_strings.addElement(getEEntityPackage(an_ss));
           depth_count++;
           purity_entity_present = true;
           paths1.value_strings.addElement(getEEntityPackage(an_ss)); // still, for new approach to entities in selects, it is not needed.
           paths1.express_types.addElement(new Integer(SelectPaths.XT_ENTITY));
          paths1.aggregate_bases.addElement(new Integer(SelectPaths.AB_NOT_AGGREGATE));
            } else {
           */

          //                current_nodes.addElement(an_ss);
          //              current_node_strings.addElement(getEEntityPackage(an_ss));
          //               depth_count++;
          //               paths1.value_strings.addElement(getEEntityPackage(an_ss)); // still, for new approach to entities in selects, it is not needed.
          paths1.value_strings.addElement("EEntity"); // still, for new approach to entities in selects, it is not needed.
          paths1.express_types.addElement(new Integer(SelectPaths.XT_ENTITY));
          paths1.aggregate_bases.addElement(new Integer(SelectPaths.AB_NOT_AGGREGATE));

          //            paths1.express_names.add("E" + ((EEntity_definition)an_ss).getName(null));
          //               }
          if (with_type) {
            purity_type_present = true;

            //                  with_type = false;
          } else {
            purity_entity_present = true;
          }
        } else {
          purity_type_present = true;
        }

        with_type = false;
        path = (Vector) current_nodes.clone();
        path_strings = (Vector) current_node_strings.clone();
        count = 1;


        //         paths1.return_symbols.add(an_ss);
        paths1.paths.addElement(path);
        paths1.path_strings.addElement(path_strings);

        if (an_ss instanceof EInteger_type) {
          paths1.value_strings.addElement("int");
          paths1.express_types.addElement(new Integer(SelectPaths.XT_INTEGER));
          paths1.aggregate_bases.addElement(new Integer(SelectPaths.AB_NOT_AGGREGATE));

          //            paths1.express_names.add("INTEGER");
        } else if (an_ss instanceof ENumber_type) {
          paths1.value_strings.addElement("double");
          paths1.express_types.addElement(new Integer(SelectPaths.XT_NUMBER));
          paths1.aggregate_bases.addElement(new Integer(SelectPaths.AB_NOT_AGGREGATE));

          //            paths1.express_names.add("NUMBER");
        } else if (an_ss instanceof EReal_type) {
          paths1.value_strings.addElement("double");
          paths1.express_types.addElement(new Integer(SelectPaths.XT_REAL));
          paths1.aggregate_bases.addElement(new Integer(SelectPaths.AB_NOT_AGGREGATE));

          //            paths1.express_names.add("NUMBER");
        } else if (an_ss instanceof EString_type) {
          paths1.value_strings.addElement("String");
          paths1.express_types.addElement(new Integer(SelectPaths.XT_STRING));
          paths1.aggregate_bases.addElement(new Integer(SelectPaths.AB_NOT_AGGREGATE));

          //            paths1.express_names.add("STRING");
        } else if (an_ss instanceof ELogical_type) {
          paths1.value_strings.addElement("int");
          paths1.express_types.addElement(new Integer(SelectPaths.XT_LOGICAL));
          paths1.aggregate_bases.addElement(new Integer(SelectPaths.AB_NOT_AGGREGATE));

          //            paths1.express_names.add("LOGICAL");
        } else if (an_ss instanceof EBoolean_type) {
          paths1.value_strings.addElement("boolean");
          paths1.express_types.addElement(new Integer(SelectPaths.XT_BOOLEAN));
          paths1.aggregate_bases.addElement(new Integer(SelectPaths.AB_NOT_AGGREGATE));

          //            paths1.express_names.add("BOOLEAN");
        } else if (an_ss instanceof EBinary_type) {
          paths1.value_strings.addElement("Binary");
          paths1.express_types.addElement(new Integer(SelectPaths.XT_BINARY));
          paths1.aggregate_bases.addElement(new Integer(SelectPaths.AB_NOT_AGGREGATE));

          //            paths1.express_names.add("BINARY");
        } else if (an_ss instanceof EEnumeration_type) {
          paths1.value_strings.addElement("int");
          paths1.express_types.addElement(new Integer(SelectPaths.XT_ENUMERATION));
          paths1.aggregate_bases.addElement(new Integer(SelectPaths.AB_NOT_AGGREGATE));

          //            paths1.express_names.add("E" + ((EDefined_type)an_ss_super).getName(null)); // the was .up in the original
        } else if (an_ss instanceof EAggregation_type) {
          paths1.express_types.addElement(new Integer(SelectPaths.XT_AGGREGATE));

          //         paths1.express_names.add("A" + an_ss.getName(null)); // an_ss.base.name
          EEntity ass = an_ss;
          EAggregation_type aas = (EAggregation_type) an_ss;
          String aggr_prefices = "";
          an_ss = aas.getElement_type(null);

          int aggregate_depth = 1;

          for (;;) {
            boolean done_something = false;

            if (an_ss instanceof EDefined_type) {
              ass = an_ss;
              an_ss = ((EDefined_type) an_ss).getDomain(null);
              done_something = true;
            } else if (an_ss instanceof EAggregation_type) {
              aggr_prefices += "a";
              aggregate_depth++;
              ass = an_ss;
              an_ss = ((EAggregation_type) an_ss).getElement_type(null);
              done_something = true;
            }

            if (!done_something) {
              break;
            }
          }

          String aggr_prefix = "A" + aggr_prefices;

          // these two lines used to store necessary depth - which aggregate classes need to be generated
          //           int the_aggr_depth = aggr_prefices.length() + 1;
          //           if (an_ss.aggr_depth < the_aggr_depth) an_ss.aggr_depth = the_aggr_depth;
          if (an_ss instanceof ESelect_type) {
            paths1.value_strings.addElement(getAggregatePackage(aggr_prefix, ass));
            paths1.aggregate_bases.addElement(new Integer(SelectPaths.AB_SELECT));
//System.out.println("UAD-07");
            updateAggregateDepth((ENamed_type) ass, aggregate_depth);
          } else if (an_ss instanceof EEntity_definition) {
            // in EC1 there is the same lines as in the non-aggregate entities - adding to current_nodes, depth_count, etc - probably a bug.
            paths1.value_strings.addElement(getAggregatePackage(aggr_prefix, an_ss));


            //--            paths1.value_strings.addElement("" + aggr_prefix + "Entity");
            paths1.aggregate_bases.addElement(new Integer(SelectPaths.AB_INSTANCE));
//System.out.println("UAD-08");
            updateAggregateDepth((ENamed_type) an_ss, aggregate_depth);
          } else if (an_ss instanceof EEnumeration_type) {
            paths1.value_strings.addElement("" + aggr_prefix + "_enumeration");
            paths1.aggregate_bases.addElement(new Integer(SelectPaths.AB_ENUMERATION));
          } else if (an_ss instanceof EInteger_type) {
            paths1.value_strings.addElement("" + aggr_prefix + "_integer");
            paths1.aggregate_bases.addElement(new Integer(SelectPaths.AB_INTEGER));
          } else if (an_ss instanceof ENumber_type) {
            paths1.value_strings.addElement("" + aggr_prefix + "_double");
            paths1.aggregate_bases.addElement(new Integer(SelectPaths.AB_DOUBLE));
          } else if (an_ss instanceof EReal_type) {
            paths1.value_strings.addElement("" + aggr_prefix + "_double");
            paths1.aggregate_bases.addElement(new Integer(SelectPaths.AB_DOUBLE));
          } else if (an_ss instanceof EString_type) {
            paths1.value_strings.addElement("" + aggr_prefix + "_string");
            paths1.aggregate_bases.addElement(new Integer(SelectPaths.AB_STRING));
          } else if (an_ss instanceof ELogical_type) {
            paths1.value_strings.addElement("" + aggr_prefix + "_enumeration");
            paths1.aggregate_bases.addElement(new Integer(SelectPaths.AB_ENUMERATION));
          } else if (an_ss instanceof EBoolean_type) {
            paths1.value_strings.addElement("" + aggr_prefix + "_boolean");
            paths1.aggregate_bases.addElement(new Integer(SelectPaths.AB_BOOLEAN));
          } else if (an_ss instanceof EBinary_type) {
            paths1.value_strings.addElement("" + aggr_prefix + "_binary");
            paths1.aggregate_bases.addElement(new Integer(SelectPaths.AB_BINARY));
          }
        }

        /*
        // separate aggregates may not be needed.
        if (an_ss instanceof EArray_type) {
        //         paths1.return_types.add("A" + an_ss.getName(null)); // an_ss.base.name
                    paths1.express_types.add(new Integer(SelectPaths.XT_ARRAY));
        //         paths1.express_names.add("A" + an_ss.getName(null)); // an_ss.base.name
                 //-EC1- an_ss.base.aggr_depth++; // this is a whole new problem for EC2 - to calculate needed maximal aggregate nesting
                    }   else
                    if (an_ss instanceof EBag_type) {
        //         paths1.return_types.add("A" + an_ss.getName(null)); // an_ss.base.name
                    paths1.express_types.add(new Integer(SelectPaths.XT_BAG));
        //         paths1.express_names.add("A" + an_ss.getName(null)); // an_ss.base.name
                    }   else
                    if (an_ss instanceof EList_type) {
        //         paths1.return_types.add("A" + an_ss.getName(null)); // an_ss.base.name
                    paths1.express_types.add(new Integer(SelectPaths.XT_LIST));
        //         paths1.express_names.add("A" + an_ss.getName(null)); // an_ss.base.name
                    }   else
                    if (an_ss instanceof ESet_type) {
        //         paths1.return_types.add("A" + an_ss.getName(null)); // an_ss.base.name
                    paths1.express_types.add(new Integer(SelectPaths.XT_SET));
        //         paths1.express_names.add("A" + an_ss.getName(null)); // an_ss.base.name
                    }   
         */
      } // not select
    } // while - iterates through all select elements

    if (depth_count > 0) {
      for (int k = depth_count; k > 0; k--) {
        current_nodes.removeElementAt(current_nodes.size() - 1);
        current_node_strings.removeElementAt(current_node_strings.size() - 1);
      }

      depth_count = 0;
    }

    // here goe actions from the inside out if any - returning when there are no deeper selects
    // entity = 0
    // dt     = 1
    // mixed  = 2
    if (returned_pure == 2) {
      is_pure = 2;
    } else if (returned_pure == 1) {
      if (is_pure == 1) {
        is_pure = 1;
      } else if (is_pure == 2) {
        is_pure = 2;
      } else if (is_pure == 0) {
        is_pure = 2;
      } else if (is_pure == -1) {
        is_pure = 1;
      }
    } else if (returned_pure == 0) {
      if (is_pure == 1) {
        is_pure = 2;
      } else if (is_pure == 2) {
        is_pure = 2;
      } else if (is_pure == 0) {
        is_pure = 0;
      } else if (is_pure == -1) {
        is_pure = 0;
      }
    } else {
    }

    if (is_pure == 2) {
      return 2;
    } else if (is_pure == 0) {
      if (purity_type_present) {
        return 2;
      } else {
        return 0;
      }
    } else if (is_pure == 1) {
      if (purity_entity_present) {
        return 2;
      } else {
        return 1;
      }
    } else if (is_pure == -1) {
      if (purity_entity_present) {
        if (purity_type_present) {
          return 2;
        } else {
          return 0;
        }
      } else {
        if (purity_type_present) {
          return 1;
        } else {
          return -1;
        }
      }
    } else {
      return -2;
    }
  }

  //============================================================== methods for debugging ==============================
  void printEntityVector(Vector vec) throws SdaiException {
    Object ee;
    printDebug("-------- printing entity vector --------------------------------------------");

    for (int i = 0; i < vec.size(); i++) {
      ee = vec.elementAt(i);

      if (ee instanceof ENamed_type) {
        printDebug(i + ": " + ((ENamed_type) ee).getName(null));
      } else {
        printDebug(i + ": NOT A NAMED TYPE");
      }
    }

    printDebug("-------- done printing entity vector --------------------------------------------");
  }

  //------- new stuff -----------------------------
  int getInternalAttributeNumber(int index, Vector all_flags) {
    int number = 0;

    for (int i = 0; i <= index; i++) {
      int attribute_flag = (int) ((Integer) all_flags.elementAt(i)).intValue();

      if ((attribute_flag == AA_JAVA_EXPLICIT_TO_DERIVED) || 
              (attribute_flag == AA_SUPERTYPE_EXPLICIT_TO_DERIVED) || 
              (attribute_flag == AA_CURRENT_EXPLICIT_TO_DERIVED)) {
        number++;
      } else if ((attribute_flag == AA_JAVA_EXPLICIT) || 
                     (attribute_flag == AA_SUPERTYPE_EXPLICIT) || 
                     (attribute_flag == AA_CURRENT_EXPLICIT)) {
        number++;
      }
    }

    return number - 1;
  }




  void generateUnsetAllX(TreeSet parts, PrintWriter pw, EEntity_definition ed, ArrayList all_attributes, 
                        ArrayList all_flags) throws SdaiException {

		SdaiModel edmod = ed.findEntityInstanceSdaiModel();
		boolean is_xim = false;
//		if (edmod.getName().endsWith("_XIM_DICTIONARY_DATA")) {
		if ((edmod.getName().endsWith("_XIM_DICTIONARY_DATA")) || (edmod.getName().equalsIgnoreCase("MIXED_COMPLEX_TYPES_DICTIONARY_DATA"))) {
			is_xim = true;
		}

    Iterator iter = parts.iterator();
    int i_part = 0;

    while (iter.hasNext()) {
      EEntity_definition part = (EEntity_definition) iter.next();

      //         pw.println("\t\tpart: " + i_part + " = " + part.getName(null));
      //RR- explicit_attributes removed-         AExplicit_attribute xa = part.getExplicit_attributes(null);
      AExplicit_attribute xa = getExplicit_attributes(part);
      SdaiIterator ia = xa.createIterator();
      int i_attr = 0;
      String at_name = null;

      while (ia.next()) {
        EExplicit_attribute xattr = (EExplicit_attribute) xa.getCurrentMemberObject(ia);

        // int all_index = all_attributes.indexOf(xattr);
				TheAttribute tattr = findTheAttributeX(all_attributes, xattr);
				



				if (!tattr.consolidated) {
					System.out.println("INTERNAL ERROR!!! NOT CONSOLIDATED: " + tattr.attr);
					continue;
				}

				if (tattr.consolidated_type == 1) { // derived
//				if (tattr.explicit_to_derived) {

					if (is_xim) {
// -------------------------------


        if (tattr.consolidated) {
        	at_name = "a" + tattr.consolidated_explicit_index;
				} else {
        	at_name = "a" + tattr.explicit_index;
					System.out.println("NOT consolidated: " + tattr.attr);
				}



        //            at_name = "a" + getInternalAttributeNumber(all_attributes.indexOf(xattr), all_flags);
        boolean is_redeclaring = xattr.testRedeclaring(null);

        if (!is_redeclaring) {
          // get attribute base type and generate for each base type appropriate code.
          EEntity bt = xattr.getDomain(null);

          if (bt instanceof ESimple_type) {
            generateSimpleTypeUnsetAll((ESimple_type) bt, pw, at_name, i_part, i_attr);
          } else if (bt instanceof EAggregation_type) {
            generateAggregationTypeUnsetAll((EAggregation_type) bt, pw, at_name, i_part, i_attr);
          } else if (bt instanceof EDefined_type) {
            generateDefinedTypeUnsetAll((EDefined_type) bt, pw, at_name, i_part, i_attr);
          } else if (bt instanceof EEntity_definition) {
            pw.println("\t\t\t" + at_name + " = unset_instance(" + at_name + ");");
          }
        } else {
        }


// -----------------------------------2 

					} else {
					}



          i_attr++; // added for consistency, because SetAll and GetAll have it, only UnsetAll did not - EXPERIMENT, added blindly!!!
          continue;
				}


//        at_name = "a" + getInternalAttributeNumber(all_index, all_flags);

//        at_name = "a" + tattr.explicit_index;
        if (tattr.consolidated) {
        	at_name = "a" + tattr.consolidated_explicit_index;
				} else {
        	at_name = "a" + tattr.explicit_index;
					System.out.println("NOT consolidated: " + tattr.attr);
				}



        //            at_name = "a" + getInternalAttributeNumber(all_attributes.indexOf(xattr), all_flags);
        boolean is_redeclaring = xattr.testRedeclaring(null);

        if (!is_redeclaring) {
          // get attribute base type and generate for each base type appropriate code.
          EEntity bt = xattr.getDomain(null);

          if (bt instanceof ESimple_type) {
            generateSimpleTypeUnsetAll((ESimple_type) bt, pw, at_name, i_part, i_attr);
          } else if (bt instanceof EAggregation_type) {
            generateAggregationTypeUnsetAll((EAggregation_type) bt, pw, at_name, i_part, i_attr);
          } else if (bt instanceof EDefined_type) {
            generateDefinedTypeUnsetAll((EDefined_type) bt, pw, at_name, i_part, i_attr);
          } else if (bt instanceof EEntity_definition) {
            pw.println("\t\t\t" + at_name + " = unset_instance(" + at_name + ");");
          }
        } else {
        }

        i_attr++;
      } // loop - attributes

      i_part++;
    } // loop - parts

    //      pw.println("\t}");
  }

  
  
  
  void generateUnsetAllX_prev(TreeSet parts, PrintWriter pw, EEntity_definition ed, ArrayList all_attributes, 
                        ArrayList all_flags) throws SdaiException {
    Iterator iter = parts.iterator();
    int i_part = 0;

    while (iter.hasNext()) {
      EEntity_definition part = (EEntity_definition) iter.next();

      //         pw.println("\t\tpart: " + i_part + " = " + part.getName(null));
      //RR- explicit_attributes removed-         AExplicit_attribute xa = part.getExplicit_attributes(null);
      AExplicit_attribute xa = getExplicit_attributes(part);
      SdaiIterator ia = xa.createIterator();
      int i_attr = 0;
      String at_name = null;

      while (ia.next()) {
        EExplicit_attribute xattr = (EExplicit_attribute) xa.getCurrentMemberObject(ia);

        // int all_index = all_attributes.indexOf(xattr);
				TheAttribute tattr = findTheAttributeX(all_attributes, xattr);
				



				if (!tattr.consolidated) {
					System.out.println("INTERNAL ERROR!!! NOT CONSOLIDATED: " + tattr.attr);
					continue;
				}

				if (tattr.consolidated_type == 1) { // derived
//				if (tattr.explicit_to_derived) {
          i_attr++; // added for consistency, because SetAll and GetAll have it, only UnsetAll did not - EXPERIMENT, added blindly!!!
          continue;
				}


//        at_name = "a" + getInternalAttributeNumber(all_index, all_flags);

//        at_name = "a" + tattr.explicit_index;
        if (tattr.consolidated) {
        	at_name = "a" + tattr.consolidated_explicit_index;
				} else {
        	at_name = "a" + tattr.explicit_index;
					System.out.println("NOT consolidated: " + tattr.attr);
				}



        //            at_name = "a" + getInternalAttributeNumber(all_attributes.indexOf(xattr), all_flags);
        boolean is_redeclaring = xattr.testRedeclaring(null);

        if (!is_redeclaring) {
          // get attribute base type and generate for each base type appropriate code.
          EEntity bt = xattr.getDomain(null);

          if (bt instanceof ESimple_type) {
            generateSimpleTypeUnsetAll((ESimple_type) bt, pw, at_name, i_part, i_attr);
          } else if (bt instanceof EAggregation_type) {
            generateAggregationTypeUnsetAll((EAggregation_type) bt, pw, at_name, i_part, i_attr);
          } else if (bt instanceof EDefined_type) {
            generateDefinedTypeUnsetAll((EDefined_type) bt, pw, at_name, i_part, i_attr);
          } else if (bt instanceof EEntity_definition) {
            pw.println("\t\t\t" + at_name + " = unset_instance(" + at_name + ");");
          }
        } else {
        }

        i_attr++;
      } // loop - attributes

      i_part++;
    } // loop - parts

    //      pw.println("\t}");
  }



  void generateUnsetAll(TreeSet parts, PrintWriter pw, EEntity_definition ed, Vector all_attributes, 
                        Vector all_flags) throws SdaiException {
    Iterator iter = parts.iterator();
    int i_part = 0;

    while (iter.hasNext()) {
      EEntity_definition part = (EEntity_definition) iter.next();

      //         pw.println("\t\tpart: " + i_part + " = " + part.getName(null));
      //RR- explicit_attributes removed-         AExplicit_attribute xa = part.getExplicit_attributes(null);
      AExplicit_attribute xa = getExplicit_attributes(part);
      SdaiIterator ia = xa.createIterator();
      int i_attr = 0;
      String at_name = null;

      while (ia.next()) {
        EExplicit_attribute xattr = (EExplicit_attribute) xa.getCurrentMemberObject(ia);
        int all_index = all_attributes.indexOf(xattr);
        int attribute_flag = (int) ((Integer) all_flags.elementAt(all_index)).intValue();

        if ((attribute_flag == AA_JAVA_EXPLICIT_TO_DERIVED) || 
                (attribute_flag == AA_SUPERTYPE_EXPLICIT_TO_DERIVED) || 
                (attribute_flag == AA_CURRENT_EXPLICIT_TO_DERIVED)) {
          continue;
        }

        at_name = "a" + getInternalAttributeNumber(all_index, all_flags);

        //            at_name = "a" + getInternalAttributeNumber(all_attributes.indexOf(xattr), all_flags);
        boolean is_redeclaring = xattr.testRedeclaring(null);

        if (!is_redeclaring) {
          // get attribute base type and generate for each base type appropriate code.
          EEntity bt = xattr.getDomain(null);

          if (bt instanceof ESimple_type) {
            generateSimpleTypeUnsetAll((ESimple_type) bt, pw, at_name, i_part, i_attr);
          } else if (bt instanceof EAggregation_type) {
            generateAggregationTypeUnsetAll((EAggregation_type) bt, pw, at_name, i_part, i_attr);
          } else if (bt instanceof EDefined_type) {
            generateDefinedTypeUnsetAll((EDefined_type) bt, pw, at_name, i_part, i_attr);
          } else if (bt instanceof EEntity_definition) {
            pw.println("\t\t\t" + at_name + " = unset_instance(" + at_name + ");");
          }
        } else {
        }

        i_attr++;
      } // loop - attributes

      i_part++;
    } // loop - parts

    //      pw.println("\t}");
  }

  void generateSimpleTypeUnsetAll(ESimple_type st, PrintWriter pw, String at_name, int i_part, 
                                  int i_attr) {
    if (st instanceof EInteger_type) {
      pw.println("\t\t\t" + at_name + " = Integer.MIN_VALUE;");
    } else if (st instanceof ENumber_type) {
      pw.println("\t\t\t" + at_name + " = Double.NaN;");
    } else if (st instanceof EReal_type) {
      pw.println("\t\t\t" + at_name + " = Double.NaN;");
    } else if (st instanceof EBoolean_type) {
      pw.println("\t\t\t" + at_name + " = 0;");
    } else if (st instanceof ELogical_type) {
      pw.println("\t\t\t" + at_name + " = 0;");
    } else if (st instanceof EBinary_type) {
      pw.println("\t\t\t" + at_name + " = null;");
    } else if (st instanceof EString_type) {
      pw.println("\t\t\t" + at_name + " = null;");
    }
  }

  void generateDefinedTypeUnsetAll(EDefined_type dt, PrintWriter pw, String at_name, int i_part, 
                                   int i_attr) throws SdaiException {
    EEntity ut = dt.getDomain(null);

    if (ut instanceof ESimple_type) {
      generateSimpleTypeUnsetAll((ESimple_type) ut, pw, at_name, i_part, i_attr);
    } else if (ut instanceof EAggregation_type) {
      generateAggregationTypeUnsetAll((EAggregation_type) ut, pw, at_name, i_part, i_attr);
    } else if (ut instanceof EDefined_type) {
      generateDefinedTypeUnsetAll((EDefined_type) ut, pw, at_name, i_part, i_attr);
    } else if (ut instanceof EEnumeration_type) {
      pw.println("\t\t\t" + at_name + " = 0;");
    } else if (ut instanceof ESelect_type) {
//      ANamed_type nt = ((ESelect_type) ut).getSelections(null);
//      ANamed_type nt = ((ESelect_type) ut).getLocal_selections(null);
      ANamed_type nt = getSelections((ESelect_type) ut);
      SelectPaths paths1 = null;
      int select_type = Integer.MIN_VALUE;
      Object temp_object = ut.getTemp();

      if (temp_object instanceof SelectPaths) {
        if (((SelectPaths) temp_object).owner == (ESelect_type) ut) {
          paths1 = (SelectPaths) temp_object;
          select_type = paths1.select_type;
        }
      }

      if (paths1 == null) {
        int count = 1;
        int[] indeces = new int[500];
        int depth = 0;
        int depth_count = 0;
        boolean with_type = false;
        Vector current_nodes = new Vector();
        Vector current_node_strings = new Vector();
        paths1 = new SelectPaths();
        paths1.owner = (ESelect_type) ut;
        select_type = calculateSelectPaths(count, current_nodes, current_node_strings, indeces, 
                                           depth, depth_count, paths1, (ESelect_type) ut, with_type);
        paths1.removeIdentical();
        paths1.select_type = select_type;
        ut.setTemp(paths1);
      }

      if (select_type != 0) { // includes defined_types
//        pw.println("\t\t\t" + at_name + " = unset_instance(" + at_name + ");");
        pw.println("\t\t\t" + at_name + " = unset_select(" + at_name + ");");
        pw.println("\t\t\t" + at_name + "$$ = 0;");
      } else {
        pw.println("\t\t\t" + at_name + " = unset_instance(" + at_name + ");");
      }
    }
  }

  void generateAggregationTypeUnsetAll(EAggregation_type at, PrintWriter pw, String at_name, 
                                       int i_part, int i_attr)
                                throws SdaiException {
    int aggregate_depth = 1;
    EEntity an_ss;
    EEntity ass = at;
    String aggr_prefices = "";
    an_ss = at.getElement_type(null);

    for (;;) {
      boolean done_something = false;

      if (an_ss instanceof EDefined_type) {
        ass = an_ss;
        an_ss = ((EDefined_type) an_ss).getDomain(null);
        done_something = true;
      } else if (an_ss instanceof EAggregation_type) {
        aggr_prefices += "a";
        aggregate_depth++;
        ass = an_ss;
        an_ss = ((EAggregation_type) an_ss).getElement_type(null);
        done_something = true;
      }

      if (!done_something) {
        break;
      }
    }

    if (an_ss instanceof EEnumeration_type) {
    } else if (an_ss instanceof EInteger_type) {
    } else if (an_ss instanceof ENumber_type) {
    } else if (an_ss instanceof EReal_type) {
    } else if (an_ss instanceof ELogical_type) {
    } else if (an_ss instanceof EBoolean_type) {
    } else {
      pw.println("\t\t\tif (" + at_name + " instanceof CAggregate)");
      pw.println("\t\t\t\t" + at_name + ".unsetAll();");
      pw.println("\t\t\t" + at_name + " = null;");
    }
  }



	TheAttribute findTheAttributeX(ArrayList all_attributes, EAttribute xattr) {
		for (int i = 0; i < all_attributes.size(); i++) {
			TheAttribute tattr = (TheAttribute)all_attributes.get(i);
			if (tattr.attr == xattr) {
				return tattr;
			}
		}
		return null;
	}



	/*
			IMPORTANT!!!
			while implementing X versions of SetAll and UnsetAll, I found inconsistency in old implementation:
			in SetAll attr number is increased in the case explicit-to-derived, in UnsetAll - not.
			It seems that conistency is needed
	*/


  void generateSetAllX(EEntity_definition ed, PrintWriter pw, ArrayList all_attributes, ArrayList all_flags) throws SdaiException {

    pw.println("\tprotected void setAll(ComplexEntityValue av) throws SdaiException {");

		// TEMP REMOVAL OF SETALL
//    pw.println("\t}");
//		if (true) return;

    //    CompareEntities ce = new CompareEntities();
    CompareUppercaseEntities ce = new CompareUppercaseEntities();
    TreeSet parts = new TreeSet(ce);
    getExternalMappingParts(ed, parts);

    boolean is_complex = ed.getComplex(null);

    if (!is_complex) {
      parts.add(ed);
    }

    pw.println("\t\tif (av == null) {");
    generateUnsetAllX(parts, pw, ed, all_attributes, all_flags);
    pw.println("\t\t\treturn;");
    pw.println("\t\t}");

    Iterator iter = parts.iterator();
    int i_part = 0;

    while (iter.hasNext()) {
      EEntity_definition part = (EEntity_definition) iter.next();

      //         pw.println("\t\tpart: " + i_part + " = " + part.getName(null));
      //RR- explicit_attributes removed-         AExplicit_attribute xa = part.getExplicit_attributes(null);
      AExplicit_attribute xa = getExplicit_attributes(part);
      SdaiIterator ia = xa.createIterator();
      int i_attr = 0;
      String at_name = null;

      while (ia.next()) {
        EExplicit_attribute xattr = (EExplicit_attribute) xa.getCurrentMemberObject(ia);

//        int all_index = all_attributes.indexOf(xattr);
        TheAttribute tattr = findTheAttributeX(all_attributes, xattr);




				if (!tattr.consolidated) {
					System.out.println("INTERNAL ERROR!!! NOT CONSOLIDATED: " + tattr.attr);
					continue;
				}

        if (tattr.consolidated) {
        	at_name = "a" + tattr.consolidated_explicit_index;
				} else {
        	at_name = "a" + tattr.explicit_index;
					System.out.println("NOT consolidated: " + tattr.attr);
				}

        EEntity bt = xattr.getDomain(null);

				if (tattr.consolidated_type == 1) { // derived
//				if (tattr.explicit_to_derived) {

          // generate the new Method here
					
					// initially requested by Gintaras
					// av.entityValues[0].checkRedefine(this, a1$);
          // later modified:
					// av.entityValues[0].values[1].checkRedefine(this, a1$);
					// for explicit I generate, for example:
					// 		a1 = av.entityValues[0].getInstance(1, this, a1$);
		
					// ok, this here should do what is needed:
					// probably this branching is no longer needed
          if (bt instanceof ESimple_type) {
            pw.println("\t\tav.entityValues[" + i_part + "].values["+ i_attr +"].checkRedefine(this, " + at_name + "$);");
          } else if (bt instanceof EAggregation_type) {
            pw.println("\t\tav.entityValues[" + i_part + "].values["+ i_attr +"].checkRedefine(this, " + at_name + "$);");
          } else if (bt instanceof EDefined_type) {
            pw.println("\t\tav.entityValues[" + i_part + "].values["+ i_attr +"].checkRedefine(this, " + at_name + "$);");
          } else if (bt instanceof EEntity_definition) {
            pw.println("\t\tav.entityValues[" + i_part + "].values["+ i_attr +"].checkRedefine(this, " + at_name + "$);");
          }



          i_attr++;
          continue;
				}


        //   			at_name = "a" + all_attributes.indexOf(xattr);
//        at_name = "a" + getInternalAttributeNumber(all_index, all_flags);
        

        boolean is_redeclaring = xattr.testRedeclaring(null);

        if (!is_redeclaring) {
          // get attribute base type and generate for each base type appropriate code.

          if (bt instanceof ESimple_type) {
            generateSimpleTypeSetAll((ESimple_type) bt, pw, at_name, i_part, i_attr);
          } else if (bt instanceof EAggregation_type) {
            generateAggregationTypeSetAll((EAggregation_type) bt, pw, at_name, i_part, i_attr);
          } else if (bt instanceof EDefined_type) {
            generateDefinedTypeSetAll((EDefined_type) bt, pw, at_name, i_part, i_attr);
          } else if (bt instanceof EEntity_definition) {
//            pw.println("\t\t" + at_name + " = av.entityValues[" + i_part + "].getInstance(" + i_attr + ", this);");
            pw.println("\t\t" + at_name + " = av.entityValues[" + i_part + "].getInstance(" + i_attr + ", this, " + at_name + "$);");
          }
        } else {
        }

        i_attr++;
      } // loop - attributes

      i_part++;
    } // loop - parts

    pw.println("\t}");
  }


  void generateSetAllX_old(EEntity_definition ed, PrintWriter pw, ArrayList all_attributes, ArrayList all_flags) throws SdaiException {

    pw.println("\tprotected void setAll(ComplexEntityValue av) throws SdaiException {");

		// TEMP REMOVAL OF SETALL
//    pw.println("\t}");
//		if (true) return;

    //    CompareEntities ce = new CompareEntities();
    CompareUppercaseEntities ce = new CompareUppercaseEntities();
    TreeSet parts = new TreeSet(ce);
    getExternalMappingParts(ed, parts);

    boolean is_complex = ed.getComplex(null);

    if (!is_complex) {
      parts.add(ed);
    }

    pw.println("\t\tif (av == null) {");
    generateUnsetAllX(parts, pw, ed, all_attributes, all_flags);
    pw.println("\t\t\treturn;");
    pw.println("\t\t}");

    Iterator iter = parts.iterator();
    int i_part = 0;

    while (iter.hasNext()) {
      EEntity_definition part = (EEntity_definition) iter.next();

      //         pw.println("\t\tpart: " + i_part + " = " + part.getName(null));
      //RR- explicit_attributes removed-         AExplicit_attribute xa = part.getExplicit_attributes(null);
      AExplicit_attribute xa = getExplicit_attributes(part);
      SdaiIterator ia = xa.createIterator();
      int i_attr = 0;
      String at_name = null;

      while (ia.next()) {
        EExplicit_attribute xattr = (EExplicit_attribute) xa.getCurrentMemberObject(ia);

//        int all_index = all_attributes.indexOf(xattr);
        TheAttribute tattr = findTheAttributeX(all_attributes, xattr);




				if (!tattr.consolidated) {
					System.out.println("INTERNAL ERROR!!! NOT CONSOLIDATED: " + tattr.attr);
					continue;
				}

				if (tattr.consolidated_type == 1) { // derived
//				if (tattr.explicit_to_derived) {

          // generate the new Method here
					
					// initially requested by Gintaras
					// av.entityValues[0].checkRedefine(this, a1$);
          // later modified:
					// av.entityValues[0].values[1].checkRedefine(this, a1$);
					// for explicit I generate, for example:
					// 		a1 = av.entityValues[0].getInstance(1, this, a1$);

          i_attr++;
          continue;
				}


        //   			at_name = "a" + all_attributes.indexOf(xattr);
//        at_name = "a" + getInternalAttributeNumber(all_index, all_flags);
        
        if (tattr.consolidated) {
        	at_name = "a" + tattr.consolidated_explicit_index;
				} else {
        	at_name = "a" + tattr.explicit_index;
					System.out.println("NOT consolidated: " + tattr.attr);
				}

        boolean is_redeclaring = xattr.testRedeclaring(null);

        if (!is_redeclaring) {
          // get attribute base type and generate for each base type appropriate code.
          EEntity bt = xattr.getDomain(null);

          if (bt instanceof ESimple_type) {
            generateSimpleTypeSetAll((ESimple_type) bt, pw, at_name, i_part, i_attr);
          } else if (bt instanceof EAggregation_type) {
            generateAggregationTypeSetAll((EAggregation_type) bt, pw, at_name, i_part, i_attr);
          } else if (bt instanceof EDefined_type) {
            generateDefinedTypeSetAll((EDefined_type) bt, pw, at_name, i_part, i_attr);
          } else if (bt instanceof EEntity_definition) {
//            pw.println("\t\t" + at_name + " = av.entityValues[" + i_part + "].getInstance(" + i_attr + ", this);");
            pw.println("\t\t" + at_name + " = av.entityValues[" + i_part + "].getInstance(" + i_attr + ", this, " + at_name + "$);");
          }
        } else {
        }

        i_attr++;
      } // loop - attributes

      i_part++;
    } // loop - parts

    pw.println("\t}");
  }

  void generateSetAll(EEntity_definition ed, PrintWriter pw, Vector all_attributes, Vector all_flags) throws SdaiException {

    pw.println("\tprotected void setAll(ComplexEntityValue av) throws SdaiException {");

		// TEMP REMOVAL OF SETALL
//    pw.println("\t}");
//		if (true) return;

    //    CompareEntities ce = new CompareEntities();
    CompareUppercaseEntities ce = new CompareUppercaseEntities();
    TreeSet parts = new TreeSet(ce);
    getExternalMappingParts(ed, parts);

    boolean is_complex = ed.getComplex(null);

    if (!is_complex) {
      parts.add(ed);
    }

    pw.println("\t\tif (av == null) {");
    generateUnsetAll(parts, pw, ed, all_attributes, all_flags);
    pw.println("\t\t\treturn;");
    pw.println("\t\t}");

    Iterator iter = parts.iterator();
    int i_part = 0;

    while (iter.hasNext()) {
      EEntity_definition part = (EEntity_definition) iter.next();

      //         pw.println("\t\tpart: " + i_part + " = " + part.getName(null));
      //RR- explicit_attributes removed-         AExplicit_attribute xa = part.getExplicit_attributes(null);
      AExplicit_attribute xa = getExplicit_attributes(part);
      SdaiIterator ia = xa.createIterator();
      int i_attr = 0;
      String at_name = null;

      while (ia.next()) {
        EExplicit_attribute xattr = (EExplicit_attribute) xa.getCurrentMemberObject(ia);
        int all_index = all_attributes.indexOf(xattr);
        int attribute_flag = (int) ((Integer) all_flags.elementAt(all_index)).intValue();
// System.out.println("ROCOFOCO attribute flag: " + attribute_flag + ", index: " + all_index);

        if ((attribute_flag == AA_JAVA_EXPLICIT_TO_DERIVED) || 
                (attribute_flag == AA_SUPERTYPE_EXPLICIT_TO_DERIVED) || 
                (attribute_flag == AA_CURRENT_EXPLICIT_TO_DERIVED)) {
          i_attr++; // testing RR
          continue;
        }


        //   			at_name = "a" + all_attributes.indexOf(xattr);
        at_name = "a" + getInternalAttributeNumber(all_index, all_flags);

        boolean is_redeclaring = xattr.testRedeclaring(null);

        if (!is_redeclaring) {
          // get attribute base type and generate for each base type appropriate code.
          EEntity bt = xattr.getDomain(null);

          if (bt instanceof ESimple_type) {
            generateSimpleTypeSetAll((ESimple_type) bt, pw, at_name, i_part, i_attr);
          } else if (bt instanceof EAggregation_type) {
            generateAggregationTypeSetAll((EAggregation_type) bt, pw, at_name, i_part, i_attr);
          } else if (bt instanceof EDefined_type) {
            generateDefinedTypeSetAll((EDefined_type) bt, pw, at_name, i_part, i_attr);
          } else if (bt instanceof EEntity_definition) {
//            pw.println("\t\t" + at_name + " = av.entityValues[" + i_part + "].getInstance(" + i_attr + ", this);");
            pw.println("\t\t" + at_name + " = av.entityValues[" + i_part + "].getInstance(" + i_attr + ", this, " + at_name + "$);");
          }
        } else {
        }

        i_attr++;
      } // loop - attributes

      i_part++;
    } // loop - parts

    pw.println("\t}");
  }

  void generateSimpleTypeSetAll(ESimple_type st, PrintWriter pw, String at_name, int i_part, 
                                int i_attr) {
    if (st instanceof EInteger_type) {
      pw.println("\t\t" + at_name + " = av.entityValues[" + i_part + "].getInteger(" + i_attr + 
                 ");");
    } else if (st instanceof ENumber_type) {
      pw.println("\t\t" + at_name + " = av.entityValues[" + i_part + "].getDouble(" + i_attr + 
                 ");");
    } else if (st instanceof EReal_type) {
      pw.println("\t\t" + at_name + " = av.entityValues[" + i_part + "].getDouble(" + i_attr + 
                 ");");
    } else if (st instanceof EBoolean_type) {
      pw.println("\t\t" + at_name + " = av.entityValues[" + i_part + "].getBoolean(" + i_attr + 
                 ");");
    } else if (st instanceof ELogical_type) {
      pw.println("\t\t" + at_name + " = av.entityValues[" + i_part + "].getLogical(" + i_attr + 
                 ");");
    } else if (st instanceof EBinary_type) {
      pw.println("\t" + at_name + " = av.entityValues[" + i_part + "].getBinary(" + i_attr + 
                 ");");
    } else if (st instanceof EString_type) {
      pw.println("\t\t" + at_name + " = av.entityValues[" + i_part + "].getString(" + i_attr + 
                 ");");
    }
  }

  void generateDefinedTypeSetAll(EDefined_type dt, PrintWriter pw, String at_name, int i_part, 
                                 int i_attr) throws SdaiException {
    EEntity ut = dt.getDomain(null);

    if (ut instanceof ESimple_type) {
      generateSimpleTypeSetAll((ESimple_type) ut, pw, at_name, i_part, i_attr);
    } else if (ut instanceof EAggregation_type) {
      generateAggregationTypeSetAll((EAggregation_type) ut, pw, at_name, i_part, i_attr);
    } else if (ut instanceof EDefined_type) {
      generateDefinedTypeSetAll((EDefined_type) ut, pw, at_name, i_part, i_attr);
    } else if (ut instanceof EEnumeration_type) {
      //         A_string enelements = ((EEnumeration_type)ut).getElements(null);
      pw.println("\t\t" + at_name + " = av.entityValues[" + i_part + "].getEnumeration(" + 
                 i_attr + ", " + at_name + "$);");
    } else if (ut instanceof ESelect_type) {
//      ANamed_type nt = ((ESelect_type) ut).getSelections(null);
//      ANamed_type nt = ((ESelect_type) ut).getLocal_selections(null);
      ANamed_type nt = getSelections((ESelect_type) ut);
      SelectPaths paths1 = null;
      int select_type = Integer.MIN_VALUE;
      Object temp_object = ut.getTemp();

      if (temp_object instanceof SelectPaths) {
        if (((SelectPaths) temp_object).owner == (ESelect_type) ut) {
          paths1 = (SelectPaths) temp_object;
          select_type = paths1.select_type;
        }
      }

      if (paths1 == null) {
        int count = 1;
        int[] indeces = new int[500];
        int depth = 0;
        int depth_count = 0;
        boolean with_type = false;
        Vector current_nodes = new Vector();
        Vector current_node_strings = new Vector();
        paths1 = new SelectPaths();
        paths1.owner = (ESelect_type) ut;
        select_type = calculateSelectPaths(count, current_nodes, current_node_strings, indeces, 
                                           depth, depth_count, paths1, (ESelect_type) ut, with_type);
        paths1.removeIdentical();
        paths1.select_type = select_type;
        ut.setTemp(paths1);
      }

      if (select_type != 0) { // includes defined_types
        pw.println("\t\t" + at_name + " = av.entityValues[" + i_part + "].getMixed(" + i_attr + 
                   "," + at_name + "$, this);");
        pw.println("\t\t" + at_name + "$$ = av.entityValues[" + i_part + "].getSelectNumber();");
      } else {
//        pw.println("\t\t" + at_name + " = av.entityValues[" + i_part + "].getInstance(" + i_attr + ", this);");
        pw.println("\t\t" + at_name + " = av.entityValues[" + i_part + "].getInstance(" + i_attr + ", this, " + at_name + "$);");
      }
    }
  }

  void generateAggregationTypeSetAll(EAggregation_type at, PrintWriter pw, String at_name, 
                                     int i_part, int i_attr)
                              throws SdaiException {


//System.out.println("<generateAggregationTypeSetAll> aggregation_type: " + at);

    int aggregate_depth = 1;
    EEntity an_ss;
    EEntity ass = at;
    String aggr_prefices = "";
    an_ss = at.getElement_type(null);

    for (;;) {
      boolean done_something = false;

      if (an_ss instanceof EDefined_type) {
        ass = an_ss;
        an_ss = ((EDefined_type) an_ss).getDomain(null);
        done_something = true;
      } else if (an_ss instanceof EAggregation_type) {
        aggr_prefices += "a";
        aggregate_depth++;
        ass = an_ss;
        an_ss = ((EAggregation_type) an_ss).getElement_type(null);
        done_something = true;
      }

      if (!done_something) {
        break;
      }
    }

    String aggr_prefix = "A" + aggr_prefices;
    String aggr_nesting = "";

    if (aggregate_depth > 1) {
      aggr_nesting += aggregate_depth;
    }

// System.out.println("<generateAggregationTypeSetAll> an_ss: " + an_ss);

    if (an_ss instanceof ESelect_type) {
      SelectPaths paths1 = null;
      int select_type = Integer.MIN_VALUE;
      Object temp_object = an_ss.getTemp();

// System.out.println("<generateAggregationTypeSetAll> temp_object: " + temp_object);


      if (temp_object instanceof SelectPaths) {
        if (((SelectPaths) temp_object).owner == (ESelect_type) an_ss) {
          paths1 = (SelectPaths) temp_object;
          select_type = paths1.select_type;
        }
      }

      if (paths1 == null) {
        int count = 1;
        int[] indeces = new int[500];
        int depth = 0;
        int depth_count = 0;
        boolean with_type = false;
        Vector current_nodes = new Vector();
        Vector current_node_strings = new Vector();
        paths1 = new SelectPaths();
        paths1.owner = (ESelect_type) an_ss;

// System.out.println("<generateAggregationTypeSetAll> before - select_type " + an_ss + ", current nodes: " + current_node_strings);

        select_type = calculateSelectPaths(count, current_nodes, current_node_strings, indeces, 
                                           depth, depth_count, paths1, (ESelect_type) an_ss, 
                                           with_type);
        paths1.removeIdentical();
        paths1.select_type = select_type;
        an_ss.setTemp(paths1);
      }

      if (select_type != 0) { // includes defined_types
        pw.println("\t\t" + at_name + " = (" + getAggregatePackage(aggr_prefix, ass) + 
                   ")av.entityValues[" + i_part + "].getMixedAggregate(" + i_attr + ", " + 
                   at_name + "$, this);");
      } else {
        pw.println("\t\t" + at_name + " = (" + getAggregatePackage(aggr_prefix, ass) + 
                   ")av.entityValues[" + i_part + "].getInstanceAggregate(" + i_attr + ", " + 
                   at_name + "$, this);");
      }
    } else if (an_ss instanceof EEntity_definition) {
      String base_entity_name = ((EEntity_definition) an_ss).getName(null);
      String base_name = getEntityPackage((EEntity_definition) an_ss) + "E" + 
                         base_entity_name.substring(0, 1).toUpperCase() + 
                         base_entity_name.substring(1).toLowerCase();


      // both for 1 and 2 - cast and getInstanceAggregate(this)
      pw.println("\t\t" + at_name + " = (" + getAggregatePackage(aggr_prefix, an_ss) + 
                 ")av.entityValues[" + i_part + "].getInstanceAggregate(" + i_attr + ", " + 
                 at_name + "$, this);");
    } else if (an_ss instanceof EEnumeration_type) {
      //      pw.println("\t\t" + at_name + " = av.entityValues[" + i_part + "].getEnumerationAggregate(" + i_attr + ", " + at_name + "$, this);");
      //       pw.println("\t\t" + at_name + " = (" + aggr_prefix + "_enumeration)av.entityValues[" + i_part + "].getEnumeration" + aggr_nesting + "Aggregate(" + i_attr + ", " + at_name + "$, this);");
      pw.println("\t\t" + at_name + " = av.entityValues[" + i_part + "].getEnumeration" + 
                 aggr_nesting + "Aggregate(" + i_attr + ", " + at_name + "$, this);");
    } else if (an_ss instanceof EInteger_type) {
      //      pw.println("\t\t" + at_name + " = av.entityValues[" + i_part + "].getInteger" + aggr_nesting + "Aggregate(" + i_attr + ", " + at_name + "$, this);");
      //       pw.println("\t\t" + at_name + " = (" + aggr_prefix + "_integer)av.entityValues[" + i_part + "].getInteger" + aggr_nesting + "Aggregate(" + i_attr + ", " + at_name + "$, this);");
      pw.println("\t\t" + at_name + " = av.entityValues[" + i_part + "].getInteger" + 
                 aggr_nesting + "Aggregate(" + i_attr + ", " + at_name + "$, this);");
    } else if (an_ss instanceof ENumber_type) {
      //      pw.println("\t\t" + at_name + " = av.entityValues[" + i_part + "].getDoubleAggregate(" + i_attr + ", " + at_name + "$, this);");
      //       pw.println("\t\t" + at_name + " = (" + aggr_prefix + "_double)av.entityValues[" + i_part + "].getDouble" + aggr_nesting + "Aggregate(" + i_attr + ", " + at_name + "$, this);");
      pw.println("\t\t" + at_name + " = av.entityValues[" + i_part + "].getDouble" + 
                 aggr_nesting + "Aggregate(" + i_attr + ", " + at_name + "$, this);");
    } else if (an_ss instanceof EReal_type) {
      //      pw.println(")av.entityValues[" + i_part + "].getDouble" + aggr_nesting + "Aggregate(" + i_attr + ", " + at_name + "$, this);");
      //       pw.println("\t\t" + at_name + " = (" + aggr_prefix + "_double)av.entityValues[" + i_part + "].getDouble" + aggr_nesting + "Aggregate(" + i_attr + ", " + at_name + "$, this);");
      pw.println("\t\t" + at_name + " = av.entityValues[" + i_part + "].getDouble" + 
                 aggr_nesting + "Aggregate(" + i_attr + ", " + at_name + "$, this);");
    } else if (an_ss instanceof EString_type) {
      //         pw.println("\t\treturn (" + aggr_prefix + "_string)get_aggregate(" + attr_internal_name + ");");
      pw.println("\t\t" + at_name + " = av.entityValues[" + i_part + "].getString" + 
                 aggr_nesting + "Aggregate(" + i_attr + ", " + at_name + "$, this);");
    } else if (an_ss instanceof ELogical_type) {
      //         pw.println("\t\treturn (" + aggr_prefix + "_enumeration)get_aggregate(" + attr_internal_name + ");");
      pw.println("\t\t" + at_name + " = av.entityValues[" + i_part + "].getLogical" + 
                 aggr_nesting + "Aggregate(" + i_attr + ", " + at_name + "$, this);");
    } else if (an_ss instanceof EBoolean_type) {
      //         pw.println("\t\treturn (" + aggr_prefix + "_boolean)get_aggregate(" + attr_internal_name + ");");
      pw.println("\t\t" + at_name + " = av.entityValues[" + i_part + "].getBoolean" + 
                 aggr_nesting + "Aggregate(" + i_attr + ", " + at_name + "$, this);");
    } else if (an_ss instanceof EBinary_type) {
      //         pw.println("\t\treturn (" + aggr_prefix + "_binary)get_aggregate(" + attr_internal_name + ");");
      pw.println("\t\t" + at_name + " = av.entityValues[" + i_part + "].getBinary" + 
                 aggr_nesting + "Aggregate(" + i_attr + ", " + at_name + "$, this);");
    }
  }





  void generateGetAllX(EEntity_definition ed, PrintWriter pw, ArrayList all_attributes, 
                      ArrayList all_flags) throws SdaiException {
    pw.println("\tprotected void getAll(ComplexEntityValue av) throws SdaiException {");


		SdaiModel edmod = ed.findEntityInstanceSdaiModel();
		boolean is_xim = false;
//		if (edmod.getName().endsWith("_XIM_DICTIONARY_DATA")) {
		if ((edmod.getName().endsWith("_XIM_DICTIONARY_DATA")) || (edmod.getName().equalsIgnoreCase("MIXED_COMPLEX_TYPES_DICTIONARY_DATA"))) {
			is_xim = true;
		}


		// TEMP REMOVAL
//    pw.println("\t}");
//		if (true) return;

    CompareUppercaseEntities ce = new CompareUppercaseEntities();

    //      CompareEntities ce = new CompareEntities();
    TreeSet parts = new TreeSet(ce);
    getExternalMappingParts(ed, parts);

    boolean is_complex = ed.getComplex(null);

    if (!is_complex) {
      parts.add(ed);
    }

    //      int extent_index0 = getPartialEntityIndex(ed); // index of current entity ed
    //RR##  pw.println("\t\tav.index = " + extent_index0 + ";");
    Iterator iter = parts.iterator();
    int i_part = 0;

    while (iter.hasNext()) {
      EEntity_definition part = (EEntity_definition) iter.next();
      pw.println("\t\t// partial entity: " + part.getName(null));

      //         int extent_index = getPartialEntityIndex(part); // index of current part
      //RR##   pw.println("\t\tav.entityValues[" + i_part + "].index = " + extent_index + ";");
      //RR- explicit_attributes removed-         AExplicit_attribute xa = part.getExplicit_attributes(null);
      AExplicit_attribute xa = getExplicit_attributes(part);
      SdaiIterator ia = xa.createIterator();
      int i_attr = 0;
      String at_name = null;

      while (ia.next()) {
        EExplicit_attribute xattr = (EExplicit_attribute) xa.getCurrentMemberObject(ia);

				TheAttribute tattr = findTheAttributeX(all_attributes, xattr);

				if (!tattr.consolidated) {
					System.out.println("INTERNAL ERROR!!! NOT CONSOLIDATED: " + tattr.attr);
					continue;
				}

//				if (tattr.explicit_to_derived) {
				if (tattr.consolidated_type == 1) { // derived
        	if (is_xim) {
        	
        	// put stuff 
        	pw.println("\t\tif (av.xim_special_substitute_instance) {");
						//av.entityValues[0].setEnumeration(0, a0, a0$); // the whole if - for xims only
// ---------------------------


  	      if (tattr.consolidated) {
    	    	at_name = "a" + tattr.consolidated_explicit_index;
					} else {
        		at_name = "a" + tattr.explicit_index;
						System.out.println("NOT consolidated: " + tattr.attr);
					}

          boolean is_redeclaring = xattr.testRedeclaring(null);

          if (!is_redeclaring) { // redeclaring will not happen here

            // get attribute base type and generate for each base type appropriate code.
            EEntity bt = xattr.getDomain(null);

            if (bt instanceof ESimple_type) {
              generateSimpleTypeGetAll((ESimple_type) bt, pw, at_name, i_part, i_attr);
            } else if (bt instanceof EAggregation_type) {
              generateAggregationTypeGetAll((EAggregation_type) bt, pw, at_name, i_part, i_attr);
            } else if (bt instanceof EDefined_type) {
              generateDefinedTypeGetAll((EDefined_type) bt, pw, at_name, i_part, i_attr);
            } else if (bt instanceof EEntity_definition) {
              pw.println("\t\t\tav.entityValues[" + i_part + "].setInstance(" + i_attr + ", " + 
                         at_name + ");");
            }
          } else {
          }
// ------------------------------------------- end
					pw.println("\t\t} else {");
          	pw.println("\t\t\tav.entityValues[" + i_part + "].values[" + i_attr + "].tag = EntityValue.REDEFINE;");
					pw.println("\t\t}");	

          	i_attr++; // test RR
        	
        	
        	} else {
        
          	pw.println("\t\tav.entityValues[" + i_part + "].values[" + i_attr + "].tag = EntityValue.REDEFINE;");
          	i_attr++; // test RR
        	}
        } else {
          //               at_name = "a" + all_index;
          //at_name = "a" + getInternalAttributeNumber(all_index, all_flags);

//					at_name = "a" + tattr.explicit_index;
  	      if (tattr.consolidated) {
    	    	at_name = "a" + tattr.consolidated_explicit_index;
					} else {
        		at_name = "a" + tattr.explicit_index;
						System.out.println("NOT consolidated: " + tattr.attr);
					}

          boolean is_redeclaring = xattr.testRedeclaring(null);

          if (!is_redeclaring) { // redeclaring will not happen here

            // get attribute base type and generate for each base type appropriate code.
            EEntity bt = xattr.getDomain(null);

            if (bt instanceof ESimple_type) {
              generateSimpleTypeGetAll((ESimple_type) bt, pw, at_name, i_part, i_attr);
            } else if (bt instanceof EAggregation_type) {
              generateAggregationTypeGetAll((EAggregation_type) bt, pw, at_name, i_part, i_attr);
            } else if (bt instanceof EDefined_type) {
              generateDefinedTypeGetAll((EDefined_type) bt, pw, at_name, i_part, i_attr);
            } else if (bt instanceof EEntity_definition) {
              pw.println("\t\tav.entityValues[" + i_part + "].setInstance(" + i_attr + ", " + 
                         at_name + ");");
            }
          } else {
          }

          i_attr++; // hope it is inside if not later redeclared.
        } // if not later redeclared
      } // loop - attributes

      i_part++;
    } // loop - parts

    pw.println("\t}");
  }




  void generateGetAllX_prev(EEntity_definition ed, PrintWriter pw, ArrayList all_attributes, 
                      ArrayList all_flags) throws SdaiException {
    pw.println("\tprotected void getAll(ComplexEntityValue av) throws SdaiException {");


		// TEMP REMOVAL
//    pw.println("\t}");
//		if (true) return;

    CompareUppercaseEntities ce = new CompareUppercaseEntities();

    //      CompareEntities ce = new CompareEntities();
    TreeSet parts = new TreeSet(ce);
    getExternalMappingParts(ed, parts);

    boolean is_complex = ed.getComplex(null);

    if (!is_complex) {
      parts.add(ed);
    }

    //      int extent_index0 = getPartialEntityIndex(ed); // index of current entity ed
    //RR##  pw.println("\t\tav.index = " + extent_index0 + ";");
    Iterator iter = parts.iterator();
    int i_part = 0;

    while (iter.hasNext()) {
      EEntity_definition part = (EEntity_definition) iter.next();
      pw.println("\t\t// partial entity: " + part.getName(null));

      //         int extent_index = getPartialEntityIndex(part); // index of current part
      //RR##   pw.println("\t\tav.entityValues[" + i_part + "].index = " + extent_index + ";");
      //RR- explicit_attributes removed-         AExplicit_attribute xa = part.getExplicit_attributes(null);
      AExplicit_attribute xa = getExplicit_attributes(part);
      SdaiIterator ia = xa.createIterator();
      int i_attr = 0;
      String at_name = null;

      while (ia.next()) {
        EExplicit_attribute xattr = (EExplicit_attribute) xa.getCurrentMemberObject(ia);

				TheAttribute tattr = findTheAttributeX(all_attributes, xattr);

				if (!tattr.consolidated) {
					System.out.println("INTERNAL ERROR!!! NOT CONSOLIDATED: " + tattr.attr);
					continue;
				}

//				if (tattr.explicit_to_derived) {
				if (tattr.consolidated_type == 1) { // derived
          pw.println("\t\tav.entityValues[" + i_part + "].values[" + i_attr + 
                     "].tag = EntityValue.REDEFINE;");
          i_attr++; // test RR
        } else {
          //               at_name = "a" + all_index;
          //at_name = "a" + getInternalAttributeNumber(all_index, all_flags);

//					at_name = "a" + tattr.explicit_index;
  	      if (tattr.consolidated) {
    	    	at_name = "a" + tattr.consolidated_explicit_index;
					} else {
        		at_name = "a" + tattr.explicit_index;
						System.out.println("NOT consolidated: " + tattr.attr);
					}

          boolean is_redeclaring = xattr.testRedeclaring(null);

          if (!is_redeclaring) { // redeclaring will not happen here

            // get attribute base type and generate for each base type appropriate code.
            EEntity bt = xattr.getDomain(null);

            if (bt instanceof ESimple_type) {
              generateSimpleTypeGetAll((ESimple_type) bt, pw, at_name, i_part, i_attr);
            } else if (bt instanceof EAggregation_type) {
              generateAggregationTypeGetAll((EAggregation_type) bt, pw, at_name, i_part, i_attr);
            } else if (bt instanceof EDefined_type) {
              generateDefinedTypeGetAll((EDefined_type) bt, pw, at_name, i_part, i_attr);
            } else if (bt instanceof EEntity_definition) {
              pw.println("\t\tav.entityValues[" + i_part + "].setInstance(" + i_attr + ", " + 
                         at_name + ");");
            }
          } else {
          }

          i_attr++; // hope it is inside if not later redeclared.
        } // if not later redeclared
      } // loop - attributes

      i_part++;
    } // loop - parts

    pw.println("\t}");
  }

  void generateGetAll(EEntity_definition ed, PrintWriter pw, Vector all_attributes, 
                      Vector all_flags) throws SdaiException {
    pw.println("\tprotected void getAll(ComplexEntityValue av) throws SdaiException {");

		// TEMP REMOVAL
//    pw.println("\t}");
//		if (true) return;

    CompareUppercaseEntities ce = new CompareUppercaseEntities();

    //      CompareEntities ce = new CompareEntities();
    TreeSet parts = new TreeSet(ce);
    getExternalMappingParts(ed, parts);

    boolean is_complex = ed.getComplex(null);

    if (!is_complex) {
      parts.add(ed);
    }

    //      int extent_index0 = getPartialEntityIndex(ed); // index of current entity ed
    //RR##  pw.println("\t\tav.index = " + extent_index0 + ";");
    Iterator iter = parts.iterator();
    int i_part = 0;

    while (iter.hasNext()) {
      EEntity_definition part = (EEntity_definition) iter.next();
      pw.println("\t\t// partial entity: " + part.getName(null));

      //         int extent_index = getPartialEntityIndex(part); // index of current part
      //RR##   pw.println("\t\tav.entityValues[" + i_part + "].index = " + extent_index + ";");
      //RR- explicit_attributes removed-         AExplicit_attribute xa = part.getExplicit_attributes(null);
      AExplicit_attribute xa = getExplicit_attributes(part);
      SdaiIterator ia = xa.createIterator();
      int i_attr = 0;
      String at_name = null;

      while (ia.next()) {
        EExplicit_attribute xattr = (EExplicit_attribute) xa.getCurrentMemberObject(ia);
        int all_index = all_attributes.indexOf(xattr);
        int attribute_flag = (int) ((Integer) all_flags.elementAt(all_index)).intValue();

        if ((attribute_flag == AA_JAVA_EXPLICIT_TO_DERIVED) || 
                (attribute_flag == AA_SUPERTYPE_EXPLICIT_TO_DERIVED) || 
                (attribute_flag == AA_CURRENT_EXPLICIT_TO_DERIVED)) {
          pw.println("\t\tav.entityValues[" + i_part + "].values[" + i_attr + 
                     "].tag = EntityValue.REDEFINE;");
          i_attr++; // test RR
        } else {
          //               at_name = "a" + all_index;
          at_name = "a" + getInternalAttributeNumber(all_index, all_flags);

          boolean is_redeclaring = xattr.testRedeclaring(null);

          if (!is_redeclaring) { // redeclaring will not happen here

            // get attribute base type and generate for each base type appropriate code.
            EEntity bt = xattr.getDomain(null);

            if (bt instanceof ESimple_type) {
              generateSimpleTypeGetAll((ESimple_type) bt, pw, at_name, i_part, i_attr);
            } else if (bt instanceof EAggregation_type) {
              generateAggregationTypeGetAll((EAggregation_type) bt, pw, at_name, i_part, i_attr);
            } else if (bt instanceof EDefined_type) {
              generateDefinedTypeGetAll((EDefined_type) bt, pw, at_name, i_part, i_attr);
            } else if (bt instanceof EEntity_definition) {
              pw.println("\t\tav.entityValues[" + i_part + "].setInstance(" + i_attr + ", " + 
                         at_name + ");");
            }
          } else {
          }

          i_attr++; // hope it is inside if not later redeclared.
        } // if not later redeclared
      } // loop - attributes

      i_part++;
    } // loop - parts

    pw.println("\t}");
  }

  void generateSimpleTypeGetAll(ESimple_type st, PrintWriter pw, String at_name, int i_part, 
                                int i_attr) {
    if (st instanceof EInteger_type) {
      pw.println("\t\tav.entityValues[" + i_part + "].setInteger(" + i_attr + ", " + at_name + 
                 ");");
    } else if (st instanceof ENumber_type) {
      pw.println("\t\tav.entityValues[" + i_part + "].setDouble(" + i_attr + ", " + at_name + 
                 ");");
    } else if (st instanceof EReal_type) {
      pw.println("\t\tav.entityValues[" + i_part + "].setDouble(" + i_attr + ", " + at_name + 
                 ");");
    } else if (st instanceof EBoolean_type) {
      pw.println("\t\tav.entityValues[" + i_part + "].setBoolean(" + i_attr + ", " + at_name + 
                 ");");
    } else if (st instanceof ELogical_type) {
      pw.println("\t\tav.entityValues[" + i_part + "].setLogical(" + i_attr + ", " + at_name + 
                 ");");
    } else if (st instanceof EBinary_type) {
      pw.println("\t\tav.entityValues[" + i_part + "].setBinary(" + i_attr + ", " + at_name + 
                 ");");
    } else if (st instanceof EString_type) {
      pw.println("\t\tav.entityValues[" + i_part + "].setString(" + i_attr + ", " + at_name + 
                 ");");
    }
  }

  void generateDefinedTypeGetAll(EDefined_type dt, PrintWriter pw, String at_name, int i_part, 
                                 int i_attr) throws SdaiException {
    EEntity ut = dt.getDomain(null);

    if (ut instanceof ESimple_type) {
      generateSimpleTypeGetAll((ESimple_type) ut, pw, at_name, i_part, i_attr);
    } else if (ut instanceof EAggregation_type) {
      generateAggregationTypeGetAll((EAggregation_type) ut, pw, at_name, i_part, i_attr);
    } else if (ut instanceof EDefined_type) {
      generateDefinedTypeGetAll((EDefined_type) ut, pw, at_name, i_part, i_attr);
    } else if (ut instanceof EEnumeration_type) {
      //         A_string enelements = ((EEnumeration_type)ut).getElements(null);
      pw.println("\t\tav.entityValues[" + i_part + "].setEnumeration(" + i_attr + ", " + at_name + 
                 ", " + at_name + "$);");
    } else if (ut instanceof ESelect_type) {
//      ANamed_type nt = ((ESelect_type) ut).getSelections(null);
//      ANamed_type nt = ((ESelect_type) ut).getLocal_selections(null);
      ANamed_type nt = getSelections((ESelect_type) ut);
      SelectPaths paths1 = null;
      int select_type = Integer.MIN_VALUE;
      Object temp_object = ut.getTemp();

      if (temp_object instanceof SelectPaths) {
        if (((SelectPaths) temp_object).owner == (ESelect_type) ut) {
          paths1 = (SelectPaths) temp_object;
          select_type = paths1.select_type;
        }
      }

      if (paths1 == null) {
        int count = 1;
        int[] indeces = new int[500];
        int depth = 0;
        int depth_count = 0;
        boolean with_type = false;
        Vector current_nodes = new Vector();
        Vector current_node_strings = new Vector();
        paths1 = new SelectPaths();
        paths1.owner = (ESelect_type) ut;
        select_type = calculateSelectPaths(count, current_nodes, current_node_strings, indeces, 
                                           depth, depth_count, paths1, (ESelect_type) ut, with_type);
        paths1.removeIdentical();
        paths1.select_type = select_type;
        ut.setTemp(paths1);
      }

      if (select_type != 0) { // includes defined_types
        pw.println("\t\tav.entityValues[" + i_part + "].setMixed(" + i_attr + ", " + at_name + 
                   ", " + at_name + "$, " + at_name + "$$);");
      } else {
        pw.println("\t\tav.entityValues[" + i_part + "].setInstance(" + i_attr + ", " + at_name + 
                   ");");
      }
    }
  }

  void generateAggregationTypeGetAll(EAggregation_type at, PrintWriter pw, String at_name, 
                                     int i_part, int i_attr)
                              throws SdaiException {
    int aggregate_depth = 1;
    EEntity an_ss;
    EEntity ass = at;
    String aggr_prefices = "";
    an_ss = at.getElement_type(null);

    for (;;) {
      boolean done_something = false;

      if (an_ss instanceof EDefined_type) {
        ass = an_ss;
        an_ss = ((EDefined_type) an_ss).getDomain(null);
        done_something = true;
      } else if (an_ss instanceof EAggregation_type) {
        aggr_prefices += "a";
        aggregate_depth++;
        ass = an_ss;
        an_ss = ((EAggregation_type) an_ss).getElement_type(null);
        done_something = true;
      }

      if (!done_something) {
        break;
      }
    }

    String aggr_prefix = "A" + aggr_prefices;
    String aggr_nesting = "";

    if (aggregate_depth > 1) {
      aggr_nesting += aggregate_depth;
    }

    if (an_ss instanceof ESelect_type) {
      SelectPaths paths1 = null;
      int select_type = Integer.MIN_VALUE;
      Object temp_object = an_ss.getTemp();

      if (temp_object instanceof SelectPaths) {
        if (((SelectPaths) temp_object).owner == (ESelect_type) an_ss) {
          paths1 = (SelectPaths) temp_object;
          select_type = paths1.select_type;
        }
      }

      if (paths1 == null) {
        int count = 1;
        int[] indeces = new int[500];
        int depth = 0;
        int depth_count = 0;
        boolean with_type = false;
        Vector current_nodes = new Vector();
        Vector current_node_strings = new Vector();
        paths1 = new SelectPaths();
        paths1.owner = (ESelect_type) an_ss;
        select_type = calculateSelectPaths(count, current_nodes, current_node_strings, indeces, 
                                           depth, depth_count, paths1, (ESelect_type) an_ss, 
                                           with_type);
        paths1.removeIdentical();
        paths1.select_type = select_type;
        an_ss.setTemp(paths1);
      }

      if (select_type != 0) { // includes defined_types
        pw.println("\t\tav.entityValues[" + i_part + "].setMixedAggregate(" + i_attr + ", " + 
                   at_name + ", " + at_name + "$);");
      } else {
        pw.println("\t\tav.entityValues[" + i_part + "].setInstanceAggregate(" + i_attr + ", " + 
                   at_name + ");");
      }
    } else if (an_ss instanceof EEntity_definition) {
      pw.println("\t\tav.entityValues[" + i_part + "].setInstanceAggregate(" + i_attr + ", " + 
                 at_name + ");");
    } else if (an_ss instanceof EEnumeration_type) {
      pw.println("\t\tav.entityValues[" + i_part + "].setEnumeration" + aggr_nesting + 
                 "Aggregate(" + i_attr + ", " + at_name + ", " + at_name + "$);");
    } else if (an_ss instanceof EInteger_type) {
      pw.println("\t\tav.entityValues[" + i_part + "].setInteger" + aggr_nesting + "Aggregate(" + 
                 i_attr + ", " + at_name + ");");
    } else if (an_ss instanceof ENumber_type) {
      pw.println("\t\tav.entityValues[" + i_part + "].setDouble" + aggr_nesting + "Aggregate(" + 
                 i_attr + ", " + at_name + ");");
    } else if (an_ss instanceof EReal_type) {
      pw.println("\t\tav.entityValues[" + i_part + "].setDouble" + aggr_nesting + "Aggregate(" + 
                 i_attr + ", " + at_name + ");");
    } else if (an_ss instanceof EString_type) {
      pw.println("\t\tav.entityValues[" + i_part + "].setString" + aggr_nesting + "Aggregate(" + 
                 i_attr + ", " + at_name + ");");
    } else if (an_ss instanceof ELogical_type) {
      pw.println("\t\tav.entityValues[" + i_part + "].setLogical" + aggr_nesting + "Aggregate(" + 
                 i_attr + ", " + at_name + ");");
    } else if (an_ss instanceof EBoolean_type) {
      pw.println("\t\tav.entityValues[" + i_part + "].setBoolean" + aggr_nesting + "Aggregate(" + 
                 i_attr + ", " + at_name + ");");
    } else if (an_ss instanceof EBinary_type) {
      pw.println("\t\tav.entityValues[" + i_part + "].setBinary" + aggr_nesting + "Aggregate(" + 
                 i_attr + ", " + at_name + ");");
    }
  }

  static void getExternalMappingParts(EEntity_definition ed, TreeSet result)
                               throws SdaiException {
//    AEntity_or_view_definition supertypes = ed.getSupertypes(null);
    AEntity_or_view_definition supertypes = ed.getGeneric_supertypes(null);

    // AEntity_definition supertypes = ed.getSupertypes(null);
    SdaiIterator iterSuper = supertypes.createIterator();

    while (iterSuper.next()) {
      EEntity_definition superEntity = (EEntity_definition) supertypes.getCurrentMember(iterSuper);
      getExternalMappingParts(superEntity, result);
      result.add(superEntity);
    }
  }

  int getPartialEntityIndex(EEntity_definition ed) throws SdaiException {
    CompareUppercaseEntities cu = new CompareUppercaseEntities();
    TreeSet part_list = new TreeSet(cu);
    getSortedPartList(part_list, ed);

    Vector part_vector = new Vector(part_list);

    return part_vector.indexOf(ed);
  }

  void getSortedPartList(TreeSet part_list, EEntity_definition ed)
                  throws SdaiException {
    // get the sdai model of ed, and then construct the sorted list of all entities in that model
    SdaiModel entity_model = ed.findEntityInstanceSdaiModel();
    Aggregate aed = entity_model.getEntityExtentInstances(EEntity_definition.class);
    SdaiIterator ied = aed.createIterator();

    while (ied.next()) {
      EEntity_definition ed1 = (EEntity_definition) aed.getCurrentMemberObject(ied);
      part_list.add(ed1);
    }
  }

  AExplicit_attribute getExplicit_attributes(EEntity_definition ed) throws SdaiException {
    AExplicit_attribute axa = new AExplicit_attribute();
    CompareAttributes ce = new CompareAttributes();
    TreeSet axas = new TreeSet(ce);
    ASdaiModel domain = null;
    AAttribute aa = ed.getAttributes(null, domain);
    SdaiIterator iaa = aa.createIterator();

    while (iaa.next()) {
      EAttribute an_a = (EAttribute) aa.getCurrentMemberObject(iaa);

      if (an_a instanceof EExplicit_attribute) {
        // EEntity_definition ped = an_a.getParent_entity(null);
        EEntity_definition ped = (EEntity_definition) an_a.getParent_entity(null);

        if (ped == ed) {
          // int order = an_a.getOrder(null);
          // if (order != Integer.MIN_VALUE) {
          if (an_a.testOrder(null)) {
            axas.add(an_a);
          }
        }
      }
    }

    Iterator iter = axas.iterator();
    int i_part = 0;

    while (iter.hasNext()) {
      EExplicit_attribute xa = (EExplicit_attribute) iter.next();
      axa.addByIndex(axa.getMemberCount() + 1, xa);
    }

    return axa;
  }

  // may need to expand - to include all redeclaring attributes, not only those that have RENAMED 
  
  AExplicit_attribute getExplicit_attributes3(EEntity_definition ed) throws SdaiException {
    AExplicit_attribute axa = new AExplicit_attribute();
    CompareAttributes2 ce = new CompareAttributes2();
    TreeSet axas = new TreeSet(ce);
    ASdaiModel domain = null;
    AAttribute aa = ed.getAttributes(null, domain);
    SdaiIterator iaa = aa.createIterator();

    while (iaa.next()) {
      EAttribute an_a = (EAttribute) aa.getCurrentMemberObject(iaa);

//System.out.println(">> entity: " + ed.getName(null) + ", attribute: " + an_a);

      if (an_a instanceof EExplicit_attribute) {
        // EEntity_definition ped = an_a.getParent_entity(null);
        EEntity_definition ped = (EEntity_definition) an_a.getParent_entity(null);

        if (ped == ed) {
          // int order = an_a.getOrder(null);
          // if (order != Integer.MIN_VALUE) {
//          if (an_a.testOrder(null)) {
            axas.add(an_a);
//System.out.println(">> entity: " + ed.getName(null) + ", added attribute: " + an_a);
//          }
        }
      }
    }
//System.out.println(">> axas: " + axas);

    Iterator iter = axas.iterator();
    int i_part = 0;

    while (iter.hasNext()) {
      EExplicit_attribute xa = (EExplicit_attribute) iter.next();
      axa.addByIndex(axa.getMemberCount() + 1, xa);
    }
//System.out.println(">> axa: " + axa);

    return axa;
  }

  AExplicit_attribute getExplicit_attributes2(EEntity_definition ed) throws SdaiException {
    AExplicit_attribute axa = new AExplicit_attribute();
    CompareAttributes2 ce = new CompareAttributes2();
    TreeSet axas = new TreeSet(ce);
    ASdaiModel domain = null;
    AAttribute aa = ed.getAttributes(null, domain);
    SdaiIterator iaa = aa.createIterator();

    while (iaa.next()) {
      EAttribute an_a = (EAttribute) aa.getCurrentMemberObject(iaa);

//System.out.println(">> entity: " + ed.getName(null) + ", attribute: " + an_a);

      if (an_a instanceof EExplicit_attribute) {
        // EEntity_definition ped = an_a.getParent_entity(null);
        EEntity_definition ped = (EEntity_definition) an_a.getParent_entity(null);

        if (ped == ed) {
          // int order = an_a.getOrder(null);
          // if (order != Integer.MIN_VALUE) {
//          if (an_a.testOrder(null)) {
            axas.add(an_a);
//System.out.println(">> entity: " + ed.getName(null) + ", added attribute: " + an_a);
//          }
        }
      }
    }
//System.out.println(">> axas: " + axas);

    Iterator iter = axas.iterator();
    int i_part = 0;

    while (iter.hasNext()) {
      EExplicit_attribute xa = (EExplicit_attribute) iter.next();
      axa.addByIndex(axa.getMemberCount() + 1, xa);
    }
//System.out.println(">> axa: " + axa);

    return axa;
  }


  ADerived_attribute getDerived_attributes3(EEntity_definition ed)
                                    throws SdaiException {
    ADerived_attribute axa = new ADerived_attribute();
    CompareAttributes ce = new CompareAttributes();
    TreeSet axas = new TreeSet(ce);
    ASdaiModel domain = null;
    AAttribute aa = ed.getAttributes(null, domain);
    SdaiIterator iaa = aa.createIterator();

// System.out.println("XOXOX---------- entity: " + ed.getName(null));
    while (iaa.next()) {
      EAttribute an_a = (EAttribute) aa.getCurrentMemberObject(iaa);

// System.out.println("\tXOXOX attribute: " + an_a);
      if (an_a instanceof EDerived_attribute) {
        // EEntity_definition ped = an_a.getParent_entity(null);
        EEntity_definition ped = (EEntity_definition) an_a.getParent_entity(null);

// System.out.println("XOXOX-2 derived attribute: " + an_a);
//          if (true) { 
        if (ped == ed) {
          // int order = an_a.getOrder(null);
          // if (order != Integer.MIN_VALUE) {
          if (an_a.testOrder(null)) {
// System.out.println("XOXOX-3 order: " + an_a.getOrder(null));
            axas.add(an_a);
          } else {
// System.out.println("XOXOX-3 order UNSET");
// order is unset in redeclaring attributes - OPTIONAL
            axas.add(an_a);
          }
        }
      }
    }

    Iterator iter = axas.iterator();
    int i_part = 0;

    while (iter.hasNext()) {
      EDerived_attribute xa = (EDerived_attribute) iter.next();
// System.out.println("\t\tXOXOX final attribute: " + xa);
      axa.addByIndex(axa.getMemberCount() + 1, xa);
    }

    return axa;
  }


  ADerived_attribute getDerived_attributes(EEntity_definition ed)
                                    throws SdaiException {
    ADerived_attribute axa = new ADerived_attribute();
    CompareAttributes ce = new CompareAttributes();
    TreeSet axas = new TreeSet(ce);
    ASdaiModel domain = null;
    AAttribute aa = ed.getAttributes(null, domain);
    SdaiIterator iaa = aa.createIterator();

// System.out.println("XOXOX---------- entity: " + ed.getName(null));
    while (iaa.next()) {
      EAttribute an_a = (EAttribute) aa.getCurrentMemberObject(iaa);

// System.out.println("\tXOXOX attribute: " + an_a);
      if (an_a instanceof EDerived_attribute) {
        // EEntity_definition ped = an_a.getParent_entity(null);
        EEntity_definition ped = (EEntity_definition) an_a.getParent_entity(null);

// System.out.println("XOXOX-2 derived attribute: " + an_a);
//          if (true) { 
        if (ped == ed) {
          // int order = an_a.getOrder(null);
          // if (order != Integer.MIN_VALUE) {
          if (an_a.testOrder(null)) {
// System.out.println("XOXOX-3 order: " + an_a.getOrder(null));
            axas.add(an_a);
          } else {
// System.out.println("XOXOX-3 order UNSET");
// order is unset in redeclaring attributes - OPTIONAL
            axas.add(an_a);
          }
        }
      }
    }

    Iterator iter = axas.iterator();
    int i_part = 0;

    while (iter.hasNext()) {
      EDerived_attribute xa = (EDerived_attribute) iter.next();
// System.out.println("\t\tXOXOX final attribute: " + xa);
      axa.addByIndex(axa.getMemberCount() + 1, xa);
    }

    return axa;
  }

  AInverse_attribute getInverse_attributes(EEntity_definition ed)
                                    throws SdaiException {
    AInverse_attribute axa = new AInverse_attribute();
    CompareAttributes ce = new CompareAttributes();
    TreeSet axas = new TreeSet(ce);
    ASdaiModel domain = null;
    AAttribute aa = ed.getAttributes(null, domain);
    SdaiIterator iaa = aa.createIterator();

    while (iaa.next()) {
      EAttribute an_a = (EAttribute) aa.getCurrentMemberObject(iaa);

//System.out.println("><>< getting inverse attributes: " + an_a);

      if (an_a instanceof EInverse_attribute) {
        EEntity_definition ped = (EEntity_definition) an_a.getParent_entity(null);

        // EEntity_definition ped = an_a.getParent_entity(null);
        if (ped == ed) {
          // int order = an_a.getOrder(null);
          // if (order != Integer.MIN_VALUE) {
          if (an_a.testOrder(null)) {
            axas.add(an_a);
          } else {
						// allow also redeclaring attributes
            axas.add(an_a);
          }
        }
      }
    }

    Iterator iter = axas.iterator();
    int i_part = 0;

    while (iter.hasNext()) {
      EInverse_attribute xa = (EInverse_attribute) iter.next();
      axa.addByIndex(axa.getMemberCount() + 1, xa);
    }

    return axa;
  }

  String get_time() {
    GregorianCalendar cal = new GregorianCalendar();
    int year = cal.get(Calendar.YEAR);
    int month = cal.get(Calendar.MONTH) + 1;
    boolean month_one_digit;

    if (month < 10) {
      month_one_digit = true;
    } else {
      month_one_digit = false;
    }

    int day = cal.get(Calendar.DAY_OF_MONTH);
    boolean day_one_digit;

    if (day < 10) {
      day_one_digit = true;
    } else {
      day_one_digit = false;
    }

    int hour = cal.get(Calendar.HOUR_OF_DAY);
    boolean hour_one_digit;

    if (hour < 10) {
      hour_one_digit = true;
    } else {
      hour_one_digit = false;
    }

    int minute = cal.get(Calendar.MINUTE);
    boolean minute_one_digit;

    if (minute < 10) {
      minute_one_digit = true;
    } else {
      minute_one_digit = false;
    }

    int second = cal.get(Calendar.SECOND);
    boolean second_one_digit;

    if (second < 10) {
      second_one_digit = true;
    } else {
      second_one_digit = false;
    }

    String time_stamp = year + "-";

    if (month_one_digit) {
      time_stamp = time_stamp + "0";
    }

    time_stamp = time_stamp + month + "-";

    if (day_one_digit) {
      time_stamp = time_stamp + "0";
    }

    time_stamp = time_stamp + day + " T";

    if (hour_one_digit) {
      time_stamp = time_stamp + "0";
    }

    time_stamp = time_stamp + hour + ":";

    if (minute_one_digit) {
      time_stamp = time_stamp + "0";
    }

    time_stamp = time_stamp + minute + ":";

    if (second_one_digit) {
      time_stamp = time_stamp + "0";
    }

    return time_stamp + second;
  }

  // no longer used, EJava_code no longer available

  /*
  EJava_code findJava_codeForDerivedAttribute(EAttribute attr) throws SdaiException {
        EJava_code result = null;
        if (java_model != null) {
  printDDebug("### ### java_model is OK: " + java_model.getName());
           Aggregate ajc = java_model.getEntityExtentInstances(EJava_code.class);
           SdaiIterator ijc = ajc.createIterator();
           while (ijc.next()) {
              EJava_code jc = (EJava_code)ajc.getCurrentMemberObject(ijc);
              EEntity attr1 = jc.getTarget(null);
              if (attr1 == attr) {
                 result = jc;
                 break;
              }
           }
        } else {
  printDDebug("### ### java_model is NULL");
        } 
        return result;
  }
   */
  static void generateExpressionBody(PrintWriter pw, A_string expression_java)
                              throws SdaiException {
    SdaiIterator is = expression_java.createIterator();

    while (is.next()) {
      String a_line = (String) expression_java.getCurrentMemberObject(is);

      //     pw.println("\t\t\t\t" + a_line);
    }
  }

  static void generateJavaExpression(PrintWriter pw, EEntity ee, EGeneric_schema_definition __sd, 
                                     EEntity_definition __ed, SdaiModel a_model)
                              throws SdaiException {
    if (!flag_expressions) {
      return;
    }

    // static_model = model;

//System.out.println("######## in generateJavaExpression, ee: " + ee + ", ed: " + __ed);
// pw.println("\t\t// #X# in generateJavaExpression, ee: " + ee + ", __sd: " + __sd + ", __ed: " + __ed + ", a_model: " + a_model + ", flag_value: " + flag_value + ", java_backend_inst: " + java_backend_inst + ", global_all_attributes_all: " + global_all_attributes_all);

    JavaClass jc = new JavaClass(pw, ee, __sd, __ed, a_model, flag_value, java_backend_inst, global_all_attributes_all);
    Compiler2Visitor v = new ECxGenerateJava(flag_debug, flag_deep_debug, flag_no_print_active_nodes, flag_split_debug, jc);


    tree.jjtAccept(v, jc);
//FIXME: suspended;      pdb.addAll(jc.pdb);
  }


  static void generateJavaExpressionSecondary(PrintWriter pw, EEntity ee, EGeneric_schema_definition __sd, 
                                     EEntity_definition __ed, SdaiModel a_model, int secondary_flag, JavaClass parent_traversing, Object reference_object)
                              throws SdaiException {
    if (!flag_expressions) {
      return;
    }

    // static_model = model;
    JavaClass jc = new JavaClass(pw, ee, __sd, __ed, a_model, flag_value, java_backend_inst, global_all_attributes_all, secondary_flag, parent_traversing, reference_object);
    Compiler2Visitor v = new ECxGenerateJava(flag_debug, flag_deep_debug, flag_no_print_active_nodes, flag_split_debug, jc);


    tree.jjtAccept(v, jc);
//FIXME: suspended;      pdb.addAll(jc.pdb);
  }


  static void generateJavaExpressionInc(PrintWriter pw, EEntity ee, EGeneric_schema_definition __sd, 
                                     EEntity_definition __ed, SdaiModel a_model, X_Expression x_e)
                              throws SdaiException {
    if (!flag_expressions) {
      return;
    }

    // static_model = model;






    JavaClass jc = new JavaClass(pw, ee, __sd, __ed, a_model, flag_value, java_backend_inst);
    jc.active = true;
		jc.expression_fragment = true;
    Compiler2Visitor v = new ECxGenerateJava(flag_debug, flag_deep_debug, flag_no_print_active_nodes, flag_split_debug, jc);


//    tree.jjtAccept(v, jc);

    x_e.jjtAccept(v, jc);


//FIXME: suspended;      pdb.addAll(jc.pdb);
  }




  void generateJavaExpressionForDeriveMethodsInc(PrintWriter pw, EAttribute attr, 
                                                     EGeneric_schema_definition __sd, 
                                                     EEntity_definition __ed, SdaiModel a_model)
                                              throws SdaiException {

// System.out.println("XOX - in generateJavaExpressionForDeriveMethodsInc, attribute: " + attr.getName(null));

    if (!flag_expressions) {
      return;
    }

// ########################### start

            //FIXME            pw.println("\t\t\treturn (" + base_name + ") (");
						//System.out.println("XIXI attr: " + attr.getName(null) + ", entity: " + _ed.getName(null) + ", schema: " + sd.getName(null));
            SdaiModel attr_model = attr.findEntityInstanceSdaiModel();
						ESchema_definition attr_schema = (ESchema_definition)getSchema_definitionFromModel(attr_model);



//            generateJavaExpression(pw, attr, sd, _ed, model);
            
            
//            generateJavaExpression(pw, attr, attr_schema, _ed, model);


  					// lets try to work directly on a fragment of a tree, just for an expression
							// check  if the schema is different and if it is not in the current parse tree
						// if so, construct the X_DerivedAttr node, set its attributes
						// owner_entity = ed;
					  // attribute = da;
		
						// run the parser on the fragment of the code of the expression of the derived attribute
						// in a string in express_code (previously - documentation)
						// the resulting tree fragment is returned by the parser with the root X_Expression
						// Add it as a child to the constructed X_DerivedAttr, run the expression generation backend
						// on X_DerivedAttr 




						
						// check if attribute schema is present in the tree.
						// one way to do it - perhaps to check if the model is read-write. 
						if (attr_model.getMode() == SdaiModel.READ_WRITE) {
							// ok, not incremental, schema present in the parse tree
							// because only models of currently parsed express schemas are read-write
// System.out.println("XOX local");
// pw.println("// XXX attr: " + attr);
// pw.println("// XXX attr schema: " + attr_schema);
// pw.println("// XXX _ed: " + _ed);


// pw.println("// XXX model: " + model);

//	if (attr.getName(null).equalsIgnoreCase("shaped_product")) {
//			System.out.println("<DERIVED> attr: " + attr + ", schema: " + attr_schema + ", _ed: " + _ed + ", model: " + model); 
//	}


//--RR-REMOVE:
//            pw.println("\t\t\t//#X# - invoking generating expression, non-incremental: generateJavaExpression");

	            generateJavaExpression(pw, attr, attr_schema, _ed, model);
						} else {


						if (!flag_incremental_enabled) {
							System.out.println("Warning! Incremental compilation is not supported or disabled. " + __sd.getName(null).toLowerCase() + " and " + attr_schema.getName(null).toLowerCase() + " have to be compiled together. Get method for derived attribute " + attr.getName(null) + " in entity " + __ed.getName(null) + " not generated");
	            pw.println("\t\t\tthrow new SdaiException(SdaiException.FN_NAVL);");
							return;
						}


// System.out.println("XOX not local");
 // pw.println("// #X# -  not local");
				      if (attr_model.getMode() == SdaiModel.NO_ACCESS) {
        				attr_model.startReadOnlyAccess();
      				}
							// schema is absent, an incremental case here

							// find the corresponding documentation model, find the express_code instance for the attribute,
							// get the expression string from it to parse.
						
							String str = null;
	  					String name_searched = "_EXPRESS_" + attr_schema.getName(null).toUpperCase();
	  					ASdaiModel models  = repo.getModels();
							SdaiIterator iter_models = models.createIterator();
							boolean all_done = false;
							while (iter_models.next()) {
								SdaiModel sm1 = models.getCurrentMember(iter_models);
								String model_name = sm1.getName();
// System.out.println("findModel - searching: " + name_searched + ", current: " + model_name + ", nr of models: " + models.getMemberCount());
								if (model_name.equalsIgnoreCase(name_searched)) {
									// now find the express_code instance for the attribute
									
									Aggregate ia = sm1.getEntityExtentInstances(EExpress_code.class);
									SdaiIterator iter_inst = ia.createIterator();
									while (iter_inst.next()) {
										EExpress_code xc = (EExpress_code)ia.getCurrentMemberObject(iter_inst);
									  EEntity target = xc.getTarget(null);
									  if (target == attr) {
											// found our attribute, get the string now
											A_string values = xc.getValues(null);
											str = values.getByIndex(1);										
											all_done = true;
											break;
										}	
									}
								}
								if (all_done) {
									break;
								}
							} // while models
	
							if (str != null) {
// System.out.println("XOX string fragment: " + str);
								// String str = "2 + 3";
//								X_Expression x_e = Compiler2.runParserDerivedExpression(str, model, attr_schema, _ed, (jsdai.SExtended_dictionary_schema.EDerived_attribute)attr, parser);
								X_Expression x_e = Compiler2.runParserDerivedExpression(str, attr_model, attr_schema, _ed, (jsdai.SExtended_dictionary_schema.EDerived_attribute)attr, parser);

						 		// x_e.dump("Derived fragment NODE: ");
// pw.println("// before generateJavaExpressionInc");

	            	generateJavaExpressionInc(pw, attr, attr_schema, _ed, model, x_e);
//	            	generateJavaExpressionInc(pw, attr, attr_schema, _ed, attr_model, x_e);
// pw.println("// after generateJavaExpressionInc");
							}

						}							

					

            //FIXME            pw.println("\t\t\t);");





// ########################### end

/*
    EEntity_definition ped = (EEntity_definition)attr.getParent_entity(null);
    SdaiModel entity_model = ped.findEntityInstanceSdaiModel();
    __sd = getSchema_definitionFromModel(entity_model);

    // static_model = model;
    JavaClass jc = new JavaClass(pw, attr, __sd, __ed, a_model, flag_value, java_backend_inst);
    Compiler2Visitor v = new ECxGenerateJava(flag_debug, flag_deep_debug, flag_no_print_active_nodes, flag_split_debug, jc);

    tree.jjtAccept(v, jc);
//FIXME: suspended;      pdb.addAll(jc.pdb);

*/  
  
  }



  /* it is used for derive attributes, where "attr" is passed   */
  static void generateJavaExpressionForDeriveMethods(PrintWriter pw, EAttribute attr, 
                                                     EGeneric_schema_definition __sd, 
                                                     EEntity_definition __ed, SdaiModel a_model)
                                              throws SdaiException {
    if (!flag_expressions) {
      return;
    }

    EEntity_definition ped = (EEntity_definition)attr.getParent_entity(null);
    SdaiModel entity_model = ped.findEntityInstanceSdaiModel();
    __sd = getSchema_definitionFromModel(entity_model);

    // static_model = model;

//	if (attr.getName(null).equalsIgnoreCase("shaped_product")) {
//		System.out.println("<DERIVED> attr: " + attr + ", __sd: " + __sd + ", __ed: " + __ed + ", model: " + a_model); 
//	}
    JavaClass jc = new JavaClass(pw, attr, __sd, __ed, a_model, flag_value, java_backend_inst);
    Compiler2Visitor v = new ECxGenerateJava(flag_debug, flag_deep_debug, flag_no_print_active_nodes, flag_split_debug, jc);

    tree.jjtAccept(v, jc);
//FIXME: suspended;      pdb.addAll(jc.pdb);
  }

  SdaiModel findJavaModel(ASdaiModel models, String model_name)
                   throws SdaiException {
    SdaiModel result = null;
    SdaiIterator iter_model = models.createIterator();

    while (iter_model.next()) {
      SdaiModel a_model = models.getCurrentMember(iter_model);
      String a_model_name = a_model.getName() + "_DICTIONARY_DATA";
      printDebug("Current model name: " + a_model_name + ", we need: _JAVA_" + 
                         model_name);

      if (a_model_name.equalsIgnoreCase("_JAVA_" + model_name)) {
        result = a_model;

        if (result.getMode() == SdaiModel.NO_ACCESS) {
          result.startReadOnlyAccess();
        }

        break;
      }
    }

    return result;
  }

	ANamed_type getSelections_old(ESelect_type st) throws SdaiException {
		ANamed_type selections = null;
		if (st.testLocal_selections(null)) {
			selections = st.getLocal_selections(null);
			for (int j = 1; j < selections.getMemberCount() + 1; j++) {
				ENamed_type element1 = (ENamed_type)selections.getByIndexEntity(j);
			}
		}
		if (st instanceof EExtended_select_type) {
			selections = addSelectionsFromExtensible((EExtended_select_type)st, selections);
		}
		return selections;
	}

	ANamed_type addSelectionsFromExtensible_old(EExtended_select_type st, ANamed_type current_selections) throws SdaiException {
		ANamed_type selections = null;
//		ESelect_type prior = st.getIs_based_on(null);
		ESelect_type prior = (ESelect_type)st.getIs_based_on(null).getDomain(null);
		if (prior.testLocal_selections(null)) {
			selections = prior.getLocal_selections(null);
			for (int j = 1; j < selections.getMemberCount() + 1; j++) {
				ENamed_type element1 = (ENamed_type)selections.getByIndexEntity(j);
			}
		}
		// selections = selections + current_selections, in that order, perhaps check for duplicates because it is SET
		for (int i = 1; i < current_selections.getMemberCount() + 1; i++) {
			ENamed_type element = (ENamed_type)current_selections.getByIndexEntity(i);
			if (!(selections.isMember(element))) {
				selections.addUnordered(element);
			}
		}
		if (prior instanceof EExtended_select_type) {
			selections = addSelectionsFromExtensible((EExtended_select_type)prior, selections);
		}
		return selections;
	}

// #################### new

	ANamed_type getSelections(ESelect_type st) throws SdaiException {
		ANamed_type l_selections = null;
		ANamed_type selections = null;
		if (st.testLocal_selections(null)) {
			l_selections = st.getLocal_selections(null);
// System.out.println("XAM 01: local nr: " + l_selections.getMemberCount() + " -: " + l_selections);			
		}
		if (st instanceof EExtended_select_type) {
			selections = addSelectionsFromExtensible((EExtended_select_type)st, l_selections);
			return selections;
		}
// System.out.println("XAM: number of selections: " + selections.getMemberCount());
		return l_selections;
	}

	ANamed_type addSelectionsFromExtensible(EExtended_select_type st, ANamed_type current_selections) throws SdaiException {
		ANamed_type l_selections = null;
		ANamed_type selections = null;
//		ESelect_type prior = st.getIs_based_on(null);
		ESelect_type prior = (ESelect_type)st.getIs_based_on(null).getDomain(null);
		if (prior.testLocal_selections(null)) {
			l_selections = prior.getLocal_selections(null);
			selections = new ANamed_type();
			for (int i = 1; i < l_selections.getMemberCount() + 1; i++) {
				ENamed_type element = (ENamed_type)l_selections.getByIndexEntity(i);
				selections.addUnordered(element);
			}
		}
		if (current_selections != null) {
			if (current_selections.getMemberCount() > 0) {
				if (selections == null) {
					selections = new ANamed_type();
				}	
		
		// selections = selections + current_selections, in that order, perhaps check for duplicates because it is SET
// System.out.println("XXRR: number of selections: " + current_selections.getMemberCount());
				for (int i = 1; i < current_selections.getMemberCount() + 1; i++) {
// System.out.println("Index: " + i + " - type: " + st);
					ENamed_type element = (ENamed_type)current_selections.getByIndexEntity(i);
					if (!(selections.isMember(element))) {
// System.out.println("XXRR Adding element from extensible: " + element);				
						selections.addUnordered(element);
					}
				}
			}
		}
		if (prior instanceof EExtended_select_type) {
			selections = addSelectionsFromExtensible((EExtended_select_type)prior, selections);
		}
		return selections;
	}


  Vector A_string2Vector(A_string input)  throws SdaiException {
		Vector result;
		if (input == null) {
			return null;
		}
		result = new Vector();
		for (int i = 1; i < input.getMemberCount() + 1; i++) {
			String element = (String)input.getByIndex(i);
			result.addElement(element);
		}
		return result;
	}	

	Vector getElementsV(EEnumeration_type et) throws SdaiException {
		A_string l_elements = null;
		Vector vl_elements = null;
		Vector elements = null;
		if (et.testLocal_elements(null)) {
			l_elements = et.getLocal_elements(null);
			vl_elements = A_string2Vector(l_elements);
		}
		if (et instanceof EExtended_enumeration_type) {
			elements = addElementsFromExtensibleV((EExtended_enumeration_type)et, vl_elements);
			return elements;
		}
		return vl_elements;
	}

	Vector addElementsFromExtensibleV(EExtended_enumeration_type et, Vector current_elements) throws SdaiException {
		A_string l_elements = null;
//		Vector vl_elements = null;
		Vector elements = null;
//		EEnumeration_type prior = et.getIs_based_on(null);
		EEnumeration_type prior = (EEnumeration_type)et.getIs_based_on(null).getDomain(null);
		if (prior.testLocal_elements(null)) {
			l_elements = prior.getLocal_elements(null);
//			vl_elements = A_string2Vector(l_elements);
			elements = A_string2Vector(l_elements);
		}
		if (current_elements != null) {
			if (current_elements.size() > 0) {
				if (elements == null) {
					elements = new Vector();
				}	
		
				for (int i = 0; i < current_elements.size(); i++) {
					String element = (String)current_elements.elementAt(i);
					if (!(elements.contains(element))) {
						elements.addElement(element);
					}
				}
			}
		}
		if (prior instanceof EExtended_enumeration_type) {
			elements = addElementsFromExtensibleV((EExtended_enumeration_type)prior, elements);
		}
		return elements;
	}

/*

	A_string getElements(EEnumeration_type et) throws SdaiException {
		A_string l_elements = null;
		A_string elements = null;
		if (et.testLocal_elements(null)) {
			l_elements = et.getLocal_elements(null);
// System.out.println("XAME 01: local nr: " + l_elements.getMemberCount() + " -: " + l_elements);			
		}
		if (et instanceof EExtended_enumeration_type) {
			elements = addElementsFromExtensible((EExtended_enumeration_type)et, l_elements);
			return elements;
		}
// System.out.println("XAME: number of elements: " + elements.getMemberCount());
		return l_elements;
	}
	
	A_string addElementsFromExtensible(EExtended_enumeration_type et, A_string current_elements) throws SdaiException {
		A_string l_elements = null;
		A_string elements = null;
		EEnumeration_type prior = et.getIs_based_on(null);
		if (prior.testLocal_elements(null)) {
			l_elements = prior.getLocal_elements(null);
			elements = new A_string();
			for (int i = 1; i < l_elements.getMemberCount() + 1; i++) {
				String element = (String)l_elements.getByIndex(i);
				elements.addUnordered(element);
			}
		}
		if (current_elements != null) {
			if (current_elements.getMemberCount() > 0) {
				if (elements == null) {
					elements = new A_string();
				}	
		
		// elements = elements + current_elements, in that order, perhaps check for duplicates because it is SET
// System.out.println("XXRRE: number of elements: " + current_elements.getMemberCount());
				for (int i = 1; i < current_elements.getMemberCount() + 1; i++) {
// System.out.println("Index: " + i + " - type: " + et);
					String element = (String)current_elements.getByIndex(i);
					if (!(elements.isMember(element))) {
// System.out.println("XXRRE Adding element from extensible: " + element);				
						elements.addUnordered(element);
					}
				}
			}
		}
		if (prior instanceof EExtended_enumeration_type) {
			elements = addElementsFromExtensible((EExtended_enumeration_type)prior, elements);
		}
		return elements;
	}

*/

// ##################### end new


	boolean skipModel(String model_name) {
			String part_model_name;
			
	    if (model_name.length() > 15) {
        part_model_name = model_name.substring(0, 15);

        if (part_model_name.equalsIgnoreCase("_DOCUMENTATION_")) {
          // System.out.println("Eliminating documentation model: " + model_name);
          return true;
        }
      }

      if (model_name.length() > 13) {
        part_model_name = model_name.substring(0, 13);

        if (part_model_name.equalsIgnoreCase("_EXPRESSIONS_")) {
          // System.out.println("Eliminating expressions model: " + model_name);
          return true;
        }
      }

      if (model_name.length() > 9) {
        part_model_name = model_name.substring(0, 9);

        if (part_model_name.equalsIgnoreCase("_EXPRESS_")) {
          // System.out.println("Eliminating express model: " + model_name);
          return true;
        }
      }

      if (model_name.length() > 6) {
        part_model_name = model_name.substring(0, 6);

        if (part_model_name.equalsIgnoreCase("_JAVA_")) {
          // System.out.println("Eliminating java model: " + model_name);
          return true;
        }
      }

      if (model_name.length() > 13) {
        part_model_name = model_name.substring(model_name.length() - 13);

        if (part_model_name.equalsIgnoreCase("_MAPPING_DATA")) {
          // System.out.println("Eliminating mapping_data model: " + model_name);
          return true;
        }
      }

			// why do we even need all the above 

      if (model_name.length() > 16) {
        part_model_name = model_name.substring(model_name.length() - 16);

        // System.out.println("Part model name: " + part_model_name);
        if (!part_model_name.equalsIgnoreCase("_DICTIONARY_DATA")) {
          //			System.out.println("Eliminating not dictionary data model: " + model_name + ", part: " + part_model_name);
          return true;
        }
      }

      if (model_name.length() <= 16) {
        // System.out.println("Eliminating short name model: " + model_name);
        return true;
      }

		  return false;
		}

  //============================================================= end ==================================================
}

class CompareEntities implements Comparator {
  public int compare(Object ed1, Object ed2) {
    String name1 = null;
    String name2 = null;

    try {
      name1 = ((EEntity_definition) ed1).getName(null);
      name2 = ((EEntity_definition) ed2).getName(null);
    } catch (SdaiException ex) {
    }

    return name1.compareTo(name2);
  }

  public boolean equals(Object obj) {
    return false;
  }
}

class CompareUppercaseEntities implements Comparator {
  public int compare(Object ed1, Object ed2) {
    String name1 = null;
    String name2 = null;

    try {
      name1 = ((EEntity_definition) ed1).getName(null).toUpperCase();
      name2 = ((EEntity_definition) ed2).getName(null).toUpperCase();
    } catch (SdaiException ex) {
    }

    return name1.compareTo(name2);
  }

  public boolean equals(Object obj) {
    return false;
  }
}

class CompareAttributes implements Comparator {
  public int compare(Object a1, Object a2) {
    // int order1 = Integer.MIN_VALUE, order2 = Integer.MIN_VALUE;
    Integer order1 = null;
    Integer order2 = null;

    try {
      if (((EAttribute) a1).testOrder(null)) {
      	order1 = new Integer(((EAttribute) a1).getOrder(null));
    	} else {
    		order1 = new Integer(Integer.MAX_VALUE);
    	}
      if (((EAttribute) a2).testOrder(null)) {
	      order2 = new Integer(((EAttribute) a2).getOrder(null));
			} else {
    		order2 = new Integer(Integer.MAX_VALUE);
			}
      //         order1 = ((EAttribute)a1).getOrder(null);
      //         order2 = ((EAttribute)a2).getOrder(null);
    } catch (SdaiException ex) {
    }

    return order1.compareTo(order2);
  }

  public boolean equals(Object obj) {
    return false;
  }
}

class CompareAttributes3 implements Comparator {
  public int compare(Object a1, Object a2) {
    // int order1 = Integer.MIN_VALUE, order2 = Integer.MIN_VALUE;
    Integer order1 = null;
    Integer order2 = null;

    try {
      if (((EAttribute) a1).testOrder(null)) {
      	order1 = new Integer(((EAttribute) a1).getOrder(null));
    	} else {
    		order1 = new Integer(((EEntity)a1).getPersistentLabel().substring(1).toLowerCase());
//System.out.println("order 1: " + order1 + ", attribute 1: " + a1);
    	}
      if (((EAttribute) a2).testOrder(null)) {
	      order2 = new Integer(((EAttribute) a2).getOrder(null));
			} else {
    		order2 = new Integer(((EEntity)a2).getPersistentLabel().substring(1).toLowerCase());
//System.out.println("order 2: " + order2 + ", attribute 2: " + a2);
			}
      //         order1 = ((EAttribute)a1).getOrder(null);
      //         order2 = ((EAttribute)a2).getOrder(null);
    } catch (SdaiException ex) {
    }

    return order1.compareTo(order2);
  }

  public boolean equals(Object obj) {
    return false;
  }
}

class CompareAttributes2 implements Comparator {
  public int compare(Object a1, Object a2) {
    // int order1 = Integer.MIN_VALUE, order2 = Integer.MIN_VALUE;
    Integer order1 = null;
    Integer order2 = null;

    try {
      if (((EAttribute) a1).testOrder(null)) {
      	order1 = new Integer(((EAttribute) a1).getOrder(null));
    	} else {
    		order1 = new Integer(a1.hashCode());
//System.out.println("hashcode 1: " + a1.hashCode() + ", attribute 1: " + a1);
//System.out.println("order 1: " + order1 + ", attribute 1: " + a1);
    	}
      if (((EAttribute) a2).testOrder(null)) {
	      order2 = new Integer(((EAttribute) a2).getOrder(null));
			} else {
    		order2 = new Integer(a2.hashCode());
//System.out.println("hashcode 2: " + a2.hashCode() + ", attribute 2: " + a2);
//System.out.println("order 2: " + order2 + ", attribute 2: " + a2);
			}
      //         order1 = ((EAttribute)a1).getOrder(null);
      //         order2 = ((EAttribute)a2).getOrder(null);
    } catch (SdaiException ex) {
    }

    return order1.compareTo(order2);
  }

  public boolean equals(Object obj) {
    return false;
  }
}

class TheAttribute {
	EAttribute attr;
	// consolidated attribute - only one such attribute in the chain of redeclarations, or even none, if java inheritance
	boolean consolidated;
  String consolidated_attribute_comment_str;
	int consolidated_inheritance;
	String consolidated_attribute_str;
	int consolidated_type;
	String consolidated_attribute_value_str;
	boolean consolidated_attribute_select_field_present;
	String consolidated_attribute_select_str;
	ArrayList consolidated_primary_derived;
	int consolidated_derived_count;
	int consolidated_explicit_index;
	int consolidated_derived_index;
	int consolidated_inverse_index;
	TheAttribute consolidated_explicit_to_derived;		  		
	boolean consolidated_flag_explicit_to_derived;
	boolean consolidated_renamed_present;
	ArrayList consolidated_renamed;

	// 0 - the 1st one has the original name
  // 1 - the 1st one is renamed but with the original name also exists
	// 2 -  only renamed exists
	int consolidated_explicit_to_derived_original_or_renamed; 

	
	boolean generate_attribute; 
	// we may want to move generation of all the methods to consolidated from all the others
	boolean generate_method;    
  TheMethod main_method;
  ArrayList renamed_methods; // containts TheMethod instances
	boolean multiple_methods;
	int explicit_renamed;
	int derived_renamed;
	int inverse_renamed;
	int renamed;
  int explicit_index;
  int derived_index;
  int alt_derived_index;
  int inverse_index;
  boolean not_first_derived;

	int a_number;
	int d_number;
	int i_number;
	int type;
	int flag;
	int flag2;
	boolean flag_redeclaring;
	TheAttribute redeclaring;
	TheAttribute redeclared;
	TheAttribute root;
	boolean flag_renamed;
	boolean field;
	boolean alt_field;
	int inheritance; // 0 - current, 1 - java, 2 - non-java
	String comment;
	EExplicit_attribute original_explicit;
	TheAttribute last_redeclared_by;
	int redeclared_by_count;
	ArrayList redeclared_by;
	boolean explicit_to_derived;
	// Vector names;
	
	TheAttribute() {
		consolidated_explicit_to_derived_original_or_renamed = -1;
		consolidated_renamed_present = false;
		consolidated_renamed = new ArrayList();
		consolidated_explicit_to_derived = null;			  		
		consolidated_flag_explicit_to_derived = false;
		
		consolidated = false;
		consolidated_attribute_comment_str = "";
		consolidated_inheritance = -1;
		consolidated_attribute_str = "";
		consolidated_type = -1;
		consolidated_attribute_value_str = "";
		consolidated_attribute_select_field_present = false;
		consolidated_attribute_select_str = "";
		consolidated_primary_derived = new ArrayList();
		consolidated_derived_count = -1;
		consolidated_explicit_index = -1;
		consolidated_derived_index = -1;
		consolidated_inverse_index = -1;
		explicit_to_derived = false;
		type = -1;
		flag = -1;
		flag2 = -1;
		renamed = 0;
		flag_renamed = false;
		explicit_renamed = 0;
		derived_renamed = 0;
		inverse_renamed = 0;
		// names = new Vector()
		main_method = null;
		renamed_methods = new ArrayList();
		multiple_methods = false;
		generate_attribute = false;
		generate_method = false;
		explicit_index = -1;
		derived_index = -1;
		alt_derived_index = -1;
		inverse_index = -1;
		not_first_derived = true;
		a_number = -1;
		d_number = -1;
		i_number = -1;
		comment = "";
		flag_redeclaring = false;
		redeclaring = null;
		redeclared = null;
		root = null;
		field = false;
		alt_field = false;
		original_explicit = null;
		last_redeclared_by = null;
		redeclared_by_count = 0;
		redeclared_by = new ArrayList();
	}

	public String toString() {
		String result = "@@@@@@@@@@@@@@@@@@@ printing TheAttribute @@@@@@@@@@@@@@@@@@\n";
		result += "attribute: " + attr + "\n"; 
		result += "consolidated: " + consolidated + "\n";
		result += "consolidated_attribute_comment_str: " + consolidated_attribute_comment_str + "\n";
		result += "consolidated_inheritance: " + consolidated_inheritance + "\n";
		result += "consolidated_attribute_str: " + consolidated_attribute_str + "\n";
		result += "consolidated_type: " + consolidated_type + "\n";
		result += "consolidated_attribute_value_str: " + consolidated_attribute_value_str + "\n";
		result += "consolidated_attribute_select_field_present: " + consolidated_attribute_select_field_present + "\n";
		result += "consolidated_attribute_select_str: " + consolidated_attribute_select_str + "\n";
		result += "consolidated_primary_derived - size: " + consolidated_primary_derived.size() + "\n";
		result += "consolidated_derived_count: " + consolidated_derived_count + "\n";
		result += "consolidated_explicit_index: " + consolidated_explicit_index + "\n";
		result += "consolidated_derived_index: " + consolidated_derived_index + "\n";
		result += "consolidated_inverse_index: " + consolidated_inverse_index + "\n";
		result += "consolidated_renamed_present: " + consolidated_renamed_present + "\n";
		result += "consolidated_renamed count: " + consolidated_renamed.size() + "\n";
		result += "explicit_index: " + explicit_index + "\n";
		result += "derived_index: " + derived_index + "\n";
		result += "alt_derived_index: " + alt_derived_index + "\n";
		result += "inverse_index: " + inverse_index + "\n";
		result += "not_first_derived: " + not_first_derived + "\n";
		result += "type: " + type + "\n";
		result += "flag: " + flag + "\n";
		result += "flag2: " + flag2 + "\n";
		result += "renamed: " + renamed + "\n";
		result += "flag_renamed: " + flag_renamed + "\n";
		result += "explicit_renamed: " + explicit_renamed + "\n";
		result += "derived_renamed: " + derived_renamed + "\n";
		result += "inverse_renamed: " + inverse_renamed + "\n";
		result += "comment: " + comment + "\n";
		result += "flag_redeclaring: " + flag_redeclaring + "\n";
		if (last_redeclared_by != null) {
			// result += "last_redeclared_by: " + last_redeclared_by.toString() + "\n";
		}
		if (redeclaring != null) {
			// result += "redeclaring: " + redeclaring.toString() + "\n";
		}
		if (redeclared != null) {
			// result += "redeclared: " + redeclared.toString() + "\n";
		}
		if (root != null) {
			// result += "root: " + root.toString() + "\n";
		}

		if (consolidated_primary_derived != null) {
			result += "consolidated_primary_derived: " + "\n";
   		for (int j = 0; j < consolidated_primary_derived.size(); j++) {
				TheAttribute tattr3 = (TheAttribute)consolidated_primary_derived.get(j);
				EAttribute attr3 = tattr3.attr;
				result += "\tindex: " + j + ", attribute: " + attr3 + "\n";			  					
			}
		}
// consolidated_renamed contains not attributes but methods, element is TheMethod, not TheAttribute 

		if (consolidated_renamed != null) {
			result += "consolidated_renamed: " + "\n";
   		for (int j = 0; j < consolidated_renamed.size(); j++) {
				TheMethod tM3 = (TheMethod)consolidated_renamed.get(j);
				result += "\tindex: " + j + ", method: " + tM3.name + "\n";			  					
			}
		}
	
		if (redeclared_by != null) {
			result += "redeclared_by: " + "\n";
   		for (int j = 0; j < redeclared_by.size(); j++) {
				TheAttribute tattr3 = (TheAttribute)redeclared_by.get(j);
				EAttribute attr3 = tattr3.attr;
				result += "\tindex: " + j + ", attribute: " + attr3 + "\n";			  					
			}
		}

		if (consolidated_explicit_to_derived != null) {
			result += "consolidated_explicit_to_derived: " + consolidated_explicit_to_derived.attr + "\n";
		}

		if (redeclaring != null) {
			result += "redeclaring: " + redeclaring.attr + "\n";
		}
		if (redeclared != null) {
			result += "redeclared: " + redeclared.attr + "\n";
		}
		if (root != null) {
			result += "root: " + root.attr + "\n";
		}
		if (last_redeclared_by != null) {
			result += "last_redeclared_by: " + last_redeclared_by.attr + "\n";
		}
		result += "original_explicit: " + original_explicit + "\n";



		result += "**********************************************************\n";
		return result;
	}

}

class	TheMethod {
	boolean has_previous;
	TheAttribute previous;
	TheAttribute current;
	TheAttribute consolidated;
	int explicit_index;
	String name;
	String previous_name;
	Object type; // or EEntity?
	String type_str;
	Object value; // or EEntity?
	String value_str;
	String package_str;
	String previous_package_str;
	Object previous_type;
	String previous_type_str;
	Object previous_value;
	String previous_value_str;
}

class Counts {
	int explicit_count;
	int derived_count;
	int alt_derived_count;
	int inverse_count;
	
	Counts () {
		explicit_count = 0;
		derived_count = 0;
		alt_derived_count = 0;
		inverse_count = 0;
	}

}
