/*
 * $Id$
 *
 * JSDAI(TM), a way to implement STEP, ISO 10303
 * Copyright (C) 1997-2008, LKSoftWare GmbH, Germany
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License
 * version 3 as published by the Free Software Foundation (AGPL v3).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * JSDAI is a registered trademark of LKSoftWare GmbH, Germany
 * This software is also available under commercial licenses.
 * See also http://www.jsdai.net/
 */

/* Generated By:JJTree: Do not edit this line. X_IfExpr.java */

package jsdai.expressCompiler;

import java.util.*;
import jsdai.lang.*;
import jsdai.SExtended_dictionary_schema.*;

public class X_IfExpr extends SimpleNode {

	int elsif_count = 0;
	boolean else_present = false;


	String if_expression = "";
	String then_expression = "";
	String else_expression = "";
	Vector elsif_conditions = null;
	Vector elsif_expressions = null;

	boolean elsif_condition = true;
	int elsif_current_count = 0;

  public X_IfExpr(int id) {
    super(id);
		elsif_count = 0;
  	else_present = false;
  }

  public X_IfExpr(Compiler2 p, int id) {
    super(p, id);
		elsif_count = 0;
  	else_present = false;
  }


  /** Accept the visitor. **/
  public Object jjtAccept(Compiler2Visitor visitor, Object data) throws jsdai.lang.SdaiException {
    return visitor.visit(this, data);
  }


  public Object childrenAccept(Compiler2Visitor visitor, Object data)
                        throws SdaiException {
    JavaClass jc = (JavaClass) data;

    if (children != null) {
      // variable_declaration = "";
      variable_names = new Vector();
      variable_declarations = new Vector();
      statements = new Vector();
      initializing_code = new Vector();

			if (elsif_count > 0) {
				elsif_conditions = new Vector();
				elsif_expressions = new Vector();
				elsif_condition = true;
				elsif_current_count = 0;
			}

			if_expression = "";
			then_expression = "";
			else_expression = "";



      // generated_code = "";     
      for (int i = 0; i < children.length; ++i) {
        children[i].jjtAccept(visitor, data);

        if (jc != null) {
          if (jc.active) {
            // if (children[i] instanceof ExpressionNode) {
            // if (((ExpressionNode)children[i]).java_contains_statements) {

              if (((SimpleNode) children[i]).java_contains_statements) {
                java_contains_statements = true;

                // variable_declaration += "\n" + ((SimpleNode)children[i]).variable_declaration;
                for (int j = 0; j < ((SimpleNode) children[i]).variable_names.size(); j++) {
                  variable_names.add(((SimpleNode) children[i]).variable_names.elementAt(j));
                }

                for (int j = 0; j < ((SimpleNode) children[i]).variable_declarations.size(); j++) {
                  variable_declarations.add(((SimpleNode) children[i]).variable_declarations.elementAt(j));
                }

                for (int j = 0; j < ((SimpleNode) children[i]).statements.size(); j++) {
                  statements.add(((SimpleNode) children[i]).statements.elementAt(j));
                }

                // initializing_code += "\n" + ((SimpleNode)children[i]).initializing_code;
                for (int j = 0; j < ((SimpleNode) children[i]).initializing_code.size(); j++) {
                  initializing_code.add(((SimpleNode) children[i]).initializing_code.elementAt(j));
                }
              } // if contains statements
						
          		// if i = 0 - IF logical expression
          		// if i = 1 - THEN expression
          		// further nodes are optional
          		// for each elsif - 2 nodes : logical expression = condition + expression
          		// if ELSE present - expression
          	
          		if (i == 0) { // if 
          			if_expression = jc.generated_java;
          			jc.generated_java = "";
          		} else 
          		if (i == 1) { // then
          			then_expression = jc.generated_java;
          			jc.generated_java = "";
          		} else //  i > 1, elsif or else here
          		if (elsif_count > 0) { // elsif present
          			if (i > 1) { // not needed, always > 1, already tested
          				if (elsif_current_count < elsif_count) { // still in elsif
          					if (elsif_condition) { // elsif condition
          						// condition node
          						elsif_conditions.addElement(jc.generated_java);
          						jc.generated_java = "";
          						elsif_condition = false;
          					} else { // elsif value expression
          						// expression node
          						elsif_expressions.addElement(jc.generated_java);
          						jc.generated_java = "";
          						elsif_condition = true;
          						elsif_current_count++;
          					}
          				} else {  // elsif done, possibly else value expression
          					// this is no longer an elsif node
          					if (else_present) {
		          				else_expression = jc.generated_java;
    		      				jc.generated_java = "";
          					} else {
          						// should not happen
          						System.out.println("Express-X compiler: IF expression, INTERNAL ERROR 1 - node index: " + i + ", node: " + children[i] + ", expression: " + jc.generated_java); 
          					}
          				}
          			} else {
          				// covered already
          				System.out.println("Express-X compiler: IF expression, INTERNAL ERROR 2 - node index: " + i + ", node: " + children[i] + ", expression: " + jc.generated_java); 
          			}
          		} else // elsif not present
          		if (else_present) {
          			if (i == 2) {
          				else_expression = jc.generated_java;
          				jc.generated_java = "";
          			} else {
          				// error
          				System.out.println("Express-X compiler: IF expression, INTERNAL ERROR 3 - node index: " + i + ", node: " + children[i] + ", expression: " + jc.generated_java); 
          			}
          		} else {
          			// should not occur, error
     						System.out.println("Express-X compiler: IF expression, INTERNAL ERROR 4 - node index: " + i + ", node: " + children[i] + ", expression: " + jc.generated_java); 
          		}
          		
          
          
          
          
          } // if active
        } // if jc not null
      } // loop through all the children

			// ok, let's make a simple experimental implementation here
			// it does not support nested IF expressions (or maybe it does?
			// it does not support absent ELSE part
			// we don't care about elsif for now

			generated_java = "( (" + if_expression + ".getBoolean() == 2) ? true : false ) ? (" + then_expression + ") : (";
			if (elsif_count > 0) {
				// elsif present
	//			String else_closings = "";
				for (int j = 0; j < elsif_count; j++) {
					String current_elsif_condition = (String)elsif_conditions.elementAt(j);
					String current_elsif_expression = (String)elsif_expressions.elementAt(j);
					generated_java += "( (" + current_elsif_condition + ".getBoolean() == 2) ? true : false ) ? (";
					generated_java += current_elsif_expression + ") : (";
//					else_closings += ")"; // closes the  current alternative
				}
				if (else_present) {
//					generated_java += else_expression + ")";
					generated_java += else_expression;
				} else {
//		      generated_java += "Value.alloc(ExpressTypes.GENERIC_TYPE).unset())";
		      generated_java += "Value.alloc(ExpressTypes.GENERIC_TYPE).unset()";
				}
				for (int j = 0; j < elsif_count; j++) {
					generated_java += ")";
				}
				
				generated_java += ")"; // closes the main else - alternative to THEN clause
			} else {
				if (else_present) {
						generated_java += else_expression + ")";
				} else {
					// generate indeterminate value here
			      generated_java += "Value.alloc(ExpressTypes.GENERIC_TYPE).unset())";
				}
			}
			jc.generated_java = generated_java;

    } // if has children

    return data;
  }



}
