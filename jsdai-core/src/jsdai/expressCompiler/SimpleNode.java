/*
 * $Id$
 *
 * JSDAI(TM), a way to implement STEP, ISO 10303
 * Copyright (C) 1997-2008, LKSoftWare GmbH, Germany
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License
 * version 3 as published by the Free Software Foundation (AGPL v3).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * JSDAI is a registered trademark of LKSoftWare GmbH, Germany
 * This software is also available under commercial licenses.
 * See also http://www.jsdai.net/
 */

/* Generated By:JJTree: Do not edit this line. SimpleNode.java */
package jsdai.expressCompiler;

import java.io.*;
import java.util.*;
import jsdai.SExtended_dictionary_schema.*;
import jsdai.lang.*;


public class SimpleNode implements Node, Serializable {

  // from ExpressionNode
	protected static SdaiRepository repository;
  static int uid = 0;

  //  protected Node parent;
  public Node parent;
  protected Node[] children;

  //  protected int id;
  public int id;
  protected Compiler2 parser;
  Token first_token;
  Token last_token;
  boolean print2string_activated = false;
  String generated_java;
  String forwarded_java;
  String opening_java;
  boolean java_contains_statements;
  Vector variable_names;
  Vector variable_declarations;
  Vector statements;
  Vector initializing_code;
	Vector forwarded_stuff;
  int current_uid; // I doubt if I'1l need it
  boolean move_up_java_statements;
  Vector variable_names_tmp;
  Vector variable_declarations_tmp;
  Vector statements_tmp;
  Vector initializing_code_tmp;

  public SimpleNode(int i) {
    id = i;


    // from ExpressionNode
    java_contains_statements = false;
    move_up_java_statements = false;
    generated_java = "";
    forwarded_java = "";
    opening_java = "";
  }

  public SimpleNode(Compiler2 p, int i) {
    this(i);
    parser = p;


    // from ExpressionNode
    java_contains_statements = false;
    move_up_java_statements = false;
    generated_java = "";
    forwarded_java = "";
    opening_java = "";
  }

  public void jjtOpen() {
  }

  public void jjtClose() throws SdaiException {
  }

  public void jjtSetParent(Node n) {
    parent = n;
  }

  public Node jjtGetParent() {
    return parent;
  }

  public void jjtAddChild(Node n, int i) {
    if (children == null) {
      children = new Node[i + 1];
    } else if (i >= children.length) {
      Node[] c = new Node[i + 1];
      System.arraycopy(children, 0, c, 0, children.length);
      children = c;
    }

    children[i] = n;
  }

  public Node jjtGetChild(int i) {
    return children[i];
  }

  public int jjtGetNumChildren() {
    return (children == null) ? 0 : children.length;
  }

  /** Accept the visitor. **/
  public Object jjtAccept(Compiler2Visitor visitor, Object data)
                   throws SdaiException {
    return visitor.visit(this, data);
  }

  /** Accept the visitor. **/

  /*
  public Object childrenAccept(Compiler2Visitor visitor, Object data)  throws SdaiException {
    if (children != null) {
      for (int i = 0; i < children.length; ++i) {
        children[i].jjtAccept(visitor, data);
      }
    }
    return data;
  }
   */
  public void getGeneratedJavaFromChildren() {
    if (children != null) {
      generated_java = "";

      for (int i = 0; i < children.length; ++i) {
        generated_java += ((SimpleNode) children[i]).generated_java;
        ((SimpleNode) children[i]).generated_java = "";
      }
    }
  }

  public void getForwardedJavaFromChildren() {
    if (children != null) {
      forwarded_java = "";

      for (int i = 0; i < children.length; ++i) {
        forwarded_java += ((SimpleNode) children[i]).forwarded_java;
        ((SimpleNode) children[i]).forwarded_java = "";
      }
    }
  }

  public void getForwardedStuffFromChildren() {
    if (children != null) {
      forwarded_stuff = new Vector();

      for (int i = 0; i < children.length; ++i) {
        forwarded_stuff.addElement(((SimpleNode) children[i]).forwarded_java);
        ((SimpleNode) children[i]).forwarded_java = "";
      }
    }
  }



  public void getOpeningJavaFromChildren() {
    if (children != null) {
      opening_java = "";

      for (int i = 0; i < children.length; ++i) {
        opening_java += ((SimpleNode) children[i]).opening_java;
        ((SimpleNode) children[i]).opening_java = "";
      }
    }
  }

  // from ExpressionNode
  public Object childrenAccept(Compiler2Visitor visitor, Object data)
                        throws SdaiException {
    JavaClass jc = (JavaClass) data;

    if (children != null) {
      // variable_declaration = "";
      variable_names = new Vector();
      variable_declarations = new Vector();
      statements = new Vector();
      initializing_code = new Vector();

      // generated_code = "";     
      for (int i = 0; i < children.length; ++i) {
        children[i].jjtAccept(visitor, data);

        if (jc != null) {
          if (jc.active) {
            // if (children[i] instanceof ExpressionNode) {
            // if (((ExpressionNode)children[i]).java_contains_statements) {
            move_up_java_statements = true; // temporarily

            if (move_up_java_statements) { // basicly almost the same as if expression node.

              if (((SimpleNode) children[i]).java_contains_statements) {
                java_contains_statements = true;

                // variable_declaration += "\n" + ((SimpleNode)children[i]).variable_declaration;
                for (int j = 0; j < ((SimpleNode) children[i]).variable_names.size(); j++) {
                  variable_names.add(((SimpleNode) children[i]).variable_names.elementAt(j));
                }

                for (int j = 0; j < ((SimpleNode) children[i]).variable_declarations.size(); j++) {
                  variable_declarations.add(((SimpleNode) children[i]).variable_declarations.elementAt(j));
                }

                for (int j = 0; j < ((SimpleNode) children[i]).statements.size(); j++) {
                  statements.add(((SimpleNode) children[i]).statements.elementAt(j));
                }

                // initializing_code += "\n" + ((SimpleNode)children[i]).initializing_code;
                for (int j = 0; j < ((SimpleNode) children[i]).initializing_code.size(); j++) {
                  initializing_code.add(((SimpleNode) children[i]).initializing_code.elementAt(j));
                }
              } // if contains statements
            } // if move_up_java_statements

            // } // if ExpressionNode
          } // if active
        } // if jc not null
      } // loop through all the children
    } // if has children

    return data;
  }

  /* You can override these two methods in subclasses of SimpleNode to
     customize the way the node appears when the tree is dumped.  If
     your output uses more than one line you should override
     toString(String), otherwise overriding toString() is probably all
     you need to do. */
  public String toString() {
    return Compiler2TreeConstants.jjtNodeName[id];
  }

  public String toString(String prefix) {
    return prefix + toString();
  }

  /* Override this method if you want to customize how the node dumps
     out its children. */
  public void dump(String prefix) {
    System.out.println(toString(prefix));

    if (children != null) {
      for (int i = 0; i < children.length; ++i) {
        SimpleNode n = (SimpleNode) children[i];

        if (n != null) {
          n.dump(prefix + " ");
        }
      }
    }
  }

  void printActive(String msg, Object data) {
    JavaClass jc = (JavaClass) data;
    if (jc.flag_print_active_nodes) {
      System.out.println(msg);
    }
  }

  void printDDebug(String msg, Object data) {
    JavaClass jc = (JavaClass) data;
    if (jc.flag_deep_debug) {
      System.out.println(msg);
    }
  }

/////////////////////////////////////////////////////////////////////////////////////////////

//  SdaiModel  findModel(String schema_name) throws SdaiException
  SdaiModel findModel(String model_name) {
//	  String name_searched = schema_name.toUpperCase() + "_DICTIONARY_DATA";
	  String name_searched = model_name;
	  try {
	  	ASdaiModel models	= repository.getModels();
	  	SdaiIterator iter_models = models.createIterator();
			while (iter_models.next()) {
				SdaiModel sm1 = models.getCurrentMember(iter_models);
				String model_name2 = sm1.getName();
				if (model_name2.equalsIgnoreCase(name_searched)) {
					return sm1;
				}
			}	
		} catch (SdaiException sx) {
			System.out.println("SdaiException while finding model: " + model_name);
		}	
  	return null;
  }

	// from calculatePDB3 returns 3
	String extractUniquePDBNumber(EPopulation_dependent_bound pdb) throws SdaiException {
		String result = "";
		if (pdb.testMethod_name(null)) {
			result = pdb.getMethod_name(null).substring(12);
		}
		return result;
	}


}
