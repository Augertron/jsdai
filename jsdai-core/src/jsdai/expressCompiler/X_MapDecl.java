/*
 * $Id$
 *
 * JSDAI(TM), a way to implement STEP, ISO 10303
 * Copyright (C) 1997-2008, LKSoftWare GmbH, Germany
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License
 * version 3 as published by the Free Software Foundation (AGPL v3).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * JSDAI is a registered trademark of LKSoftWare GmbH, Germany
 * This software is also available under commercial licenses.
 * See also http://www.jsdai.net/
 */

/* Generated By:JJTree: Do not edit this line. X_MapDecl.java */

package jsdai.expressCompiler;

import java.util.*;
import java.io.*;
import jsdai.lang.*;
import jsdai.SExtended_dictionary_schema.*;

public class X_MapDecl extends SimpleNode {

	static boolean flag_generate_execute_in_nodes = true;


  jsdai.SExtended_dictionary_schema.EMap_definition map_definition;

  public X_MapDecl(int id) {
    super(id);
  }

  public X_MapDecl(Compiler2 p, int id) {
    super(p, id);
  }


  /** Accept the visitor. **/
  public Object jjtAccept(Compiler2Visitor visitor, Object data) throws jsdai.lang.SdaiException {
    return visitor.visit(this, data);
  }

  public Object childrenAccept(Compiler2Visitor visitor, Object data) throws jsdai.lang.SdaiException {
    JavaClass jc = ( JavaClass )data;
		PrintWriter pw = jc.pw;

		EMap_or_view_partition mp_from_last_binding_header = null;

	 switch (jc.secondary) {
		case 1: // invoking on supertype map, print the WHERE rule expression only, in BindingHeader or directly if not present (not root)

			jc.asp = jc.parent.asp;

			// ----------------- case 1 begins ------------------------------------------------------------------------------
//			System.out.println("MapDecl node - secondary case 1, map: " + map_definition);
//			pw.println("// ############# secondary case 1");
			if (children != null) {
			  for (int i = 0; i < children.length; i++) {
					if (children[i] instanceof X_BindingHeader) { // that has to be the root supertype

						jc.identified_by = false;

						if (((X_BindingHeader)children[i]).partition == jc.reference) {

	//						jc.ind = ind;
 //System.out.println("IN SUPERTYPE - Oh YES, invoking!");
// 	pw.println("// INVOKING IN SUPERTYPE -------- YES YES YES - TO BindingHeader!!!!!!!!!!!!!!");
							children[i].jjtAccept(visitor, data);
					}



					} else
					if (children[i] instanceof X_SubtypeBindingHeader) { // that has to be intermediate supertype, itself a subtype, explicit partitions present


						jc.identified_by = false;

							String child_partition_name = ((X_SubtypeBindingHeader)children[i]).partition.getName(null);
							String required_partition_name = ((EMap_partition)jc.reference).getName(null);
	
//						if (((X_SubtypeBindingHeader)children[i]).partition == jc.reference) {
							
	//				pw.println("("); 
							if (child_partition_name.equalsIgnoreCase(required_partition_name)) {
//					pw.println(")"); 

//					pw.println("&&"); 


							children[i].jjtAccept(visitor, data);
					}




					} else
					if 	(children[i] instanceof X_WhereClause) { 
						// intermediate sub-supertypes, need to test, especially with multiple partitions

						jc.identified_by = false;
						children[i].jjtAccept(visitor, data);

					}
				}
			}
			// ----------------- case 1 ends --------------------------------------------------------------------------------
			break;
		case 2: // invoking on supertype map, processing map attributes

// System.out.println("MapDecl node - secondary case 2, map: " + map_definition);
			pw.println("// ############# secondary case 2 - interested in MapAttributeDeclaration");

			// need source parameters from the root
			jc.asp = jc.parent.asp;
			jc.attribute_mappings = jc.parent.attribute_mappings;
			

			if (children != null) {
				boolean first_for_this_partition = true;
			  for (int i = 0; i < children.length; i++) {

//-------------begin


				if (children[i] instanceof X_MapAttributeDeclaration) {


//			System.out.println("MapDecl node - secondary case 2 - MapAttributeDeclaration found: " + children[i]);
//			pw.println("// ############# secondary case 2 - MapAttributeDeclaration found: " + children[i]);

					
//2?					attributes_present = true;
					// define variables in X_MapAttributeDeclaration in first pass
//					jc.first_pass = true; 
					jc.first_pass = false; 
//2?					jc.first_pass = first_for_this_partition;



	// System.out.println("child: " + children[i] + ", partition: " + mp_name + ", is 1st pass: " + jc.first_pass);	



//					EMap_partition child_partition = ((X_MapAttributeDeclaration)children[i]).partition;
					EMap_partition child_partition = (EMap_partition)((X_MapAttributeDeclaration)children[i]).partition;
					String child_partition_name = null;
					if (child_partition == null) {
						child_partition_name = "default";
					} else {
						child_partition_name = child_partition.getName(null);
					}
					if(child_partition_name.equalsIgnoreCase("_implicit_partition_")){
						child_partition_name = "default";
					}
					String current_partition_name = ((EMap_partition)jc.reference).getName(null);
					if(current_partition_name.equalsIgnoreCase("_implicit_partition_")){
						current_partition_name = "default";
					}


//			System.out.println("// ############# secondary case 2 - child partition: " + child_partition_name + ", current partition: " + ((EMap_partition)jc.reference).getName(null));
//			pw.println("// ############# secondary case 2 - child partition: " + child_partition_name + ", current partition: " + ((EMap_partition)jc.reference).getName(null));



//if (true) {
//						if (((X_MapAttributeDeclaration)children[i]).partition == mp) { 


//						if (((X_MapAttributeDeclaration)children[i]).partition.getName(null).equalsIgnoreCase(((EMap_partition)jc.reference).getName(null))) { 
//						if (child_partition_name.equalsIgnoreCase(((EMap_partition)jc.reference).getName(null))) { 
						if (child_partition_name.equalsIgnoreCase(current_partition_name)) { 
							if (first_for_this_partition) {
//2								if (jc.identified_by == false) {
//2									pw.println("\t\tfor(int j=0; j < binding_inst_extent.size(); j++){ ");
//2								}
//2								((X_MapAttributeDeclaration)children[i]).targets = new HashSet();
								first_for_this_partition = false;
								// is it perhaps the same as jc.first_pass ?
							}
						
							children[i].jjtAccept(visitor, data);
						}
//						jc.first_pass = false;

				} // MapAttributeDeclaration


//-------------end



				} // for - children
			} // children not NULL

			jc.parent.attribute_mappings = jc.attribute_mappings;
			break;
		case 0:
		default:
			// ------------------ the main case begins here, non-supertype (and with supertypes main subtype, if not moved to a separate later) ---------------
//			System.out.println("MapDecl node - primary case 0, map: " + map_definition);
			pw.println("// ############# primary case 0");


		if (flag_generate_execute_in_nodes) {
	


		String map_name = map_definition.getName(null);
		String map_class_name = "M" + map_name.substring(0, 1).toUpperCase() + map_name.substring(1).toLowerCase();

		pw.println("public class " + map_class_name + " {");
		
		pw.println("");
		pw.println("\t/*---------------------- methods to execute maps for each target --------------------*/");
		// ? for each target or everything together?
		pw.println("");

		ATarget_parameter atp = map_definition.getTarget_parameters(null, null);

		jsdai.lang.SdaiIterator tpi = atp.createIterator();

		String etar_type = "" ;
		
		// need other approach for execute handling
		//		while (tpi.next()) {
		tpi.next();
		ETarget_parameter tp = (ETarget_parameter)atp.getCurrentMemberObject(tpi); //here
			String tp_name = tp.getName(null);
// System.out.println("target parameter: " + tp);
			EEntity_definition tp_extent = tp.getExtent(null);
			String tp_extent_name = tp_extent.getName(null);
			String atar_type = getEntityPackage(tp_extent, jc.model) + "A" + tp_extent_name.substring(0, 1).toUpperCase() + tp_extent_name.substring(1).toLowerCase();
			etar_type = getEntityPackage(tp_extent, jc.model) + "E" + tp_extent_name.substring(0, 1).toUpperCase() + tp_extent_name.substring(1).toLowerCase();
//RR			pw.println("\tpublic " +atar_type +" execute(SdaiContext _context) throws SdaiException {");
			pw.println("\tpublic void  execute(SdaiContext _context) throws SdaiException {");
			//TODO: select appopriate partition: suspended, because em-planer doesn't use partitions - always call default partition. 
			pw.println("");
			pw.println("\t\tSdaiModel src_model = _context.src_model;");
			pw.println("\t\tSdaiModel tar_model = _context.tar_model;");
			pw.println("\t\tVector instances_partition_default;");
//RR			pw.println("\t\tHashtable target_instances;");
			pw.println("\t\tHashtable target_instances = new Hashtable();");
			pw.println("");
			pw.println("\t\t_context.mapHashTable = new Hashtable();");
			pw.println("");


// let's remove for now
/*
			pw.println("\t\t" +atar_type +" aggr_" +tp_name +"= new "+atar_type +"();");
			pw.println("");
			pw.println("\t\tif ( _context.mapHashTable.contains(this)){");
			pw.println("\t\t\ttarget_instances = (Hashtable)_context.mapHashTable.get(this);");
			pw.println("\t\t\tIterator it = target_instances.entrySet().iterator();");
			pw.println("\t\t\twhile(it.hasNext()){");
			pw.println("\t\t\t\taggr_" +tp_name +".addUnordered(it.next(), null);");
			pw.println("\t\t\t}");
			pw.println("\t\t\treturn aggr_" +tp_name +";");
			pw.println("\t\t}else{");
			pw.println("\t\t\ttarget_instances = new Hashtable();");
			pw.println("\t\t\t_context.mapHashTable.put(this, target_instances);");
			pw.println("\t\t}");

*/

//			pw.println("\t\tSystem.out.println(\"processing partition..\");");
			pw.println("\t\tSystem.out.println(\"processing partitions..\");");
//			pw.println("\t\taggr_" +tp_name +" = (" +atar_type +")processPartition_default(src_model, tar_model, target_instances);");

//			pw.println("\t\taggr_" +tp_name +" = (" +atar_type +")processPartition_default(src_model, tar_model, target_instances, _context);");


			AMap_partition am_p = map_definition.getPartitions(null, null);
			SdaiIterator mp_i = am_p.createIterator();
			while (mp_i.next()) {
				EMap_partition m_p = (EMap_partition)am_p.getCurrentMemberObject(mp_i);
				String m_p_name = m_p.getName(null);
// System.out.println("partition: " + m_p_name);				
pw.println("\t//---partition: " + m_p_name);
				if(m_p_name.equalsIgnoreCase("_implicit_partition_")){
					m_p_name = "default";
				}
//RR				pw.println("\t\taggr_" +tp_name +" = (" +atar_type +")processPartition_" + m_p_name + "(src_model, tar_model, target_instances, _context);");
				pw.println("\t\tprocessPartition_" + m_p_name + "(src_model, tar_model, target_instances, _context);");
			}


//RR			pw.println("\t\treturn aggr_" +tp_name +";");
			pw.println("\t\treturn;");
			pw.println("\t}");
			//		}

    // generating methods to be called from other maps

	   
	   // map calls to subtype maps not supported yet
	   if (!map_definition.testSuper_type(null)) {


			if (atp.getMemberCount() < 2) {

				AMap_partition am_p0 = map_definition.getPartitions(null, null);
				if (am_p0.getMemberCount() > 1) { // if more than one partition


					pw.println("\tprotected static Value call(SdaiContext _context, Value input) throws SdaiException {");
//		EData_type declared_type = input.getDeclaredType();
//		EData_type actual_type = input.getActualType();
					pw.println("\t\tEEntity inst = input.getInstance();");
					pw.println("\t\tValue result = Value.alloc().unset();");
					pw.println("");
					boolean first_time = true;

					SdaiIterator mp_i0 = am_p0.createIterator();
					while (mp_i0.next()) {
//          mp_i0.end();
//					while (mp_i0.previous()) {
						EMap_partition m_p0 = (EMap_partition)am_p0.getCurrentMemberObject(mp_i0);
						String m_p_name0 = m_p0.getName(null);

						// for each partition go through source parameters
						ASource_parameter asp0 = m_p0.getSource_parameters(null, null);
						SdaiIterator spi0 = asp0.createIterator();
						if (asp0.getMemberCount() > 1) {
							// if more than one source parameter - if IDENTIFIED_BY is present, the number of arguments may be different!
							while (spi0.next()) {
								ESource_parameter sp0 = (ESource_parameter)asp0.getCurrentMemberObject(spi0);
								String sp0_name = sp0.getName(null);
								EEntity_definition edef = (EEntity_definition)sp0.getExtent(null);
								
							} // while source parameters
						} else { // one source parameter only
							// this first implementation handles only cases with one source parameter without IDENTIFIEB_BY,
							// or with one source parameter with IDENTIFIED_BY with also only one parameter
							if (spi0.next()) {
								ESource_parameter sp0 = (ESource_parameter)asp0.getCurrentMemberObject(spi0);
								String sp0_name = sp0.getName(null);
								EEntity_definition edef = (EEntity_definition)sp0.getExtent(null);
								String entity_name = edef.getName(null);
								String sp_package = getEntityPackage(edef, jc.model); 

								String normalized_name = entity_name.substring(0, 1).toUpperCase() + entity_name.substring(1).toLowerCase();
								String esrc_type = sp_package + "E" + normalized_name;

								if (first_time) {
									first_time = false;
								} else {
									pw.println("\t\t} else"); 
								}
								pw.println("\t\tif (inst instanceof " + esrc_type + ") {");	
									pw.println("\t\t\tresult = callPartition_" + m_p_name0 + "(_context, input);");

							}
						}
		
					} // while partitions
					pw.println("\t\t}");	
				  pw.println("\t\treturn result;");
					pw.println("\t}");	
				} // only one partition - do nothing
			
			} else { // if more than one target parameter
			}


			if (atp.getMemberCount() < 2) {

			String partition_suffix = "";
			AMap_partition am_p2 = map_definition.getPartitions(null, null);
			SdaiIterator mp_i2 = am_p2.createIterator();
			while (mp_i2.next()) {
				EMap_partition m_p2 = (EMap_partition)am_p2.getCurrentMemberObject(mp_i2);
				String m_p_name2 = m_p2.getName(null);
// System.out.println("partition: " + m_p_name);				
// pw.println("\t//---partition: " + m_p_name);
				if(m_p_name2.equalsIgnoreCase("_implicit_partition_")){
					m_p_name2 = "default";
				} else {
					partition_suffix = "Partition_" + m_p_name2;
				}
				

				// wee need this only when one target parameter, I think
				pw.println("\tprotected static Value call" + partition_suffix + "(SdaiContext _context, Value input) throws SdaiException {");
//				pw.println("\tprotected static Value call(SdaiContext _context, Value input) {");
			  pw.println("\t\tValue result;");

			pw.println("\t\tSdaiModel src_model = _context.src_model;");
			pw.println("\t\tSdaiModel tar_model = _context.tar_model;");
//			pw.println("\t\tVector instances_partition_default;");
//RR			pw.println("\t\tHashtable target_instances;");
			pw.println("\t\tHashtable target_instances = new Hashtable();");
			pw.println("");
//			pw.println("\t\t_context.mapHashTable = new Hashtable();");
			pw.println("");


//				pw.println("\t\tresult = callPartition_" + m_p_name + "(src_model, tar_model, target_instances, _context, input);");
				pw.println("\t\tresult = callPartition_" + m_p_name2 + "(src_model, tar_model, target_instances, _context, input);");
				pw.println("\t\treturn result;");
				pw.println("\t}");

			 } // through partitions    	
    	}


			if (atp.getMemberCount() < 2) {

			String partition_suffix = "";
			AMap_partition am_p2 = map_definition.getPartitions(null, null);
			SdaiIterator mp_i2 = am_p2.createIterator();
			while (mp_i2.next()) {
				EMap_partition m_p2 = (EMap_partition)am_p2.getCurrentMemberObject(mp_i2);
				String m_p_name2 = m_p2.getName(null);
// System.out.println("partition: " + m_p_name);				
// pw.println("\t//---partition: " + m_p_name);
				if(m_p_name2.equalsIgnoreCase("_implicit_partition_")){
					m_p_name2 = "default";
				} else {
					partition_suffix = "Partition_" + m_p_name2;
				}
    
			pw.println("\tprotected static Value callTarget_" + tp_name +  partition_suffix + "(SdaiContext _context, Value input) throws SdaiException {");
//			pw.println("\tprotected static Value callTarget_" + tp_name + "(SdaiContext _context, Value input) {");
			  pw.println("\t\tValue result;");

			pw.println("\t\tSdaiModel src_model = _context.src_model;");
			pw.println("\t\tSdaiModel tar_model = _context.tar_model;");
//			pw.println("\t\tVector instances_partition_default;");
//RR			pw.println("\t\tHashtable target_instances;");
			pw.println("\t\tHashtable target_instances = new Hashtable();");
			pw.println("");
//			pw.println("\t\t_context.mapHashTable = new Hashtable();");
			pw.println("");


//				pw.println("\t\tresult = callPartition_" + m_p_name + "(src_model, tar_model, target_instances, _context, input);");
				jc.target = null;
				pw.println("\t\tresult = callPartition_" + m_p_name2 + "(src_model, tar_model, target_instances, _context, input);");
			pw.println("\t\treturn result;");
			pw.println("\t}");
    	} // through partitions

			} else {
				// multiple targets			

			jsdai.lang.SdaiIterator tpi2 = atp.createIterator();

			while (tpi2.next()) {
				
			ETarget_parameter tp2 = (ETarget_parameter)atp.getCurrentMemberObject(tpi2); //here
			String tp2_name = tp2.getName(null);


			String partition_suffix = "";
			AMap_partition am_p2 = map_definition.getPartitions(null, null);
			SdaiIterator mp_i2 = am_p2.createIterator();
			while (mp_i2.next()) {
				EMap_partition m_p2 = (EMap_partition)am_p2.getCurrentMemberObject(mp_i2);
				String m_p_name2 = m_p2.getName(null);
// System.out.println("partition: " + m_p_name);				
// pw.println("\t//---partition: " + m_p_name);
				if(m_p_name2.equalsIgnoreCase("_implicit_partition_")){
					m_p_name2 = "default";
				} else {
					partition_suffix = "Partition_" + m_p_name2;
				}



			pw.println("\tprotected static Value callTarget_" + tp2_name + partition_suffix + "(SdaiContext _context, Value input) throws SdaiException {");
//			pw.println("\tprotected static Value callTarget_" + tp_name + "(SdaiContext _context, Value input) {");
			  pw.println("\t\tValue result;");

			pw.println("\t\tSdaiModel src_model = _context.src_model;");
			pw.println("\t\tSdaiModel tar_model = _context.tar_model;");
//			pw.println("\t\tVector instances_partition_default;");
//RR			pw.println("\t\tHashtable target_instances;");
			pw.println("\t\tHashtable target_instances = new Hashtable();");
			pw.println("");
//			pw.println("\t\t_context.mapHashTable = new Hashtable();");
			pw.println("");


//				pw.println("\t\tresult = callPartition_" + m_p_name + "(src_model, tar_model, target_instances, _context, input);");
			// jc.target = tp2;
				pw.println("\t\tresult = callTarget_" + tp2_name + "Partition_" + m_p_name2 + "(src_model, tar_model, target_instances, _context, input);");
			// jc.target = null;
			pw.println("\t\treturn result;");
			pw.println("\t}");


	    } // through partitions			
		} // through targets
			
			}

} // if not subtype map - this is temporaririly, map calls to subtype maps not yet supported

		pw.println("");
		pw.println("\t/*---------------------- methods to execute maps for each partition --------------------*/");
		pw.println("");


	if (false) {
//	if (map_definition.testSuper_type(null)) {

		// ------------------ begin -----------------------------------------------------------


	 



		// get the first non-subtype map, because only partitions of this map contain source parameters

	  jsdai.SExtended_dictionary_schema.EMap_definition map_definition_root;
		
		map_definition_root = getRootSupertypeMap(map_definition);


//    jsdai.expressCompiler.JavaBackend.generateJavaExpressionSecondary(pw, map_definition_root, jc.sd, null, jc.model, 1, jc, null);



		AMap_partition ampr = map_definition_root.getPartitions(null, null);
		SdaiIterator mpri = ampr.createIterator();


		AMap_partition amp = map_definition.getPartitions(null, null);
		SdaiIterator mpi = amp.createIterator();

		boolean first_for_this_partition = true;
		while (mpri.next()) {
			EMap_partition mp = (EMap_partition)ampr.getCurrentMemberObject(mpri);
			jc.partition = mp;
			String mp_name = mp.getName(null);
			first_for_this_partition = true;
			// ...
			// only default partition supported - em-planner doesn't need others
			// ...

			if(mp_name.equalsIgnoreCase("_implicit_partition_")){
				mp_name = "default";
			}

//			pw.println("\tpublic AEntity processPartition_" +mp_name +"(SdaiModel src_model, SdaiModel tar_model, Hashtable target_instances) throws SdaiException {");
			pw.println("\tpublic AEntity processPartition_" +mp_name +"(SdaiModel src_model, SdaiModel tar_model, Hashtable target_instances, SdaiContext _context) throws SdaiException {");

			// FROM part, generate source binding extent
			pw.println("\t// FROM part, generate source binding extent");
			ASource_parameter asp = mp.getSource_parameters(null, null);
// System.out.println("source parameters: " + asp);
			jc.asp = asp; // save reference for src parameters to be used in Identified_by node
			SdaiIterator spi = asp.createIterator();
			int ind=0;
			String add_instances="";

			pw.println("\t\tVector binding_inst_extent = new Vector();");
			pw.println("\t\tVector binding_inst = new Vector();");
			pw.println("\t\tHashtable src_id_map = new Hashtable();");

			
			// if it is a subtype, then we need to get source parameters from supertype, etc
			// let's have a separate handling of subtype maps
    

			while (spi.next()) {
				ind++;
				ESource_parameter sp = (ESource_parameter)asp.getCurrentMemberObject(spi);
				String sp_name = sp.getName(null);

				EEntity_or_view_definition sp_extent = (EEntity_or_view_definition)sp.getExtent(null);
				String sp_extent_name = sp_extent.getName(null);
				String sp_package = getEntityPackage(sp_extent, jc.model); 
				String normalized_name = sp_extent_name.substring(0, 1).toUpperCase() + sp_extent_name.substring(1).toLowerCase();
				String esrc_type = sp_package + "E" + normalized_name;
				String asrc_type = sp_package + "A" + normalized_name;

				pw.println("\t\t" +asrc_type +" a" +ind +"_inst = (" +asrc_type +")src_model.getInstances(" +esrc_type +".class);");
			}

			spi.beginning();
			ind=0;
			while (spi.next()) {
				ind++;
				ESource_parameter sp = (ESource_parameter)asp.getCurrentMemberObject(spi);
				String sp_name = sp.getName(null);

				EEntity_or_view_definition sp_extent = (EEntity_or_view_definition)sp.getExtent(null);
				String sp_extent_name = sp_extent.getName(null);
				String sp_package = getEntityPackage(sp_extent, jc.model); 
				String normalized_name = sp_extent_name.substring(0, 1).toUpperCase() + sp_extent_name.substring(1).toLowerCase();
				String esrc_type = sp_package + "E" + normalized_name;
				String csrc_type = sp_package + "C" + normalized_name;
				String asrc_type = sp_package + "A" + normalized_name;

				//						tabByIndex(ind, pw); pw.println(asrc_type +" a" +ind +"_inst = (" +asrc_type +")src_model.getInstances(" +esrc_type +".class);");
				pw.println("");
				tabByIndex(ind, pw); pw.println("for (int i" +ind +" = 1; i" +ind +" < a" +ind +"_inst.getMemberCount()+1; i" +ind +"++) {");
				tabByIndex(ind, pw); pw.println("\tValue " +sp_name +" = Value.alloc(" +csrc_type +".definition).set(_context, a" +ind +"_inst.getByIndex(i" +ind +"));");
				add_instances = tabByIndexToString(asp.getMemberCount(), pw, add_instances); add_instances += "\tbinding_inst.addElement(" +sp_name +");\n";
				if(asp.getMemberCount() < 2) { tabByIndex(ind, pw); pw.println("\tbinding_inst.addElement(\"\");"); }
				if(ind == asp.getMemberCount()){ 
					tabByIndex(ind, pw); pw.println("\tbinding_inst = new Vector();");
					pw.println(add_instances);
				}
				tabByIndex(ind, pw); pw.println("\tsrc_id_map.put(\""+ sp_name +"\", new Integer(" +(ind-1) +"));");
			}

			//
			// WHERE part 
			//
			

			if (children != null) {

		  boolean attributes_present = false;
			 			
		  for (int i = 0; i < children.length; i++) {
				// possible children: 
				// X_BindingHeader (includes inside optional clauses: From clause, local declarations, WHERE clause, Identified_by clause, Ordered_by clause)
				// X_MapAttributeDeclaration
				// etc

				// so move actions for all this stuff into the children nodes (BindingHeader etc)

// System.out.println("current child: " + children[i] + ", current partition: " + mp.getName(null));

				if (children[i] instanceof X_BindingHeader) {
// System.out.println("current child - BindingHeader, partition: " + ((X_BindingHeader)children[i]).partition.getName(null));
					jc.identified_by = false;
					if (((X_BindingHeader)children[i]).partition == mp) {
						jc.ind = ind;
// System.out.println("Oh YES, invoking!");
// 	pw.println("// INVOKING -------- YES YES YES - TO BindingHeader!!!!!!!!!!!!!!");
						children[i].jjtAccept(visitor, data);
					}
				} else
				if (children[i] instanceof X_MapAttributeDeclaration) {
					
					attributes_present = true;
					jc.first_pass = true; // define variables in X_MapAttributeDeclaration in first pass
					jc.first_pass = first_for_this_partition;



	// System.out.println("child: " + children[i] + ", partition: " + mp_name + ", is 1st pass: " + jc.first_pass);	
						if (((X_MapAttributeDeclaration)children[i]).partition == mp) { 
							if (first_for_this_partition) {
								if (jc.identified_by == false) {
									pw.println("\t\tfor(int j=0; j < binding_inst_extent.size(); j++){ ");
								}
								((X_MapAttributeDeclaration)children[i]).targets = new HashSet();
								first_for_this_partition = false;
								// is it perhaps the same as jc.first_pass ?
							}
						
							children[i].jjtAccept(visitor, data);
						}
//						jc.first_pass = false;

				} else // MapAttributeDeclaration
				if (children[i] instanceof X_EntityInstantiationLoop) {
					attributes_present = true;
				} // X_EntityInstantiationLoop

			} // for
			if (!attributes_present) {
				// better move from attribute, but temporarily, duplicate these things here
			
				// this whole thing is inside the loop through partitions, so it is ok
				// we way need to handle the following cases:
				// 1. no source parameters (no FROM clause) - just generate 1 instance
				// 2. 1 source parameter
				// 3. multiple source parameters
				// 4. if source parameters, also WHERE clause present or not
				// 5 IDENTIFIED_BY clause present or not
				

				ATarget_parameter atp2 = map_definition.getTarget_parameters(null, null);
				jsdai.lang.SdaiIterator tpi2 = atp2.createIterator();
				while (tpi2.next()) {
					ETarget_parameter tp2 = (ETarget_parameter)atp2.getCurrentMemberObject(tpi2);

				  if (jc.identified_by == false) {
							pw.println("\t\tfor(int j=0; j < binding_inst_extent.size(); j++){ ");

							jsdai.SExtended_dictionary_schema.ETarget_parameter target_parameter = tp2;
							String tar_par_name = target_parameter.getName(null);
							String plain_target_name = tar_par_name;
							Vector src_par_names = new Vector();
							Vector src_par_orders = new Vector();
							// target instance should be created only once - when first encountered target_parameter 
							HashSet targets = new HashSet();  // this is stupid, it does not do that, just so that it is compileable
					
							SdaiIterator spi2 = jc.asp.createIterator();
							while (spi2.next()) {
								ESource_parameter sp2 = (ESource_parameter)jc.asp.getCurrentMemberObject(spi2);
								String sp_name2 = sp2.getName(null);
								src_par_names.add(sp_name2);
							}


							tar_par_name += "_" +jc.target_par_count;
							jc.target_par_count++;
//							pw.println("\t\t\tValue expr_" +tar_par_name +" = Value.alloc().unset();");

//							pw.println("\t\t\tValue last_expr_" +tar_par_name +" = Value.alloc().unset();");
							pw.println("");

							for(int si=0; si < src_par_names.size(); si++){
	//							pw.println("\t\tint src_par_id_" +(String)src_par_names.get(si) +";");
	//							pw.println("\t\t\tValue " +(String)src_par_names.get(si) +";");
								first_for_this_partition = false;

							}

							if(!targets.contains(plain_target_name)){
		    		    EEntity_definition target_type = target_parameter.getExtent(null);
								String tar_extent_name  = target_type.getName(null);
								String normalized_name = tar_extent_name.substring(0, 1).toUpperCase() + tar_extent_name.substring(1).toLowerCase();
								String tar_package = getEntityPackage(target_type);
								String etar_type2 = tar_package + "E" + normalized_name;
								String ctar_type2 = tar_package + "C" + normalized_name;
		
								pw.println("\t\t\t" +etar_type2 +" " +plain_target_name +"_inst = (" +etar_type2 +")tar_model.createEntityInstance(" +etar_type2 +".class);");		
//								pw.println("\t\t\tValue " +plain_target_name +" = Value.alloc(" +ctar_type2 +".definition).set(_context, " +plain_target_name +"_inst);");
								targets.add(plain_target_name);
							}
//String gen_target_attr = "KUKU-HAHA";
//							pw.println("\t\t\t" +gen_target_attr +" expr_" +tar_par_name +");"); //  d.setName();


					} else { // no identified_by
						// identified_by present
						// TODO
					}

				} // while - through target parameters 		

			} // if attributes NOT present - constant partition
			
		} // if children NOT null (children include binding header)


/*

			int i=0;  // change into the loop, needed for multiple partitions

			if(children[i] instanceof X_WhereClause){
				pw.println("\t\t\t// WHERE clause");
				tabByIndex(ind, pw); pw.print("\tif(");
				children[i].jjtAccept(visitor, data);
				pw.println("){"); 
				tabByIndex(ind, pw); pw.println("\t\tbinding_inst_extent.addElement(binding_inst);");
				tabByIndex(ind, pw); pw.println("\t}");
				i++; // generate next clause
			}else{
				tabByIndex(ind, pw); pw.println("\tbinding_inst_extent.addElement(binding_inst);");
				//								children[i].jjtAccept(visitor, data);
			}

*/
	
	
/*	
	
			while(ind > 0){
				tabByIndex(ind, pw); pw.println("}");
				ind--;
			}

*/



/*

			//
			// IDENTIFIED_BY expression, classification to eq class
			//
			if(i < children.length){
				if(children[i] instanceof X_IdentifiedByClause){
					pw.println("\t\t// IDENTIFIED_BY clause");
					children[i].jjtAccept(visitor, data);
					i++;
				}
			}
			pw.println("");

*/


/*

			//
			// SELECT part
			//
			// evaluate expression parts for the bindings of the same eq class and set appopriate values
			//
			// TODO: error handling in case of incompatible result of expression with left side of select statement
			// TODO: control by numeric increment, control by iteration over aggregate (
			//
			if(i > 0 && children[i-1] instanceof X_IdentifiedByClause){
				pw.println("\t\t// Evaluating expression parts for the bindings of the same eq class and setting appopriate values");
				pw.println("\t\tIterator iter = alist.iterator();");
				pw.println("\t\tfor(int i = 0; i < alist.size() ; i++) {");
				pw.println("\t\t\tint inst_num = 0;");
				// don't do checking, rely on the size
				pw.println("\t\t\tVector eq_class = (Vector)iter.next();");

				jc.identified_by = true;
			}else{
				pw.println("\t\tfor(int j=0; j < binding_inst_extent.size(); j++){ ");
			}


*/





      // this is handling of MapAttributeDeclarations, a separate loop through the children, as of now



/*


			if (children != null) {
				jc.first_pass = true; // define variables in X_MapAttributeDeclaration in first pass

//				for (int l = i; l < children.length; ++l) {
        // could do also from 1, actually better switch to that, because there are changes about i value, making a loop
				for (int l = 0; l < children.length; ++l) {
	System.out.println("child: " + children[l] + ", partition: " + mp_name + ", is 1st pass: " + jc.first_pass);	
					if (children[l] instanceof X_MapAttributeDeclaration) {
						if (((X_MapAttributeDeclaration)children[l]).partition == mp) { 
							if (first_for_this_partition) {
								((X_MapAttributeDeclaration)children[l]).targets = new HashSet();
								first_for_this_partition = false;
								// is it perhaps the same as jc.first_pass ?
							}
						
							children[l].jjtAccept(visitor, data);
						}
					}
				}
				jc.first_pass = false;
			} // if children not NULL

			pw.println("\t\t}");

*/





// moved into the partition loop
		pw.println("\t\t}");					
		pw.println("\t\treturn tar_model.getInstances(" +etar_type +".class);");
		pw.println("\t}");					


		} // loop through partitions


		// ------------------ end -------------------------------------------------------------
	} else	
	if (map_definition.testSuper_type(null)) {
		// new subtype map implementation ------------------- begins --------------------------------------------------------


		// FROM clause and source parameters are present only in the partitions of the root supertype, not in any of subtypes
		// so we need to get to the root supertype to get source parameters from there
			

	  jsdai.SExtended_dictionary_schema.EMap_definition map_definition_root;
		map_definition_root = getRootSupertypeMap(map_definition);

//    jsdai.expressCompiler.JavaBackend.generateJavaExpressionSecondary(pw, map_definition_root, jc.sd, null, jc.model, 1, jc, null);

	// may not be needed, we we'll use the root partitions, at least for source parameters, etc
	AMap_partition amp = map_definition.getPartitions(null, null);
	SdaiIterator mpi = amp.createIterator();

		AMap_partition ampr = map_definition_root.getPartitions(null, null);
		SdaiIterator mpri = ampr.createIterator();


		boolean first_for_this_partition = true;
//		while (mpi.next()) {
		while (mpri.next()) {
//			EMap_partition mp = (EMap_partition)amp.getCurrentMemberObject(mpi);
			EMap_partition mp = (EMap_partition)ampr.getCurrentMemberObject(mpri);
			jc.partition = mp;
			String mp_name = mp.getName(null);
			first_for_this_partition = true;
			// ...
			// only default partition supported - em-planner doesn't need others
			// ...

			if(mp_name.equalsIgnoreCase("_implicit_partition_")){
				mp_name = "default";
			}

//			pw.println("\tpublic AEntity processPartition_" +mp_name +"(SdaiModel src_model, SdaiModel tar_model, Hashtable target_instances) throws SdaiException {");
			pw.println("\tpublic AEntity processPartition_" +mp_name +"(SdaiModel src_model, SdaiModel tar_model, Hashtable target_instances, SdaiContext _context) throws SdaiException {");

			// FROM part, generate source binding extent
			pw.println("\t// FROM part, generate source binding extent");

			
			ASource_parameter asp = mp.getSource_parameters(null, null);
// System.out.println("source parameters: " + asp);
			jc.asp = asp; // save reference for src parameters to be used in Identified_by node
			SdaiIterator spi = asp.createIterator();
			int ind=0;
			String add_instances="";

			pw.println("\t\tVector binding_inst_extent = new Vector();");
			pw.println("\t\tVector binding_inst = new Vector();");
			pw.println("\t\tHashtable src_id_map = new Hashtable();");

			
			// if it is a subtype, then we need to get source parameters from supertype, etc
			// let's have a separate handling of subtype maps
    

			while (spi.next()) {
				ind++;
				ESource_parameter sp = (ESource_parameter)asp.getCurrentMemberObject(spi);
				String sp_name = sp.getName(null);

				EEntity_or_view_definition sp_extent = (EEntity_or_view_definition)sp.getExtent(null);
				String sp_extent_name = sp_extent.getName(null);
				String sp_package = getEntityPackage(sp_extent, jc.model); 
				String normalized_name = sp_extent_name.substring(0, 1).toUpperCase() + sp_extent_name.substring(1).toLowerCase();
				String esrc_type = sp_package + "E" + normalized_name;
				String asrc_type = sp_package + "A" + normalized_name;

				pw.println("\t\t" +asrc_type +" a" +ind +"_inst = (" +asrc_type +")src_model.getInstances(" +esrc_type +".class);");
			}

			spi.beginning();
			ind=0;
			while (spi.next()) {
				ind++;
				ESource_parameter sp = (ESource_parameter)asp.getCurrentMemberObject(spi);
				String sp_name = sp.getName(null);

				EEntity_or_view_definition sp_extent = (EEntity_or_view_definition)sp.getExtent(null);
				String sp_extent_name = sp_extent.getName(null);
				String sp_package = getEntityPackage(sp_extent, jc.model); 
				String normalized_name = sp_extent_name.substring(0, 1).toUpperCase() + sp_extent_name.substring(1).toLowerCase();
				String esrc_type = sp_package + "E" + normalized_name;
				String csrc_type = sp_package + "C" + normalized_name;
				String asrc_type = sp_package + "A" + normalized_name;

				//						tabByIndex(ind, pw); pw.println(asrc_type +" a" +ind +"_inst = (" +asrc_type +")src_model.getInstances(" +esrc_type +".class);");
				pw.println("");
				tabByIndex(ind, pw); pw.println("for (int i" +ind +" = 1; i" +ind +" < a" +ind +"_inst.getMemberCount()+1; i" +ind +"++) {");
				tabByIndex(ind, pw); pw.println("\tValue " +sp_name +" = Value.alloc(" +csrc_type +".definition).set(_context, a" +ind +"_inst.getByIndex(i" +ind +"));");
				add_instances = tabByIndexToString(asp.getMemberCount(), pw, add_instances); add_instances += "\tbinding_inst.addElement(" +sp_name +");\n";
				if(asp.getMemberCount() < 2) { tabByIndex(ind, pw); pw.println("\tbinding_inst.addElement(\"\");"); }
				if(ind == asp.getMemberCount()){ 
					tabByIndex(ind, pw); pw.println("\tbinding_inst = new Vector();");
					pw.println(add_instances);
				}
				tabByIndex(ind, pw); pw.println("\tsrc_id_map.put(\""+ sp_name +"\", new Integer(" +(ind-1) +"));");
			}

			//
			// WHERE part 
			//
			
			// in subtype map there will not be binding header node, just directly WHERE clause,
			// at least with default implicit partition
			
			

			if (children != null) {

		  boolean attributes_present = false;
			 			
			jc.attribute_mappings = new HashSet();
			 			
			 			
		  for (int i = 0; i < children.length; i++) {
				// possible children: 
				// X_BindingHeader (includes inside optional clauses: From clause, local declarations, WHERE clause, Identified_by clause, Ordered_by clause)
				// X_MapAttributeDeclaration
				// etc

				// so move actions for all this stuff into the children nodes (BindingHeader etc)

// System.out.println("current child: " + children[i] + ", current partition: " + mp.getName(null));

				if (children[i] instanceof X_BindingHeader) {
// System.out.println("current child - BindingHeader, partition: " + ((X_BindingHeader)children[i]).partition.getName(null) + ", current partition: " + mp.getName(null));
					jc.identified_by = false;
					if (((X_BindingHeader)children[i]).partition == mp) {
						jc.ind = ind;
 // System.out.println("Oh YES, invoking!");
 	pw.println("// INVOKING -------- YES YES YES - TO BindingHeader!!!!!!!!!!!!!!");
						children[i].jjtAccept(visitor, data);
					}
				} else
				if (children[i] instanceof X_SubtypeBindingHeader) {
					 // in the main subtype branch (secondary = 0) this should be the same as directly WhereClause node,
					 // currently internal implementation in the node just returns the where clause expression
					 // may have to extend for other things, identified_by not supported yet

					if (((X_SubtypeBindingHeader)children[i]).partition.getName(null).equalsIgnoreCase(mp.getName(null))) {


					tabByIndex(ind, pw); pw.print("\tif(");
//					pw.println("("); 

					jsdai.SExtended_dictionary_schema.EMap_definition md_current = map_definition;
					for (;;) {
						if (md_current.testSuper_type(null)) {
							md_current = md_current.getSuper_type(null);
					pw.println("("); 
			    		jsdai.expressCompiler.JavaBackend.generateJavaExpressionSecondary(pw, md_current, jc.sd, null, jc.model, 1, jc, mp);
					pw.println(")"); 
					pw.println("&&"); 
						} else {
							break;
						}
					}

//					pw.println(")"); 

//					pw.println("&&"); 
					pw.println("("); 
					children[i].jjtAccept(visitor, data);
					pw.println(")"); 
					pw.println("){"); 
					tabByIndex(ind, pw); pw.println("\t\tbinding_inst_extent.addElement(binding_inst); // where clause");
					tabByIndex(ind, pw); pw.println("\t}");
					// i++; // generate next clause
					while(ind > 0){
						tabByIndex(ind, pw); pw.println("}");
						ind--;
					}

				} // if right partition
				
				} else
				if 	(children[i] instanceof X_WhereClause) {
					// after SubtypeBindingHeader node was introduced, WhereClause cannot occur directly, so the code below is obsolete
					// try to put the where rule here then
//---------------start					
					
				pw.println("\t\t\t// WHERE clause");
				tabByIndex(ind, pw); pw.print("\tif(");
				pw.println("("); 

// also add from root types, in this case just from the root, but we need to implement support for longer chains as well					

			jsdai.SExtended_dictionary_schema.EMap_definition md_current = map_definition;
			for (;;) {
				if (md_current.testSuper_type(null)) {
					md_current = md_current.getSuper_type(null);
			    jsdai.expressCompiler.JavaBackend.generateJavaExpressionSecondary(pw, md_current, jc.sd, null, jc.model, 1, jc, mp);
				} else {
					break;
				}
			}

//    jsdai.expressCompiler.JavaBackend.generateJavaExpressionSecondary(pw, map_definition_root, jc.sd, null, jc.model, 1, jc, mp);

//---------------

/*
     do  a loop

			jsdai.SExtended_dictionary_schema.EMap_definition md = null;
			if (map_definition.testSuper_type(null)) {
				md = getRootSupertypeMap(map_definition.getSuper_type(null));
			} else {
				md = map_definition;
			}

*/

//---------------
				pw.println(")"); 

				pw.println("&&"); 
				pw.println("("); 
				children[i].jjtAccept(visitor, data);
				pw.println(")"); 
				pw.println("){"); 
				tabByIndex(ind, pw); pw.println("\t\tbinding_inst_extent.addElement(binding_inst); // where clause");
				tabByIndex(ind, pw); pw.println("\t}");
				// i++; // generate next clause
				while(ind > 0){
					tabByIndex(ind, pw); pw.println("}");
					ind--;
				}




//---------------end					
				} else
				if (children[i] instanceof X_MapAttributeDeclaration) {
					
					attributes_present = true;
					jc.first_pass = true; // define variables in X_MapAttributeDeclaration in first pass
					jc.first_pass = first_for_this_partition;



	// System.out.println("child: " + children[i] + ", partition: " + mp_name + ", is 1st pass: " + jc.first_pass);	

//if (true) {
//						if (((X_MapAttributeDeclaration)children[i]).partition == mp) { 
//						if (((X_MapAttributeDeclaration)children[i]).partition.getName(null).equalsIgnoreCase(mp.getName(null))) { 
// System.out.println("<><>partition: " + ((X_MapAttributeDeclaration)children[i]).partition);

//					EMap_partition child_partition = ((X_MapAttributeDeclaration)children[i]).partition;
					EMap_partition child_partition = (EMap_partition)((X_MapAttributeDeclaration)children[i]).partition;
					String child_partition_name = null;
					if (child_partition == null) {
						child_partition_name = "default";
					} else {
						child_partition_name = child_partition.getName(null);
					}
					if(child_partition_name.equalsIgnoreCase("_implicit_partition_")){
						child_partition_name = "default";
					}
// System.out.println("<><>child partition: " + child_partition_name);

//						if (((X_MapAttributeDeclaration)children[i]).partition.getName(null).equalsIgnoreCase(mp_name) { 
// if (true) {
						if (child_partition_name.equalsIgnoreCase(mp_name)) { 

							if (first_for_this_partition) {
								if (jc.identified_by == false) {
									pw.println("\t\tfor(int j=0; j < binding_inst_extent.size(); j++){ ");
								}
								((X_MapAttributeDeclaration)children[i]).targets = new HashSet();
								first_for_this_partition = false;
								// is it perhaps the same as jc.first_pass ?
							}
						
							children[i].jjtAccept(visitor, data);
						}
//						jc.first_pass = false;

				} // MapAttributeDeclaration


			} // for - children
			// let's take also attributes from supertypes
			
			jsdai.SExtended_dictionary_schema.EMap_definition md_current = map_definition;
			for (;;) {
				if (md_current.testSuper_type(null)) {
					md_current = md_current.getSuper_type(null);
			    jsdai.expressCompiler.JavaBackend.generateJavaExpressionSecondary(pw, md_current, jc.sd, null, jc.model, 2, jc, mp);
				} else {
					break;
				}
			}
			
			
			
			if (!attributes_present) {
				// better move from attribute, but temporarily, duplicate these things here
			
				// this whole thing is inside the loop through partitions, so it is ok
				// we way need to handle the following cases:
				// 1. no source parameters (no FROM clause) - just generate 1 instance
				// 2. 1 source parameter
				// 3. multiple source parameters
				// 4. if source parameters, also WHERE clause present or not
				// 5 IDENTIFIED_BY clause present or not
				

				ATarget_parameter atp2 = map_definition.getTarget_parameters(null, null);
				jsdai.lang.SdaiIterator tpi2 = atp2.createIterator();
				while (tpi2.next()) {
					ETarget_parameter tp2 = (ETarget_parameter)atp2.getCurrentMemberObject(tpi2);

				  if (jc.identified_by == false) {
							pw.println("\t\tfor(int j=0; j < binding_inst_extent.size(); j++){ ");

							jsdai.SExtended_dictionary_schema.ETarget_parameter target_parameter = tp2;
							String tar_par_name = target_parameter.getName(null);
							String plain_target_name = tar_par_name;
							Vector src_par_names = new Vector();
							Vector src_par_orders = new Vector();
							// target instance should be created only once - when first encountered target_parameter 
							HashSet targets = new HashSet();  // this is stupid, it does not do that, just so that it is compileable
					
							SdaiIterator spi2 = jc.asp.createIterator();
							while (spi2.next()) {
								ESource_parameter sp2 = (ESource_parameter)jc.asp.getCurrentMemberObject(spi2);
								String sp_name2 = sp2.getName(null);
								src_par_names.add(sp_name2);
							}


							tar_par_name += "_" +jc.target_par_count;
							jc.target_par_count++;
//							pw.println("\t\t\tValue expr_" +tar_par_name +" = Value.alloc().unset();");

//							pw.println("\t\t\tValue last_expr_" +tar_par_name +" = Value.alloc().unset();");
							pw.println("");

							for(int si=0; si < src_par_names.size(); si++){
	//							pw.println("\t\tint src_par_id_" +(String)src_par_names.get(si) +";");
	//							pw.println("\t\t\tValue " +(String)src_par_names.get(si) +";");
								first_for_this_partition = false;

							}

							if(!targets.contains(plain_target_name)){
		    		    EEntity_definition target_type = target_parameter.getExtent(null);
								String tar_extent_name  = target_type.getName(null);
								String normalized_name = tar_extent_name.substring(0, 1).toUpperCase() + tar_extent_name.substring(1).toLowerCase();
								String tar_package = getEntityPackage(target_type);
								String etar_type2 = tar_package + "E" + normalized_name;
								String ctar_type2 = tar_package + "C" + normalized_name;
		
								pw.println("\t\t\t" +etar_type2 +" " +plain_target_name +"_inst = (" +etar_type2 +")tar_model.createEntityInstance(" +etar_type2 +".class);");		
//								pw.println("\t\t\tValue " +plain_target_name +" = Value.alloc(" +ctar_type2 +".definition).set(_context, " +plain_target_name +"_inst);");
								targets.add(plain_target_name);
							}
//String gen_target_attr = "KUKU-HAHA";
//							pw.println("\t\t\t" +gen_target_attr +" expr_" +tar_par_name +");"); //  d.setName();


					} else { // no identified_by
						// identified_by present
						// TODO
					}

				} // while - through target parameters 		

			} // if attributes NOT present - constant partition
			
		} // if children NOT null (children include binding header)
		jc.attribute_mappings = null;


/*

			int i=0;  // change into the loop, needed for multiple partitions

			if(children[i] instanceof X_WhereClause){
				pw.println("\t\t\t// WHERE clause");
				tabByIndex(ind, pw); pw.print("\tif(");
				children[i].jjtAccept(visitor, data);
				pw.println("){"); 
				tabByIndex(ind, pw); pw.println("\t\tbinding_inst_extent.addElement(binding_inst);");
				tabByIndex(ind, pw); pw.println("\t}");
				i++; // generate next clause
			}else{
				tabByIndex(ind, pw); pw.println("\tbinding_inst_extent.addElement(binding_inst);");
				//								children[i].jjtAccept(visitor, data);
			}

*/
	
	
/*	
	
			while(ind > 0){
				tabByIndex(ind, pw); pw.println("}");
				ind--;
			}

*/



/*

			//
			// IDENTIFIED_BY expression, classification to eq class
			//
			if(i < children.length){
				if(children[i] instanceof X_IdentifiedByClause){
					pw.println("\t\t// IDENTIFIED_BY clause");
					children[i].jjtAccept(visitor, data);
					i++;
				}
			}
			pw.println("");

*/


/*

			//
			// SELECT part
			//
			// evaluate expression parts for the bindings of the same eq class and set appopriate values
			//
			// TODO: error handling in case of incompatible result of expression with left side of select statement
			// TODO: control by numeric increment, control by iteration over aggregate (
			//
			if(i > 0 && children[i-1] instanceof X_IdentifiedByClause){
				pw.println("\t\t// Evaluating expression parts for the bindings of the same eq class and setting appopriate values");
				pw.println("\t\tIterator iter = alist.iterator();");
				pw.println("\t\tfor(int i = 0; i < alist.size() ; i++) {");
				pw.println("\t\t\tint inst_num = 0;");
				// don't do checking, rely on the size
				pw.println("\t\t\tVector eq_class = (Vector)iter.next();");

				jc.identified_by = true;
			}else{
				pw.println("\t\tfor(int j=0; j < binding_inst_extent.size(); j++){ ");
			}


*/





      // this is handling of MapAttributeDeclarations, a separate loop through the children, as of now



/*


			if (children != null) {
				jc.first_pass = true; // define variables in X_MapAttributeDeclaration in first pass

//				for (int l = i; l < children.length; ++l) {
        // could do also from 1, actually better switch to that, because there are changes about i value, making a loop
				for (int l = 0; l < children.length; ++l) {
	System.out.println("child: " + children[l] + ", partition: " + mp_name + ", is 1st pass: " + jc.first_pass);	
					if (children[l] instanceof X_MapAttributeDeclaration) {
						if (((X_MapAttributeDeclaration)children[l]).partition == mp) { 
							if (first_for_this_partition) {
								((X_MapAttributeDeclaration)children[l]).targets = new HashSet();
								first_for_this_partition = false;
								// is it perhaps the same as jc.first_pass ?
							}
						
							children[l].jjtAccept(visitor, data);
						}
					}
				}
				jc.first_pass = false;
			} // if children not NULL

			pw.println("\t\t}");

*/





// moved into the partition loop
		pw.println("\t\t}");					
		pw.println("\t\treturn tar_model.getInstances(" +etar_type +".class);");
		pw.println("\t}");					


		} // loop through partitions



		// new subtype map implementation ------------------- ends -------------------------------------------------------------
	} else { //  not a subtype map
		

		AMap_partition amp = map_definition.getPartitions(null, null);
		SdaiIterator mpi = amp.createIterator();

		boolean first_for_this_partition = true;
		boolean binding_header_visited_for_this_partition = false;
		
		while (mpi.next()) {
			EMap_partition mp = (EMap_partition)amp.getCurrentMemberObject(mpi);
			jc.partition = mp;
			String mp_name = mp.getName(null);

 	pw.println("// #### in MapDecl, starting next partition: " + mp_name + " #####");

			first_for_this_partition = true;
			mp_from_last_binding_header = null;
			binding_header_visited_for_this_partition = false;
			
			// ...
			// only default partition supported - em-planner doesn't need others
			// ...

			if(mp_name.equalsIgnoreCase("_implicit_partition_")){
				mp_name = "default";
			}

//			pw.println("\tpublic AEntity processPartition_" +mp_name +"(SdaiModel src_model, SdaiModel tar_model, Hashtable target_instances) throws SdaiException {");
			pw.println("\tpublic AEntity processPartition_" +mp_name +"(SdaiModel src_model, SdaiModel tar_model, Hashtable target_instances, SdaiContext _context) throws SdaiException {");

			// FROM part, generate source binding extent
			pw.println("\t// FROM part, generate source binding extent");
			ASource_parameter asp = mp.getSource_parameters(null, null);
// System.out.println("source parameters: " + asp);
			jc.asp = asp; // save reference for src parameters to be used in Identified_by node
			SdaiIterator spi = asp.createIterator();
			int ind=0;
			String add_instances="";

			pw.println("\t\tVector binding_inst_extent = new Vector();");
			pw.println("\t\tVector binding_inst = new Vector();");
			pw.println("\t\tHashtable src_id_map = new Hashtable();");

			
			// if it is a subtype, then we need to get source parameters from supertype, etc
			// let's have a separate handling of subtype maps
    

			while (spi.next()) {
				ind++;
				ESource_parameter sp = (ESource_parameter)asp.getCurrentMemberObject(spi);
				String sp_name = sp.getName(null);

				EEntity_or_view_definition sp_extent = (EEntity_or_view_definition)sp.getExtent(null);
				String sp_extent_name = sp_extent.getName(null);
				String sp_package = getEntityPackage(sp_extent, jc.model); 
				String normalized_name = sp_extent_name.substring(0, 1).toUpperCase() + sp_extent_name.substring(1).toLowerCase();
				String esrc_type = sp_package + "E" + normalized_name;
				String asrc_type = sp_package + "A" + normalized_name;

				pw.println("\t\t" +asrc_type +" a" +ind +"_inst = (" +asrc_type +")src_model.getInstances(" +esrc_type +".class);");
			}

			spi.beginning();
			ind=0;
			while (spi.next()) {
				ind++;
				ESource_parameter sp = (ESource_parameter)asp.getCurrentMemberObject(spi);
				String sp_name = sp.getName(null);

				EEntity_or_view_definition sp_extent = (EEntity_or_view_definition)sp.getExtent(null);
				String sp_extent_name = sp_extent.getName(null);
				String sp_package = getEntityPackage(sp_extent, jc.model); 
				String normalized_name = sp_extent_name.substring(0, 1).toUpperCase() + sp_extent_name.substring(1).toLowerCase();
				String esrc_type = sp_package + "E" + normalized_name;
				String csrc_type = sp_package + "C" + normalized_name;
				String asrc_type = sp_package + "A" + normalized_name;

				//						tabByIndex(ind, pw); pw.println(asrc_type +" a" +ind +"_inst = (" +asrc_type +")src_model.getInstances(" +esrc_type +".class);");
				pw.println("");
				tabByIndex(ind, pw); pw.println("for (int i" +ind +" = 1; i" +ind +" < a" +ind +"_inst.getMemberCount()+1; i" +ind +"++) {");
				tabByIndex(ind, pw); pw.println("\tValue " +sp_name +" = Value.alloc(" +csrc_type +".definition).set(_context, a" +ind +"_inst.getByIndex(i" +ind +"));");
				add_instances = tabByIndexToString(asp.getMemberCount(), pw, add_instances); add_instances += "\tbinding_inst.addElement(" +sp_name +");\n";
				if(asp.getMemberCount() < 2) { tabByIndex(ind, pw); pw.println("\tbinding_inst.addElement(\"\");"); }
				if(ind == asp.getMemberCount()){ 
					tabByIndex(ind, pw); pw.println("\tbinding_inst = new Vector();");
					pw.println(add_instances);
				}
				tabByIndex(ind, pw); pw.println("\tsrc_id_map.put(\""+ sp_name +"\", new Integer(" +(ind-1) +"));");
			}

			//
			// WHERE part 
			//
			

			if (children != null) {

		  boolean attributes_present = false;
	
			 			
		  for (int i = 0; i < children.length; i++) {
 	pw.println("// #### in MapDecl, starting next child: " + children[i] + " #######");
				// possible children: 
				// X_BindingHeader (includes inside optional clauses: From clause, local declarations, WHERE clause, Identified_by clause, Ordered_by clause)
				// X_MapAttributeDeclaration
				// etc

				// so move actions for all this stuff into the children nodes (BindingHeader etc)

// System.out.println("current child: " + children[i] + ", current partition: " + mp.getName(null));

				if (children[i] instanceof X_BindingHeader) {
// System.out.println("current child - BindingHeader, partition: " + ((X_BindingHeader)children[i]).partition.getName(null) + ", current partition: " + mp.getName(null));
					jc.identified_by = false;
					if (((X_BindingHeader)children[i]).partition == mp) {
						jc.ind = ind;
						
						mp_from_last_binding_header = ((X_BindingHeader)children[i]).partition;
 // System.out.println("Oh YES, invoking!");
 	pw.println("// #### in MapDecl - going into BindingHeader #####");
						children[i].jjtAccept(visitor, data);
						binding_header_visited_for_this_partition = true;
 	pw.println("// #### in MapDecl - back from BindingHeader #####");
					} else {
						mp_from_last_binding_header = null;
						binding_header_visited_for_this_partition = false;
					}
				} else
				if (children[i] instanceof X_MapAttributeDeclaration) {
 	pw.println("// #### in MapDecl - going into MapAttributeDeclaration #####");
					
					attributes_present = true;
					jc.first_pass = true; // define variables in X_MapAttributeDeclaration in first pass
					jc.first_pass = first_for_this_partition;



	// System.out.println("child: " + children[i] + ", partition: " + mp_name + ", is 1st pass: " + jc.first_pass);	
						if (((X_MapAttributeDeclaration)children[i]).partition == mp) { 
							if (first_for_this_partition) {
								if (jc.identified_by == false) {
									pw.println("\t\tfor(int j=0; j < binding_inst_extent.size(); j++){ ");
								}
								((X_MapAttributeDeclaration)children[i]).targets = new HashSet();
								first_for_this_partition = false;
								// is it perhaps the same as jc.first_pass ?
							}
						
							children[i].jjtAccept(visitor, data);
						}
//						jc.first_pass = false;
 	pw.println("// #### in MapDecl - back from MapAttributeDeclaration #####");

				} else // MapAttributeDeclaration
				if (children[i] instanceof X_EntityInstantiationLoop) {
 	pw.println("// #### in MapDecl - going into EntityInstantiationLoop #####");
					attributes_present = true;
					children[i].jjtAccept(visitor, data);
 	pw.println("// #### in MapDecl - back from EntityInstantiationLoop #####");
				} else { // X_EntityInstantiationLoop
					// this might be map with RETURN expression
 	pw.println("// #### in MapDecl - going into everything else - possibly, RETURN expression #####");
					
					attributes_present = true;

					// this might help
					if (mp_from_last_binding_header == mp) {

					children[i].jjtAccept(visitor, data);

 	pw.println("// #### in MapDecl - back from everything else - possibly, RETURN expression - continuing with the branch, though #####");
					// what if IDENTIFIED_BY present - TODO
					pw.println("\t\tfor(int j=0; j < binding_inst_extent.size(); j++){ ");


					Vector src_par_names = new Vector();
			
					SdaiIterator spi2 = jc.asp.createIterator();
					while (spi2.next()) {
						ESource_parameter sp = (ESource_parameter)jc.asp.getCurrentMemberObject(spi2);
						String sp_name = sp.getName(null);
						src_par_names.add(sp_name);
					}


					// if(jc.first_pass){
					for(int si=0; si < src_par_names.size(); si++){
						jc.first_pass = false;
						pw.println("\t\tint src_par_id_" +(String)src_par_names.get(si) +";");
						pw.println("\t\t\tValue " +(String)src_par_names.get(si) +";");
					} // for
					// }

					for(int si=0; si < src_par_names.size(); si++){
						pw.println("\t\t\tsrc_par_id_" +(String)src_par_names.get(si)+" = ((Integer)src_id_map.get(\""+(String)src_par_names.get(si)+"\")).intValue();");
						pw.println("\t\t\t" +(String)src_par_names.get(si) +" = (Value)((Vector)binding_inst_extent.elementAt(j)).elementAt(src_par_id_" +(String)src_par_names.get(si) +");");
					} // for

pw.println("// ### THIS IS generated_java ####: " + jc.generated_java + ";");
					pw.println("" + jc.generated_java + ";");
					jc.generated_java = "";


			} // if partition ends here, hopefully unnecessary stuff no longer generated
 	pw.println("// #### in MapDecl - everything else - possibly, RETURN expression - branch ended #####");

				}

			} // for
			if (!attributes_present) {
 	pw.println("// #### in MapDecl - empty SELECT, it seems, starting #####");
// pw.println("// ### DON't GO THERE!!! ####");
				// better move from attribute, but temporarily, duplicate these things here
			
				// this whole thing is inside the loop through partitions, so it is ok
				// we way need to handle the following cases:
				// 1. no source parameters (no FROM clause) - just generate 1 instance
				// 2. 1 source parameter
				// 3. multiple source parameters
				// 4. if source parameters, also WHERE clause present or not
				// 5 IDENTIFIED_BY clause present or not
				

				ATarget_parameter atp2 = map_definition.getTarget_parameters(null, null);
				jsdai.lang.SdaiIterator tpi2 = atp2.createIterator();
				while (tpi2.next()) {
					ETarget_parameter tp2 = (ETarget_parameter)atp2.getCurrentMemberObject(tpi2);

				  if (jc.identified_by == false) {
							pw.println("\t\tfor(int j=0; j < binding_inst_extent.size(); j++){ ");

							jsdai.SExtended_dictionary_schema.ETarget_parameter target_parameter = tp2;
							String tar_par_name = target_parameter.getName(null);
							String plain_target_name = tar_par_name;
							Vector src_par_names = new Vector();
							Vector src_par_orders = new Vector();
							// target instance should be created only once - when first encountered target_parameter 
							HashSet targets = new HashSet();  // this is stupid, it does not do that, just so that it is compileable
					
							SdaiIterator spi2 = jc.asp.createIterator();
							while (spi2.next()) {
								ESource_parameter sp2 = (ESource_parameter)jc.asp.getCurrentMemberObject(spi2);
								String sp_name2 = sp2.getName(null);
								src_par_names.add(sp_name2);
							}


							tar_par_name += "_" +jc.target_par_count;
							jc.target_par_count++;
//							pw.println("\t\t\tValue expr_" +tar_par_name +" = Value.alloc().unset();");

//							pw.println("\t\t\tValue last_expr_" +tar_par_name +" = Value.alloc().unset();");
							pw.println("");

							for(int si=0; si < src_par_names.size(); si++){
	//							pw.println("\t\tint src_par_id_" +(String)src_par_names.get(si) +";");
	//							pw.println("\t\t\tValue " +(String)src_par_names.get(si) +";");
								first_for_this_partition = false;

							}

							if(!targets.contains(plain_target_name)){
		    		    EEntity_definition target_type = target_parameter.getExtent(null);
								String tar_extent_name  = target_type.getName(null);
								String normalized_name = tar_extent_name.substring(0, 1).toUpperCase() + tar_extent_name.substring(1).toLowerCase();
								String tar_package = getEntityPackage(target_type);
								String etar_type2 = tar_package + "E" + normalized_name;
								String ctar_type2 = tar_package + "C" + normalized_name;
		
								pw.println("\t\t\t" +etar_type2 +" " +plain_target_name +"_inst = (" +etar_type2 +")tar_model.createEntityInstance(" +etar_type2 +".class);");		
//								pw.println("\t\t\tValue " +plain_target_name +" = Value.alloc(" +ctar_type2 +".definition).set(_context, " +plain_target_name +"_inst);");
								targets.add(plain_target_name);
							}
//String gen_target_attr = "KUKU-HAHA";
//							pw.println("\t\t\t" +gen_target_attr +" expr_" +tar_par_name +");"); //  d.setName();


					} else { // no identified_by
						// identified_by present
						// TODO
					}

				} // while - through target parameters 		

 	pw.println("// #### in MapDecl - empty SELECT, it seems, ending #####");


			} // if attributes NOT present - constant partition
			
		} // if children NOT null (children include binding header)


/*

			int i=0;  // change into the loop, needed for multiple partitions

			if(children[i] instanceof X_WhereClause){
				pw.println("\t\t\t// WHERE clause");
				tabByIndex(ind, pw); pw.print("\tif(");
				children[i].jjtAccept(visitor, data);
				pw.println("){"); 
				tabByIndex(ind, pw); pw.println("\t\tbinding_inst_extent.addElement(binding_inst);");
				tabByIndex(ind, pw); pw.println("\t}");
				i++; // generate next clause
			}else{
				tabByIndex(ind, pw); pw.println("\tbinding_inst_extent.addElement(binding_inst);");
				//								children[i].jjtAccept(visitor, data);
			}

*/
	
	
/*	
	
			while(ind > 0){
				tabByIndex(ind, pw); pw.println("}");
				ind--;
			}

*/



/*

			//
			// IDENTIFIED_BY expression, classification to eq class
			//
			if(i < children.length){
				if(children[i] instanceof X_IdentifiedByClause){
					pw.println("\t\t// IDENTIFIED_BY clause");
					children[i].jjtAccept(visitor, data);
					i++;
				}
			}
			pw.println("");

*/


/*

			//
			// SELECT part
			//
			// evaluate expression parts for the bindings of the same eq class and set appopriate values
			//
			// TODO: error handling in case of incompatible result of expression with left side of select statement
			// TODO: control by numeric increment, control by iteration over aggregate (
			//
			if(i > 0 && children[i-1] instanceof X_IdentifiedByClause){
				pw.println("\t\t// Evaluating expression parts for the bindings of the same eq class and setting appopriate values");
				pw.println("\t\tIterator iter = alist.iterator();");
				pw.println("\t\tfor(int i = 0; i < alist.size() ; i++) {");
				pw.println("\t\t\tint inst_num = 0;");
				// don't do checking, rely on the size
				pw.println("\t\t\tVector eq_class = (Vector)iter.next();");

				jc.identified_by = true;
			}else{
				pw.println("\t\tfor(int j=0; j < binding_inst_extent.size(); j++){ ");
			}


*/





      // this is handling of MapAttributeDeclarations, a separate loop through the children, as of now



/*


			if (children != null) {
				jc.first_pass = true; // define variables in X_MapAttributeDeclaration in first pass

//				for (int l = i; l < children.length; ++l) {
        // could do also from 1, actually better switch to that, because there are changes about i value, making a loop
				for (int l = 0; l < children.length; ++l) {
	System.out.println("child: " + children[l] + ", partition: " + mp_name + ", is 1st pass: " + jc.first_pass);	
					if (children[l] instanceof X_MapAttributeDeclaration) {
						if (((X_MapAttributeDeclaration)children[l]).partition == mp) { 
							if (first_for_this_partition) {
								((X_MapAttributeDeclaration)children[l]).targets = new HashSet();
								first_for_this_partition = false;
								// is it perhaps the same as jc.first_pass ?
							}
						
							children[l].jjtAccept(visitor, data);
						}
					}
				}
				jc.first_pass = false;
			} // if children not NULL

			pw.println("\t\t}");

*/





// moved into the partition loop
		pw.println("\t\t}");					
		pw.println("\t\treturn tar_model.getInstances(" +etar_type +".class);");
		pw.println("\t}");					

		// generate here partition method for handling map calls
		// differences:
		// 1. source extent formed from argument
		// 2. created instance returned instead of all target instances in the model
		// 3. need to handle partial binding calls - different version again, probably

			if (atp.getMemberCount() < 2) {


		first_for_this_partition = true;

//################## start - for map call
      jc.single_map_call = true;
 			jc.current_target = null;
 
//			pw.println("\tpublic AEntity processPartition_" +mp_name +"(SdaiModel src_model, SdaiModel tar_model, Hashtable target_instances) throws SdaiException {");
			pw.println("\t static Value callPartition_" + mp_name +"(SdaiModel src_model, SdaiModel tar_model, Hashtable target_instances, SdaiContext _context, Value input) throws SdaiException {");
//			pw.println("\t\tValue result = null;");
			pw.println("\t\tValue result = Value.alloc().unset();");
			

			// FROM part, generate source binding extent
			pw.println("\t// FROM part, generate source binding extent");
//already			ASource_parameter asp = mp.getSource_parameters(null, null);
			asp = mp.getSource_parameters(null, null);
// System.out.println("source parameters: " + asp);
			jc.asp = asp; // save reference for src parameters to be used in Identified_by node
//already			SdaiIterator spi = asp.createIterator();
			spi = asp.createIterator();
//already			int ind=0;
			ind = 0;
//already			String add_instances="";
			add_instances = "";

			pw.println("\t\tVector binding_inst_extent = new Vector();");
			pw.println("\t\tVector binding_inst = new Vector();");
			pw.println("\t\tHashtable src_id_map = new Hashtable();");

			
			// if it is a subtype, then we need to get source parameters from supertype, etc
			// let's have a separate handling of subtype maps
    

    // do not need all the instances in extent, input parameter instead 


		if (hasIdentify_by()) {
     
			while (spi.next()) {
				ind++;
				ESource_parameter sp = (ESource_parameter)asp.getCurrentMemberObject(spi);
				String sp_name = sp.getName(null);

				EEntity_or_view_definition sp_extent = (EEntity_or_view_definition)sp.getExtent(null);
				String sp_extent_name = sp_extent.getName(null);
				String sp_package = getEntityPackage(sp_extent, jc.model); 
				String normalized_name = sp_extent_name.substring(0, 1).toUpperCase() + sp_extent_name.substring(1).toLowerCase();
				String esrc_type = sp_package + "E" + normalized_name;
				String asrc_type = sp_package + "A" + normalized_name;

				pw.println("\t\t" +asrc_type +" a" +ind +"_inst = (" +asrc_type +")src_model.getInstances(" +esrc_type +".class);");
			}
			
		} // has identified_by

			// could be optimized more for a single source instance
			// but also for partial binding calls needed
			
			spi.beginning();
			ind=0;
			while (spi.next()) {
				ind++;
				ESource_parameter sp = (ESource_parameter)asp.getCurrentMemberObject(spi);
				String sp_name = sp.getName(null);

				EEntity_or_view_definition sp_extent = (EEntity_or_view_definition)sp.getExtent(null);
				String sp_extent_name = sp_extent.getName(null);
				String sp_package = getEntityPackage(sp_extent, jc.model); 
				String normalized_name = sp_extent_name.substring(0, 1).toUpperCase() + sp_extent_name.substring(1).toLowerCase();
				String esrc_type = sp_package + "E" + normalized_name;
				String csrc_type = sp_package + "C" + normalized_name;
				String asrc_type = sp_package + "A" + normalized_name;

				//						tabByIndex(ind, pw); pw.println(asrc_type +" a" +ind +"_inst = (" +asrc_type +")src_model.getInstances(" +esrc_type +".class);");
				pw.println("");

				if (hasIdentify_by()) {
					tabByIndex(ind, pw); pw.println("for (int i" +ind +" = 1; i" +ind +" < a" +ind +"_inst.getMemberCount()+1; i" +ind +"++) {");
					tabByIndex(ind, pw); pw.println("\tValue " +sp_name +" = Value.alloc(" +csrc_type +".definition).set(_context, a" +ind +"_inst.getByIndex(i" +ind +"));");
				} else {
					tabByIndex(ind, pw); pw.println("for (int i" +ind +" = 1; i" +ind +" < 2; i" +ind +"++) {");
					tabByIndex(ind, pw); pw.println("\tValue " +sp_name +" = input;");
				}
				add_instances = tabByIndexToString(asp.getMemberCount(), pw, add_instances); add_instances += "\tbinding_inst.addElement(" +sp_name +");\n";
				if(asp.getMemberCount() < 2) { tabByIndex(ind, pw); pw.println("\tbinding_inst.addElement(\"\");"); }
				if(ind == asp.getMemberCount()){ 
					tabByIndex(ind, pw); pw.println("\tbinding_inst = new Vector();");
					pw.println(add_instances);
				}
				tabByIndex(ind, pw); pw.println("\tsrc_id_map.put(\""+ sp_name +"\", new Integer(" +(ind-1) +"));");
			}

			//
			// WHERE part 
			//
			

			

			if (children != null) {

		  boolean attributes_present = false;
			 			
		  for (int i = 0; i < children.length; i++) {
				// possible children: 
				// X_BindingHeader (includes inside optional clauses: From clause, local declarations, WHERE clause, Identified_by clause, Ordered_by clause)
				// X_MapAttributeDeclaration
				// etc

				// so move actions for all this stuff into the children nodes (BindingHeader etc)

// System.out.println("current child: " + children[i] + ", current partition: " + mp.getName(null));

				if (children[i] instanceof X_BindingHeader) {
// System.out.println("current child - BindingHeader, partition: " + ((X_BindingHeader)children[i]).partition.getName(null) + ", current partition: " + mp.getName(null));
					jc.identified_by = false;
					if (((X_BindingHeader)children[i]).partition == mp) {
						jc.ind = ind;
						mp_from_last_binding_header = ((X_BindingHeader)children[i]).partition;
 // System.out.println("Oh YES, invoking!");
 	pw.println("// INVOKING -------- YES YES YES - TO BindingHeader!!!!!!!!!!!!!!");
						children[i].jjtAccept(visitor, data);
					} else {
						mp_from_last_binding_header = null;
					}
				} else
				if (children[i] instanceof X_MapAttributeDeclaration) {
					
					attributes_present = true;
					jc.first_pass = true; // define variables in X_MapAttributeDeclaration in first pass
					jc.first_pass = first_for_this_partition;



	// System.out.println("child: " + children[i] + ", partition: " + mp_name + ", is 1st pass: " + jc.first_pass);	
						if (((X_MapAttributeDeclaration)children[i]).partition == mp) { 
							if (first_for_this_partition) {
								if (jc.identified_by == false) {
									pw.println("\t\tfor(int j=0; j < binding_inst_extent.size(); j++){ ");
								}
								((X_MapAttributeDeclaration)children[i]).targets = new HashSet();
								first_for_this_partition = false;
								// is it perhaps the same as jc.first_pass ?
							}
						
							children[i].jjtAccept(visitor, data);
						}
//						jc.first_pass = false;

				} else // MapAttributeDeclaration
				if (children[i] instanceof X_EntityInstantiationLoop) {
					attributes_present = true;
					children[i].jjtAccept(visitor, data);
				} else { // X_EntityInstantiationLoop

					// this might be map with RETURN expression

//				String normalized_name = tar_extent_name.substring(0, 1).toUpperCase() + tar_extent_name.substring(1).toLowerCase();
//				String tar_package = getEntityPackage(target_type);
//				String etar_type = tar_package + "E" + normalized_name;
				jc.x_target_type = etar_type;



					
					attributes_present = true;

			// this might help
			if (mp_from_last_binding_header == mp) {


					children[i].jjtAccept(visitor, data);
					// what if IDENTIFIED_BY present - TODO
					pw.println("\t\tfor(int j=0; j < binding_inst_extent.size(); j++){ ");


					Vector src_par_names = new Vector();
			
					SdaiIterator spi2 = jc.asp.createIterator();
					while (spi2.next()) {
						ESource_parameter sp = (ESource_parameter)jc.asp.getCurrentMemberObject(spi2);
						String sp_name = sp.getName(null);
						src_par_names.add(sp_name);
					}


					// if(jc.first_pass){
					for(int si=0; si < src_par_names.size(); si++){
						jc.first_pass = false;
						pw.println("\t\tint src_par_id_" +(String)src_par_names.get(si) +";");
						pw.println("\t\t\tValue " +(String)src_par_names.get(si) +";");
					} // for
					// }

					for(int si=0; si < src_par_names.size(); si++){
						pw.println("\t\t\tsrc_par_id_" +(String)src_par_names.get(si)+" = ((Integer)src_id_map.get(\""+(String)src_par_names.get(si)+"\")).intValue();");
						pw.println("\t\t\t" +(String)src_par_names.get(si) +" = (Value)((Vector)binding_inst_extent.elementAt(j)).elementAt(src_par_id_" +(String)src_par_names.get(si) +");");
					} // for

					pw.println("result = " + jc.generated_java  + ";");
					jc.generated_java = "";


					} // if partition

				}


			} // for
			if (!attributes_present) {
				// better move from attribute, but temporarily, duplicate these things here
			
				// this whole thing is inside the loop through partitions, so it is ok
				// we way need to handle the following cases:
				// 1. no source parameters (no FROM clause) - just generate 1 instance
				// 2. 1 source parameter
				// 3. multiple source parameters
				// 4. if source parameters, also WHERE clause present or not
				// 5 IDENTIFIED_BY clause present or not
				

				ATarget_parameter atp2 = map_definition.getTarget_parameters(null, null);
				jsdai.lang.SdaiIterator tpi2 = atp2.createIterator();
				while (tpi2.next()) {
					ETarget_parameter tp2 = (ETarget_parameter)atp2.getCurrentMemberObject(tpi2);

				  if (jc.identified_by == false) {
							pw.println("\t\tfor(int j=0; j < binding_inst_extent.size(); j++){ ");

							jsdai.SExtended_dictionary_schema.ETarget_parameter target_parameter = tp2;
							String tar_par_name = target_parameter.getName(null);
							String plain_target_name = tar_par_name;
							Vector src_par_names = new Vector();
							Vector src_par_orders = new Vector();
							// target instance should be created only once - when first encountered target_parameter 
							HashSet targets = new HashSet();  // this is stupid, it does not do that, just so that it is compileable
					
							SdaiIterator spi2 = jc.asp.createIterator();
							while (spi2.next()) {
								ESource_parameter sp2 = (ESource_parameter)jc.asp.getCurrentMemberObject(spi2);
								String sp_name2 = sp2.getName(null);
								src_par_names.add(sp_name2);
							}


							tar_par_name += "_" +jc.target_par_count;
							jc.target_par_count++;

							pw.println("");

							for(int si=0; si < src_par_names.size(); si++){
								first_for_this_partition = false;

							}

							if(!targets.contains(plain_target_name)){
		    		    EEntity_definition target_type = target_parameter.getExtent(null);
								String tar_extent_name  = target_type.getName(null);
								String normalized_name = tar_extent_name.substring(0, 1).toUpperCase() + tar_extent_name.substring(1).toLowerCase();
								String tar_package = getEntityPackage(target_type);
								String etar_type2 = tar_package + "E" + normalized_name;
								String ctar_type2 = tar_package + "C" + normalized_name;
		
								pw.println("\t\t\t" +etar_type2 +" " +plain_target_name +"_inst = (" +etar_type2 +")tar_model.createEntityInstance(" +etar_type2 +".class);");		
        				pw.println("\t\t\tValue " +plain_target_name +" = Value.alloc(" +ctar_type2 +".definition).set(_context, " +plain_target_name +"_inst);");
								pw.println("\t\t\tresult = " + plain_target_name + ";");
								jc.x_target_type = etar_type2;

								targets.add(plain_target_name);
							}


					} else { // no identified_by
						// identified_by present
						// TODO
					}

				} // while - through target parameters 		

			} // if attributes NOT present - constant partition
			
		} // if children NOT null (children include binding header)


		pw.println("\t\t}");					
//		pw.println("\t\treturn result;");

//		pw.println("\t\treturn Value.replaceByAlreadyExistingAndDelete(_context, result, " + jc.x_target_type + ".class, tar_model);");
		pw.println("\t\treturn result.replaceByAlreadyExistingAndDelete(_context, " + jc.x_target_type + ".class, tar_model);");
		pw.println("\t}");					

    jc.single_map_call = false;
    jc.current_target = null;

		} else {
			// if more than 1 target
			
			jsdai.lang.SdaiIterator tpi3 = atp.createIterator();

			while (tpi3.next()) {
				
			ETarget_parameter tp3 = (ETarget_parameter)atp.getCurrentMemberObject(tpi3); //here
			String tp3_name = tp3.getName(null);




		first_for_this_partition = true;

//################## start - for map call
      jc.single_map_call = true;
 			jc.current_target = tp3;
//			jc.target = tp;

 
//			pw.println("\tpublic AEntity processPartition_" +mp_name +"(SdaiModel src_model, SdaiModel tar_model, Hashtable target_instances) throws SdaiException {");
			pw.println("\t static Value callTarget_"+ tp3_name +"Partition_" + mp_name +"(SdaiModel src_model, SdaiModel tar_model, Hashtable target_instances, SdaiContext _context, Value input) throws SdaiException {");
//			pw.println("\t\tValue result = null;");
			pw.println("\t\tValue result = Value.alloc().unset();");

			// FROM part, generate source binding extent
			pw.println("\t// FROM part, generate source binding extent");
//already			ASource_parameter asp = mp.getSource_parameters(null, null);
			asp = mp.getSource_parameters(null, null);
// System.out.println("source parameters: " + asp);
			jc.asp = asp; // save reference for src parameters to be used in Identified_by node
//already			SdaiIterator spi = asp.createIterator();
			spi = asp.createIterator();
//already			int ind=0;
			ind = 0;
//already			String add_instances="";
			add_instances = "";

			pw.println("\t\tVector binding_inst_extent = new Vector();");
			pw.println("\t\tVector binding_inst = new Vector();");
			pw.println("\t\tHashtable src_id_map = new Hashtable();");

			
			// if it is a subtype, then we need to get source parameters from supertype, etc
			// let's have a separate handling of subtype maps
    

    // do not need all the instances in extent, input parameter instead 

		if (hasIdentify_by()) {

     
			while (spi.next()) {
				ind++;
				ESource_parameter sp = (ESource_parameter)asp.getCurrentMemberObject(spi);
				String sp_name = sp.getName(null);

				EEntity_or_view_definition sp_extent = (EEntity_or_view_definition)sp.getExtent(null);
				String sp_extent_name = sp_extent.getName(null);
				String sp_package = getEntityPackage(sp_extent, jc.model); 
				String normalized_name = sp_extent_name.substring(0, 1).toUpperCase() + sp_extent_name.substring(1).toLowerCase();
				String esrc_type = sp_package + "E" + normalized_name;
				String asrc_type = sp_package + "A" + normalized_name;

				pw.println("\t\t" +asrc_type +" a" +ind +"_inst = (" +asrc_type +")src_model.getInstances(" +esrc_type +".class);");
			}
		} // has identified_by

			// could be optimized more for a single source instance
			// but also for partial binding calls needed
			
			spi.beginning();
			ind=0;
			while (spi.next()) {
				ind++;
				ESource_parameter sp = (ESource_parameter)asp.getCurrentMemberObject(spi);
				String sp_name = sp.getName(null);

				EEntity_or_view_definition sp_extent = (EEntity_or_view_definition)sp.getExtent(null);
				String sp_extent_name = sp_extent.getName(null);
				String sp_package = getEntityPackage(sp_extent, jc.model); 
				String normalized_name = sp_extent_name.substring(0, 1).toUpperCase() + sp_extent_name.substring(1).toLowerCase();
				String esrc_type = sp_package + "E" + normalized_name;
				String csrc_type = sp_package + "C" + normalized_name;
				String asrc_type = sp_package + "A" + normalized_name;

				//						tabByIndex(ind, pw); pw.println(asrc_type +" a" +ind +"_inst = (" +asrc_type +")src_model.getInstances(" +esrc_type +".class);");
				pw.println("");
				if (hasIdentify_by()) {
					tabByIndex(ind, pw); pw.println("for (int i" +ind +" = 1; i" +ind +" < a" +ind +"_inst.getMemberCount()+1; i" +ind +"++) {");
					tabByIndex(ind, pw); pw.println("\tValue " +sp_name +" = Value.alloc(" +csrc_type +".definition).set(_context, a" +ind +"_inst.getByIndex(i" +ind +"));");
				} else {
					tabByIndex(ind, pw); pw.println("for (int i" +ind +" = 1; i" +ind +" < 2; i" +ind +"++) {");
					tabByIndex(ind, pw); pw.println("\tValue " +sp_name +" = input;");
				}
				add_instances = tabByIndexToString(asp.getMemberCount(), pw, add_instances); add_instances += "\tbinding_inst.addElement(" +sp_name +");\n";
				if(asp.getMemberCount() < 2) { tabByIndex(ind, pw); pw.println("\tbinding_inst.addElement(\"\");"); }
				if(ind == asp.getMemberCount()){ 
					tabByIndex(ind, pw); pw.println("\tbinding_inst = new Vector();");
					pw.println(add_instances);
				}
				tabByIndex(ind, pw); pw.println("\tsrc_id_map.put(\""+ sp_name +"\", new Integer(" +(ind-1) +"));");
			}

			//
			// WHERE part 
			//
			

			if (children != null) {

		  boolean attributes_present = false;
			 			
		  for (int i = 0; i < children.length; i++) {
				// possible children: 
				// X_BindingHeader (includes inside optional clauses: From clause, local declarations, WHERE clause, Identified_by clause, Ordered_by clause)
				// X_MapAttributeDeclaration
				// etc

				// so move actions for all this stuff into the children nodes (BindingHeader etc)

// System.out.println("current child: " + children[i] + ", current partition: " + mp.getName(null));

				if (children[i] instanceof X_BindingHeader) {
// System.out.println("current child - BindingHeader, partition: " + ((X_BindingHeader)children[i]).partition.getName(null) + ", current partition: " + mp.getName(null));
					jc.identified_by = false;
					if (((X_BindingHeader)children[i]).partition == mp) {
						jc.ind = ind;
						mp_from_last_binding_header = ((X_BindingHeader)children[i]).partition;
 // System.out.println("Oh YES, invoking!");
 	pw.println("// INVOKING -------- YES YES YES - TO BindingHeader!!!!!!!!!!!!!!");
						children[i].jjtAccept(visitor, data);
					} else {
				  	mp_from_last_binding_header = null;
				  }
				} else
				if (children[i] instanceof X_MapAttributeDeclaration) {
					
					attributes_present = true;
					jc.first_pass = true; // define variables in X_MapAttributeDeclaration in first pass
					jc.first_pass = first_for_this_partition;



	// System.out.println("child: " + children[i] + ", partition: " + mp_name + ", is 1st pass: " + jc.first_pass);	
						if (((X_MapAttributeDeclaration)children[i]).partition == mp) { 
							if (first_for_this_partition) {
								if (jc.identified_by == false) {
									pw.println("\t\tfor(int j=0; j < binding_inst_extent.size(); j++){ ");
								}
								((X_MapAttributeDeclaration)children[i]).targets = new HashSet();
								first_for_this_partition = false;
								// is it perhaps the same as jc.first_pass ?
							}
						
							children[i].jjtAccept(visitor, data);
						}
//						jc.first_pass = false;

				} else // MapAttributeDeclaration
				if (children[i] instanceof X_EntityInstantiationLoop) {
					attributes_present = true;
					children[i].jjtAccept(visitor, data);
				} // X_EntityInstantiationLoop
				else {
					// might be return statement
					attributes_present = true;
					if (mp_from_last_binding_header == mp) {
				  
				  //TODO  this is empty so far!
				  
				  }
				}

			} // for
			if (!attributes_present) {
				// better move from attribute, but temporarily, duplicate these things here
			
				// this whole thing is inside the loop through partitions, so it is ok
				// we way need to handle the following cases:
				// 1. no source parameters (no FROM clause) - just generate 1 instance
				// 2. 1 source parameter
				// 3. multiple source parameters
				// 4. if source parameters, also WHERE clause present or not
				// 5 IDENTIFIED_BY clause present or not
				

				ATarget_parameter atp2 = map_definition.getTarget_parameters(null, null);
				jsdai.lang.SdaiIterator tpi2 = atp2.createIterator();
				while (tpi2.next()) {
					ETarget_parameter tp2 = (ETarget_parameter)atp2.getCurrentMemberObject(tpi2);

				  if (jc.identified_by == false) {
							pw.println("\t\tfor(int j=0; j < binding_inst_extent.size(); j++){ ");

							jsdai.SExtended_dictionary_schema.ETarget_parameter target_parameter = tp2;
							String tar_par_name = target_parameter.getName(null);
							String plain_target_name = tar_par_name;
							Vector src_par_names = new Vector();
							Vector src_par_orders = new Vector();
							// target instance should be created only once - when first encountered target_parameter 
							HashSet targets = new HashSet();  // this is stupid, it does not do that, just so that it is compileable
					
							SdaiIterator spi2 = jc.asp.createIterator();
							while (spi2.next()) {
								ESource_parameter sp2 = (ESource_parameter)jc.asp.getCurrentMemberObject(spi2);
								String sp_name2 = sp2.getName(null);
								src_par_names.add(sp_name2);
							}


							tar_par_name += "_" +jc.target_par_count;
							jc.target_par_count++;

							pw.println("");

							for(int si=0; si < src_par_names.size(); si++){
								first_for_this_partition = false;

							}

							if(!targets.contains(plain_target_name)){
		    		    EEntity_definition target_type = target_parameter.getExtent(null);
								String tar_extent_name  = target_type.getName(null);
								String normalized_name = tar_extent_name.substring(0, 1).toUpperCase() + tar_extent_name.substring(1).toLowerCase();
								String tar_package = getEntityPackage(target_type);
								String etar_type2 = tar_package + "E" + normalized_name;
								String ctar_type2 = tar_package + "C" + normalized_name;
		
								pw.println("\t\t\t" +etar_type2 +" " +plain_target_name +"_inst = (" +etar_type2 +")tar_model.createEntityInstance(" +etar_type2 +".class);");		
        				pw.println("\t\t\tValue " +plain_target_name +" = Value.alloc(" +ctar_type2 +".definition).set(_context, " +plain_target_name +"_inst);");
								pw.println("\t\t\tresult = " + plain_target_name + ";");
								jc.x_target_type = etar_type2;

								targets.add(plain_target_name);
							}


					} else { // no identified_by
						// identified_by present
						// TODO
					}

				} // while - through target parameters 		

			} // if attributes NOT present - constant partition
			
		} // if children NOT null (children include binding header)


		pw.println("\t\t}");					
//		pw.println("\t\treturn result;");

//		pw.println("\t\treturn Value.replaceByAlreadyExistingAndDelete(_context, result, " + jc.x_target_type + ".class, tar_model);");
		pw.println("\t\treturn result.replaceByAlreadyExistingAndDelete(_context, " + jc.x_target_type + ".class, tar_model);");
		pw.println("\t}");					

    jc.single_map_call = false;
    jc.target = null;
    jc.current_target = null;

		} // while - through the targets
			
		} // if more than one target parameter


//################ end - for map call

 	pw.println("// #### in MapDecl, ending current partition: " + mp_name + " #####");

		
		} // loop through partitions



	} // if not subtype


		//     if (children != null) {

		//       for (int l = i; l < children.length; ++l) {
		// 				if(children[l] instanceof X_WhereClause && (jc.entity == map_definition)){
		// 						children[l].jjtAccept(visitor, data);
		// 						pw.println(jc.generated_java);
		// 				}else{
		// 						children[l].jjtAccept(visitor, data);
		// 				}
		//       }

		//     }



		// FIXME: temporary
		// moving up into the partitino loop 
//		pw.println("\t\treturn tar_model.getInstances(" +etar_type +".class);");
//		pw.println("\t}");					


		} else { // generate execute in java backend instead of here


		AMap_partition amp = map_definition.getPartitions(null, null);
		SdaiIterator mpi = amp.createIterator();

		boolean first_for_this_partition = true;
		while (mpi.next()) {
			EMap_partition mp = (EMap_partition)amp.getCurrentMemberObject(mpi);
			jc.partition = mp;
			String mp_name = mp.getName(null);
			first_for_this_partition = true;
			// ...
			// only default partition supported - em-planner doesn't need others
			// ...

			if(mp_name.equalsIgnoreCase("_implicit_partition_")){
				mp_name = "default";
			}

////


/*

//			pw.println("\tpublic AEntity processPartition_" +mp_name +"(SdaiModel src_model, SdaiModel tar_model, Hashtable target_instances) throws SdaiException {");
			pw.println("\tpublic AEntity processPartition_" +mp_name +"(SdaiModel src_model, SdaiModel tar_model, Hashtable target_instances, SdaiContext _context) throws SdaiException {");

			// FROM part, generate source binding extent
			pw.println("\t// FROM part, generate source binding extent");
*/
			ASource_parameter asp = mp.getSource_parameters(null, null);
//System.out.println("source parameters: " + asp);
			jc.asp = asp; // save reference for src parameters to be used in Identified_by node
//			SdaiIterator spi = asp.createIterator();

			int ind=0;
/*
			String add_instances="";

			pw.println("\t\tVector binding_inst_extent = new Vector();");
			pw.println("\t\tVector binding_inst = new Vector();");
			pw.println("\t\tHashtable src_id_map = new Hashtable();");

*/

///////


//				ASource_parameter asp = mp.getSource_parameters(null, null);
	
//				 jc.asp = asp; // save reference for src parameters to be used in Identified_by node



if (children != null) {

		  boolean attributes_present = false;
			 			
		  for (int i = 0; i < children.length; i++) {
				// possible children: 
				// X_BindingHeader (includes inside optional clauses: From clause, local declarations, WHERE clause, Identified_by clause, Ordered_by clause)
				// X_MapAttributeDeclaration
				// etc

				// so move actions for all this stuff into the children nodes (BindingHeader etc)

// System.out.println("current child: " + children[i] + ", current partition: " + mp.getName(null));

				if (children[i] instanceof X_BindingHeader) {
// System.out.println("current child - BindingHeader, partition: " + ((X_BindingHeader)children[i]).partition.getName(null));
					jc.identified_by = false;
					if (((X_BindingHeader)children[i]).partition == mp) {
						jc.ind = ind;
// System.out.println("Oh YES, invoking!");
// 	pw.println("// INVOKING -------- YES YES YES - TO BindingHeader!!!!!!!!!!!!!!");


						children[i].jjtAccept(visitor, data);
					}
				} else
				if (children[i] instanceof X_MapAttributeDeclaration) {
					
					attributes_present = true;
					jc.first_pass = true; // define variables in X_MapAttributeDeclaration in first pass
					jc.first_pass = first_for_this_partition;



	// System.out.println("child: " + children[i] + ", partition: " + mp_name + ", is 1st pass: " + jc.first_pass);	
						if (((X_MapAttributeDeclaration)children[i]).partition == mp) { 
							if (first_for_this_partition) {
								if (jc.identified_by == false) {
									pw.println("\t\tfor(int j=0; j < binding_inst_extent.size(); j++){ ");
								}
								((X_MapAttributeDeclaration)children[i]).targets = new HashSet();
								first_for_this_partition = false;
								// is it perhaps the same as jc.first_pass ?
							}
						
							children[i].jjtAccept(visitor, data);
						}
//						jc.first_pass = false;

				} // MapAttributeDeclaration


			} // for
			if (!attributes_present) {
				// better move from attribute, but temporarily, duplicate these things here
			
				// this whole thing is inside the loop through partitions, so it is ok
				// we way need to handle the following cases:
				// 1. no source parameters (no FROM clause) - just generate 1 instance
				// 2. 1 source parameter
				// 3. multiple source parameters
				// 4. if source parameters, also WHERE clause present or not
				// 5 IDENTIFIED_BY clause present or not
				

				ATarget_parameter atp2 = map_definition.getTarget_parameters(null, null);
				jsdai.lang.SdaiIterator tpi2 = atp2.createIterator();
				while (tpi2.next()) {
					ETarget_parameter tp2 = (ETarget_parameter)atp2.getCurrentMemberObject(tpi2);

				  if (jc.identified_by == false) {
							pw.println("\t\tfor(int j=0; j < binding_inst_extent.size(); j++){ ");

							jsdai.SExtended_dictionary_schema.ETarget_parameter target_parameter = tp2;
							String tar_par_name = target_parameter.getName(null);
							String plain_target_name = tar_par_name;
							Vector src_par_names = new Vector();
							Vector src_par_orders = new Vector();
							// target instance should be created only once - when first encountered target_parameter 
							HashSet targets = new HashSet();  // this is stupid, it does not do that, just so that it is compileable
					
							SdaiIterator spi2 = jc.asp.createIterator();
							while (spi2.next()) {
								ESource_parameter sp2 = (ESource_parameter)jc.asp.getCurrentMemberObject(spi2);
								String sp_name2 = sp2.getName(null);
								src_par_names.add(sp_name2);
							}


							tar_par_name += "_" +jc.target_par_count;
							jc.target_par_count++;
//							pw.println("\t\t\tValue expr_" +tar_par_name +" = Value.alloc().unset();");

//							pw.println("\t\t\tValue last_expr_" +tar_par_name +" = Value.alloc().unset();");
							pw.println("");

							for(int si=0; si < src_par_names.size(); si++){
	//							pw.println("\t\tint src_par_id_" +(String)src_par_names.get(si) +";");
	//							pw.println("\t\t\tValue " +(String)src_par_names.get(si) +";");
								first_for_this_partition = false;

							}

							if(!targets.contains(plain_target_name)){
		    		    EEntity_definition target_type = target_parameter.getExtent(null);
								String tar_extent_name  = target_type.getName(null);
								String normalized_name = tar_extent_name.substring(0, 1).toUpperCase() + tar_extent_name.substring(1).toLowerCase();
								String tar_package = getEntityPackage(target_type);
								String etar_type2 = tar_package + "E" + normalized_name;
								String ctar_type2 = tar_package + "C" + normalized_name;
		
								pw.println("\t\t\t" +etar_type2 +" " +plain_target_name +"_inst = (" +etar_type2 +")tar_model.createEntityInstance(" +etar_type2 +".class);");		
//								pw.println("\t\t\tValue " +plain_target_name +" = Value.alloc(" +ctar_type2 +".definition).set(_context, " +plain_target_name +"_inst);");
								targets.add(plain_target_name);
							}
//String gen_target_attr = "KUKU-HAHA";
//							pw.println("\t\t\t" +gen_target_attr +" expr_" +tar_par_name +");"); //  d.setName();


					} else { // no identified_by
						// identified_by present
						// TODO
					}

				} // while - through target parameters 		

			} // if attributes NOT present - constant partition
			
		}

} // through partitions 
			
		}	// generate execute in java backend instead of here	


			// ------------------ the main case ends here, non-supertype (and with supertypes main subtype, if not moved to a separate later) ---------------
			break;
		
		} // switch primary - secondary cases

    return data;
  }

  String getEntityPackage(EEntity_or_view_definition eds, SdaiModel current_model)
		throws jsdai.lang.SdaiException {

    // return an empty string if ed and eds in the same schema, and the package of eds otherwise
    String entity_package = "";
    SdaiModel entity_model = eds.findEntityInstanceSdaiModel();
		
    if (entity_model != current_model) {
      String entity_schema_name = getSchema_definitionFromModel(entity_model).getName(null);

      if (entity_schema_name.equalsIgnoreCase("Sdai_dictionary_schema")) {
        entity_package = "jsdai.dictionary.";
      } else {
        entity_package = "jsdai.S" + entity_schema_name.substring(0, 1).toUpperCase() + entity_schema_name.substring(1).toLowerCase() + ".";
      }
    }

    return entity_package;
  }

  String getEntityPackage(EEntity_definition eds) throws SdaiException {
    // return an empty string if ed and eds in the same schema, and the package of eds otherwise
    String entity_package = "";
    SdaiModel entity_model = eds.findEntityInstanceSdaiModel();

    //    if (entity_model != current_model) {
    String entity_schema_name = getSchema_definitionFromModel(entity_model).getName(null);

    if (entity_schema_name.equalsIgnoreCase("Sdai_dictionary_schema")) {
      entity_package = "jsdai.dictionary.";
    } else {
      entity_package = "jsdai.S" + entity_schema_name.substring(0, 1).toUpperCase() + 
                       entity_schema_name.substring(1).toLowerCase() + ".";
    }

    //    }
    return entity_package;
  }


  EGeneric_schema_definition getSchema_definitionFromModel(SdaiModel sm) throws jsdai.lang.SdaiException {
    jsdai.lang.Aggregate ia = sm.getEntityExtentInstances(EGeneric_schema_definition.class);
    jsdai.lang.SdaiIterator iter_inst = ia.createIterator();

    while (iter_inst.next()) {
      EGeneric_schema_definition inst = ( EGeneric_schema_definition )ia.getCurrentMemberObject(iter_inst);
      return inst;
    }

    return null;
	  }

	void tabByIndex(int ind, PrintWriter pw){
		pw.print("\t");
		for(int tt=0; tt < ind; tt++) pw.print("\t");
	}

	String  tabByIndexToString(int ind, PrintWriter pw, String st){
		st += "\t";
		for(int tt=0; tt < ind; tt++)	st += "\t";
		return st;
	}


	  jsdai.SExtended_dictionary_schema.EMap_definition getRootSupertypeMap( jsdai.SExtended_dictionary_schema.EMap_definition map_definition) throws SdaiException {
			jsdai.SExtended_dictionary_schema.EMap_definition md = null;
			if (map_definition.testSuper_type(null)) {
				md = getRootSupertypeMap(map_definition.getSuper_type(null));
			} else {
				md = map_definition;
			}
			return md;
		}


	boolean hasIdentify_by() {
		for (int i = 0; i < children.length; i++) {
			if (children[i] instanceof X_BindingHeader) {
				X_BindingHeader child = (X_BindingHeader)children[i];
// System.out.println("child: " + child + ", its children: "  + child.children);
        if (child.children == null) {
        	break;
        }
				for (int j = 0; j < child.children.length; j++) {
					if (child.children[j] instanceof X_IdentifiedByClause) {
						return true;
					}
				}
				break;
			}
		}
		return false;
	}			


}

/*
  // addons

	if(isIdentifiedBy){
	// remove repetative bindings from alist
			
	}
	return tar_model.getInstances(jsdai.STar.EDepartment.class);
		
*/
