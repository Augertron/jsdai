/*
 * $Id$
 *
 * JSDAI(TM), a way to implement STEP, ISO 10303
 * Copyright (C) 1997-2008, LKSoftWare GmbH, Germany
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License
 * version 3 as published by the Free Software Foundation (AGPL v3).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * JSDAI is a registered trademark of LKSoftWare GmbH, Germany
 * This software is also available under commercial licenses.
 * See also http://www.jsdai.net/
 */

/* Generated By:JJTree: Do not edit this line. X_EntityInstantiationLoop.java */

package jsdai.expressCompiler;

import java.util.*;
import java.io.*;
import jsdai.lang.*;
import jsdai.SExtended_dictionary_schema.*;

public class X_EntityInstantiationLoop extends SimpleNode {

	String variable_id;
	int variable_uid;
 
  jsdai.SExtended_dictionary_schema.EMap_definition map_definition;
	jsdai.SExtended_dictionary_schema.EMap_or_view_partition partition;

	static boolean flag_generate_execute_in_nodes = true;

  public X_EntityInstantiationLoop(int id) {
    super(id);
  }

  public X_EntityInstantiationLoop(Compiler2 p, int id) {
    super(p, id);
  }


  /** Accept the visitor. **/
  public Object jjtAccept(Compiler2Visitor visitor, Object data) throws jsdai.lang.SdaiException {
    return visitor.visit(this, data);
  }

  public Object childrenAccept_own(Compiler2Visitor visitor, Object data) throws jsdai.lang.SdaiException {
    JavaClass jc = ( JavaClass )data;
		PrintWriter pw = jc.pw;

		switch (jc.secondary) {
			case 0: // ----------------------------------------------------------------------------------
			default:


			pw.println("// variable_id: " + variable_id);
			pw.println("// variable_uid: " + variable_uid);

			// variable_id: _implicit_1_
			// variable_uid: 1






				break; // case 0, default ------------------------------------------------------------
		} // switch jc.secondary

    return data;
  }

// =====================================================================================================================




  public Object childrenAccept(Compiler2Visitor visitor, Object data) throws jsdai.lang.SdaiException {


    JavaClass jc = ( JavaClass )data;
		PrintWriter pw = jc.pw;

	 switch (jc.secondary) {
		case 1: // invoking on supertype map, print the WHERE rule expression only, in BindingHeader or directly if not present (not root)

			jc.asp = jc.parent.asp;

			// ----------------- case 1 begins ------------------------------------------------------------------------------
//			System.out.println("MapDecl node - secondary case 1");
//			pw.println("// ############# secondary case 1");
			if (children != null) {
			  for (int i = 0; i < children.length; i++) {
					if (children[i] instanceof X_BindingHeader) { // that has to be the root supertype

						jc.identified_by = false;

						if (((X_BindingHeader)children[i]).partition == jc.reference) {

	//						jc.ind = ind;
 //System.out.println("IN SUPERTYPE - Oh YES, invoking!");
// 	pw.println("// INVOKING IN SUPERTYPE -------- YES YES YES - TO BindingHeader!!!!!!!!!!!!!!");
							children[i].jjtAccept(visitor, data);
					}



					} else
					if (children[i] instanceof X_SubtypeBindingHeader) { // that has to be intermediate supertype, itself a subtype, explicit partitions present


						jc.identified_by = false;

							String child_partition_name = ((X_SubtypeBindingHeader)children[i]).partition.getName(null);
							String required_partition_name = ((EMap_partition)jc.reference).getName(null);
	
//						if (((X_SubtypeBindingHeader)children[i]).partition == jc.reference) {
							
	//				pw.println("("); 
							if (child_partition_name.equalsIgnoreCase(required_partition_name)) {
//					pw.println(")"); 

//					pw.println("&&"); 


							children[i].jjtAccept(visitor, data);
					}




					} else
					if 	(children[i] instanceof X_WhereClause) { 
						// intermediate sub-supertypes, need to test, especially with multiple partitions

						jc.identified_by = false;
						children[i].jjtAccept(visitor, data);

					}
				}
			}
			// ----------------- case 1 ends --------------------------------------------------------------------------------
			break;
		case 2: // invoking on supertype map, processing map attributes

//			System.out.println("MapDecl node - secondary case 2");
			pw.println("// ############# secondary case 2 - interested in MapAttributeDeclaration");

			// need source parameters from the root
			jc.asp = jc.parent.asp;
			jc.attribute_mappings = jc.parent.attribute_mappings;
			

			if (children != null) {
				boolean first_for_this_partition = true;
			  for (int i = 0; i < children.length; i++) {

//-------------begin


				if (children[i] instanceof X_MapAttributeDeclaration) {


//			System.out.println("MapDecl node - secondary case 2 - MapAttributeDeclaration found: " + children[i]);
//			pw.println("// ############# secondary case 2 - MapAttributeDeclaration found: " + children[i]);

					
//2?					attributes_present = true;
					// define variables in X_MapAttributeDeclaration in first pass
//					jc.first_pass = true; 
					jc.first_pass = false; 
//2?					jc.first_pass = first_for_this_partition;



	// System.out.println("child: " + children[i] + ", partition: " + mp_name + ", is 1st pass: " + jc.first_pass);	



//					EMap_partition child_partition = ((X_MapAttributeDeclaration)children[i]).partition;
					EMap_partition child_partition = (EMap_partition)((X_MapAttributeDeclaration)children[i]).partition;
					String child_partition_name = null;
					if (child_partition == null) {
						child_partition_name = "default";
					} else {
						child_partition_name = child_partition.getName(null);
					}
					if(child_partition_name.equalsIgnoreCase("_implicit_partition_")){
						child_partition_name = "default";
					}
					String current_partition_name = ((EMap_partition)jc.reference).getName(null);
					if(current_partition_name.equalsIgnoreCase("_implicit_partition_")){
						current_partition_name = "default";
					}


//			System.out.println("// ############# secondary case 2 - child partition: " + child_partition_name + ", current partition: " + ((EMap_partition)jc.reference).getName(null));
//			pw.println("// ############# secondary case 2 - child partition: " + child_partition_name + ", current partition: " + ((EMap_partition)jc.reference).getName(null));



//if (true) {
//						if (((X_MapAttributeDeclaration)children[i]).partition == mp) { 


//						if (((X_MapAttributeDeclaration)children[i]).partition.getName(null).equalsIgnoreCase(((EMap_partition)jc.reference).getName(null))) { 
//						if (child_partition_name.equalsIgnoreCase(((EMap_partition)jc.reference).getName(null))) { 
						if (child_partition_name.equalsIgnoreCase(current_partition_name)) { 
							if (first_for_this_partition) {
//2								if (jc.identified_by == false) {
//2									pw.println("\t\tfor(int j=0; j < binding_inst_extent.size(); j++){ ");
//2								}
//2								((X_MapAttributeDeclaration)children[i]).targets = new HashSet();
								first_for_this_partition = false;
								// is it perhaps the same as jc.first_pass ?
							}
						
							children[i].jjtAccept(visitor, data);
						}
//						jc.first_pass = false;

				} // MapAttributeDeclaration


//-------------end



				} // for - children
			} // children not NULL

			jc.parent.attribute_mappings = jc.attribute_mappings;
			break;
		case 0:
		default:
			// ------------------ the main case begins here, non-supertype (and with supertypes main subtype, if not moved to a separate later) ---------------
//			System.out.println("MapDecl node - primary case 0");
			pw.println("// ############# primary case 0");


		if (flag_generate_execute_in_nodes) {
	


		String map_name = map_definition.getName(null);
		String map_class_name = "M" + map_name.substring(0, 1).toUpperCase() + map_name.substring(1).toLowerCase();

//		pw.println("public class " + map_class_name + " {");
		
//		pw.println("");
//		pw.println("\t/*---------------------- methods to execute maps for each target --------------------*/");
		// ? for each target or everything together?
//		pw.println("");

		ATarget_parameter atp = map_definition.getTarget_parameters(null, null);

		jsdai.lang.SdaiIterator tpi = atp.createIterator();

		String etar_type = "" ;
		
		// need other approach for execute handling
		//		while (tpi.next()) {
		tpi.next();
		ETarget_parameter tp = (ETarget_parameter)atp.getCurrentMemberObject(tpi); //here
			String tp_name = tp.getName(null);
			EEntity_definition tp_extent = tp.getExtent(null);
			String tp_extent_name = tp_extent.getName(null);
			String atar_type = getEntityPackage(tp_extent, jc.model) + "A" + tp_extent_name.substring(0, 1).toUpperCase() + tp_extent_name.substring(1).toLowerCase();
			etar_type = getEntityPackage(tp_extent, jc.model) + "E" + tp_extent_name.substring(0, 1).toUpperCase() + tp_extent_name.substring(1).toLowerCase();
//RR			pw.println("\tpublic " +atar_type +" execute(SdaiContext _context) throws SdaiException {");
//			pw.println("\tpublic void  execute(SdaiContext _context) throws SdaiException {");
			//TODO: select appopriate partition: suspended, because em-planer doesn't use partitions - always call default partition. 
//			pw.println("");
//			pw.println("\t\tSdaiModel src_model = _context.src_model;");
//			pw.println("\t\tSdaiModel tar_model = _context.tar_model;");
//			pw.println("\t\tVector instances_partition_default;");
//RR			pw.println("\t\tHashtable target_instances;");
//			pw.println("\t\tHashtable target_instances = new Hashtable();");
//			pw.println("");
//			pw.println("\t\t_context.mapHashTable = new Hashtable();");
//			pw.println("");


// let's remove for now
/*
			pw.println("\t\t" +atar_type +" aggr_" +tp_name +"= new "+atar_type +"();");
			pw.println("");
			pw.println("\t\tif ( _context.mapHashTable.contains(this)){");
			pw.println("\t\t\ttarget_instances = (Hashtable)_context.mapHashTable.get(this);");
			pw.println("\t\t\tIterator it = target_instances.entrySet().iterator();");
			pw.println("\t\t\twhile(it.hasNext()){");
			pw.println("\t\t\t\taggr_" +tp_name +".addUnordered(it.next(), null);");
			pw.println("\t\t\t}");
			pw.println("\t\t\treturn aggr_" +tp_name +";");
			pw.println("\t\t}else{");
			pw.println("\t\t\ttarget_instances = new Hashtable();");
			pw.println("\t\t\t_context.mapHashTable.put(this, target_instances);");
			pw.println("\t\t}");

*/

//			pw.println("\t\tSystem.out.println(\"processing partition..\");");
//			pw.println("\t\tSystem.out.println(\"processing partitions..\");");
//			pw.println("\t\taggr_" +tp_name +" = (" +atar_type +")processPartition_default(src_model, tar_model, target_instances);");

//			pw.println("\t\taggr_" +tp_name +" = (" +atar_type +")processPartition_default(src_model, tar_model, target_instances, _context);");


			AMap_partition am_p = map_definition.getPartitions(null, null);
			SdaiIterator mp_i = am_p.createIterator();
			while (mp_i.next()) {
				EMap_partition m_p = (EMap_partition)am_p.getCurrentMemberObject(mp_i);
				String m_p_name = m_p.getName(null);
// System.out.println("partition: " + m_p_name);				
//pw.println("\t//---partition: " + m_p_name);
				if(m_p_name.equalsIgnoreCase("_implicit_partition_")){
					m_p_name = "default";
				}
//RR				pw.println("\t\taggr_" +tp_name +" = (" +atar_type +")processPartition_" + m_p_name + "(src_model, tar_model, target_instances, _context);");
//				pw.println("\t\tprocessPartition_" + m_p_name + "(src_model, tar_model, target_instances, _context);");
			}


//RR			pw.println("\t\treturn aggr_" +tp_name +";");
//			pw.println("\t\treturn;");
//			pw.println("\t}");
			//		}

//		pw.println("");
//		pw.println("\t/*---------------------- methods to execute maps for each partition --------------------*/");
//		pw.println("");


	if (false) {
//	if (map_definition.testSuper_type(null)) {

		// ------------------ begin -----------------------------------------------------------


	 



		// get the first non-subtype map, because only partitions of this map contain source parameters

	  jsdai.SExtended_dictionary_schema.EMap_definition map_definition_root;
		
		map_definition_root = getRootSupertypeMap(map_definition);


//    jsdai.expressCompiler.JavaBackend.generateJavaExpressionSecondary(pw, map_definition_root, jc.sd, null, jc.model, 1, jc, null);



		AMap_partition ampr = map_definition_root.getPartitions(null, null);
		SdaiIterator mpri = ampr.createIterator();


		AMap_partition amp = map_definition.getPartitions(null, null);
		SdaiIterator mpi = amp.createIterator();

		boolean first_for_this_partition = true;
		while (mpri.next()) {
			EMap_partition mp = (EMap_partition)ampr.getCurrentMemberObject(mpri);
			jc.partition = mp;
			String mp_name = mp.getName(null);
			first_for_this_partition = true;
			// ...
			// only default partition supported - em-planner doesn't need others
			// ...

			if(mp_name.equalsIgnoreCase("_implicit_partition_")){
				mp_name = "default";
			}

//			pw.println("\tpublic AEntity processPartition_" +mp_name +"(SdaiModel src_model, SdaiModel tar_model, Hashtable target_instances) throws SdaiException {");
			pw.println("\tpublic AEntity processPartition_" +mp_name +"(SdaiModel src_model, SdaiModel tar_model, Hashtable target_instances, SdaiContext _context) throws SdaiException {");

			// FROM part, generate source binding extent
			pw.println("\t// FROM part, generate source binding extent");
			ASource_parameter asp = mp.getSource_parameters(null, null);
System.out.println("source parameters: " + asp);
			jc.asp = asp; // save reference for src parameters to be used in Identified_by node
			SdaiIterator spi = asp.createIterator();
			int ind=0;
			String add_instances="";

			pw.println("\t\tVector binding_inst_extent = new Vector();");
			pw.println("\t\tVector binding_inst = new Vector();");
			pw.println("\t\tHashtable src_id_map = new Hashtable();");

			
			// if it is a subtype, then we need to get source parameters from supertype, etc
			// let's have a separate handling of subtype maps
    

			while (spi.next()) {
				ind++;
				ESource_parameter sp = (ESource_parameter)asp.getCurrentMemberObject(spi);
				String sp_name = sp.getName(null);

				EEntity_or_view_definition sp_extent = (EEntity_or_view_definition)sp.getExtent(null);
				String sp_extent_name = sp_extent.getName(null);
				String sp_package = getEntityPackage(sp_extent, jc.model); 
				String normalized_name = sp_extent_name.substring(0, 1).toUpperCase() + sp_extent_name.substring(1).toLowerCase();
				String esrc_type = sp_package + "E" + normalized_name;
				String asrc_type = sp_package + "A" + normalized_name;

				pw.println("\t\t" +asrc_type +" a" +ind +"_inst = (" +asrc_type +")src_model.getInstances(" +esrc_type +".class);");
			}

			spi.beginning();
			ind=0;
			while (spi.next()) {
				ind++;
				ESource_parameter sp = (ESource_parameter)asp.getCurrentMemberObject(spi);
				String sp_name = sp.getName(null);

				EEntity_or_view_definition sp_extent = (EEntity_or_view_definition)sp.getExtent(null);
				String sp_extent_name = sp_extent.getName(null);
				String sp_package = getEntityPackage(sp_extent, jc.model); 
				String normalized_name = sp_extent_name.substring(0, 1).toUpperCase() + sp_extent_name.substring(1).toLowerCase();
				String esrc_type = sp_package + "E" + normalized_name;
				String csrc_type = sp_package + "C" + normalized_name;
				String asrc_type = sp_package + "A" + normalized_name;

				//						tabByIndex(ind, pw); pw.println(asrc_type +" a" +ind +"_inst = (" +asrc_type +")src_model.getInstances(" +esrc_type +".class);");
				pw.println("");
				tabByIndex(ind, pw); pw.println("for (int i" +ind +" = 1; i" +ind +" < a" +ind +"_inst.getMemberCount()+1; i" +ind +"++) {");
				tabByIndex(ind, pw); pw.println("\tValue " +sp_name +" = Value.alloc(" +csrc_type +".definition).set(_context, a" +ind +"_inst.getByIndex(i" +ind +"));");
				add_instances = tabByIndexToString(asp.getMemberCount(), pw, add_instances); add_instances += "\tbinding_inst.addElement(" +sp_name +");\n";
				if(asp.getMemberCount() < 2) { tabByIndex(ind, pw); pw.println("\tbinding_inst.addElement(\"\");"); }
				if(ind == asp.getMemberCount()){ 
					tabByIndex(ind, pw); pw.println("\tbinding_inst = new Vector();");
					pw.println(add_instances);
				}
				tabByIndex(ind, pw); pw.println("\tsrc_id_map.put(\""+ sp_name +"\", new Integer(" +(ind-1) +"));");
			}

			//
			// WHERE part 
			//
			

			if (children != null) {

		  boolean attributes_present = false;
			 			
		  for (int i = 0; i < children.length; i++) {
				// possible children: 
				// X_BindingHeader (includes inside optional clauses: From clause, local declarations, WHERE clause, Identified_by clause, Ordered_by clause)
				// X_MapAttributeDeclaration
				// etc

				// so move actions for all this stuff into the children nodes (BindingHeader etc)

// System.out.println("current child: " + children[i] + ", current partition: " + mp.getName(null));

				if (children[i] instanceof X_BindingHeader) {
// System.out.println("current child - BindingHeader, partition: " + ((X_BindingHeader)children[i]).partition.getName(null));
					jc.identified_by = false;
					if (((X_BindingHeader)children[i]).partition == mp) {
						jc.ind = ind;
// System.out.println("Oh YES, invoking!");
// 	pw.println("// INVOKING -------- YES YES YES - TO BindingHeader!!!!!!!!!!!!!!");
						children[i].jjtAccept(visitor, data);
					}
				} else
				if (children[i] instanceof X_MapAttributeDeclaration) {
					
					attributes_present = true;
					jc.first_pass = true; // define variables in X_MapAttributeDeclaration in first pass
					jc.first_pass = first_for_this_partition;



	// System.out.println("child: " + children[i] + ", partition: " + mp_name + ", is 1st pass: " + jc.first_pass);	
						if (((X_MapAttributeDeclaration)children[i]).partition == mp) { 
							if (first_for_this_partition) {
								if (jc.identified_by == false) {
									pw.println("\t\tfor(int j=0; j < binding_inst_extent.size(); j++){ ");
								}
								((X_MapAttributeDeclaration)children[i]).targets = new HashSet();
								first_for_this_partition = false;
								// is it perhaps the same as jc.first_pass ?
							}
						
							children[i].jjtAccept(visitor, data);
						}
//						jc.first_pass = false;

				}
//				} else // MapAttributeDeclaration
//				if (children[i] instanceof X_EntityInstantiationLoop) {
//					attributes_present = true;
//				} // X_EntityInstantiationLoop

			} // for
			if (!attributes_present) {
				// better move from attribute, but temporarily, duplicate these things here
			
				// this whole thing is inside the loop through partitions, so it is ok
				// we way need to handle the following cases:
				// 1. no source parameters (no FROM clause) - just generate 1 instance
				// 2. 1 source parameter
				// 3. multiple source parameters
				// 4. if source parameters, also WHERE clause present or not
				// 5 IDENTIFIED_BY clause present or not
				

				ATarget_parameter atp2 = map_definition.getTarget_parameters(null, null);
				jsdai.lang.SdaiIterator tpi2 = atp2.createIterator();
				while (tpi2.next()) {
					ETarget_parameter tp2 = (ETarget_parameter)atp2.getCurrentMemberObject(tpi2);

				  if (jc.identified_by == false) {
							pw.println("\t\tfor(int j=0; j < binding_inst_extent.size(); j++){ ");

							jsdai.SExtended_dictionary_schema.ETarget_parameter target_parameter = tp2;
							String tar_par_name = target_parameter.getName(null);
							String plain_target_name = tar_par_name;
							Vector src_par_names = new Vector();
							Vector src_par_orders = new Vector();
							// target instance should be created only once - when first encountered target_parameter 
							HashSet targets = new HashSet();  // this is stupid, it does not do that, just so that it is compileable
					
							SdaiIterator spi2 = jc.asp.createIterator();
							while (spi2.next()) {
								ESource_parameter sp2 = (ESource_parameter)jc.asp.getCurrentMemberObject(spi2);
								String sp_name2 = sp2.getName(null);
								src_par_names.add(sp_name2);
							}


							tar_par_name += "_" +jc.target_par_count;
							jc.target_par_count++;
//							pw.println("\t\t\tValue expr_" +tar_par_name +" = Value.alloc().unset();");

//							pw.println("\t\t\tValue last_expr_" +tar_par_name +" = Value.alloc().unset();");
							pw.println("");

							for(int si=0; si < src_par_names.size(); si++){
	//							pw.println("\t\tint src_par_id_" +(String)src_par_names.get(si) +";");
	//							pw.println("\t\t\tValue " +(String)src_par_names.get(si) +";");
								first_for_this_partition = false;

							}

							if(!targets.contains(plain_target_name)){
		    		    EEntity_definition target_type = target_parameter.getExtent(null);
								String tar_extent_name  = target_type.getName(null);
								String normalized_name = tar_extent_name.substring(0, 1).toUpperCase() + tar_extent_name.substring(1).toLowerCase();
								String tar_package = getEntityPackage(target_type);
								String etar_type2 = tar_package + "E" + normalized_name;
								String ctar_type2 = tar_package + "C" + normalized_name;
		
								pw.println("\t\t\t" +etar_type2 +" " +plain_target_name +"_inst = (" +etar_type2 +")tar_model.createEntityInstance(" +etar_type2 +".class);");		
//								pw.println("\t\t\tValue " +plain_target_name +" = Value.alloc(" +ctar_type2 +".definition).set(_context, " +plain_target_name +"_inst);");
								targets.add(plain_target_name);
							}
//String gen_target_attr = "KUKU-HAHA";
//							pw.println("\t\t\t" +gen_target_attr +" expr_" +tar_par_name +");"); //  d.setName();


					} else { // no identified_by
						// identified_by present
						// TODO
					}

				} // while - through target parameters 		

			} // if attributes NOT present - constant partition
			
		} // if children NOT null (children include binding header)


/*

			int i=0;  // change into the loop, needed for multiple partitions

			if(children[i] instanceof X_WhereClause){
				pw.println("\t\t\t// WHERE clause");
				tabByIndex(ind, pw); pw.print("\tif(");
				children[i].jjtAccept(visitor, data);
				pw.println("){"); 
				tabByIndex(ind, pw); pw.println("\t\tbinding_inst_extent.addElement(binding_inst);");
				tabByIndex(ind, pw); pw.println("\t}");
				i++; // generate next clause
			}else{
				tabByIndex(ind, pw); pw.println("\tbinding_inst_extent.addElement(binding_inst);");
				//								children[i].jjtAccept(visitor, data);
			}

*/
	
	
/*	
	
			while(ind > 0){
				tabByIndex(ind, pw); pw.println("}");
				ind--;
			}

*/



/*

			//
			// IDENTIFIED_BY expression, classification to eq class
			//
			if(i < children.length){
				if(children[i] instanceof X_IdentifiedByClause){
					pw.println("\t\t// IDENTIFIED_BY clause");
					children[i].jjtAccept(visitor, data);
					i++;
				}
			}
			pw.println("");

*/


/*

			//
			// SELECT part
			//
			// evaluate expression parts for the bindings of the same eq class and set appopriate values
			//
			// TODO: error handling in case of incompatible result of expression with left side of select statement
			// TODO: control by numeric increment, control by iteration over aggregate (
			//
			if(i > 0 && children[i-1] instanceof X_IdentifiedByClause){
				pw.println("\t\t// Evaluating expression parts for the bindings of the same eq class and setting appopriate values");
				pw.println("\t\tIterator iter = alist.iterator();");
				pw.println("\t\tfor(int i = 0; i < alist.size() ; i++) {");
				pw.println("\t\t\tint inst_num = 0;");
				// don't do checking, rely on the size
				pw.println("\t\t\tVector eq_class = (Vector)iter.next();");

				jc.identified_by = true;
			}else{
				pw.println("\t\tfor(int j=0; j < binding_inst_extent.size(); j++){ ");
			}


*/





      // this is handling of MapAttributeDeclarations, a separate loop through the children, as of now



/*


			if (children != null) {
				jc.first_pass = true; // define variables in X_MapAttributeDeclaration in first pass

//				for (int l = i; l < children.length; ++l) {
        // could do also from 1, actually better switch to that, because there are changes about i value, making a loop
				for (int l = 0; l < children.length; ++l) {
	System.out.println("child: " + children[l] + ", partition: " + mp_name + ", is 1st pass: " + jc.first_pass);	
					if (children[l] instanceof X_MapAttributeDeclaration) {
						if (((X_MapAttributeDeclaration)children[l]).partition == mp) { 
							if (first_for_this_partition) {
								((X_MapAttributeDeclaration)children[l]).targets = new HashSet();
								first_for_this_partition = false;
								// is it perhaps the same as jc.first_pass ?
							}
						
							children[l].jjtAccept(visitor, data);
						}
					}
				}
				jc.first_pass = false;
			} // if children not NULL

			pw.println("\t\t}");

*/





// moved into the partition loop
		pw.println("\t\t}");					
		pw.println("\t\treturn tar_model.getInstances(" +etar_type +".class);");
		pw.println("\t}");					


		} // loop through partitions


		// ------------------ end -------------------------------------------------------------
	} else	
	if (map_definition.testSuper_type(null)) {
		// new subtype map implementation ------------------- begins --------------------------------------------------------


		// FROM clause and source parameters are present only in the partitions of the root supertype, not in any of subtypes
		// so we need to get to the root supertype to get source parameters from there
			

	  jsdai.SExtended_dictionary_schema.EMap_definition map_definition_root;
		map_definition_root = getRootSupertypeMap(map_definition);

//    jsdai.expressCompiler.JavaBackend.generateJavaExpressionSecondary(pw, map_definition_root, jc.sd, null, jc.model, 1, jc, null);

	// may not be needed, we we'll use the root partitions, at least for source parameters, etc
	AMap_partition amp = map_definition.getPartitions(null, null);
	SdaiIterator mpi = amp.createIterator();

		AMap_partition ampr = map_definition_root.getPartitions(null, null);
		SdaiIterator mpri = ampr.createIterator();


		boolean first_for_this_partition = true;
//		while (mpi.next()) {
		while (mpri.next()) {
//			EMap_partition mp = (EMap_partition)amp.getCurrentMemberObject(mpi);
			EMap_partition mp = (EMap_partition)ampr.getCurrentMemberObject(mpri);
			jc.partition = mp;
			String mp_name = mp.getName(null);
			first_for_this_partition = true;
			// ...
			// only default partition supported - em-planner doesn't need others
			// ...

			if(mp_name.equalsIgnoreCase("_implicit_partition_")){
				mp_name = "default";
			}

//			pw.println("\tpublic AEntity processPartition_" +mp_name +"(SdaiModel src_model, SdaiModel tar_model, Hashtable target_instances) throws SdaiException {");
			pw.println("\tpublic AEntity processPartition_" +mp_name +"(SdaiModel src_model, SdaiModel tar_model, Hashtable target_instances, SdaiContext _context) throws SdaiException {");

			// FROM part, generate source binding extent
			pw.println("\t// FROM part, generate source binding extent");

			
			ASource_parameter asp = mp.getSource_parameters(null, null);
System.out.println("source parameters: " + asp);
			jc.asp = asp; // save reference for src parameters to be used in Identified_by node
			SdaiIterator spi = asp.createIterator();
			int ind=0;
			String add_instances="";

			pw.println("\t\tVector binding_inst_extent = new Vector();");
			pw.println("\t\tVector binding_inst = new Vector();");
			pw.println("\t\tHashtable src_id_map = new Hashtable();");

			
			// if it is a subtype, then we need to get source parameters from supertype, etc
			// let's have a separate handling of subtype maps
    

			while (spi.next()) {
				ind++;
				ESource_parameter sp = (ESource_parameter)asp.getCurrentMemberObject(spi);
				String sp_name = sp.getName(null);

				EEntity_or_view_definition sp_extent = (EEntity_or_view_definition)sp.getExtent(null);
				String sp_extent_name = sp_extent.getName(null);
				String sp_package = getEntityPackage(sp_extent, jc.model); 
				String normalized_name = sp_extent_name.substring(0, 1).toUpperCase() + sp_extent_name.substring(1).toLowerCase();
				String esrc_type = sp_package + "E" + normalized_name;
				String asrc_type = sp_package + "A" + normalized_name;

				pw.println("\t\t" +asrc_type +" a" +ind +"_inst = (" +asrc_type +")src_model.getInstances(" +esrc_type +".class);");
			}

			spi.beginning();
			ind=0;
			while (spi.next()) {
				ind++;
				ESource_parameter sp = (ESource_parameter)asp.getCurrentMemberObject(spi);
				String sp_name = sp.getName(null);

				EEntity_or_view_definition sp_extent = (EEntity_or_view_definition)sp.getExtent(null);
				String sp_extent_name = sp_extent.getName(null);
				String sp_package = getEntityPackage(sp_extent, jc.model); 
				String normalized_name = sp_extent_name.substring(0, 1).toUpperCase() + sp_extent_name.substring(1).toLowerCase();
				String esrc_type = sp_package + "E" + normalized_name;
				String csrc_type = sp_package + "C" + normalized_name;
				String asrc_type = sp_package + "A" + normalized_name;

				//						tabByIndex(ind, pw); pw.println(asrc_type +" a" +ind +"_inst = (" +asrc_type +")src_model.getInstances(" +esrc_type +".class);");
				pw.println("");
				tabByIndex(ind, pw); pw.println("for (int i" +ind +" = 1; i" +ind +" < a" +ind +"_inst.getMemberCount()+1; i" +ind +"++) {");
				tabByIndex(ind, pw); pw.println("\tValue " +sp_name +" = Value.alloc(" +csrc_type +".definition).set(_context, a" +ind +"_inst.getByIndex(i" +ind +"));");
				add_instances = tabByIndexToString(asp.getMemberCount(), pw, add_instances); add_instances += "\tbinding_inst.addElement(" +sp_name +");\n";
				if(asp.getMemberCount() < 2) { tabByIndex(ind, pw); pw.println("\tbinding_inst.addElement(\"\");"); }
				if(ind == asp.getMemberCount()){ 
					tabByIndex(ind, pw); pw.println("\tbinding_inst = new Vector();");
					pw.println(add_instances);
				}
				tabByIndex(ind, pw); pw.println("\tsrc_id_map.put(\""+ sp_name +"\", new Integer(" +(ind-1) +"));");
			}

			//
			// WHERE part 
			//
			
			// in subtype map there will not be binding header node, just directly WHERE clause,
			// at least with default implicit partition
			
			

			if (children != null) {

		  boolean attributes_present = false;
			 			
			jc.attribute_mappings = new HashSet();
			 			
			 			
		  for (int i = 0; i < children.length; i++) {
				// possible children: 
				// X_BindingHeader (includes inside optional clauses: From clause, local declarations, WHERE clause, Identified_by clause, Ordered_by clause)
				// X_MapAttributeDeclaration
				// etc

				// so move actions for all this stuff into the children nodes (BindingHeader etc)

// System.out.println("current child: " + children[i] + ", current partition: " + mp.getName(null));

				if (children[i] instanceof X_BindingHeader) {
// System.out.println("current child - BindingHeader, partition: " + ((X_BindingHeader)children[i]).partition.getName(null) + ", current partition: " + mp.getName(null));
					jc.identified_by = false;
					if (((X_BindingHeader)children[i]).partition == mp) {
						jc.ind = ind;
 // System.out.println("Oh YES, invoking!");
 	pw.println("// INVOKING -------- YES YES YES - TO BindingHeader!!!!!!!!!!!!!!");
						children[i].jjtAccept(visitor, data);
					}
				} else
				if (children[i] instanceof X_SubtypeBindingHeader) {
					 // in the main subtype branch (secondary = 0) this should be the same as directly WhereClause node,
					 // currently internal implementation in the node just returns the where clause expression
					 // may have to extend for other things, identified_by not supported yet

					if (((X_SubtypeBindingHeader)children[i]).partition.getName(null).equalsIgnoreCase(mp.getName(null))) {


					tabByIndex(ind, pw); pw.print("\tif(");
//					pw.println("("); 

					jsdai.SExtended_dictionary_schema.EMap_definition md_current = map_definition;
					for (;;) {
						if (md_current.testSuper_type(null)) {
							md_current = md_current.getSuper_type(null);
					pw.println("("); 
			    		jsdai.expressCompiler.JavaBackend.generateJavaExpressionSecondary(pw, md_current, jc.sd, null, jc.model, 1, jc, mp);
					pw.println(")"); 
					pw.println("&&"); 
						} else {
							break;
						}
					}

//					pw.println(")"); 

//					pw.println("&&"); 
					pw.println("("); 
					children[i].jjtAccept(visitor, data);
					pw.println(")"); 
					pw.println("){"); 
					tabByIndex(ind, pw); pw.println("\t\tbinding_inst_extent.addElement(binding_inst); // where clause");
					tabByIndex(ind, pw); pw.println("\t}");
					// i++; // generate next clause
					while(ind > 0){
						tabByIndex(ind, pw); pw.println("}");
						ind--;
					}

				} // if right partition
				
				} else
				if 	(children[i] instanceof X_WhereClause) {
					// after SubtypeBindingHeader node was introduced, WhereClause cannot occur directly, so the code below is obsolete
					// try to put the where rule here then
//---------------start					
					
				pw.println("\t\t\t// WHERE clause");
				tabByIndex(ind, pw); pw.print("\tif(");
				pw.println("("); 

// also add from root types, in this case just from the root, but we need to implement support for longer chains as well					

			jsdai.SExtended_dictionary_schema.EMap_definition md_current = map_definition;
			for (;;) {
				if (md_current.testSuper_type(null)) {
					md_current = md_current.getSuper_type(null);
			    jsdai.expressCompiler.JavaBackend.generateJavaExpressionSecondary(pw, md_current, jc.sd, null, jc.model, 1, jc, mp);
				} else {
					break;
				}
			}

//    jsdai.expressCompiler.JavaBackend.generateJavaExpressionSecondary(pw, map_definition_root, jc.sd, null, jc.model, 1, jc, mp);

//---------------

/*
     do  a loop

			jsdai.SExtended_dictionary_schema.EMap_definition md = null;
			if (map_definition.testSuper_type(null)) {
				md = getRootSupertypeMap(map_definition.getSuper_type(null));
			} else {
				md = map_definition;
			}

*/

//---------------
				pw.println(")"); 

				pw.println("&&"); 
				pw.println("("); 
				children[i].jjtAccept(visitor, data);
				pw.println(")"); 
				pw.println("){"); 
				tabByIndex(ind, pw); pw.println("\t\tbinding_inst_extent.addElement(binding_inst); // where clause");
				tabByIndex(ind, pw); pw.println("\t}");
				// i++; // generate next clause
				while(ind > 0){
					tabByIndex(ind, pw); pw.println("}");
					ind--;
				}




//---------------end					
				} else
				if (children[i] instanceof X_MapAttributeDeclaration) {
					
					attributes_present = true;
					jc.first_pass = true; // define variables in X_MapAttributeDeclaration in first pass
					jc.first_pass = first_for_this_partition;



	// System.out.println("child: " + children[i] + ", partition: " + mp_name + ", is 1st pass: " + jc.first_pass);	

//if (true) {
//						if (((X_MapAttributeDeclaration)children[i]).partition == mp) { 
//						if (((X_MapAttributeDeclaration)children[i]).partition.getName(null).equalsIgnoreCase(mp.getName(null))) { 
// System.out.println("<><>partition: " + ((X_MapAttributeDeclaration)children[i]).partition);

//					EMap_partition child_partition = ((X_MapAttributeDeclaration)children[i]).partition;
					EMap_partition child_partition = (EMap_partition)((X_MapAttributeDeclaration)children[i]).partition;
					String child_partition_name = null;
					if (child_partition == null) {
						child_partition_name = "default";
					} else {
						child_partition_name = child_partition.getName(null);
					}
					if(child_partition_name.equalsIgnoreCase("_implicit_partition_")){
						child_partition_name = "default";
					}
// System.out.println("<><>child partition: " + child_partition_name);

//						if (((X_MapAttributeDeclaration)children[i]).partition.getName(null).equalsIgnoreCase(mp_name) { 
// if (true) {
						if (child_partition_name.equalsIgnoreCase(mp_name)) { 

							if (first_for_this_partition) {
								if (jc.identified_by == false) {
									pw.println("\t\tfor(int j=0; j < binding_inst_extent.size(); j++){ ");
								}
								((X_MapAttributeDeclaration)children[i]).targets = new HashSet();
								first_for_this_partition = false;
								// is it perhaps the same as jc.first_pass ?
							}
						
							children[i].jjtAccept(visitor, data);
						}
//						jc.first_pass = false;

				} // MapAttributeDeclaration


			} // for - children
			// let's take also attributes from supertypes
			
			jsdai.SExtended_dictionary_schema.EMap_definition md_current = map_definition;
			for (;;) {
				if (md_current.testSuper_type(null)) {
					md_current = md_current.getSuper_type(null);
			    jsdai.expressCompiler.JavaBackend.generateJavaExpressionSecondary(pw, md_current, jc.sd, null, jc.model, 2, jc, mp);
				} else {
					break;
				}
			}
			
			
			
			if (!attributes_present) {
				// better move from attribute, but temporarily, duplicate these things here
			
				// this whole thing is inside the loop through partitions, so it is ok
				// we way need to handle the following cases:
				// 1. no source parameters (no FROM clause) - just generate 1 instance
				// 2. 1 source parameter
				// 3. multiple source parameters
				// 4. if source parameters, also WHERE clause present or not
				// 5 IDENTIFIED_BY clause present or not
				

				ATarget_parameter atp2 = map_definition.getTarget_parameters(null, null);
				jsdai.lang.SdaiIterator tpi2 = atp2.createIterator();
				while (tpi2.next()) {
					ETarget_parameter tp2 = (ETarget_parameter)atp2.getCurrentMemberObject(tpi2);

				  if (jc.identified_by == false) {
							pw.println("\t\tfor(int j=0; j < binding_inst_extent.size(); j++){ ");

							jsdai.SExtended_dictionary_schema.ETarget_parameter target_parameter = tp2;
							String tar_par_name = target_parameter.getName(null);
							String plain_target_name = tar_par_name;
							Vector src_par_names = new Vector();
							Vector src_par_orders = new Vector();
							// target instance should be created only once - when first encountered target_parameter 
							HashSet targets = new HashSet();  // this is stupid, it does not do that, just so that it is compileable
					
							SdaiIterator spi2 = jc.asp.createIterator();
							while (spi2.next()) {
								ESource_parameter sp2 = (ESource_parameter)jc.asp.getCurrentMemberObject(spi2);
								String sp_name2 = sp2.getName(null);
								src_par_names.add(sp_name2);
							}


							tar_par_name += "_" +jc.target_par_count;
							jc.target_par_count++;
//							pw.println("\t\t\tValue expr_" +tar_par_name +" = Value.alloc().unset();");

//							pw.println("\t\t\tValue last_expr_" +tar_par_name +" = Value.alloc().unset();");
							pw.println("");

							for(int si=0; si < src_par_names.size(); si++){
	//							pw.println("\t\tint src_par_id_" +(String)src_par_names.get(si) +";");
	//							pw.println("\t\t\tValue " +(String)src_par_names.get(si) +";");
								first_for_this_partition = false;

							}

							if(!targets.contains(plain_target_name)){
		    		    EEntity_definition target_type = target_parameter.getExtent(null);
								String tar_extent_name  = target_type.getName(null);
								String normalized_name = tar_extent_name.substring(0, 1).toUpperCase() + tar_extent_name.substring(1).toLowerCase();
								String tar_package = getEntityPackage(target_type);
								String etar_type2 = tar_package + "E" + normalized_name;
								String ctar_type2 = tar_package + "C" + normalized_name;
		
								pw.println("\t\t\t" +etar_type2 +" " +plain_target_name +"_inst = (" +etar_type2 +")tar_model.createEntityInstance(" +etar_type2 +".class);");		
//								pw.println("\t\t\tValue " +plain_target_name +" = Value.alloc(" +ctar_type2 +".definition).set(_context, " +plain_target_name +"_inst);");
								targets.add(plain_target_name);
							}
//String gen_target_attr = "KUKU-HAHA";
//							pw.println("\t\t\t" +gen_target_attr +" expr_" +tar_par_name +");"); //  d.setName();


					} else { // no identified_by
						// identified_by present
						// TODO
					}

				} // while - through target parameters 		

			} // if attributes NOT present - constant partition
			
		} // if children NOT null (children include binding header)
		jc.attribute_mappings = null;


/*

			int i=0;  // change into the loop, needed for multiple partitions

			if(children[i] instanceof X_WhereClause){
				pw.println("\t\t\t// WHERE clause");
				tabByIndex(ind, pw); pw.print("\tif(");
				children[i].jjtAccept(visitor, data);
				pw.println("){"); 
				tabByIndex(ind, pw); pw.println("\t\tbinding_inst_extent.addElement(binding_inst);");
				tabByIndex(ind, pw); pw.println("\t}");
				i++; // generate next clause
			}else{
				tabByIndex(ind, pw); pw.println("\tbinding_inst_extent.addElement(binding_inst);");
				//								children[i].jjtAccept(visitor, data);
			}

*/
	
	
/*	
	
			while(ind > 0){
				tabByIndex(ind, pw); pw.println("}");
				ind--;
			}

*/



/*

			//
			// IDENTIFIED_BY expression, classification to eq class
			//
			if(i < children.length){
				if(children[i] instanceof X_IdentifiedByClause){
					pw.println("\t\t// IDENTIFIED_BY clause");
					children[i].jjtAccept(visitor, data);
					i++;
				}
			}
			pw.println("");

*/


/*

			//
			// SELECT part
			//
			// evaluate expression parts for the bindings of the same eq class and set appopriate values
			//
			// TODO: error handling in case of incompatible result of expression with left side of select statement
			// TODO: control by numeric increment, control by iteration over aggregate (
			//
			if(i > 0 && children[i-1] instanceof X_IdentifiedByClause){
				pw.println("\t\t// Evaluating expression parts for the bindings of the same eq class and setting appopriate values");
				pw.println("\t\tIterator iter = alist.iterator();");
				pw.println("\t\tfor(int i = 0; i < alist.size() ; i++) {");
				pw.println("\t\t\tint inst_num = 0;");
				// don't do checking, rely on the size
				pw.println("\t\t\tVector eq_class = (Vector)iter.next();");

				jc.identified_by = true;
			}else{
				pw.println("\t\tfor(int j=0; j < binding_inst_extent.size(); j++){ ");
			}


*/





      // this is handling of MapAttributeDeclarations, a separate loop through the children, as of now



/*


			if (children != null) {
				jc.first_pass = true; // define variables in X_MapAttributeDeclaration in first pass

//				for (int l = i; l < children.length; ++l) {
        // could do also from 1, actually better switch to that, because there are changes about i value, making a loop
				for (int l = 0; l < children.length; ++l) {
	System.out.println("child: " + children[l] + ", partition: " + mp_name + ", is 1st pass: " + jc.first_pass);	
					if (children[l] instanceof X_MapAttributeDeclaration) {
						if (((X_MapAttributeDeclaration)children[l]).partition == mp) { 
							if (first_for_this_partition) {
								((X_MapAttributeDeclaration)children[l]).targets = new HashSet();
								first_for_this_partition = false;
								// is it perhaps the same as jc.first_pass ?
							}
						
							children[l].jjtAccept(visitor, data);
						}
					}
				}
				jc.first_pass = false;
			} // if children not NULL

			pw.println("\t\t}");

*/





// moved into the partition loop
		pw.println("\t\t}");					
		pw.println("\t\treturn tar_model.getInstances(" +etar_type +".class);");
		pw.println("\t}");					


		} // loop through partitions



		// new subtype map implementation ------------------- ends -------------------------------------------------------------
	} else { //  not a subtype map
		

		AMap_partition amp = map_definition.getPartitions(null, null);
		SdaiIterator mpi = amp.createIterator();

		boolean first_for_this_partition = true;
		while (mpi.next()) {
			EMap_partition mp = (EMap_partition)amp.getCurrentMemberObject(mpi);
			jc.partition = mp;
			String mp_name = mp.getName(null);
			first_for_this_partition = true;
			// ...
			// only default partition supported - em-planner doesn't need others
			// ...

			if(mp_name.equalsIgnoreCase("_implicit_partition_")){
				mp_name = "default";
			}

//			pw.println("\tpublic AEntity processPartition_" +mp_name +"(SdaiModel src_model, SdaiModel tar_model, Hashtable target_instances) throws SdaiException {");
//			pw.println("\tpublic AEntity processPartition_" +mp_name +"(SdaiModel src_model, SdaiModel tar_model, Hashtable target_instances, SdaiContext _context) throws SdaiException {");

			// FROM part, generate source binding extent
//			pw.println("\t// FROM part, generate source binding extent");
			ASource_parameter asp = mp.getSource_parameters(null, null);
//System.out.println("source parameters: " + asp);
			jc.asp = asp; // save reference for src parameters to be used in Identified_by node
			SdaiIterator spi = asp.createIterator();
			int ind=0;
			String add_instances="";

//			pw.println("\t\tVector binding_inst_extent = new Vector();");
//			pw.println("\t\tVector binding_inst = new Vector();");
//			pw.println("\t\tHashtable src_id_map = new Hashtable();");

			
			// if it is a subtype, then we need to get source parameters from supertype, etc
			// let's have a separate handling of subtype maps
    

			while (spi.next()) {
				ind++;
				ESource_parameter sp = (ESource_parameter)asp.getCurrentMemberObject(spi);
				String sp_name = sp.getName(null);

				EEntity_or_view_definition sp_extent = (EEntity_or_view_definition)sp.getExtent(null);
				String sp_extent_name = sp_extent.getName(null);
				String sp_package = getEntityPackage(sp_extent, jc.model); 
				String normalized_name = sp_extent_name.substring(0, 1).toUpperCase() + sp_extent_name.substring(1).toLowerCase();
				String esrc_type = sp_package + "E" + normalized_name;
				String asrc_type = sp_package + "A" + normalized_name;

	//			pw.println("\t\t" +asrc_type +" a" +ind +"_inst = (" +asrc_type +")src_model.getInstances(" +esrc_type +".class);");
			}

			spi.beginning();
			ind=0;
			while (spi.next()) {
				ind++;
				ESource_parameter sp = (ESource_parameter)asp.getCurrentMemberObject(spi);
				String sp_name = sp.getName(null);

				EEntity_or_view_definition sp_extent = (EEntity_or_view_definition)sp.getExtent(null);
				String sp_extent_name = sp_extent.getName(null);
				String sp_package = getEntityPackage(sp_extent, jc.model); 
				String normalized_name = sp_extent_name.substring(0, 1).toUpperCase() + sp_extent_name.substring(1).toLowerCase();
				String esrc_type = sp_package + "E" + normalized_name;
				String csrc_type = sp_package + "C" + normalized_name;
				String asrc_type = sp_package + "A" + normalized_name;

				//						tabByIndex(ind, pw); pw.println(asrc_type +" a" +ind +"_inst = (" +asrc_type +")src_model.getInstances(" +esrc_type +".class);");
//				pw.println("");
//				tabByIndex(ind, pw); pw.println("for (int i" +ind +" = 1; i" +ind +" < a" +ind +"_inst.getMemberCount()+1; i" +ind +"++) {");
//				tabByIndex(ind, pw); pw.println("\tValue " +sp_name +" = Value.alloc(" +csrc_type +".definition).set(_context, a" +ind +"_inst.getByIndex(i" +ind +"));");
//				add_instances = tabByIndexToString(asp.getMemberCount(), pw, add_instances); add_instances += "\tbinding_inst.addElement(" +sp_name +");\n";
//				if(asp.getMemberCount() < 2) { tabByIndex(ind, pw); pw.println("\tbinding_inst.addElement(\"\");"); }
//				if(ind == asp.getMemberCount()){ 
//					tabByIndex(ind, pw); pw.println("\tbinding_inst = new Vector();");
//					pw.println(add_instances);
//				}
//				tabByIndex(ind, pw); pw.println("\tsrc_id_map.put(\""+ sp_name +"\", new Integer(" +(ind-1) +"));");
			}

			//
			// WHERE part 
			//
			

			if (children != null) {

		  boolean attributes_present = false;
			 			
		  for (int i = 0; i < children.length; i++) {
				// possible children: 
				// X_BindingHeader (includes inside optional clauses: From clause, local declarations, WHERE clause, Identified_by clause, Ordered_by clause)
				// X_MapAttributeDeclaration
				// etc

				// so move actions for all this stuff into the children nodes (BindingHeader etc)

// System.out.println("current child: " + children[i] + ", current partition: " + mp.getName(null));

				if (children[i] instanceof X_BindingHeader) {
// System.out.println("current child - BindingHeader, partition: " + ((X_BindingHeader)children[i]).partition.getName(null) + ", current partition: " + mp.getName(null));
					jc.identified_by = false;
					if (((X_BindingHeader)children[i]).partition == mp) {
						jc.ind = ind;
 // System.out.println("Oh YES, invoking!");
 	pw.println("// INVOKING -------- YES YES YES - TO BindingHeader!!!!!!!!!!!!!!");
						children[i].jjtAccept(visitor, data);
					}
				
				} else
				if (children[i] instanceof X_IncrementControl) {
pw.println("\t\t// <EntityInstantiationLoop>: in IncrementControl");

					/*
							have to generate the following code, put into a string and insert later via jc fields and flags in X_MapAttributeDeclaration, probably:
							

			---- start of code to generate: ----------------------
			Value expr_loop_start = Value.alloc().unset();
			expr_loop_start = src2.getAttribute(jsdai.STest_one2many_1b_source.CFirst_friend.attributeWhich_one(null), _context);
			int loop_start = expr_loop_start.getInteger();

			Value expr_loop_end = Value.alloc().unset();
			expr_loop_end = src1.getAttribute(jsdai.STest_one2many_1b_source.CMy_friends.attributeNumber_of_friends(null), _context);
			int loop_end = expr_loop_end.getInteger();


			for (int i = loop_start; i <= loop_end; i++) { 
      ---- end of code to generate ------------------------------------------							
					
					Alternative, perhaps a better one: to generate this code in the X_MapAttributeDeclaration node,
					but loop start and loop end expressions have to be passed over there in a similar way, then.
				 	
       after processing children for  FOR loop with increment control we get:
       
       jc.java_str2: Value _implicit_1_i=src2.getAttribute(jsdai.STest_one2many_1b_source.CFirst_friend.attributeWhich_one(null), _context)
			jc.java_str3: src1.getAttribute(jsdai.STest_one2many_1b_source.CMy_friends.attributeNumber_of_friends(null), _context)

			we also have from this node:
			variable_id: _implicit_1_


------------------- example with a function REPEAT statement pretty much the same:

						Value _end1 = Value.alloc(ExpressTypes.NUMBER_TYPE).set(_nonvar__e_par1.getAttribute("sumber_of_friends", _context));
						Value _step1 = Value.alloc(ExpressTypes.INTEGER_TYPE).set(_context, 1);
						for (Value _implicit_1_i=_nonvar__e_par2.getAttribute(jsdai.STest_one2many_1b_source.CFirst_friend.attributeWhich_one(null), _context);Value.alloc(ExpressTypes.LOGICAL_TYPE).lequal(_context, _implicit_1_i, _end1).getLogical() == 2;_implicit_1_i.inc(_step1)) {						
							_e_a_name.set(_context, _nonvar__e_par1.getAttribute(jsdai.STest_one2many_1b_source.CMy_friends.attributeFriends_names(null), _context).indexing(_implicit_1_i, null));
						} // for - REPEAT


------------------- changing to the case when step is present and not 1:

						Value _end1 = Value.alloc(ExpressTypes.NUMBER_TYPE).set(_nonvar__e_par1.getAttribute("sumber_of_friends", _context));
						Value _step1 = Value.alloc(ExpressTypes.NUMBER_TYPE).set(Value.alloc(ExpressTypes.INTEGER_TYPE).set(_context, 2));
						for (Value _implicit_1_i=_nonvar__e_par2.getAttribute(jsdai.STest_one2many_1b_source.CFirst_friend.attributeWhich_one(null), _context);Value.alloc(ExpressTypes.LOGICAL_TYPE).greater(_context, _step1, Value.alloc(ExpressTypes.INTEGER_TYPE).set(_context, 0)).getLogical() == 2 ? Value.alloc(ExpressTypes.LOGICAL_TYPE).lequal(_context, _implicit_1_i, _end1).getLogical() == 2 : Value.alloc(ExpressTypes.LOGICAL_TYPE).gequal(_context, _implicit_1_i, _end1).getLogical() == 2;_implicit_1_i.inc(_step1)) {						
							_e_a_name.set(_context, _nonvar__e_par1.getAttribute(jsdai.STest_one2many_1b_source.CMy_friends.attributeFriends_names(null), _context).indexing(_implicit_1_i, null));
						} // for - REPEAT



-- in that case (when step is present and not 1), we have:

			jc.java_str2: Value _implicit_2_i=src2.getAttribute(jsdai.STest_one2many_1b_source.CFirst_friend.attributeWhich_one(null), _context)
			jc.java_str3: src1.getAttribute(jsdai.STest_one2many_1b_source.CMy_friends.attributeNumber_of_friends(null), _context)
			jc.java_str4: Value.alloc(ExpressTypes.INTEGER_TYPE).set(_context, 2)


					
			so, we can generate something like this:		
					
			Value _end1 = "Value.alloc(ExpressTypes.NUMBER_TYPE).set(" + jc.java_str3 + ");";		
 		  if (step not present)
 		  Value _step1 = Value.alloc(ExpressTypes.INTEGER_TYPE).set(_context, 1);
			else
			Value _step1 = "Value.alloc(ExpressTypes.NUMBER_TYPE).set(" + jc.java_str4 + ");";
					
			for (" + jc.java_str2 + ";Value.alloc(ExpressTypes.LOGICAL_TYPE).greater(_context, _step1, Value.alloc(ExpressTypes.INTEGER_TYPE).set(_context, 0)).getLogical() == 2 ? Value.alloc(ExpressTypes.LOGICAL_TYPE).lequal(_context, _implicit_1_i, _end1).getLogical() == 2 : Value.alloc(ExpressTypes.LOGICAL_TYPE).gequal(_context, _implicit_1_i, _end1).getLogical() == 2;_implicit_1_i.inc(_step1)) {						
			
			and for indexing use (which will happen by itself): _implicit_1_i		
					
					
					*/
							children[i].jjtAccept(visitor, data);

// pw.println("\t\t// <EntityInstantiationLoop>: in IncrementControl after children");
// pw.println("\t\t\t// generated_java: " + generated_java);
// pw.println("\t\t\t// jc.generated_java: " + jc.generated_java);
// pw.println("\t\t\t// jc.variable_ids: " + jc.variable_ids);
// pw.println("\t\t\t// jc.saved_str: " + jc.saved_str);
// pw.println("\t\t\t// jc.java_str2: " + jc.java_str2);
// pw.println("\t\t\t// jc.java_str3: " + jc.java_str3);
// pw.println("\t\t\t// jc.java_str4: " + jc.java_str4);
// pw.println("\t\t\t// jc.java_str5: " + jc.java_str5);
// pw.println("\t\t\t// jc.java_str6: " + jc.java_str6);

				// ok, so trying to construct such a string:
				
				String variable_idi = variable_id + "i";
				String end_str = "_end" + variable_uid;
				String step_str = "_step" + variable_uid;
				String end_expr_str =	"Value " + end_str + " = Value.alloc(ExpressTypes.NUMBER_TYPE).set(" + jc.java_str3 + ");";		
				String step_expr_str = null;
				if ((jc.java_str4 == null) || (jc.java_str4.equals(""))) {
		 		  step_expr_str = "Value " + step_str + " = Value.alloc(ExpressTypes.INTEGER_TYPE).set(_context, 1);";
				} else {
					step_expr_str = "Value " + step_str + " = Value.alloc(ExpressTypes.NUMBER_TYPE).set(" + jc.java_str4 + ");";
				}
				String for_str = "for (" + jc.java_str2 + "; Value.alloc(ExpressTypes.LOGICAL_TYPE).greater(_context, " + step_str + ", Value.alloc(ExpressTypes.INTEGER_TYPE).set(_context, 0)).getLogical() == 2 ? Value.alloc(ExpressTypes.LOGICAL_TYPE).lequal(_context, " + variable_idi + ", " +  end_str + ").getLogical() == 2 : Value.alloc(ExpressTypes.LOGICAL_TYPE).gequal(_context, " + variable_idi + ", " + end_str + ").getLogical() == 2; " + variable_idi + ".inc(" + step_str + ")) {";						

//					pw.println("\t\t\t// ----- printing what generated: ------");
//					pw.println("\t\t\t//" + end_expr_str);
//					pw.println("\t\t\t//" + step_expr_str);
//					pw.println("\t\t\t//" + for_str);
//					pw.println("\t\t\t// ----- end of generated: ------");

        /*
        	 the generated code is:
        	 
			Value _end2 = Value.alloc(ExpressTypes.NUMBER_TYPE).set(src1.getAttribute(jsdai.STest_one2many_1b_source.CMy_friends.attributeNumber_of_friends(null), _context));
			Value _step2 = Value.alloc(ExpressTypes.NUMBER_TYPE).set(Value.alloc(ExpressTypes.INTEGER_TYPE).set(_context, 2));
			for (Value _implicit_2_i=src2.getAttribute(jsdai.STest_one2many_1b_source.CFirst_friend.attributeWhich_one(null), _context); Value.alloc(ExpressTypes.LOGICAL_TYPE).greater(_context, _step2, Value.alloc(ExpressTypes.INTEGER_TYPE).set(_context, 0)).getLogical() == 2 ? Value.alloc(ExpressTypes.LOGICAL_TYPE).lequal(_context, _implicit_2_, _end2).getLogical() == 2 : Value.alloc(ExpressTypes.LOGICAL_TYPE).gequal(_context, _implicit_2_, _end2).getLogical() == 2; _implicit_2_.inc(_step2)) {
        	 
					 let's compare again with the one from REPEAT in a function:
					         
			Value _end1 = Value.alloc(ExpressTypes.NUMBER_TYPE).set(_nonvar__e_par1.getAttribute("sumber_of_friends", _context));
			Value _step1 = Value.alloc(ExpressTypes.NUMBER_TYPE).set(Value.alloc(ExpressTypes.INTEGER_TYPE).set(_context, 2));
			for (Value _implicit_1_i=_nonvar__e_par2.getAttribute(jsdai.STest_one2many_1b_source.CFirst_friend.attributeWhich_one(null), _context);Value.alloc(ExpressTypes.LOGICAL_TYPE).greater(_context, _step1, Value.alloc(ExpressTypes.INTEGER_TYPE).set(_context, 0)).getLogical() == 2 ? Value.alloc(ExpressTypes.LOGICAL_TYPE).lequal(_context, _implicit_1_i, _end1).getLogical() == 2 : Value.alloc(ExpressTypes.LOGICAL_TYPE).gequal(_context, _implicit_1_i, _end1).getLogical() == 2;_implicit_1_i.inc(_step1)) {						
				_e_a_name.set(_context, _nonvar__e_par1.getAttribute(jsdai.STest_one2many_1b_source.CMy_friends.attributeFriends_names(null), _context).indexing(_implicit_1_i, null));
			} // for - REPEAT
        
      perhaps ok, too much trouble to check, I will test with the complete version
        
        */

			// let's put it into jc.java_str5 which is not used:
			
			jc.java_str5 = 	"\n\t\t\t" + end_expr_str + "\n\t\t\t" + step_expr_str + "\n\n\n\t\t\t" + for_str;
			// perhaps we need also some flag:
			jc.in_entity_instantiation_loop = true;
			jc.in_entity_instantiation_loop_first = true;
				

				} else
				if (children[i] instanceof X_InstantiationForeachControl) {
pw.println("\t\t// <EntityInstantiationLoop>: in InstantiationForeachControl");



							children[i].jjtAccept(visitor, data);

 pw.println("\t\t// <EntityInstantiationLoop>: in  InstantiationForeachControl after children");
 pw.println("\t\t\t// generated_java: " + generated_java);
 pw.println("\t\t\t// jc.generated_java: " + jc.generated_java);
 pw.println("\t\t\t// jc.variable_ids: " + jc.variable_ids);
 pw.println("\t\t\t// jc.saved_str: " + jc.saved_str);
 pw.println("\t\t\t// jc.java_str2: " + jc.java_str2);
 pw.println("\t\t\t// jc.java_str3: " + jc.java_str3);
 pw.println("\t\t\t// jc.java_str4: " + jc.java_str4);
 pw.println("\t\t\t// jc.java_str5: " + jc.java_str5);
 pw.println("\t\t\t// jc.java_str6: " + jc.java_str6);

 pw.println("\t\t\t// variable_id: " + variable_id);
 pw.println("\t\t\t// variable_uid: " + variable_uid);


				String source_str = "_source" + variable_uid;
				String end_str = "_end" + variable_uid;
				String step_str = "_step" + variable_uid;
				// TODO to implement correctly source_expr_str - jc.java_str3 or something
				// String end_expr_str =	"Value " + end_str + " = Value.alloc(ExpressTypes.NUMBER_TYPE).set(" + jc.java_str3 + ");";		
				// String source_expr_str = "Value " + source_str + " = Value.alloc(ExpressTypes.NUMBER_TYPE).set(src.getAttribute(jsdai.STest_one2many_2_source.CMy_friends.attributeFriends_names(null), _context));";
				String source_expr_str = "Value " + source_str + " = " + jc.generated_java + ";";
				String end_expr_str = "Value " + end_str + " = Value.alloc(ExpressTypes.NUMBER_TYPE).set(Value.alloc(ExpressTypes.INTEGER_TYPE).hiIndex(" + source_str + "));";
	 		  String step_expr_str = "Value " + step_str + " = Value.alloc(ExpressTypes.INTEGER_TYPE).set(_context, 1);";
				String for_str = "for (\n\tValue " + jc.index_uid + " = Value.alloc(ExpressTypes.INTEGER_TYPE).set(_context, 1);\n\tValue.alloc(ExpressTypes.LOGICAL_TYPE).lequal(_context, " + jc.index_uid + ", " + end_str + ").getLogical() == 2;\n\t" + jc.index_uid + ".inc(" + step_str + ")) {";
				String element_value_str = "\n\tValue " + jc.iterator_uid + " = " + source_str + ".indexing(" + jc.index_uid + ", null);";

			jc.java_str5 = 	"\n\t\t\t" + source_expr_str + "\n\t\t\t" + end_expr_str + "\n\t\t\t" + step_expr_str + "\n\n\n\t\t\t" + for_str + "\n\n\n\t\t\t\t" + element_value_str;
			jc.in_entity_instantiation_loop = true;
			jc.in_entity_instantiation_loop_first = true;

				} else
				if (children[i] instanceof X_MapAttributeDeclaration) {
					
					attributes_present = true;
					jc.first_pass = true; // define variables in X_MapAttributeDeclaration in first pass
					jc.first_pass = first_for_this_partition;


pw.println("\t\t// <EntityInstantiationLoop>: in MapAttributeDeclaration");


	// System.out.println("child: " + children[i] + ", partition: " + mp_name + ", is 1st pass: " + jc.first_pass);	
//						if (((X_MapAttributeDeclaration)children[i]).partition == mp) { 
						if (((X_MapAttributeDeclaration)children[i]).partition == mp) { 
pw.println("\t\t// <EntityInstantiationLoop>: in partition");

							if (first_for_this_partition) {
pw.println("\t\t// <EntityInstantiationLoop>: in first for partition");
								if (jc.identified_by == false) {
pw.println("\t\t// <EntityInstantiationLoop>: no identified_by");
									pw.println("\t\tfor(int j=0; j < binding_inst_extent.size(); j++){ ");
								}
								((X_MapAttributeDeclaration)children[i]).targets = new HashSet();
								first_for_this_partition = false;
								// is it perhaps the same as jc.first_pass ?
							}
pw.println("\t\t// <EntityInstantiationLoop>: going to  children");
						
							children[i].jjtAccept(visitor, data);
pw.println("\t\t// <EntityInstantiationLoop>: after  children");
						} else {
pw.println("\t\t// <EntityInstantiationLoop>: WRONG partition: " + ((X_MapAttributeDeclaration)children[i]).partition);
pw.println("\t\t// <EntityInstantiationLoop>: Expected partition: " + mp);
pw.println("\t\t// <EntityInstantiationLoop>: node partition: " + partition);
						}
//						jc.first_pass = false;

				}
//				} else // MapAttributeDeclaration
//				if (children[i] instanceof X_EntityInstantiationLoop) {
//					attributes_present = true;
//					children[i].jjtAccept(visitor, data);
//				} // X_EntityInstantiationLoop


			} // for
			
			jc.in_entity_instantiation_loop = false;

			if (!attributes_present) {
				// better move from attribute, but temporarily, duplicate these things here
			
				// this whole thing is inside the loop through partitions, so it is ok
				// we way need to handle the following cases:
				// 1. no source parameters (no FROM clause) - just generate 1 instance
				// 2. 1 source parameter
				// 3. multiple source parameters
				// 4. if source parameters, also WHERE clause present or not
				// 5 IDENTIFIED_BY clause present or not
				

				ATarget_parameter atp2 = map_definition.getTarget_parameters(null, null);
				jsdai.lang.SdaiIterator tpi2 = atp2.createIterator();
				while (tpi2.next()) {
					ETarget_parameter tp2 = (ETarget_parameter)atp2.getCurrentMemberObject(tpi2);

				  if (jc.identified_by == false) {
							pw.println("\t\tfor(int j=0; j < binding_inst_extent.size(); j++){ ");

							jsdai.SExtended_dictionary_schema.ETarget_parameter target_parameter = tp2;
							String tar_par_name = target_parameter.getName(null);
							String plain_target_name = tar_par_name;
							Vector src_par_names = new Vector();
							Vector src_par_orders = new Vector();
							// target instance should be created only once - when first encountered target_parameter 
							HashSet targets = new HashSet();  // this is stupid, it does not do that, just so that it is compileable
					
							SdaiIterator spi2 = jc.asp.createIterator();
							while (spi2.next()) {
								ESource_parameter sp2 = (ESource_parameter)jc.asp.getCurrentMemberObject(spi2);
								String sp_name2 = sp2.getName(null);
								src_par_names.add(sp_name2);
							}


							tar_par_name += "_" +jc.target_par_count;
							jc.target_par_count++;
//							pw.println("\t\t\tValue expr_" +tar_par_name +" = Value.alloc().unset();");

//							pw.println("\t\t\tValue last_expr_" +tar_par_name +" = Value.alloc().unset();");
							pw.println("");

							for(int si=0; si < src_par_names.size(); si++){
	//							pw.println("\t\tint src_par_id_" +(String)src_par_names.get(si) +";");
	//							pw.println("\t\t\tValue " +(String)src_par_names.get(si) +";");
								first_for_this_partition = false;

							}

							if(!targets.contains(plain_target_name)){
		    		    EEntity_definition target_type = target_parameter.getExtent(null);
								String tar_extent_name  = target_type.getName(null);
								String normalized_name = tar_extent_name.substring(0, 1).toUpperCase() + tar_extent_name.substring(1).toLowerCase();
								String tar_package = getEntityPackage(target_type);
								String etar_type2 = tar_package + "E" + normalized_name;
								String ctar_type2 = tar_package + "C" + normalized_name;
		
								pw.println("\t\t\t" +etar_type2 +" " +plain_target_name +"_inst = (" +etar_type2 +")tar_model.createEntityInstance(" +etar_type2 +".class);");		
//								pw.println("\t\t\tValue " +plain_target_name +" = Value.alloc(" +ctar_type2 +".definition).set(_context, " +plain_target_name +"_inst);");
								targets.add(plain_target_name);
							}
//String gen_target_attr = "KUKU-HAHA";
//							pw.println("\t\t\t" +gen_target_attr +" expr_" +tar_par_name +");"); //  d.setName();


					} else { // no identified_by
						// identified_by present
						// TODO
					}

				} // while - through target parameters 		

			} // if attributes NOT present - constant partition

		pw.println("\t\t} // one-to-many for loop");					

			
		} // if children NOT null (children include binding header)


/*

			int i=0;  // change into the loop, needed for multiple partitions

			if(children[i] instanceof X_WhereClause){
				pw.println("\t\t\t// WHERE clause");
				tabByIndex(ind, pw); pw.print("\tif(");
				children[i].jjtAccept(visitor, data);
				pw.println("){"); 
				tabByIndex(ind, pw); pw.println("\t\tbinding_inst_extent.addElement(binding_inst);");
				tabByIndex(ind, pw); pw.println("\t}");
				i++; // generate next clause
			}else{
				tabByIndex(ind, pw); pw.println("\tbinding_inst_extent.addElement(binding_inst);");
				//								children[i].jjtAccept(visitor, data);
			}

*/
	
	
/*	
	
			while(ind > 0){
				tabByIndex(ind, pw); pw.println("}");
				ind--;
			}

*/



/*

			//
			// IDENTIFIED_BY expression, classification to eq class
			//
			if(i < children.length){
				if(children[i] instanceof X_IdentifiedByClause){
					pw.println("\t\t// IDENTIFIED_BY clause");
					children[i].jjtAccept(visitor, data);
					i++;
				}
			}
			pw.println("");

*/


/*

			//
			// SELECT part
			//
			// evaluate expression parts for the bindings of the same eq class and set appopriate values
			//
			// TODO: error handling in case of incompatible result of expression with left side of select statement
			// TODO: control by numeric increment, control by iteration over aggregate (
			//
			if(i > 0 && children[i-1] instanceof X_IdentifiedByClause){
				pw.println("\t\t// Evaluating expression parts for the bindings of the same eq class and setting appopriate values");
				pw.println("\t\tIterator iter = alist.iterator();");
				pw.println("\t\tfor(int i = 0; i < alist.size() ; i++) {");
				pw.println("\t\t\tint inst_num = 0;");
				// don't do checking, rely on the size
				pw.println("\t\t\tVector eq_class = (Vector)iter.next();");

				jc.identified_by = true;
			}else{
				pw.println("\t\tfor(int j=0; j < binding_inst_extent.size(); j++){ ");
			}


*/





      // this is handling of MapAttributeDeclarations, a separate loop through the children, as of now



/*


			if (children != null) {
				jc.first_pass = true; // define variables in X_MapAttributeDeclaration in first pass

//				for (int l = i; l < children.length; ++l) {
        // could do also from 1, actually better switch to that, because there are changes about i value, making a loop
				for (int l = 0; l < children.length; ++l) {
	System.out.println("child: " + children[l] + ", partition: " + mp_name + ", is 1st pass: " + jc.first_pass);	
					if (children[l] instanceof X_MapAttributeDeclaration) {
						if (((X_MapAttributeDeclaration)children[l]).partition == mp) { 
							if (first_for_this_partition) {
								((X_MapAttributeDeclaration)children[l]).targets = new HashSet();
								first_for_this_partition = false;
								// is it perhaps the same as jc.first_pass ?
							}
						
							children[l].jjtAccept(visitor, data);
						}
					}
				}
				jc.first_pass = false;
			} // if children not NULL

			pw.println("\t\t}");

*/





// moved into the partition loop

//		pw.println("\t\t}");					
//		pw.println("\t\treturn tar_model.getInstances(" +etar_type +".class);");
//		pw.println("\t}");					


		} // loop through partitions

	} // if not subtype


		//     if (children != null) {

		//       for (int l = i; l < children.length; ++l) {
		// 				if(children[l] instanceof X_WhereClause && (jc.entity == map_definition)){
		// 						children[l].jjtAccept(visitor, data);
		// 						pw.println(jc.generated_java);
		// 				}else{
		// 						children[l].jjtAccept(visitor, data);
		// 				}
		//       }

		//     }



		// FIXME: temporary
		// moving up into the partitino loop 
//		pw.println("\t\treturn tar_model.getInstances(" +etar_type +".class);");
//		pw.println("\t}");					


		} else { // generate execute in java backend instead of here


		AMap_partition amp = map_definition.getPartitions(null, null);
		SdaiIterator mpi = amp.createIterator();

		boolean first_for_this_partition = true;
		while (mpi.next()) {
			EMap_partition mp = (EMap_partition)amp.getCurrentMemberObject(mpi);
			jc.partition = mp;
			String mp_name = mp.getName(null);
			first_for_this_partition = true;
			// ...
			// only default partition supported - em-planner doesn't need others
			// ...

			if(mp_name.equalsIgnoreCase("_implicit_partition_")){
				mp_name = "default";
			}

////


/*

//			pw.println("\tpublic AEntity processPartition_" +mp_name +"(SdaiModel src_model, SdaiModel tar_model, Hashtable target_instances) throws SdaiException {");
			pw.println("\tpublic AEntity processPartition_" +mp_name +"(SdaiModel src_model, SdaiModel tar_model, Hashtable target_instances, SdaiContext _context) throws SdaiException {");

			// FROM part, generate source binding extent
			pw.println("\t// FROM part, generate source binding extent");
*/
			ASource_parameter asp = mp.getSource_parameters(null, null);
//System.out.println("source parameters: " + asp);
			jc.asp = asp; // save reference for src parameters to be used in Identified_by node
//			SdaiIterator spi = asp.createIterator();

			int ind=0;
/*
			String add_instances="";

			pw.println("\t\tVector binding_inst_extent = new Vector();");
			pw.println("\t\tVector binding_inst = new Vector();");
			pw.println("\t\tHashtable src_id_map = new Hashtable();");

*/

///////


//				ASource_parameter asp = mp.getSource_parameters(null, null);
	
//				 jc.asp = asp; // save reference for src parameters to be used in Identified_by node



if (children != null) {

		  boolean attributes_present = false;
			 			
		  for (int i = 0; i < children.length; i++) {
				// possible children: 
				// X_BindingHeader (includes inside optional clauses: From clause, local declarations, WHERE clause, Identified_by clause, Ordered_by clause)
				// X_MapAttributeDeclaration
				// etc

				// so move actions for all this stuff into the children nodes (BindingHeader etc)

// System.out.println("current child: " + children[i] + ", current partition: " + mp.getName(null));

				if (children[i] instanceof X_BindingHeader) {
// System.out.println("current child - BindingHeader, partition: " + ((X_BindingHeader)children[i]).partition.getName(null));
					jc.identified_by = false;
					if (((X_BindingHeader)children[i]).partition == mp) {
						jc.ind = ind;
// System.out.println("Oh YES, invoking!");
// 	pw.println("// INVOKING -------- YES YES YES - TO BindingHeader!!!!!!!!!!!!!!");


						children[i].jjtAccept(visitor, data);
					}
				} else
				if (children[i] instanceof X_MapAttributeDeclaration) {
					
					attributes_present = true;
					jc.first_pass = true; // define variables in X_MapAttributeDeclaration in first pass
					jc.first_pass = first_for_this_partition;



	// System.out.println("child: " + children[i] + ", partition: " + mp_name + ", is 1st pass: " + jc.first_pass);	
						if (((X_MapAttributeDeclaration)children[i]).partition == mp) { 
							if (first_for_this_partition) {
								if (jc.identified_by == false) {
									pw.println("\t\tfor(int j=0; j < binding_inst_extent.size(); j++){ ");
								}
								((X_MapAttributeDeclaration)children[i]).targets = new HashSet();
								first_for_this_partition = false;
								// is it perhaps the same as jc.first_pass ?
							}
						
							children[i].jjtAccept(visitor, data);
						}
//						jc.first_pass = false;

				} // MapAttributeDeclaration


			} // for
			if (!attributes_present) {
				// better move from attribute, but temporarily, duplicate these things here
			
				// this whole thing is inside the loop through partitions, so it is ok
				// we way need to handle the following cases:
				// 1. no source parameters (no FROM clause) - just generate 1 instance
				// 2. 1 source parameter
				// 3. multiple source parameters
				// 4. if source parameters, also WHERE clause present or not
				// 5 IDENTIFIED_BY clause present or not
				

				ATarget_parameter atp2 = map_definition.getTarget_parameters(null, null);
				jsdai.lang.SdaiIterator tpi2 = atp2.createIterator();
				while (tpi2.next()) {
					ETarget_parameter tp2 = (ETarget_parameter)atp2.getCurrentMemberObject(tpi2);

				  if (jc.identified_by == false) {
							pw.println("\t\tfor(int j=0; j < binding_inst_extent.size(); j++){ ");

							jsdai.SExtended_dictionary_schema.ETarget_parameter target_parameter = tp2;
							String tar_par_name = target_parameter.getName(null);
							String plain_target_name = tar_par_name;
							Vector src_par_names = new Vector();
							Vector src_par_orders = new Vector();
							// target instance should be created only once - when first encountered target_parameter 
							HashSet targets = new HashSet();  // this is stupid, it does not do that, just so that it is compileable
					
							SdaiIterator spi2 = jc.asp.createIterator();
							while (spi2.next()) {
								ESource_parameter sp2 = (ESource_parameter)jc.asp.getCurrentMemberObject(spi2);
								String sp_name2 = sp2.getName(null);
								src_par_names.add(sp_name2);
							}


							tar_par_name += "_" +jc.target_par_count;
							jc.target_par_count++;
//							pw.println("\t\t\tValue expr_" +tar_par_name +" = Value.alloc().unset();");

//							pw.println("\t\t\tValue last_expr_" +tar_par_name +" = Value.alloc().unset();");
							pw.println("");

							for(int si=0; si < src_par_names.size(); si++){
	//							pw.println("\t\tint src_par_id_" +(String)src_par_names.get(si) +";");
	//							pw.println("\t\t\tValue " +(String)src_par_names.get(si) +";");
								first_for_this_partition = false;

							}

							if(!targets.contains(plain_target_name)){
		    		    EEntity_definition target_type = target_parameter.getExtent(null);
								String tar_extent_name  = target_type.getName(null);
								String normalized_name = tar_extent_name.substring(0, 1).toUpperCase() + tar_extent_name.substring(1).toLowerCase();
								String tar_package = getEntityPackage(target_type);
								String etar_type2 = tar_package + "E" + normalized_name;
								String ctar_type2 = tar_package + "C" + normalized_name;
		
								pw.println("\t\t\t" +etar_type2 +" " +plain_target_name +"_inst = (" +etar_type2 +")tar_model.createEntityInstance(" +etar_type2 +".class);");		
//								pw.println("\t\t\tValue " +plain_target_name +" = Value.alloc(" +ctar_type2 +".definition).set(_context, " +plain_target_name +"_inst);");
								targets.add(plain_target_name);
							}
//String gen_target_attr = "KUKU-HAHA";
//							pw.println("\t\t\t" +gen_target_attr +" expr_" +tar_par_name +");"); //  d.setName();


					} else { // no identified_by
						// identified_by present
						// TODO
					}

				} // while - through target parameters 		

			} // if attributes NOT present - constant partition
			
		}

} // through partitions 
			
		}	// generate execute in java backend instead of here	


			// ------------------ the main case ends here, non-supertype (and with supertypes main subtype, if not moved to a separate later) ---------------
			break;
		
		} // switch primary - secondary cases

    return data;
  }

//############################################################################################################################
// temporarily duplicated from MapDecl, could be used from one place

  String getEntityPackage(EEntity_or_view_definition eds, SdaiModel current_model)
		throws jsdai.lang.SdaiException {

    // return an empty string if ed and eds in the same schema, and the package of eds otherwise
    String entity_package = "";
    SdaiModel entity_model = eds.findEntityInstanceSdaiModel();
		
    if (entity_model != current_model) {
      String entity_schema_name = getSchema_definitionFromModel(entity_model).getName(null);

      if (entity_schema_name.equalsIgnoreCase("Sdai_dictionary_schema")) {
        entity_package = "jsdai.dictionary.";
      } else {
        entity_package = "jsdai.S" + entity_schema_name.substring(0, 1).toUpperCase() + entity_schema_name.substring(1).toLowerCase() + ".";
      }
    }

    return entity_package;
  }

  String getEntityPackage(EEntity_definition eds) throws SdaiException {
    // return an empty string if ed and eds in the same schema, and the package of eds otherwise
    String entity_package = "";
    SdaiModel entity_model = eds.findEntityInstanceSdaiModel();

    //    if (entity_model != current_model) {
    String entity_schema_name = getSchema_definitionFromModel(entity_model).getName(null);

    if (entity_schema_name.equalsIgnoreCase("Sdai_dictionary_schema")) {
      entity_package = "jsdai.dictionary.";
    } else {
      entity_package = "jsdai.S" + entity_schema_name.substring(0, 1).toUpperCase() + 
                       entity_schema_name.substring(1).toLowerCase() + ".";
    }

    //    }
    return entity_package;
  }


  EGeneric_schema_definition getSchema_definitionFromModel(SdaiModel sm) throws jsdai.lang.SdaiException {
    jsdai.lang.Aggregate ia = sm.getEntityExtentInstances(EGeneric_schema_definition.class);
    jsdai.lang.SdaiIterator iter_inst = ia.createIterator();

    while (iter_inst.next()) {
      EGeneric_schema_definition inst = ( EGeneric_schema_definition )ia.getCurrentMemberObject(iter_inst);
      return inst;
    }

    return null;
	  }

	void tabByIndex(int ind, PrintWriter pw){
		pw.print("\t");
		for(int tt=0; tt < ind; tt++) pw.print("\t");
	}

	String  tabByIndexToString(int ind, PrintWriter pw, String st){
		st += "\t";
		for(int tt=0; tt < ind; tt++)	st += "\t";
		return st;
	}


	  jsdai.SExtended_dictionary_schema.EMap_definition getRootSupertypeMap( jsdai.SExtended_dictionary_schema.EMap_definition map_definition) throws SdaiException {
			jsdai.SExtended_dictionary_schema.EMap_definition md = null;
			if (map_definition.testSuper_type(null)) {
				md = getRootSupertypeMap(map_definition.getSuper_type(null));
			} else {
				md = map_definition;
			}
			return md;
		}




}
